[
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22a.c\nLabel Definition File: CWE78_OS_Command_Injection.strings.label.xml\nTemplate File: sources-sink-22a.tmpl.c\n*/\n/*\n * @description\n * CWE: 78 OS Command Injection\n * BadSource: listen_socket Read data using a listen socket (server side)\n * GoodSource: Fixed string\n * Sink: w32_spawnvp\n *    BadSink : execute command with wspawnvp\n * Flow Variant: 22 Control flow: Flow controlled by value of a global variable. Sink functions are in a separate file from sources.\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else /* NOT _WIN32 */\n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#include <process.h>\n\n#ifndef OMITBAD\n\n/* The global variable below is used to drive control flow in the source function */\nint CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_badGlobal = 0;\n\nwchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_badSource(wchar_t * data);\n\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_badGlobal = 1; /* true */\n    data = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_badSource(data);\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* wspawnvp - searches for the location of the command among\n         * the directories specified by the PATH environment variable */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* The global variables below are used to drive control flow in the source functions. */\nint CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_goodG2B1Global = 0;\nint CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_goodG2B2Global = 0;\n\n/* goodG2B1() - use goodsource and badsink by setting the static variable to false instead of true */\nwchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_goodG2B1Source(wchar_t * data);\n\nstatic void goodG2B1()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_goodG2B1Global = 0; /* false */\n    data = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_goodG2B1Source(data);\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* wspawnvp - searches for the location of the command among\n         * the directories specified by the PATH environment variable */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the if in the source function */\nwchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_goodG2B2Source(wchar_t * data);\n\nstatic void goodG2B2()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_goodG2B2Global = 1; /* true */\n    data = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_goodG2B2Source(data);\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* wspawnvp - searches for the location of the command among\n         * the directories specified by the PATH environment variable */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_good()\n{\n    goodG2B1();\n    goodG2B2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"os_command_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code allows untrusted input to be executed as operating system commands. Attackers can exploit this to execute arbitrary commands on the server with the application's privileges.\",\n  \"risk\": \"Complete system compromise, arbitrary command execution, data theft, system modification\",\n  \"compliant_patch\": \"\\n// FIXED: Use parameterized commands or input validation\\n// Instead of: system(user_input)\\n// Use: validated_input = validate_user_input(user_input);\\n//       system(escape_shell_command(validated_input));\\n\\n// Or better, use library functions that handle arguments safely:\\n// execvp() with proper argument array\\n// or use higher-level APIs that avoid shell entirely\\n\",\n  \"source\": \"SARD-248694\",\n  \"cwe\": \"CWE-78\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22b.c\nLabel Definition File: CWE78_OS_Command_Injection.strings.label.xml\nTemplate File: sources-sink-22b.tmpl.c\n*/\n/*\n * @description\n * CWE: 78 OS Command Injection\n * BadSource: listen_socket Read data using a listen socket (server side)\n * GoodSource: Fixed string\n * Sink: w32_spawnvp\n *    BadSink : execute command with wspawnvp\n * Flow Variant: 22 Control flow: Flow controlled by value of a global variable. Sink functions are in a separate file from sources.\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else /* NOT _WIN32 */\n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#ifndef OMITBAD\n\n/* The global variable below is used to drive control flow in the source function */\nextern int CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_badGlobal;\n\nwchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_badSource(wchar_t * data)\n{\n    if(CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_badGlobal)\n    {\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                /* Eliminate CRLF */\n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n    }\n    return data;\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* The global variables below are used to drive control flow in the source functions. */\nextern int CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_goodG2B1Global;\nextern int CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_goodG2B2Global;\n\n/* goodG2B1() - use goodsource and badsink by setting the static variable to false instead of true */\nwchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_goodG2B1Source(wchar_t * data)\n{\n    if(CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_goodG2B1Global)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Append a fixed string to data (not user / external input) */\n        wcscat(data, L\"*.*\");\n    }\n    return data;\n}\n\n/* goodG2B2() - use goodsource and badsink by reversing the blocks in the if in the source function */\nwchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_goodG2B2Source(wchar_t * data)\n{\n    if(CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_22_goodG2B2Global)\n    {\n        /* FIX: Append a fixed string to data (not user / external input) */\n        wcscat(data, L\"*.*\");\n    }\n    return data;\n}\n\n#endif /* OMITGOOD */\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"os_command_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code allows untrusted input to be executed as operating system commands. Attackers can exploit this to execute arbitrary commands on the server with the application's privileges.\",\n  \"risk\": \"Complete system compromise, arbitrary command execution, data theft, system modification\",\n  \"compliant_patch\": \"\\n// FIXED: Use parameterized commands or input validation\\n// Instead of: system(user_input)\\n// Use: validated_input = validate_user_input(user_input);\\n//       system(escape_shell_command(validated_input));\\n\\n// Or better, use library functions that handle arguments safely:\\n// execvp() with proper argument array\\n// or use higher-level APIs that avoid shell entirely\\n\",\n  \"source\": \"SARD-248694\",\n  \"cwe\": \"CWE-78\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"os_command_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code allows untrusted input to be executed as operating system commands. Attackers can exploit this to execute arbitrary commands on the server with the application's privileges.\",\n  \"risk\": \"Complete system compromise, arbitrary command execution, data theft, system modification\",\n  \"compliant_patch\": \"\\n// FIXED: Use parameterized commands or input validation\\n// Instead of: system(user_input)\\n// Use: validated_input = validate_user_input(user_input);\\n//       system(escape_shell_command(validated_input));\\n\\n// Or better, use library functions that handle arguments safely:\\n// execvp() with proper argument array\\n// or use higher-level APIs that avoid shell entirely\\n\",\n  \"source\": \"SARD-248694\",\n  \"cwe\": \"CWE-78\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_66a.c\nLabel Definition File: CWE78_OS_Command_Injection.strings.label.xml\nTemplate File: sources-sink-66a.tmpl.c\n*/\n/*\n * @description\n * CWE: 78 OS Command Injection\n * BadSource: listen_socket Read data using a listen socket (server side)\n * GoodSource: Fixed string\n * Sinks: w32_spawnvp\n *    BadSink : execute command with wspawnvp\n * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else /* NOT _WIN32 */\n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\n#ifndef OMITBAD\n\n/* bad function declaration */\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_66b_badSink(wchar_t * dataArray[]);\n\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_66_bad()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    /* put data in array */\n    dataArray[2] = data;\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_66b_badSink(dataArray);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_66b_goodG2BSink(wchar_t * dataArray[]);\n\nstatic void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * dataArray[5];\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    /* FIX: Append a fixed string to data (not user / external input) */\n    wcscat(data, L\"*.*\");\n    dataArray[2] = data;\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_66b_goodG2BSink(dataArray);\n}\n\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_66_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_66_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_66_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"os_command_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code allows untrusted input to be executed as operating system commands. Attackers can exploit this to execute arbitrary commands on the server with the application's privileges.\",\n  \"risk\": \"Complete system compromise, arbitrary command execution, data theft, system modification\",\n  \"compliant_patch\": \"\\n// FIXED: Use parameterized commands or input validation\\n// Instead of: system(user_input)\\n// Use: validated_input = validate_user_input(user_input);\\n//       system(escape_shell_command(validated_input));\\n\\n// Or better, use library functions that handle arguments safely:\\n// execvp() with proper argument array\\n// or use higher-level APIs that avoid shell entirely\\n\",\n  \"source\": \"SARD-248713\",\n  \"cwe\": \"CWE-78\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_66b.c\nLabel Definition File: CWE78_OS_Command_Injection.strings.label.xml\nTemplate File: sources-sink-66b.tmpl.c\n*/\n/*\n * @description\n * CWE: 78 OS Command Injection\n * BadSource: listen_socket Read data using a listen socket (server side)\n * GoodSource: Fixed string\n * Sinks: w32_spawnvp\n *    BadSink : execute command with wspawnvp\n * Flow Variant: 66 Data flow: data passed in an array from one function to another in different source files\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else /* NOT _WIN32 */\n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\n#ifndef OMITBAD\n\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_66b_badSink(wchar_t * dataArray[])\n{\n    /* copy data out of dataArray */\n    wchar_t * data = dataArray[2];\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* wspawnvp - searches for the location of the command among\n         * the directories specified by the PATH environment variable */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_66b_goodG2BSink(wchar_t * dataArray[])\n{\n    wchar_t * data = dataArray[2];\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* wspawnvp - searches for the location of the command among\n         * the directories specified by the PATH environment variable */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n#endif /* OMITGOOD */\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"os_command_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code allows untrusted input to be executed as operating system commands. Attackers can exploit this to execute arbitrary commands on the server with the application's privileges.\",\n  \"risk\": \"Complete system compromise, arbitrary command execution, data theft, system modification\",\n  \"compliant_patch\": \"\\n// FIXED: Use parameterized commands or input validation\\n// Instead of: system(user_input)\\n// Use: validated_input = validate_user_input(user_input);\\n//       system(escape_shell_command(validated_input));\\n\\n// Or better, use library functions that handle arguments safely:\\n// execvp() with proper argument array\\n// or use higher-level APIs that avoid shell entirely\\n\",\n  \"source\": \"SARD-248713\",\n  \"cwe\": \"CWE-78\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"os_command_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code allows untrusted input to be executed as operating system commands. Attackers can exploit this to execute arbitrary commands on the server with the application's privileges.\",\n  \"risk\": \"Complete system compromise, arbitrary command execution, data theft, system modification\",\n  \"compliant_patch\": \"\\n// FIXED: Use parameterized commands or input validation\\n// Instead of: system(user_input)\\n// Use: validated_input = validate_user_input(user_input);\\n//       system(escape_shell_command(validated_input));\\n\\n// Or better, use library functions that handle arguments safely:\\n// execvp() with proper argument array\\n// or use higher-level APIs that avoid shell entirely\\n\",\n  \"source\": \"SARD-248713\",\n  \"cwe\": \"CWE-78\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68a.c\nLabel Definition File: CWE78_OS_Command_Injection.strings.label.xml\nTemplate File: sources-sink-68a.tmpl.c\n*/\n/*\n * @description\n * CWE: 78 OS Command Injection\n * BadSource: listen_socket Read data using a listen socket (server side)\n * GoodSource: Fixed string\n * Sink: w32_spawnvp\n *    BadSink : execute command with wspawnvp\n * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else /* NOT _WIN32 */\n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\nwchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_badData;\nwchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_goodG2BData;\n\n#ifndef OMITBAD\n\n/* bad function declaration */\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68b_badSink();\n\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_bad()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n#ifdef _WIN32\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n#endif\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t dataLen = wcslen(data);\n        do\n        {\n#ifdef _WIN32\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n#endif\n            /* POTENTIAL FLAW: Read data using a listen socket */\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(data, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(data, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            CLOSE_SOCKET(acceptSocket);\n        }\n#ifdef _WIN32\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n#endif\n    }\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_badData = data;\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68b_badSink();\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* good function declarations */\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68b_goodG2BSink();\n\n/* goodG2B uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    wchar_t * data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    /* FIX: Append a fixed string to data (not user / external input) */\n    wcscat(data, L\"*.*\");\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_goodG2BData = data;\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68b_goodG2BSink();\n}\n\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"os_command_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code allows untrusted input to be executed as operating system commands. Attackers can exploit this to execute arbitrary commands on the server with the application's privileges.\",\n  \"risk\": \"Complete system compromise, arbitrary command execution, data theft, system modification\",\n  \"compliant_patch\": \"\\n// FIXED: Use parameterized commands or input validation\\n// Instead of: system(user_input)\\n// Use: validated_input = validate_user_input(user_input);\\n//       system(escape_shell_command(validated_input));\\n\\n// Or better, use library functions that handle arguments safely:\\n// execvp() with proper argument array\\n// or use higher-level APIs that avoid shell entirely\\n\",\n  \"source\": \"SARD-248715\",\n  \"cwe\": \"CWE-78\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68b.c\nLabel Definition File: CWE78_OS_Command_Injection.strings.label.xml\nTemplate File: sources-sink-68b.tmpl.c\n*/\n/*\n * @description\n * CWE: 78 OS Command Injection\n * BadSource: listen_socket Read data using a listen socket (server side)\n * GoodSource: Fixed string\n * Sink: w32_spawnvp\n *    BadSink : execute command with wspawnvp\n * Flow Variant: 68 Data flow: data passed as a global variable from one function to another in different source files\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else /* NOT _WIN32 */\n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\nextern wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_badData;\nextern wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_goodG2BData;\n\n/* all the sinks are the same, we just want to know where the hit originated if a tool flags one */\n\n#ifndef OMITBAD\n\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68b_badSink()\n{\n    wchar_t * data = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_badData;\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* wspawnvp - searches for the location of the command among\n         * the directories specified by the PATH environment variable */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68b_goodG2BSink()\n{\n    wchar_t * data = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_68_goodG2BData;\n    {\n        wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n        /* wspawnvp - searches for the location of the command among\n         * the directories specified by the PATH environment variable */\n        /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n        _wspawnvp(_P_WAIT, COMMAND_INT, args);\n    }\n}\n\n#endif /* OMITGOOD */\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"os_command_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code allows untrusted input to be executed as operating system commands. Attackers can exploit this to execute arbitrary commands on the server with the application's privileges.\",\n  \"risk\": \"Complete system compromise, arbitrary command execution, data theft, system modification\",\n  \"compliant_patch\": \"\\n// FIXED: Use parameterized commands or input validation\\n// Instead of: system(user_input)\\n// Use: validated_input = validate_user_input(user_input);\\n//       system(escape_shell_command(validated_input));\\n\\n// Or better, use library functions that handle arguments safely:\\n// execvp() with proper argument array\\n// or use higher-level APIs that avoid shell entirely\\n\",\n  \"source\": \"SARD-248715\",\n  \"cwe\": \"CWE-78\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"os_command_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code allows untrusted input to be executed as operating system commands. Attackers can exploit this to execute arbitrary commands on the server with the application's privileges.\",\n  \"risk\": \"Complete system compromise, arbitrary command execution, data theft, system modification\",\n  \"compliant_patch\": \"\\n// FIXED: Use parameterized commands or input validation\\n// Instead of: system(user_input)\\n// Use: validated_input = validate_user_input(user_input);\\n//       system(escape_shell_command(validated_input));\\n\\n// Or better, use library functions that handle arguments safely:\\n// execvp() with proper argument array\\n// or use higher-level APIs that avoid shell entirely\\n\",\n  \"source\": \"SARD-248715\",\n  \"cwe\": \"CWE-78\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_32.c\nLabel Definition File: CWE78_OS_Command_Injection.strings.label.xml\nTemplate File: sources-sink-32.tmpl.c\n*/\n/*\n * @description\n * CWE: 78 OS Command Injection\n * BadSource: listen_socket Read data using a listen socket (server side)\n * GoodSource: Fixed string\n * Sink: w32_spawnvp\n *    BadSink : execute command with wspawnvp\n * Flow Variant: 32 Data flow using two pointers to the same value within the same function\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifdef _WIN32\n#define COMMAND_INT_PATH L\"%WINDIR%\\\\system32\\\\cmd.exe\"\n#define COMMAND_INT L\"cmd.exe\"\n#define COMMAND_ARG1 L\"/c\"\n#define COMMAND_ARG2 L\"dir \"\n#define COMMAND_ARG3 data\n#else /* NOT _WIN32 */\n#include <unistd.h>\n#define COMMAND_INT_PATH L\"/bin/sh\"\n#define COMMAND_INT L\"sh\"\n#define COMMAND_ARG1 L\"-c\"\n#define COMMAND_ARG2 L\"ls \"\n#define COMMAND_ARG3 data\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n#define CLOSE_SOCKET closesocket\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#define INVALID_SOCKET -1\n#define SOCKET_ERROR -1\n#define CLOSE_SOCKET close\n#define SOCKET int\n#endif\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#include <process.h>\n\n#ifndef OMITBAD\n\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_32_bad()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        {\n#ifdef _WIN32\n            WSADATA wsaData;\n            int wsaDataInit = 0;\n#endif\n            int recvResult;\n            struct sockaddr_in service;\n            wchar_t *replace;\n            SOCKET listenSocket = INVALID_SOCKET;\n            SOCKET acceptSocket = INVALID_SOCKET;\n            size_t dataLen = wcslen(data);\n            do\n            {\n#ifdef _WIN32\n                if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n                {\n                    break;\n                }\n                wsaDataInit = 1;\n#endif\n                /* POTENTIAL FLAW: Read data using a listen socket */\n                listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n                if (listenSocket == INVALID_SOCKET)\n                {\n                    break;\n                }\n                memset(&service, 0, sizeof(service));\n                service.sin_family = AF_INET;\n                service.sin_addr.s_addr = INADDR_ANY;\n                service.sin_port = htons(TCP_PORT);\n                if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n                {\n                    break;\n                }\n                acceptSocket = accept(listenSocket, NULL, NULL);\n                if (acceptSocket == SOCKET_ERROR)\n                {\n                    break;\n                }\n                /* Abort on error or the connection was closed */\n                recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);\n                if (recvResult == SOCKET_ERROR || recvResult == 0)\n                {\n                    break;\n                }\n                /* Append null terminator */\n                data[dataLen + recvResult / sizeof(wchar_t)] = L'\\0';\n                /* Eliminate CRLF */\n                replace = wcschr(data, L'\\r');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n                replace = wcschr(data, L'\\n');\n                if (replace)\n                {\n                    *replace = L'\\0';\n                }\n            }\n            while (0);\n            if (listenSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(listenSocket);\n            }\n            if (acceptSocket != INVALID_SOCKET)\n            {\n                CLOSE_SOCKET(acceptSocket);\n            }\n#ifdef _WIN32\n            if (wsaDataInit)\n            {\n                WSACleanup();\n            }\n#endif\n        }\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n            /* wspawnvp - searches for the location of the command among\n             * the directories specified by the PATH environment variable */\n            /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n            _wspawnvp(_P_WAIT, COMMAND_INT, args);\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B() uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    wchar_t * data;\n    wchar_t * *dataPtr1 = &data;\n    wchar_t * *dataPtr2 = &data;\n    wchar_t dataBuffer[100] = COMMAND_ARG2;\n    data = dataBuffer;\n    {\n        wchar_t * data = *dataPtr1;\n        /* FIX: Append a fixed string to data (not user / external input) */\n        wcscat(data, L\"*.*\");\n        *dataPtr1 = data;\n    }\n    {\n        wchar_t * data = *dataPtr2;\n        {\n            wchar_t *args[] = {COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL};\n            /* wspawnvp - searches for the location of the command among\n             * the directories specified by the PATH environment variable */\n            /* POTENTIAL FLAW: Execute command without validating input possibly leading to command injection */\n            _wspawnvp(_P_WAIT, COMMAND_INT, args);\n        }\n    }\n}\n\nvoid CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_32_good()\n{\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n * its own for testing or for building a binary to use in testing binary\n * analysis tools. It is not used when compiling all the testcases as one\n * application, which is how source code analysis tools are tested.\n */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_32_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnvp_32_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"os_command_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code allows untrusted input to be executed as operating system commands. Attackers can exploit this to execute arbitrary commands on the server with the application's privileges.\",\n  \"risk\": \"Complete system compromise, arbitrary command execution, data theft, system modification\",\n  \"compliant_patch\": \"\\n// FIXED: Use parameterized commands or input validation\\n// Instead of: system(user_input)\\n// Use: validated_input = validate_user_input(user_input);\\n//       system(escape_shell_command(validated_input));\\n\\n// Or better, use library functions that handle arguments safely:\\n// execvp() with proper argument array\\n// or use higher-level APIs that avoid shell entirely\\n\",\n  \"source\": \"SARD-248696\",\n  \"cwe\": \"CWE-78\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"os_command_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code allows untrusted input to be executed as operating system commands. Attackers can exploit this to execute arbitrary commands on the server with the application's privileges.\",\n  \"risk\": \"Complete system compromise, arbitrary command execution, data theft, system modification\",\n  \"compliant_patch\": \"\\n// FIXED: Use parameterized commands or input validation\\n// Instead of: system(user_input)\\n// Use: validated_input = validate_user_input(user_input);\\n//       system(escape_shell_command(validated_input));\\n\\n// Or better, use library functions that handle arguments safely:\\n// execvp() with proper argument array\\n// or use higher-level APIs that avoid shell entirely\\n\",\n  \"source\": \"SARD-248696\",\n  \"cwe\": \"CWE-78\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE416_Use_After_Free__return_freed_ptr_08.c\nLabel Definition File: CWE416_Use_After_Free__return_freed_ptr.label.xml\nTemplate File: point-flaw-08.tmpl.c\n*/\n/*\n * @description\n * CWE: 416 Use After Free\n * Sinks:\n *    GoodSink: Use a block of memory returned from a function\n *    BadSink : Use a block of memory returned from a function after it has been freed\n * Flow Variant: 08 Control flow: if(staticReturnsTrue()) and if(staticReturnsFalse())\n *\n * */\n\n#include \"std_testcase.h\"\n\nstatic char * helperBad(char * aString)\n{\n    size_t i = 0;\n    size_t j;\n    char * reversedString = NULL;\n    if (aString != NULL)\n    {\n        i = strlen(aString);\n        reversedString = (char *) malloc(i+1);\n        if (reversedString == NULL) {exit(-1);}\n        for (j = 0; j < i; j++)\n        {\n            reversedString[j] = aString[i-j-1];\n        }\n        reversedString[i] = '\\0';\n        /* FLAW: Freeing a memory block and then returning a pointer to the freed memory */\n        free(reversedString);\n        return reversedString;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\nstatic char * helperGood(char * aString)\n{\n    size_t i = 0;\n    size_t j;\n    char * reversedString = NULL;\n    if (aString != NULL)\n    {\n        i = strlen(aString);\n        reversedString = (char *) malloc(i+1);\n        if (reversedString == NULL) {exit(-1);}\n        for (j = 0; j < i; j++)\n        {\n            reversedString[j] = aString[i-j-1];\n        }\n        reversedString[i] = '\\0';\n        /* FIX: Do not free the memory before returning */\n        return reversedString;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\n/* The two function below always return the same value, so a tool\n   should be able to identify that calls to the functions will always\n   return a fixed value. */\nstatic int staticReturnsTrue()\n{\n    return 1;\n}\n\nstatic int staticReturnsFalse()\n{\n    return 0;\n}\n\n#ifndef OMITBAD\n\nvoid CWE416_Use_After_Free__return_freed_ptr_08_bad()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* Call the bad helper function */\n            char * reversedString = helperBad(\"BadSink\");\n            printLine(reversedString);\n            /* free(reversedString);\n             * This call to free() was removed because we want the tool to detect the use after free,\n             * but we don't want that function to be free(). Essentially we want to avoid a double free\n             */\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* good1() uses if(staticReturnsFalse()) instead of if(staticReturnsTrue()) */\nstatic void good1()\n{\n    if(staticReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* Call the good helper function */\n            char * reversedString = helperGood(\"GoodSink\");\n            printLine(reversedString);\n            /* free(reversedString);\n             * This call to free() was removed because we want the tool to detect the use after free,\n             * but we don't want that function to be free(). Essentially we want to avoid a double free\n             */\n        }\n    }\n}\n\n/* good2() reverses the bodies in the if statement */\nstatic void good2()\n{\n    if(staticReturnsTrue())\n    {\n        {\n            /* Call the good helper function */\n            char * reversedString = helperGood(\"GoodSink\");\n            printLine(reversedString);\n            /* free(reversedString);\n             * This call to free() was removed because we want the tool to detect the use after free,\n             * but we don't want that function to be free(). Essentially we want to avoid a double free\n             */\n        }\n    }\n}\n\nvoid CWE416_Use_After_Free__return_freed_ptr_08_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE416_Use_After_Free__return_freed_ptr_08_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE416_Use_After_Free__return_freed_ptr_08_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"use_after_free\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code uses memory after it has been freed. This can lead to crashes, data corruption, or arbitrary code execution if an attacker can control the freed memory.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, privilege escalation\",\n  \"compliant_patch\": \"\\n// FIXED: Nullify pointers after free and check before use\\n// Instead of: free(ptr); ... use(ptr);\\n// Use: free(ptr); ptr = NULL; ... if (ptr) use(ptr);\\n\\n// Better: restructure code to avoid dangling pointers\\n// Use smart pointers or automatic memory management\\n\",\n  \"source\": \"SARD-240390\",\n  \"cwe\": \"CWE-416\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"use_after_free\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code uses memory after it has been freed. This can lead to crashes, data corruption, or arbitrary code execution if an attacker can control the freed memory.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, privilege escalation\",\n  \"compliant_patch\": \"\\n// FIXED: Nullify pointers after free and check before use\\n// Instead of: free(ptr); ... use(ptr);\\n// Use: free(ptr); ptr = NULL; ... if (ptr) use(ptr);\\n\\n// Better: restructure code to avoid dangling pointers\\n// Use smart pointers or automatic memory management\\n\",\n  \"source\": \"SARD-240390\",\n  \"cwe\": \"CWE-416\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE416_Use_After_Free__malloc_free_wchar_t_17.c\nLabel Definition File: CWE416_Use_After_Free__malloc_free.label.xml\nTemplate File: sources-sinks-17.tmpl.c\n*/\n/*\n * @description\n * CWE: 416 Use After Free\n * BadSource:  Allocate data using malloc(), initialize memory block, and Deallocate data using free()\n * GoodSource: Allocate data using malloc() and initialize memory block\n * Sinks:\n *    GoodSink: Do nothing\n *    BadSink : Use data\n * Flow Variant: 17 Control flow: for loops\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <wchar.h>\n\n#ifndef OMITBAD\n\nvoid CWE416_Use_After_Free__malloc_free_wchar_t_17_bad()\n{\n    int i,j;\n    wchar_t * data;\n    /* Initialize data */\n    data = NULL;\n    for(i = 0; i < 1; i++)\n    {\n        data = (wchar_t *)malloc(100*sizeof(wchar_t));\n        if (data == NULL) {exit(-1);}\n        wmemset(data, L'A', 100-1);\n        data[100-1] = L'\\0';\n        /* POTENTIAL FLAW: Free data in the source - the bad sink attempts to use data */\n        free(data);\n    }\n    for(j = 0; j < 1; j++)\n    {\n        /* POTENTIAL FLAW: Use of data that may have been freed */\n        printWLine(data);\n        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodB2G() - use badsource and goodsink in the for statements */\nstatic void goodB2G()\n{\n    int i,k;\n    wchar_t * data;\n    /* Initialize data */\n    data = NULL;\n    for(i = 0; i < 1; i++)\n    {\n        data = (wchar_t *)malloc(100*sizeof(wchar_t));\n        if (data == NULL) {exit(-1);}\n        wmemset(data, L'A', 100-1);\n        data[100-1] = L'\\0';\n        /* POTENTIAL FLAW: Free data in the source - the bad sink attempts to use data */\n        free(data);\n    }\n    for(k = 0; k < 1; k++)\n    {\n        /* FIX: Don't use data that may have been freed already */\n        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */\n        /* do nothing */\n        ; /* empty statement needed for some flow variants */\n    }\n}\n\n/* goodG2B() - use goodsource and badsink in the for statements */\nstatic void goodG2B()\n{\n    int h,j;\n    wchar_t * data;\n    /* Initialize data */\n    data = NULL;\n    for(h = 0; h < 1; h++)\n    {\n        data = (wchar_t *)malloc(100*sizeof(wchar_t));\n        if (data == NULL) {exit(-1);}\n        wmemset(data, L'A', 100-1);\n        data[100-1] = L'\\0';\n        /* FIX: Do not free data in the source */\n    }\n    for(j = 0; j < 1; j++)\n    {\n        /* POTENTIAL FLAW: Use of data that may have been freed */\n        printWLine(data);\n        /* POTENTIAL INCIDENTAL - Possible memory leak here if data was not freed */\n    }\n}\n\nvoid CWE416_Use_After_Free__malloc_free_wchar_t_17_good()\n{\n    goodB2G();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE416_Use_After_Free__malloc_free_wchar_t_17_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE416_Use_After_Free__malloc_free_wchar_t_17_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"use_after_free\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code uses memory after it has been freed. This can lead to crashes, data corruption, or arbitrary code execution if an attacker can control the freed memory.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, privilege escalation\",\n  \"compliant_patch\": \"\\n// FIXED: Nullify pointers after free and check before use\\n// Instead of: free(ptr); ... use(ptr);\\n// Use: free(ptr); ptr = NULL; ... if (ptr) use(ptr);\\n\\n// Better: restructure code to avoid dangling pointers\\n// Use smart pointers or automatic memory management\\n\",\n  \"source\": \"SARD-240379\",\n  \"cwe\": \"CWE-416\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"use_after_free\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code uses memory after it has been freed. This can lead to crashes, data corruption, or arbitrary code execution if an attacker can control the freed memory.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, privilege escalation\",\n  \"compliant_patch\": \"\\n// FIXED: Nullify pointers after free and check before use\\n// Instead of: free(ptr); ... use(ptr);\\n// Use: free(ptr); ptr = NULL; ... if (ptr) use(ptr);\\n\\n// Better: restructure code to avoid dangling pointers\\n// Use smart pointers or automatic memory management\\n\",\n  \"source\": \"SARD-240379\",\n  \"cwe\": \"CWE-416\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE416_Use_After_Free__return_freed_ptr_14.c\nLabel Definition File: CWE416_Use_After_Free__return_freed_ptr.label.xml\nTemplate File: point-flaw-14.tmpl.c\n*/\n/*\n * @description\n * CWE: 416 Use After Free\n * Sinks:\n *    GoodSink: Use a block of memory returned from a function\n *    BadSink : Use a block of memory returned from a function after it has been freed\n * Flow Variant: 14 Control flow: if(globalFive==5) and if(globalFive!=5)\n *\n * */\n\n#include \"std_testcase.h\"\n\nstatic char * helperBad(char * aString)\n{\n    size_t i = 0;\n    size_t j;\n    char * reversedString = NULL;\n    if (aString != NULL)\n    {\n        i = strlen(aString);\n        reversedString = (char *) malloc(i+1);\n        if (reversedString == NULL) {exit(-1);}\n        for (j = 0; j < i; j++)\n        {\n            reversedString[j] = aString[i-j-1];\n        }\n        reversedString[i] = '\\0';\n        /* FLAW: Freeing a memory block and then returning a pointer to the freed memory */\n        free(reversedString);\n        return reversedString;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\nstatic char * helperGood(char * aString)\n{\n    size_t i = 0;\n    size_t j;\n    char * reversedString = NULL;\n    if (aString != NULL)\n    {\n        i = strlen(aString);\n        reversedString = (char *) malloc(i+1);\n        if (reversedString == NULL) {exit(-1);}\n        for (j = 0; j < i; j++)\n        {\n            reversedString[j] = aString[i-j-1];\n        }\n        reversedString[i] = '\\0';\n        /* FIX: Do not free the memory before returning */\n        return reversedString;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\n#ifndef OMITBAD\n\nvoid CWE416_Use_After_Free__return_freed_ptr_14_bad()\n{\n    if(globalFive==5)\n    {\n        {\n            /* Call the bad helper function */\n            char * reversedString = helperBad(\"BadSink\");\n            printLine(reversedString);\n            /* free(reversedString);\n             * This call to free() was removed because we want the tool to detect the use after free,\n             * but we don't want that function to be free(). Essentially we want to avoid a double free\n             */\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* good1() uses if(globalFive!=5) instead of if(globalFive==5) */\nstatic void good1()\n{\n    if(globalFive!=5)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* Call the good helper function */\n            char * reversedString = helperGood(\"GoodSink\");\n            printLine(reversedString);\n            /* free(reversedString);\n             * This call to free() was removed because we want the tool to detect the use after free,\n             * but we don't want that function to be free(). Essentially we want to avoid a double free\n             */\n        }\n    }\n}\n\n/* good2() reverses the bodies in the if statement */\nstatic void good2()\n{\n    if(globalFive==5)\n    {\n        {\n            /* Call the good helper function */\n            char * reversedString = helperGood(\"GoodSink\");\n            printLine(reversedString);\n            /* free(reversedString);\n             * This call to free() was removed because we want the tool to detect the use after free,\n             * but we don't want that function to be free(). Essentially we want to avoid a double free\n             */\n        }\n    }\n}\n\nvoid CWE416_Use_After_Free__return_freed_ptr_14_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE416_Use_After_Free__return_freed_ptr_14_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE416_Use_After_Free__return_freed_ptr_14_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"use_after_free\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code uses memory after it has been freed. This can lead to crashes, data corruption, or arbitrary code execution if an attacker can control the freed memory.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, privilege escalation\",\n  \"compliant_patch\": \"\\n// FIXED: Nullify pointers after free and check before use\\n// Instead of: free(ptr); ... use(ptr);\\n// Use: free(ptr); ptr = NULL; ... if (ptr) use(ptr);\\n\\n// Better: restructure code to avoid dangling pointers\\n// Use smart pointers or automatic memory management\\n\",\n  \"source\": \"SARD-240396\",\n  \"cwe\": \"CWE-416\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"use_after_free\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code uses memory after it has been freed. This can lead to crashes, data corruption, or arbitrary code execution if an attacker can control the freed memory.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, privilege escalation\",\n  \"compliant_patch\": \"\\n// FIXED: Nullify pointers after free and check before use\\n// Instead of: free(ptr); ... use(ptr);\\n// Use: free(ptr); ptr = NULL; ... if (ptr) use(ptr);\\n\\n// Better: restructure code to avoid dangling pointers\\n// Use smart pointers or automatic memory management\\n\",\n  \"source\": \"SARD-240396\",\n  \"cwe\": \"CWE-416\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE416_Use_After_Free__return_freed_ptr_11.c\nLabel Definition File: CWE416_Use_After_Free__return_freed_ptr.label.xml\nTemplate File: point-flaw-11.tmpl.c\n*/\n/*\n * @description\n * CWE: 416 Use After Free\n * Sinks:\n *    GoodSink: Use a block of memory returned from a function\n *    BadSink : Use a block of memory returned from a function after it has been freed\n * Flow Variant: 11 Control flow: if(globalReturnsTrue()) and if(globalReturnsFalse())\n *\n * */\n\n#include \"std_testcase.h\"\n\nstatic char * helperBad(char * aString)\n{\n    size_t i = 0;\n    size_t j;\n    char * reversedString = NULL;\n    if (aString != NULL)\n    {\n        i = strlen(aString);\n        reversedString = (char *) malloc(i+1);\n        if (reversedString == NULL) {exit(-1);}\n        for (j = 0; j < i; j++)\n        {\n            reversedString[j] = aString[i-j-1];\n        }\n        reversedString[i] = '\\0';\n        /* FLAW: Freeing a memory block and then returning a pointer to the freed memory */\n        free(reversedString);\n        return reversedString;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\nstatic char * helperGood(char * aString)\n{\n    size_t i = 0;\n    size_t j;\n    char * reversedString = NULL;\n    if (aString != NULL)\n    {\n        i = strlen(aString);\n        reversedString = (char *) malloc(i+1);\n        if (reversedString == NULL) {exit(-1);}\n        for (j = 0; j < i; j++)\n        {\n            reversedString[j] = aString[i-j-1];\n        }\n        reversedString[i] = '\\0';\n        /* FIX: Do not free the memory before returning */\n        return reversedString;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\n#ifndef OMITBAD\n\nvoid CWE416_Use_After_Free__return_freed_ptr_11_bad()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* Call the bad helper function */\n            char * reversedString = helperBad(\"BadSink\");\n            printLine(reversedString);\n            /* free(reversedString);\n             * This call to free() was removed because we want the tool to detect the use after free,\n             * but we don't want that function to be free(). Essentially we want to avoid a double free\n             */\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* good1() uses if(globalReturnsFalse()) instead of if(globalReturnsTrue()) */\nstatic void good1()\n{\n    if(globalReturnsFalse())\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        {\n            /* Call the good helper function */\n            char * reversedString = helperGood(\"GoodSink\");\n            printLine(reversedString);\n            /* free(reversedString);\n             * This call to free() was removed because we want the tool to detect the use after free,\n             * but we don't want that function to be free(). Essentially we want to avoid a double free\n             */\n        }\n    }\n}\n\n/* good2() reverses the bodies in the if statement */\nstatic void good2()\n{\n    if(globalReturnsTrue())\n    {\n        {\n            /* Call the good helper function */\n            char * reversedString = helperGood(\"GoodSink\");\n            printLine(reversedString);\n            /* free(reversedString);\n             * This call to free() was removed because we want the tool to detect the use after free,\n             * but we don't want that function to be free(). Essentially we want to avoid a double free\n             */\n        }\n    }\n}\n\nvoid CWE416_Use_After_Free__return_freed_ptr_11_good()\n{\n    good1();\n    good2();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE416_Use_After_Free__return_freed_ptr_11_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE416_Use_After_Free__return_freed_ptr_11_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"use_after_free\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code uses memory after it has been freed. This can lead to crashes, data corruption, or arbitrary code execution if an attacker can control the freed memory.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, privilege escalation\",\n  \"compliant_patch\": \"\\n// FIXED: Nullify pointers after free and check before use\\n// Instead of: free(ptr); ... use(ptr);\\n// Use: free(ptr); ptr = NULL; ... if (ptr) use(ptr);\\n\\n// Better: restructure code to avoid dangling pointers\\n// Use smart pointers or automatic memory management\\n\",\n  \"source\": \"SARD-240393\",\n  \"cwe\": \"CWE-416\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"use_after_free\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code uses memory after it has been freed. This can lead to crashes, data corruption, or arbitrary code execution if an attacker can control the freed memory.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, privilege escalation\",\n  \"compliant_patch\": \"\\n// FIXED: Nullify pointers after free and check before use\\n// Instead of: free(ptr); ... use(ptr);\\n// Use: free(ptr); ptr = NULL; ... if (ptr) use(ptr);\\n\\n// Better: restructure code to avoid dangling pointers\\n// Use smart pointers or automatic memory management\\n\",\n  \"source\": \"SARD-240393\",\n  \"cwe\": \"CWE-416\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE416_Use_After_Free__return_freed_ptr_01.c\nLabel Definition File: CWE416_Use_After_Free__return_freed_ptr.label.xml\nTemplate File: point-flaw-01.tmpl.c\n*/\n/*\n * @description\n * CWE: 416 Use After Free\n * Sinks:\n *    GoodSink: Use a block of memory returned from a function\n *    BadSink : Use a block of memory returned from a function after it has been freed\n * Flow Variant: 01 Baseline\n *\n * */\n\n#include \"std_testcase.h\"\n\nstatic char * helperBad(char * aString)\n{\n    size_t i = 0;\n    size_t j;\n    char * reversedString = NULL;\n    if (aString != NULL)\n    {\n        i = strlen(aString);\n        reversedString = (char *) malloc(i+1);\n        if (reversedString == NULL) {exit(-1);}\n        for (j = 0; j < i; j++)\n        {\n            reversedString[j] = aString[i-j-1];\n        }\n        reversedString[i] = '\\0';\n        /* FLAW: Freeing a memory block and then returning a pointer to the freed memory */\n        free(reversedString);\n        return reversedString;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\nstatic char * helperGood(char * aString)\n{\n    size_t i = 0;\n    size_t j;\n    char * reversedString = NULL;\n    if (aString != NULL)\n    {\n        i = strlen(aString);\n        reversedString = (char *) malloc(i+1);\n        if (reversedString == NULL) {exit(-1);}\n        for (j = 0; j < i; j++)\n        {\n            reversedString[j] = aString[i-j-1];\n        }\n        reversedString[i] = '\\0';\n        /* FIX: Do not free the memory before returning */\n        return reversedString;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\n#ifndef OMITBAD\n\nvoid CWE416_Use_After_Free__return_freed_ptr_01_bad()\n{\n    {\n        /* Call the bad helper function */\n        char * reversedString = helperBad(\"BadSink\");\n        printLine(reversedString);\n        /* free(reversedString);\n         * This call to free() was removed because we want the tool to detect the use after free,\n         * but we don't want that function to be free(). Essentially we want to avoid a double free\n         */\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\nstatic void good1()\n{\n    {\n        /* Call the good helper function */\n        char * reversedString = helperGood(\"GoodSink\");\n        printLine(reversedString);\n        /* free(reversedString);\n         * This call to free() was removed because we want the tool to detect the use after free,\n         * but we don't want that function to be free(). Essentially we want to avoid a double free\n         */\n    }\n}\n\nvoid CWE416_Use_After_Free__return_freed_ptr_01_good()\n{\n    good1();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE416_Use_After_Free__return_freed_ptr_01_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE416_Use_After_Free__return_freed_ptr_01_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"use_after_free\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code uses memory after it has been freed. This can lead to crashes, data corruption, or arbitrary code execution if an attacker can control the freed memory.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, privilege escalation\",\n  \"compliant_patch\": \"\\n// FIXED: Nullify pointers after free and check before use\\n// Instead of: free(ptr); ... use(ptr);\\n// Use: free(ptr); ptr = NULL; ... if (ptr) use(ptr);\\n\\n// Better: restructure code to avoid dangling pointers\\n// Use smart pointers or automatic memory management\\n\",\n  \"source\": \"SARD-240383\",\n  \"cwe\": \"CWE-416\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"use_after_free\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code uses memory after it has been freed. This can lead to crashes, data corruption, or arbitrary code execution if an attacker can control the freed memory.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, privilege escalation\",\n  \"compliant_patch\": \"\\n// FIXED: Nullify pointers after free and check before use\\n// Instead of: free(ptr); ... use(ptr);\\n// Use: free(ptr); ptr = NULL; ... if (ptr) use(ptr);\\n\\n// Better: restructure code to avoid dangling pointers\\n// Use smart pointers or automatic memory management\\n\",\n  \"source\": \"SARD-240383\",\n  \"cwe\": \"CWE-416\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__unsigned_int_rand_preinc_51a.c\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-51a.tmpl.c\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: rand Set data to result of rand()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: increment\n *    GoodSink: Ensure there will not be an overflow before incrementing data\n *    BadSink : Increment data, which can cause an overflow\n * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files\n *\n * */\n\n#include \"std_testcase.h\"\n\n#ifndef OMITBAD\n\n/* bad function declaration */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_51b_badSink(unsigned int data);\n\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_51_bad()\n{\n    unsigned int data;\n    data = 0;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (unsigned int)RAND32();\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_51b_badSink(data);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_51b_goodG2BSink(unsigned int data);\n\nstatic void goodG2B()\n{\n    unsigned int data;\n    data = 0;\n    /* FIX: Use a small, non-zero value that will not cause an overflow in the sinks */\n    data = 2;\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_51b_goodG2BSink(data);\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_51b_goodB2GSink(unsigned int data);\n\nstatic void goodB2G()\n{\n    unsigned int data;\n    data = 0;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (unsigned int)RAND32();\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_51b_goodB2GSink(data);\n}\n\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_51_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_51_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_51_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"integer_overflow\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code performs arithmetic operations that can exceed the maximum size of the data type. This can lead to unexpected behavior, crashes, or security vulnerabilities.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, security bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before arithmetic operations\\n// Instead of: result = a + b;\\n// Use: if (b > INT_MAX - a) { handle_error(); }\\n//       result = a + b;\\n\\n// Or use safe arithmetic functions:\\n// if (!safe_add(a, b, &result)) { handle_error(); }\\n\",\n  \"source\": \"SARD-237272\",\n  \"cwe\": \"CWE-190\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__unsigned_int_rand_preinc_51b.c\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-51b.tmpl.c\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: rand Set data to result of rand()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: increment\n *    GoodSink: Ensure there will not be an overflow before incrementing data\n *    BadSink : Increment data, which can cause an overflow\n * Flow Variant: 51 Data flow: data passed as an argument from one function to another in different source files\n *\n * */\n\n#include \"std_testcase.h\"\n\n#ifndef OMITBAD\n\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_51b_badSink(unsigned int data)\n{\n    {\n        /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n        ++data;\n        unsigned int result = data;\n        printUnsignedLine(result);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_51b_goodG2BSink(unsigned int data)\n{\n    {\n        /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n        ++data;\n        unsigned int result = data;\n        printUnsignedLine(result);\n    }\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_51b_goodB2GSink(unsigned int data)\n{\n    /* FIX: Add a check to prevent an overflow from occurring */\n    if (data < UINT_MAX)\n    {\n        ++data;\n        unsigned int result = data;\n        printUnsignedLine(result);\n    }\n    else\n    {\n        printLine(\"data value is too large to perform arithmetic safely.\");\n    }\n}\n\n#endif /* OMITGOOD */\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"integer_overflow\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code performs arithmetic operations that can exceed the maximum size of the data type. This can lead to unexpected behavior, crashes, or security vulnerabilities.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, security bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before arithmetic operations\\n// Instead of: result = a + b;\\n// Use: if (b > INT_MAX - a) { handle_error(); }\\n//       result = a + b;\\n\\n// Or use safe arithmetic functions:\\n// if (!safe_add(a, b, &result)) { handle_error(); }\\n\",\n  \"source\": \"SARD-237272\",\n  \"cwe\": \"CWE-190\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"integer_overflow\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code performs arithmetic operations that can exceed the maximum size of the data type. This can lead to unexpected behavior, crashes, or security vulnerabilities.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, security bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before arithmetic operations\\n// Instead of: result = a + b;\\n// Use: if (b > INT_MAX - a) { handle_error(); }\\n//       result = a + b;\\n\\n// Or use safe arithmetic functions:\\n// if (!safe_add(a, b, &result)) { handle_error(); }\\n\",\n  \"source\": \"SARD-237272\",\n  \"cwe\": \"CWE-190\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__unsigned_int_rand_preinc_65a.c\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-65a.tmpl.c\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: rand Set data to result of rand()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: increment\n *    GoodSink: Ensure there will not be an overflow before incrementing data\n *    BadSink : Increment data, which can cause an overflow\n * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer\n *\n * */\n\n#include \"std_testcase.h\"\n\n#ifndef OMITBAD\n\n/* bad function declaration */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_65b_badSink(unsigned int data);\n\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_65_bad()\n{\n    unsigned int data;\n    /* define a function pointer */\n    void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_rand_preinc_65b_badSink;\n    data = 0;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (unsigned int)RAND32();\n    /* use the function pointer */\n    funcPtr(data);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_65b_goodG2BSink(unsigned int data);\n\nstatic void goodG2B()\n{\n    unsigned int data;\n    void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_rand_preinc_65b_goodG2BSink;\n    data = 0;\n    /* FIX: Use a small, non-zero value that will not cause an overflow in the sinks */\n    data = 2;\n    funcPtr(data);\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_65b_goodB2GSink(unsigned int data);\n\nstatic void goodB2G()\n{\n    unsigned int data;\n    void (*funcPtr) (unsigned int) = CWE190_Integer_Overflow__unsigned_int_rand_preinc_65b_goodB2GSink;\n    data = 0;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (unsigned int)RAND32();\n    funcPtr(data);\n}\n\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_65_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_65_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_65_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"integer_overflow\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code performs arithmetic operations that can exceed the maximum size of the data type. This can lead to unexpected behavior, crashes, or security vulnerabilities.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, security bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before arithmetic operations\\n// Instead of: result = a + b;\\n// Use: if (b > INT_MAX - a) { handle_error(); }\\n//       result = a + b;\\n\\n// Or use safe arithmetic functions:\\n// if (!safe_add(a, b, &result)) { handle_error(); }\\n\",\n  \"source\": \"SARD-237279\",\n  \"cwe\": \"CWE-190\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__unsigned_int_rand_preinc_65b.c\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-65b.tmpl.c\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: rand Set data to result of rand()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: increment\n *    GoodSink: Ensure there will not be an overflow before incrementing data\n *    BadSink : Increment data, which can cause an overflow\n * Flow Variant: 65 Data/control flow: data passed as an argument from one function to a function in a different source file called via a function pointer\n *\n * */\n\n#include \"std_testcase.h\"\n\n#ifndef OMITBAD\n\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_65b_badSink(unsigned int data)\n{\n    {\n        /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n        ++data;\n        unsigned int result = data;\n        printUnsignedLine(result);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_65b_goodG2BSink(unsigned int data)\n{\n    {\n        /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n        ++data;\n        unsigned int result = data;\n        printUnsignedLine(result);\n    }\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_65b_goodB2GSink(unsigned int data)\n{\n    /* FIX: Add a check to prevent an overflow from occurring */\n    if (data < UINT_MAX)\n    {\n        ++data;\n        unsigned int result = data;\n        printUnsignedLine(result);\n    }\n    else\n    {\n        printLine(\"data value is too large to perform arithmetic safely.\");\n    }\n}\n\n#endif /* OMITGOOD */\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"integer_overflow\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code performs arithmetic operations that can exceed the maximum size of the data type. This can lead to unexpected behavior, crashes, or security vulnerabilities.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, security bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before arithmetic operations\\n// Instead of: result = a + b;\\n// Use: if (b > INT_MAX - a) { handle_error(); }\\n//       result = a + b;\\n\\n// Or use safe arithmetic functions:\\n// if (!safe_add(a, b, &result)) { handle_error(); }\\n\",\n  \"source\": \"SARD-237279\",\n  \"cwe\": \"CWE-190\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"integer_overflow\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code performs arithmetic operations that can exceed the maximum size of the data type. This can lead to unexpected behavior, crashes, or security vulnerabilities.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, security bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before arithmetic operations\\n// Instead of: result = a + b;\\n// Use: if (b > INT_MAX - a) { handle_error(); }\\n//       result = a + b;\\n\\n// Or use safe arithmetic functions:\\n// if (!safe_add(a, b, &result)) { handle_error(); }\\n\",\n  \"source\": \"SARD-237279\",\n  \"cwe\": \"CWE-190\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__unsigned_int_rand_preinc_67a.c\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-67a.tmpl.c\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: rand Set data to result of rand()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: increment\n *    GoodSink: Ensure there will not be an overflow before incrementing data\n *    BadSink : Increment data, which can cause an overflow\n * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files\n *\n * */\n\n#include \"std_testcase.h\"\n\ntypedef struct _CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType\n{\n    unsigned int structFirst;\n} CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType;\n\n#ifndef OMITBAD\n\n/* bad function declaration */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b_badSink(CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType myStruct);\n\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_bad()\n{\n    unsigned int data;\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType myStruct;\n    data = 0;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (unsigned int)RAND32();\n    myStruct.structFirst = data;\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b_badSink(myStruct);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b_goodG2BSink(CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType myStruct);\n\nstatic void goodG2B()\n{\n    unsigned int data;\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType myStruct;\n    data = 0;\n    /* FIX: Use a small, non-zero value that will not cause an overflow in the sinks */\n    data = 2;\n    myStruct.structFirst = data;\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b_goodG2BSink(myStruct);\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b_goodB2GSink(CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType myStruct);\n\nstatic void goodB2G()\n{\n    unsigned int data;\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType myStruct;\n    data = 0;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (unsigned int)RAND32();\n    myStruct.structFirst = data;\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b_goodB2GSink(myStruct);\n}\n\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"integer_overflow\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code performs arithmetic operations that can exceed the maximum size of the data type. This can lead to unexpected behavior, crashes, or security vulnerabilities.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, security bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before arithmetic operations\\n// Instead of: result = a + b;\\n// Use: if (b > INT_MAX - a) { handle_error(); }\\n//       result = a + b;\\n\\n// Or use safe arithmetic functions:\\n// if (!safe_add(a, b, &result)) { handle_error(); }\\n\",\n  \"source\": \"SARD-237281\",\n  \"cwe\": \"CWE-190\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b.c\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-67b.tmpl.c\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: rand Set data to result of rand()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: increment\n *    GoodSink: Ensure there will not be an overflow before incrementing data\n *    BadSink : Increment data, which can cause an overflow\n * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files\n *\n * */\n\n#include \"std_testcase.h\"\n\ntypedef struct _CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType\n{\n    unsigned int structFirst;\n} CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType;\n\n#ifndef OMITBAD\n\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b_badSink(CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType myStruct)\n{\n    unsigned int data = myStruct.structFirst;\n    {\n        /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n        ++data;\n        unsigned int result = data;\n        printUnsignedLine(result);\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b_goodG2BSink(CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType myStruct)\n{\n    unsigned int data = myStruct.structFirst;\n    {\n        /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n        ++data;\n        unsigned int result = data;\n        printUnsignedLine(result);\n    }\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_67b_goodB2GSink(CWE190_Integer_Overflow__unsigned_int_rand_preinc_67_structType myStruct)\n{\n    unsigned int data = myStruct.structFirst;\n    /* FIX: Add a check to prevent an overflow from occurring */\n    if (data < UINT_MAX)\n    {\n        ++data;\n        unsigned int result = data;\n        printUnsignedLine(result);\n    }\n    else\n    {\n        printLine(\"data value is too large to perform arithmetic safely.\");\n    }\n}\n\n#endif /* OMITGOOD */\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"integer_overflow\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code performs arithmetic operations that can exceed the maximum size of the data type. This can lead to unexpected behavior, crashes, or security vulnerabilities.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, security bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before arithmetic operations\\n// Instead of: result = a + b;\\n// Use: if (b > INT_MAX - a) { handle_error(); }\\n//       result = a + b;\\n\\n// Or use safe arithmetic functions:\\n// if (!safe_add(a, b, &result)) { handle_error(); }\\n\",\n  \"source\": \"SARD-237281\",\n  \"cwe\": \"CWE-190\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"integer_overflow\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code performs arithmetic operations that can exceed the maximum size of the data type. This can lead to unexpected behavior, crashes, or security vulnerabilities.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, security bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before arithmetic operations\\n// Instead of: result = a + b;\\n// Use: if (b > INT_MAX - a) { handle_error(); }\\n//       result = a + b;\\n\\n// Or use safe arithmetic functions:\\n// if (!safe_add(a, b, &result)) { handle_error(); }\\n\",\n  \"source\": \"SARD-237281\",\n  \"cwe\": \"CWE-190\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE190_Integer_Overflow__unsigned_int_rand_preinc_21.c\nLabel Definition File: CWE190_Integer_Overflow.label.xml\nTemplate File: sources-sinks-21.tmpl.c\n*/\n/*\n * @description\n * CWE: 190 Integer Overflow\n * BadSource: rand Set data to result of rand()\n * GoodSource: Set data to a small, non-zero number (two)\n * Sinks: increment\n *    GoodSink: Ensure there will not be an overflow before incrementing data\n *    BadSink : Increment data, which can cause an overflow\n * Flow Variant: 21 Control flow: Flow controlled by value of a static global variable. All functions contained in one file.\n *\n * */\n\n#include \"std_testcase.h\"\n\n#ifndef OMITBAD\n\n/* The static variable below is used to drive control flow in the sink function */\nstatic int badStatic = 0;\n\nstatic void badSink(unsigned int data)\n{\n    if(badStatic)\n    {\n        {\n            /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n            ++data;\n            unsigned int result = data;\n            printUnsignedLine(result);\n        }\n    }\n}\n\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_21_bad()\n{\n    unsigned int data;\n    data = 0;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (unsigned int)RAND32();\n    badStatic = 1; /* true */\n    badSink(data);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* The static variables below are used to drive control flow in the sink functions. */\nstatic int goodB2G1Static = 0;\nstatic int goodB2G2Static = 0;\nstatic int goodG2BStatic = 0;\n\n/* goodB2G1() - use badsource and goodsink by setting the static variable to false instead of true */\nstatic void goodB2G1Sink(unsigned int data)\n{\n    if(goodB2G1Static)\n    {\n        /* INCIDENTAL: CWE 561 Dead Code, the code below will never run */\n        printLine(\"Benign, fixed string\");\n    }\n    else\n    {\n        /* FIX: Add a check to prevent an overflow from occurring */\n        if (data < UINT_MAX)\n        {\n            ++data;\n            unsigned int result = data;\n            printUnsignedLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\nstatic void goodB2G1()\n{\n    unsigned int data;\n    data = 0;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (unsigned int)RAND32();\n    goodB2G1Static = 0; /* false */\n    goodB2G1Sink(data);\n}\n\n/* goodB2G2() - use badsource and goodsink by reversing the blocks in the if in the sink function */\nstatic void goodB2G2Sink(unsigned int data)\n{\n    if(goodB2G2Static)\n    {\n        /* FIX: Add a check to prevent an overflow from occurring */\n        if (data < UINT_MAX)\n        {\n            ++data;\n            unsigned int result = data;\n            printUnsignedLine(result);\n        }\n        else\n        {\n            printLine(\"data value is too large to perform arithmetic safely.\");\n        }\n    }\n}\n\nstatic void goodB2G2()\n{\n    unsigned int data;\n    data = 0;\n    /* POTENTIAL FLAW: Use a random value */\n    data = (unsigned int)RAND32();\n    goodB2G2Static = 1; /* true */\n    goodB2G2Sink(data);\n}\n\n/* goodG2B() - use goodsource and badsink */\nstatic void goodG2BSink(unsigned int data)\n{\n    if(goodG2BStatic)\n    {\n        {\n            /* POTENTIAL FLAW: Incrementing data could cause an overflow */\n            ++data;\n            unsigned int result = data;\n            printUnsignedLine(result);\n        }\n    }\n}\n\nstatic void goodG2B()\n{\n    unsigned int data;\n    data = 0;\n    /* FIX: Use a small, non-zero value that will not cause an overflow in the sinks */\n    data = 2;\n    goodG2BStatic = 1; /* true */\n    goodG2BSink(data);\n}\n\nvoid CWE190_Integer_Overflow__unsigned_int_rand_preinc_21_good()\n{\n    goodB2G1();\n    goodB2G2();\n    goodG2B();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_21_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE190_Integer_Overflow__unsigned_int_rand_preinc_21_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"integer_overflow\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code performs arithmetic operations that can exceed the maximum size of the data type. This can lead to unexpected behavior, crashes, or security vulnerabilities.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, security bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before arithmetic operations\\n// Instead of: result = a + b;\\n// Use: if (b > INT_MAX - a) { handle_error(); }\\n//       result = a + b;\\n\\n// Or use safe arithmetic functions:\\n// if (!safe_add(a, b, &result)) { handle_error(); }\\n\",\n  \"source\": \"SARD-237263\",\n  \"cwe\": \"CWE-190\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"integer_overflow\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code performs arithmetic operations that can exceed the maximum size of the data type. This can lead to unexpected behavior, crashes, or security vulnerabilities.\",\n  \"risk\": \"Memory corruption, arbitrary code execution, denial of service, security bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before arithmetic operations\\n// Instead of: result = a + b;\\n// Use: if (b > INT_MAX - a) { handle_error(); }\\n//       result = a + b;\\n\\n// Or use safe arithmetic functions:\\n// if (!safe_add(a, b, &result)) { handle_error(); }\\n\",\n  \"source\": \"SARD-237263\",\n  \"cwe\": \"CWE-190\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* pcapng.c\n *\n * $Id$\n *\n * Wiretap Library\n * Copyright (c) 1998 by Gilbert Ramirez <gram@alumni.rice.edu>\n *\n * File format support for pcap-ng file format\n * Copyright (c) 2007 by Ulf Lamping <ulf.lamping@web.de>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\n\n/* File format reference:\n *   http://www.winpcap.org/ntar/draft/PCAP-DumpFileFormat.html\n * Related Wiki page:\n *   http://wiki.wireshark.org/Development/PcapNg\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n/* Needed for addrinfo */\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\n\n#ifdef HAVE_NETINET_IN_H\n# include <netinet/in.h>\n#endif\n\n#ifdef HAVE_NETDB_H\n# include <netdb.h>\n#endif\n\n#ifdef HAVE_WINSOCK2_H\n# include <winsock2.h>\n#endif\n\n#if defined(_WIN32) && defined(INET6)\n# include <ws2tcpip.h>\n#endif\n\n#include \"wtap-int.h\"\n#include \"file_wrappers.h\"\n#include \"buffer.h\"\n#include \"libpcap.h\"\n#include \"pcap-common.h\"\n#include \"pcap-encap.h\"\n#include \"pcapng.h\"\n\n#if 0\n#define pcapng_debug0(str) g_warning(str)\n#define pcapng_debug1(str,p1) g_warning(str,p1)\n#define pcapng_debug2(str,p1,p2) g_warning(str,p1,p2)\n#define pcapng_debug3(str,p1,p2,p3) g_warning(str,p1,p2,p3)\n#else\n#define pcapng_debug0(str)\n#define pcapng_debug1(str,p1)\n#define pcapng_debug2(str,p1,p2)\n#define pcapng_debug3(str,p1,p2,p3)\n#endif\n\nstatic gboolean\npcapng_read(wtap *wth, int *err, gchar **err_info,\n    gint64 *data_offset);\nstatic gboolean\npcapng_seek_read(wtap *wth, gint64 seek_off,\n    union wtap_pseudo_header *pseudo_header, guint8 *pd, int length,\n    int *err, gchar **err_info);\nstatic void\npcapng_close(wtap *wth);\n\n\n/* pcapng: common block header for every block type */\ntypedef struct pcapng_block_header_s {\n        guint32 block_type;\n        guint32 block_total_length;\n        /* x bytes block_body */\n        /* guint32 block_total_length */\n} pcapng_block_header_t;\n\n/*\n * Minimum block size = size of block header + size of block trailer.\n */\n#define MIN_BLOCK_SIZE  ((guint32)(sizeof(pcapng_block_header_t) + sizeof(guint32)))\n\n/* pcapng: section header block */\ntypedef struct pcapng_section_header_block_s {\n        /* pcapng_block_header_t */\n        guint32 magic;\n        guint16 version_major;\n        guint16 version_minor;\n        guint64 section_length; /* might be -1 for unknown */\n        /* ... Options ... */\n} pcapng_section_header_block_t;\n\n/*\n * Minimum SHB size = minimum block size + size of fixed length portion of SHB.\n */\n#define MIN_SHB_SIZE    ((guint32)(MIN_BLOCK_SIZE + sizeof(pcapng_section_header_block_t)))\n\n/* pcapng: interface description block */\ntypedef struct pcapng_interface_description_block_s {\n        guint16 linktype;\n        guint16 reserved;\n        guint32 snaplen;\n        /* ... Options ... */\n} pcapng_interface_description_block_t;\n\n/*\n * Minimum IDB size = minimum block size + size of fixed length portion of IDB.\n */\n#define MIN_IDB_SIZE    ((guint32)(MIN_BLOCK_SIZE + sizeof(pcapng_interface_description_block_t)))\n\n/* pcapng: packet block (obsolete) */\ntypedef struct pcapng_packet_block_s {\n        guint16 interface_id;\n        guint16 drops_count;\n        guint32 timestamp_high;\n        guint32 timestamp_low;\n        guint32 captured_len;\n        guint32 packet_len;\n        /* ... Packet Data ... */\n        /* ... Padding ... */\n        /* ... Options ... */\n} pcapng_packet_block_t;\n\n/*\n * Minimum PB size = minimum block size + size of fixed length portion of PB.\n */\n#define MIN_PB_SIZE     ((guint32)(MIN_BLOCK_SIZE + sizeof(pcapng_packet_block_t)))\n\n/* pcapng: enhanced packet block */\ntypedef struct pcapng_enhanced_packet_block_s {\n        guint32 interface_id;\n        guint32 timestamp_high;\n        guint32 timestamp_low;\n        guint32 captured_len;\n        guint32 packet_len;\n        /* ... Packet Data ... */\n        /* ... Padding ... */\n        /* ... Options ... */\n} pcapng_enhanced_packet_block_t;\n\n/*\n * Minimum EPB size = minimum block size + size of fixed length portion of EPB.\n */\n#define MIN_EPB_SIZE    ((guint32)(MIN_BLOCK_SIZE + sizeof(pcapng_enhanced_packet_block_t)))\n\n/* pcapng: simple packet block */\ntypedef struct pcapng_simple_packet_block_s {\n        guint32 packet_len;\n        /* ... Packet Data ... */\n        /* ... Padding ... */\n} pcapng_simple_packet_block_t;\n\n/*\n * Minimum SPB size = minimum block size + size of fixed length portion of SPB.\n */\n#define MIN_SPB_SIZE    ((guint32)(MIN_BLOCK_SIZE + sizeof(pcapng_simple_packet_block_t)))\n\n/* pcapng: name resolution block */\ntypedef struct pcapng_name_resolution_block_s {\n        guint16 record_type;\n        guint16 record_len;\n        /* ... Record ... */\n} pcapng_name_resolution_block_t;\n\n/*\n * Minimum NRB size = minimum block size + size of smallest NRB record\n * (there must at least be an \"end of records\" record).\n */\n#define MIN_NRB_SIZE    ((guint32)(MIN_BLOCK_SIZE + sizeof(pcapng_name_resolution_block_t)))\n\n/* pcapng: interface statistics block */\ntypedef struct pcapng_interface_statistics_block_s {\n        guint32 interface_id;\n        guint32 timestamp_high;\n        guint32 timestamp_low;\n        /* ... Options ... */\n} pcapng_interface_statistics_block_t;\n\n/*\n * Minimum ISB size = minimum block size + size of fixed length portion of ISB.\n */\n#define MIN_ISB_SIZE    ((guint32)(MIN_BLOCK_SIZE + sizeof(pcapng_interface_statistics_block_t)))\n\n/* pcapng: common option header for every option type */\ntypedef struct pcapng_option_header_s {\n        guint16 option_code;\n        guint16 option_length;\n        /* ... x bytes Option Body ... */\n        /* ... Padding ... */\n} pcapng_option_header_t;\n\nstruct option {\n        guint16 type;\n        guint16 value_length;\n};\n\n/* Block types */\n#define BLOCK_TYPE_IDB 0x00000001 /* Interface Description Block */\n#define BLOCK_TYPE_PB  0x00000002 /* Packet Block (obsolete) */\n#define BLOCK_TYPE_SPB 0x00000003 /* Simple Packet Block */\n#define BLOCK_TYPE_NRB 0x00000004 /* Name Resolution Block */\n#define BLOCK_TYPE_ISB 0x00000005 /* Interface Statistics Block */\n#define BLOCK_TYPE_EPB 0x00000006 /* Enhanced Packet Block */\n#define BLOCK_TYPE_SHB 0x0A0D0D0A /* Section Header Block */\n\n/* Options */\n#define OPT_EOFOPT       0\n#define OPT_COMMENT      1\n#define OPT_SHB_HARDWARE 2\n#define OPT_SHB_OS       3\n#define OPT_SHB_USERAPPL 4\n\n/* Capture section */\n#if 0\n/* Moved to wtap.h */\ntypedef struct wtapng_section_s {\n        /* mandatory */\n        guint64                         section_length;\n        /* options */\n        gchar                           *opt_comment;   /* NULL if not available */\n        gchar                           *shb_hardware;  /* NULL if not available */\n        gchar                           *shb_os;                /* NULL if not available */\n        gchar                           *shb_user_appl; /* NULL if not available */\n} wtapng_section_t;\n#endif\n\n#if 0\n/* Moved to wtap.h */\n\n/* Interface Description\n *\n * Options:\n * if_name        2  A UTF-8 string containing the name of the device used to capture data. \"eth0\" / \"\\Device\\NPF_{AD1CE675-96D0-47C5-ADD0-2504B9126B68}\" / ...\n * if_description 3  A UTF-8 string containing the description of the device used to capture data. \"Broadcom NetXtreme\" / \"First Ethernet Interface\" / ...\n * if_IPv4addr    4  Interface network address and netmask. This option can be repeated multiple times within the same Interface Description Block when multiple IPv4 addresses are assigned to the interface. 192 168 1 1 255 255 255 0\n * if_IPv6addr    5  Interface network address and prefix length (stored in the last byte). This option can be repeated multiple times within the same Interface Description Block when multiple IPv6 addresses are assigned to the interface. 2001:0db8:85a3:08d3:1319:8a2e:0370:7344/64 is written (in hex) as \"20 01 0d b8 85 a3 08 d3 13 19 8a 2e 03 70 73 44 40\"\n * if_MACaddr     6  Interface Hardware MAC address (48 bits). 00 01 02 03 04 05\n * if_EUIaddr     7  Interface Hardware EUI address (64 bits), if available. TODO: give a good example\n * if_speed       8  Interface speed (in bps). 100000000 for 100Mbps\n * if_tsresol     9  Resolution of timestamps. If the Most Significant Bit is equal to zero, the remaining bits indicates the resolution of the timestamp as as a negative power of 10 (e.g. 6 means microsecond resolution, timestamps are the number of microseconds since 1/1/1970). If the Most Significant Bit is equal to one, the remaining bits indicates the resolution as as negative power of 2 (e.g. 10 means 1/1024 of second). If this option is not present, a resolution of 10^-6 is assumed (i.e. timestamps have the same resolution of the standard 'libpcap' timestamps). 6\n * if_tzone      10  Time zone for GMT support (TODO: specify better). TODO: give a good example\n * if_filter     11  The filter (e.g. \"capture only TCP traffic\") used to capture traffic. The first byte of the Option Data keeps a code of the filter used (e.g. if this is a libpcap string, or BPF bytecode, and more). More details about this format will be presented in Appendix XXX (TODO). (TODO: better use different options for different fields? e.g. if_filter_pcap, if_filter_bpf, ...) 00 \"tcp port 23 and host 10.0.0.5\"\n * if_os         12  A UTF-8 string containing the name of the operating system of the machine in which this interface is installed. This can be different from the same information that can be contained by the Section Header Block (Section 3.1 (Section Header Block (mandatory))) because the capture can have been done on a remote machine. \"Windows XP SP2\" / \"openSUSE 10.2\" / ...\n * if_fcslen     13  An integer value that specified the length of the Frame Check Sequence (in bits) for this interface. For link layers whose FCS length can change during time, the Packet Block Flags Word can be used (see Appendix A (Packet Block Flags Word)). 4\n * if_tsoffset   14  A 64 bits integer value that specifies an offset (in seconds) that must be added to the timestamp of each packet to obtain the absolute timestamp of a packet. If the option is missing, the timestamps stored in the packet must be considered absolute timestamps. The time zone of the offset can be specified with the option if_tzone. TODO: won't a if_tsoffset_low for fractional second offsets be useful for highly synchronized capture systems? 1234\n */\n\ntypedef struct wtapng_if_descr_s {\n        /* mandatory */\n        guint16                         link_type;\n        guint                           encap;\n        guint32                         snap_len;\n        /* options */\n        gchar                           *opt_comment;   /* NULL if not available */\n        gchar                           *if_name;               /* NULL if not available, opt 2 A UTF-8 string containing the name of the device used to capture data. */\n        gchar                           *if_description;/* NULL if not available, opt 3 A UTF-8 string containing the description of the device used to capture data. */\n        /* XXX: if_IPv4addr opt 4  Interface network address and netmask.*/\n        /* XXX: if_IPv6addr opt 5  Interface network address and prefix length (stored in the last byte).*/\n        /* XXX: if_MACaddr  opt 6  Interface Hardware MAC address (48 bits).*/\n        /* XXX: if_EUIaddr  opt 7  Interface Hardware EUI address (64 bits)*/\n        guint64                         if_speed;       /* 0 if unknown, opt 8  Interface speed (in bps). 100000000 for 100Mbps */\n        guint8                          if_tsresol;     /* default is 6 for microsecond resolution, opt 9  Resolution of timestamps.\n                                                                         * If the Most Significant Bit is equal to zero, the remaining bits indicates the resolution of the timestamp as as a negative power of 10\n                                                                         */\n        /* XXX: if_tzone      10  Time zone for GMT support (TODO: specify better). */\n        gchar                           *if_filter;     /* NULL if not available, opt 11  The filter (e.g. \"capture only TCP traffic\") used to capture traffic.\n                                                                         * The first byte of the Option Data keeps a code of the filter used (e.g. if this is a libpcap string, or BPF bytecode, and more).\n                                                                         */\n        gchar                           *if_os;         /* NULL if not available, 12  A UTF-8 string containing the name of the operating system of the machine in which this interface is installed. */\n        gint8                           if_fcslen;      /* -1 if unknown or changes between packets, opt 13  An integer value that specified the length of the Frame Check Sequence (in bits) for this interface. */\n        /* XXX: guint64 if_tsoffset; opt 14  A 64 bits integer value that specifies an offset (in seconds)...*/\n} wtapng_if_descr_t;\n#endif\n\n/* Packets */\ntypedef struct wtapng_packet_s {\n        /* mandatory */\n        guint32                         ts_high;        /* seconds since 1.1.1970 */\n        guint32                         ts_low;         /* fraction of seconds, depends on if_tsresol */\n        guint32                         cap_len;        /* data length in the file */\n        guint32                         packet_len;     /* data length on the wire */\n        guint32                         interface_id;   /* identifier of the interface. */\n        guint16                         drops_count;    /* drops count, only valid for packet block */\n                                                                                /* 0xffff if information no available */\n        /* pack_hash */\n        /* XXX - put the packet data / pseudo_header here as well? */\n} wtapng_packet_t;\n\n/* Simple Packets */\ntypedef struct wtapng_simple_packet_s {\n        /* mandatory */\n        guint32                         cap_len;        /* data length in the file */\n        guint32                         packet_len;     /* data length on the wire */\n        guint32                         pseudo_header_len;\n        int                             wtap_encap;\n        /* XXX - put the packet data / pseudo_header here as well? */\n} wtapng_simple_packet_t;\n\n/* Name Resolution */\ntypedef struct wtapng_name_res_s {\n        /* options */\n        gchar                           *opt_comment;   /* NULL if not available */\n        /* XXX */\n} wtapng_name_res_t;\n\n#if 0\n/* Interface Statistics moved to wtap.h*/\ntypedef struct wtapng_if_stats_s {\n        /* mandatory */\n        guint32                         interface_id;\n        guint32                         ts_high;\n        guint32                         ts_low;\n        /* options */\n        gchar                           *opt_comment;   /* NULL if not available */\n        guint64                         isb_starttime;\n        guint64                         isb_endtime;\n        guint64                         isb_ifrecv;\n        guint64                         isb_ifdrop;\n        guint64                         isb_filteraccept;\n        guint64                         isb_osdrop;\n        guint64                         isb_usrdeliv;\n} wtapng_if_stats_t;\n#endif\n\ntypedef struct wtapng_block_s {\n        guint32                                 type;           /* block_type as defined by pcapng */\n        union {\n                wtapng_section_t        section;\n                wtapng_if_descr_t       if_descr;\n                wtapng_packet_t         packet;\n                wtapng_simple_packet_t  simple_packet;\n                wtapng_name_res_t       name_res;\n                wtapng_if_stats_t       if_stats;\n        } data;\n\n        /*\n         * XXX - currently don't know how to handle these!\n         *\n         * For one thing, when we're reading a block, they must be\n         * writable, i.e. not const, so that we can read into them,\n         * but, when we're writing a block, they can be const, and,\n         * in fact, they sometimes point to const values.\n         */\n        const union wtap_pseudo_header *pseudo_header;\n        struct wtap_pkthdr *packet_header;\n        const guint8 *frame_buffer;\n        int *file_encap;\n} wtapng_block_t;\n\n/* Interface data in private struct */\ntypedef struct interface_data_s {\n        int wtap_encap;\n        guint64 time_units_per_second;\n} interface_data_t;\n\ntypedef struct {\n        gboolean shb_read;                                              /**< Set when first SHB read, second read will fail */\n        gboolean read_idbs;                                             /**< Indicates that it is the first read after a SHB, at least one IDB is expected */\n        gboolean byte_swapped;\n        guint16 version_major;\n        guint16 version_minor;\n        GArray *interface_data;\n        guint number_of_interfaces;\n        gint8 if_fcslen;\n        wtap_new_ipv4_callback_t add_new_ipv4;\n        wtap_new_ipv6_callback_t add_new_ipv6;\n} pcapng_t;\n\nstatic int\npcapng_read_option(FILE_T fh, pcapng_t *pn, pcapng_option_header_t *oh,\n                   char *content, int len, int *err, gchar **err_info)\n{\n        int     bytes_read;\n        int     block_read;\n        guint64 file_offset64;\n\n\n        /* read option header */\n        errno = WTAP_ERR_CANT_READ;\n        bytes_read = file_read(oh, sizeof (*oh), fh);\n        if (bytes_read != sizeof (*oh)) {\n            pcapng_debug0(\"pcapng_read_option: failed to read option\");\n            *err = file_error(fh, err_info);\n            if (*err != 0)\n                    return -1;\n            return 0;\n        }\n        block_read = sizeof (*oh);\n        if (pn->byte_swapped) {\n                oh->option_code      = BSWAP16(oh->option_code);\n                oh->option_length    = BSWAP16(oh->option_length);\n        }\n\n        /* sanity check: option length */\n        if (oh->option_length > len) {\n                pcapng_debug2(\"pcapng_read_option: option_length %u larger than buffer (%u)\",\n                              oh->option_length, len);\n                return 0;\n        }\n\n        /* read option content */\n        errno = WTAP_ERR_CANT_READ;\n        bytes_read = file_read(content, oh->option_length, fh);\n        if (bytes_read != oh->option_length) {\n                pcapng_debug1(\"pcapng_read_option: failed to read content of option %u\", oh->option_code);\n                *err = file_error(fh, err_info);\n                if (*err != 0)\n                        return -1;\n                return 0;\n        }\n        block_read += oh->option_length;\n\n        /* jump over potential padding bytes at end of option */\n        if ( (oh->option_length % 4) != 0) {\n                file_offset64 = file_seek(fh, 4 - (oh->option_length % 4), SEEK_CUR, err);\n                if (file_offset64 <= 0) {\n                        if (*err != 0)\n                                return -1;\n                        return 0;\n                }\n                block_read += 4 - (oh->option_length % 4);\n        }\n\n        return block_read;\n}\n\n\nstatic int\npcapng_read_section_header_block(FILE_T fh, gboolean first_block,\n                                 pcapng_block_header_t *bh, pcapng_t *pn,\n                                 wtapng_block_t *wblock, int *err,\n                                 gchar **err_info)\n{\n        int     bytes_read;\n        int     block_read;\n        int to_read, opt_cont_buf_len;\n        pcapng_section_header_block_t shb;\n        pcapng_option_header_t oh;\n        char *option_content = NULL; /* Allocate as large as the options block */\n\n        /*\n         * Is this block long enough to be an SHB?\n         */\n        if (bh->block_total_length < MIN_SHB_SIZE) {\n                /*\n                 * No.\n                 */\n                if (first_block)\n                        return 0;       /* probably not a pcap-ng file */\n                *err = WTAP_ERR_BAD_FILE;\n                *err_info = g_strdup_printf(\"pcapng_read_section_header_block: total block length %u of an SHB is less than the minimum SHB size %u\",\n                              bh->block_total_length, MIN_SHB_SIZE);\n                return -1;\n        }\n\n        /* read block content */\n        errno = WTAP_ERR_CANT_READ;\n        bytes_read = file_read(&shb, sizeof shb, fh);\n        if (bytes_read != sizeof shb) {\n                *err = file_error(fh, err_info);\n                if (*err == 0) {\n                        if (first_block) {\n                                /*\n                                 * We're reading this as part of an open,\n                                 * and this block is too short to be\n                                 * an SHB, so the file is too short\n                                 * to be a pcap-ng file.\n                                 */\n                                return 0;\n                        }\n\n                        /*\n                         * Otherwise, just report this as an error.\n                         */\n                        *err = WTAP_ERR_SHORT_READ;\n                }\n                return -1;\n        }\n        block_read = bytes_read;\n\n        /* is the magic number one we expect? */\n        switch (shb.magic) {\n            case(0x1A2B3C4D):\n                /* this seems pcapng with correct byte order */\n                pn->byte_swapped                = FALSE;\n                pn->version_major               = shb.version_major;\n                pn->version_minor               = shb.version_minor;\n\n                pcapng_debug3(\"pcapng_read_section_header_block: SHB (little endian) V%u.%u, len %u\",\n                                pn->version_major, pn->version_minor, bh->block_total_length);\n                break;\n            case(0x4D3C2B1A):\n                /* this seems pcapng with swapped byte order */\n                pn->byte_swapped                = TRUE;\n                pn->version_major               = BSWAP16(shb.version_major);\n                pn->version_minor               = BSWAP16(shb.version_minor);\n\n                /* tweak the block length to meet current swapping that we know now */\n                bh->block_total_length  = BSWAP32(bh->block_total_length);\n\n                pcapng_debug3(\"pcapng_read_section_header_block: SHB (big endian) V%u.%u, len %u\",\n                                pn->version_major, pn->version_minor, bh->block_total_length);\n                break;\n            default:\n                /* Not a \"pcapng\" magic number we know about. */\n                if (first_block) {\n                        /* Not a pcap-ng file. */\n                        return 0;\n                }\n\n                /* A bad block */\n                *err = WTAP_ERR_BAD_FILE;\n                *err_info = g_strdup_printf(\"pcapng_read_section_header_block: unknown byte-order magic number 0x%08x\", shb.magic);\n                return 0;\n        }\n\n        /* OK, at this point we assume it's a pcap-ng file. */\n        /* We currently only suport one SHB */\n        if (pn->shb_read == TRUE) {\n                *err = WTAP_ERR_UNSUPPORTED;\n                *err_info = g_strdup_printf(\"pcapng: multiple section header blocks not supported.\");\n                return 0;\n        }\n\n        /* we currently only understand SHB V1.0 */\n        if (pn->version_major != 1 || pn->version_minor > 0) {\n                *err = WTAP_ERR_UNSUPPORTED;\n                *err_info = g_strdup_printf(\"pcapng_read_section_header_block: unknown SHB version %u.%u\",\n                              pn->version_major, pn->version_minor);\n                return -1;\n        }\n\n\n        /* 64bit section_length (currently unused) */\n        if (pn->byte_swapped) {\n                wblock->data.section.section_length = BSWAP64(shb.section_length);\n        } else {\n                wblock->data.section.section_length = shb.section_length;\n        }\n\n        /* Option defaults */\n        wblock->data.section.opt_comment        = NULL;\n        wblock->data.section.shb_hardware       = NULL;\n        wblock->data.section.shb_os                     = NULL;\n        wblock->data.section.shb_user_appl      = NULL;\n\n        /* Options */\n        errno = WTAP_ERR_CANT_READ;\n        to_read = bh->block_total_length - MIN_SHB_SIZE;\n        /* Allocate enough memory to hold all options */\n        opt_cont_buf_len = to_read;\n        option_content = (char *)g_malloc(opt_cont_buf_len);\n        pcapng_debug1(\"pcapng_read_section_header_block: Options %u bytes\", to_read);\n        while (to_read > 0) {\n                /* read option */\n                pcapng_debug1(\"pcapng_read_section_header_block: Options %u bytes remaining\", to_read);\n                bytes_read = pcapng_read_option(fh, pn, &oh, option_content, opt_cont_buf_len, err, err_info);\n                if (bytes_read <= 0) {\n                        pcapng_debug0(\"pcapng_read_section_header_block: failed to read option\");\n                        return bytes_read;\n                }\n                block_read += bytes_read;\n                to_read -= bytes_read;\n\n                /* handle option content */\n                switch (oh.option_code) {\n                    case(0): /* opt_endofopt */\n                        if (to_read != 0) {\n                                pcapng_debug1(\"pcapng_read_section_header_block: %u bytes after opt_endofopt\", to_read);\n                        }\n                        /* padding should be ok here, just get out of this */\n                        to_read = 0;\n                        break;\n                    case(1): /* opt_comment */\n                        if (oh.option_length > 0 && oh.option_length < opt_cont_buf_len) {\n                                wblock->data.section.opt_comment = g_strndup(option_content, oh.option_length);\n                                pcapng_debug1(\"pcapng_read_section_header_block: opt_comment %s\", wblock->data.section.opt_comment);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_section_header_block: opt_comment length %u seems strange\", oh.option_length);\n                        }\n                        break;\n                    case(2): /* shb_hardware */\n                        if (oh.option_length > 0 && oh.option_length < opt_cont_buf_len) {\n                                wblock->data.section.shb_hardware = g_strndup(option_content, oh.option_length);\n                                pcapng_debug1(\"pcapng_read_section_header_block: shb_hardware %s\", wblock->data.section.shb_hardware);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_section_header_block: shb_hardware length %u seems strange\", oh.option_length);\n                        }\n                        break;\n                    case(3): /* shb_os */\n                        if (oh.option_length > 0 && oh.option_length < opt_cont_buf_len) {\n                                wblock->data.section.shb_os = g_strndup(option_content, oh.option_length);\n                                pcapng_debug1(\"pcapng_read_section_header_block: shb_os %s\", wblock->data.section.shb_os);\n                        } else {\n                                pcapng_debug2(\"pcapng_read_section_header_block: shb_os length %u seems strange, opt buffsize %u\", oh.option_length,to_read);\n                        }\n                        break;\n                    case(4): /* shb_user_appl */\n                        if (oh.option_length > 0 && oh.option_length < opt_cont_buf_len) {\n                                wblock->data.section.shb_user_appl = g_strndup(option_content, oh.option_length);\n                                pcapng_debug1(\"pcapng_read_section_header_block: shb_user_appl %s\", wblock->data.section.shb_user_appl);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_section_header_block: shb_user_appl length %u seems strange\", oh.option_length);\n                        }\n                        break;\n                    default:\n                        pcapng_debug2(\"pcapng_read_section_header_block: unknown option %u - ignoring %u bytes\",\n                                      oh.option_code, oh.option_length);\n                }\n        }\n        g_free(option_content);\n\n        return block_read;\n}\n\n\n/* \"Interface Description Block\" */\nstatic int\npcapng_read_if_descr_block(FILE_T fh, pcapng_block_header_t *bh, pcapng_t *pn,\n                           wtapng_block_t *wblock, int *err, gchar **err_info)\n{\n        guint64 time_units_per_second = 1000000; /* default */\n        int     bytes_read;\n        int     block_read;\n        int to_read, opt_cont_buf_len;\n        pcapng_interface_description_block_t idb;\n        pcapng_option_header_t oh;\n        char *option_content = NULL; /* Allocate as large as the options block */\n\n        /*\n         * Is this block long enough to be an IDB?\n         */\n        if (bh->block_total_length < MIN_IDB_SIZE) {\n                /*\n                 * No.\n                 */\n                *err = WTAP_ERR_BAD_FILE;\n                *err_info = g_strdup_printf(\"pcapng_read_if_descr_block: total block length %u of an IDB is less than the minimum IDB size %u\",\n                              bh->block_total_length, MIN_IDB_SIZE);\n                return -1;\n        }\n\n        /* read block content */\n        errno = WTAP_ERR_CANT_READ;\n        bytes_read = file_read(&idb, sizeof idb, fh);\n        if (bytes_read != sizeof idb) {\n                pcapng_debug0(\"pcapng_read_if_descr_block: failed to read IDB\");\n                *err = file_error(fh, err_info);\n                if (*err != 0)\n                        return -1;\n                return 0;\n        }\n        block_read = bytes_read;\n\n        /* mandatory values */\n        if (pn->byte_swapped) {\n                wblock->data.if_descr.link_type = BSWAP16(idb.linktype);\n                wblock->data.if_descr.snap_len  = BSWAP32(idb.snaplen);\n        } else {\n                wblock->data.if_descr.link_type = idb.linktype;\n                wblock->data.if_descr.snap_len  = idb.snaplen;\n        }\n\n        wblock->data.if_descr.wtap_encap = wtap_pcap_encap_to_wtap_encap(wblock->data.if_descr.link_type);\n        wblock->data.if_descr.time_units_per_second = time_units_per_second;\n\n        pcapng_debug3(\"pcapng_read_if_descr_block: IDB link_type %u (%s), snap %u\",\n                      wblock->data.if_descr.link_type,\n                      wtap_encap_string(wblock->data.if_descr.wtap_encap),\n                      wblock->data.if_descr.snap_len);\n\n        if (wblock->data.if_descr.snap_len > WTAP_MAX_PACKET_SIZE) {\n                /* This is unrealistic, but text2pcap currently uses 102400.\n                 * We do not use this value, maybe we should check the\n                 * snap_len of the packets against it. For now, only warn.\n                 */\n                pcapng_debug1(\"pcapng_read_if_descr_block: snapshot length %u unrealistic.\",\n                              wblock->data.if_descr.snap_len);\n                /*wblock->data.if_descr.snap_len = WTAP_MAX_PACKET_SIZE;*/\n        }\n\n        /* Option defaults */\n        wblock->data.if_descr.opt_comment = NULL;\n        wblock->data.if_descr.if_name = NULL;\n        wblock->data.if_descr.if_description = NULL;\n        /* XXX: if_IPv4addr */\n        /* XXX: if_IPv6addr */\n        /* XXX: if_MACaddr */\n        /* XXX: if_EUIaddr */\n        wblock->data.if_descr.if_speed = 0;                     /* \"unknown\" */\n        wblock->data.if_descr.if_tsresol = 6;                   /* default is 6 for microsecond resolution */\n        wblock->data.if_descr.if_filter_str = NULL;\n        wblock->data.if_descr.bpf_filter_len = 0;\n        wblock->data.if_descr.if_filter_bpf_bytes = NULL;\n        wblock->data.if_descr.if_os = NULL;\n        wblock->data.if_descr.if_fcslen = -1;                   /* unknown or changes between packets */\n        /* XXX: guint64 if_tsoffset; */\n\n\n        /* Options */\n        errno = WTAP_ERR_CANT_READ;\n        to_read = bh->block_total_length - MIN_IDB_SIZE;\n\n        /* Allocate enough memory to hold all options */\n        opt_cont_buf_len = to_read;\n        option_content = (char *)g_malloc(opt_cont_buf_len);\n\n        while (to_read > 0) {\n                /* read option */\n                bytes_read = pcapng_read_option(fh, pn, &oh, option_content, opt_cont_buf_len, err, err_info);\n                if (bytes_read <= 0) {\n                        pcapng_debug0(\"pcapng_read_if_descr_block: failed to read option\");\n                        return bytes_read;\n                }\n                block_read += bytes_read;\n                to_read -= bytes_read;\n\n                /* handle option content */\n                switch (oh.option_code) {\n                    case(0): /* opt_endofopt */\n                        if (to_read != 0) {\n                                pcapng_debug1(\"pcapng_read_if_descr_block: %u bytes after opt_endofopt\", to_read);\n                        }\n                        /* padding should be ok here, just get out of this */\n                        to_read = 0;\n                        break;\n                    case(1): /* opt_comment */\n                        if (oh.option_length > 0 && oh.option_length < opt_cont_buf_len) {\n                                wblock->data.if_descr.opt_comment = g_strndup(option_content, oh.option_length);\n                                pcapng_debug1(\"pcapng_read_if_descr_block: opt_comment %s\", wblock->data.if_descr.opt_comment);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_if_descr_block: opt_comment length %u seems strange\", oh.option_length);\n                        }\n                        break;\n                    case(2): /* if_name */\n                        if (oh.option_length > 0 && oh.option_length < opt_cont_buf_len) {\n                                wblock->data.if_descr.if_name = g_strndup(option_content, oh.option_length);\n                                pcapng_debug1(\"pcapng_read_if_descr_block: if_name %s\", wblock->data.if_descr.if_name);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_if_descr_block: if_name length %u seems strange\", oh.option_length);\n                        }\n                        break;\n                    case(3): /* if_description */\n                        if (oh.option_length > 0 && oh.option_length < opt_cont_buf_len) {\n                            wblock->data.if_descr.if_description = g_strndup(option_content, oh.option_length);\n                                pcapng_debug1(\"pcapng_read_if_descr_block: if_description %s\", wblock->data.if_descr.if_description);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_if_descr_block: if_description length %u seems strange\", oh.option_length);\n                        }\n                        break;\n                        /*\n                         * if_IPv4addr    4  Interface network address and netmask. This option can be repeated multiple times within the same Interface Description Block when multiple IPv4 addresses are assigned to the interface. 192 168 1 1 255 255 255 0\n                         * if_IPv6addr    5  Interface network address and prefix length (stored in the last byte). This option can be repeated multiple times within the same Interface Description Block when multiple IPv6 addresses are assigned to the interface. 2001:0db8:85a3:08d3:1319:8a2e:0370:7344/64 is written (in hex) as \"20 01 0d b8 85 a3 08 d3 13 19 8a 2e 03 70 73 44 40\"\n                         * if_MACaddr     6  Interface Hardware MAC address (48 bits). 00 01 02 03 04 05\n                         * if_EUIaddr     7  Interface Hardware EUI address (64 bits), if available. TODO: give a good example\n                         */\n                    case(8): /* if_speed */\n                        if (oh.option_length == 8) {\n                                /*  Don't cast a char[] into a guint64--the\n                                 *  char[] may not be aligned correctly.\n                                 */\n                                memcpy(&wblock->data.if_descr.if_speed, option_content, sizeof(guint64));\n                                if (pn->byte_swapped)\n                                        wblock->data.if_descr.if_speed = BSWAP64(wblock->data.if_descr.if_speed);\n                                pcapng_debug1(\"pcapng_read_if_descr_block: if_speed %\" G_GINT64_MODIFIER \"u (bps)\", wblock->data.if_descr.if_speed);\n                        } else {\n                                    pcapng_debug1(\"pcapng_read_if_descr_block: if_speed length %u not 8 as expected\", oh.option_length);\n                        }\n                        break;\n                    case(9): /* if_tsresol */\n                        if (oh.option_length == 1) {\n                                guint64 base;\n                                guint64 result;\n                                guint8 i, exponent, if_tsresol;\n\n                                if_tsresol = option_content[0];\n                                if (if_tsresol & 0x80) {\n                                        base = 2;\n                                } else {\n                                        base = 10;\n                                }\n                                exponent = (guint8)(if_tsresol & 0x7f);\n                                if (((base == 2) && (exponent < 64)) || ((base == 10) && (exponent < 20))) {\n                                        result = 1;\n                                        for (i = 0; i < exponent; i++) {\n                                                result *= base;\n                                        }\n                                        time_units_per_second = result;\n                                } else {\n                                        time_units_per_second = G_MAXUINT64;\n                                }\n                                if (time_units_per_second > (((guint64)1) << 32)) {\n                                        pcapng_debug0(\"pcapng_open: time conversion might be inaccurate\");\n                                }\n                                wblock->data.if_descr.time_units_per_second = time_units_per_second;\n                                wblock->data.if_descr.if_tsresol = if_tsresol;\n                                pcapng_debug2(\"pcapng_read_if_descr_block: if_tsresol %u, units/s %\" G_GINT64_MODIFIER \"u\", wblock->data.if_descr.if_tsresol, wblock->data.if_descr.time_units_per_second);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_if_descr_block: if_tsresol length %u not 1 as expected\", oh.option_length);\n                        }\n                        break;\n                        /*\n                         * if_tzone      10  Time zone for GMT support (TODO: specify better). TODO: give a good example\n                         */\n                    case(11): /* if_filter */\n                        if (oh.option_length > 0 && oh.option_length < opt_cont_buf_len) {\n                                /* The first byte of the Option Data keeps a code of the filter used (e.g. if this is a libpcap string,\n                                 * or BPF bytecode.\n                                 */\n                                if (option_content[0] == 0) {\n                                        wblock->data.if_descr.if_filter_str = g_strndup(option_content+1, oh.option_length-1);\n                                        pcapng_debug2(\"pcapng_read_if_descr_block: if_filter_str %s oh.option_length %u\", wblock->data.if_descr.if_filter_str, oh.option_length);\n                                } else if (option_content[0] == 1) {\n                                        wblock->data.if_descr.bpf_filter_len = oh.option_length-1;\n                                        wblock->data.if_descr.if_filter_bpf_bytes = (gchar *)g_malloc(oh.option_length-1);\n                                        memcpy(&wblock->data.if_descr.if_filter_bpf_bytes, option_content+1, oh.option_length-1);\n                                }\n                        } else {\n                                pcapng_debug1(\"pcapng_read_if_descr_block: if_filter length %u seems strange\", oh.option_length);\n                        }\n                        break;\n                        case(12): /* if_os */\n                        /*\n                         * if_os         12  A UTF-8 string containing the name of the operating system of the machine in which this interface is installed.\n                         * This can be different from the same information that can be contained by the Section Header Block (Section 3.1 (Section Header Block (mandatory)))\n                         * because the capture can have been done on a remote machine. \"Windows XP SP2\" / \"openSUSE 10.2\" / ...\n                         */\n                        if (oh.option_length > 0 && oh.option_length < opt_cont_buf_len) {\n                            wblock->data.if_descr.if_os = g_strndup(option_content, oh.option_length);\n                                pcapng_debug1(\"pcapng_read_if_descr_block: if_os %s\", wblock->data.if_descr.if_os);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_if_descr_block: if_os length %u seems strange\", oh.option_length);\n                        }\n                        break;\n                    case(13): /* if_fcslen */\n                        if (oh.option_length == 1) {\n                                wblock->data.if_descr.if_fcslen = option_content[0];\n                                pn->if_fcslen = wblock->data.if_descr.if_fcslen;\n                                pcapng_debug1(\"pcapng_read_if_descr_block: if_fcslen %u\", wblock->data.if_descr.if_fcslen);\n                                /* XXX - add sanity check */\n                        } else {\n                                pcapng_debug1(\"pcapng_read_if_descr_block: if_fcslen length %u not 1 as expected\", oh.option_length);\n                        }\n                        break;\n                        /*\n                         * if_tsoffset   14  A 64 bits integer value that specifies an offset (in seconds) that must be added to the timestamp of each packet\n                         * to obtain the absolute timestamp of a packet. If the option is missing, the timestamps stored in the packet must be considered absolute timestamps.\n                         * The time zone of the offset can be specified with the option if_tzone.\n                         * TODO: won't a if_tsoffset_low for fractional second offsets be useful for highly synchronized capture systems? 1234\n                         */\n                    default:\n                        pcapng_debug2(\"pcapng_read_if_descr_block: unknown option %u - ignoring %u bytes\",\n                                      oh.option_code, oh.option_length);\n                }\n        }\n\n        g_free(option_content);\n\n        if (*wblock->file_encap == WTAP_ENCAP_UNKNOWN) {\n                *wblock->file_encap = wblock->data.if_descr.wtap_encap;\n        } else {\n                if (*wblock->file_encap != wblock->data.if_descr.wtap_encap) {\n                        *wblock->file_encap = WTAP_ENCAP_PER_PACKET;\n                }\n        }\n\n        return block_read;\n}\n\n\nstatic int\npcapng_read_packet_block(FILE_T fh, pcapng_block_header_t *bh, pcapng_t *pn, wtapng_block_t *wblock, int *err, gchar **err_info, gboolean enhanced)\n{\n        int bytes_read;\n        int block_read;\n        int to_read, opt_cont_buf_len;\n        guint64 file_offset64;\n        pcapng_enhanced_packet_block_t epb;\n        pcapng_packet_block_t pb;\n        guint32 block_total_length;\n        guint32 padding;\n        interface_data_t int_data;\n        guint64 ts;\n        pcapng_option_header_t oh;\n        int pseudo_header_len;\n        char *option_content = NULL; /* Allocate as large as the options block */\n        int fcslen;\n\n        /* \"(Enhanced) Packet Block\" read fixed part */\n        errno = WTAP_ERR_CANT_READ;\n        if (enhanced) {\n                /*\n                 * Is this block long enough to be an EPB?\n                 */\n                if (bh->block_total_length < MIN_EPB_SIZE) {\n                        /*\n                         * No.\n                         */\n                        *err = WTAP_ERR_BAD_FILE;\n                        *err_info = g_strdup_printf(\"pcapng_read_packet_block: total block length %u of an EPB is less than the minimum EPB size %u\",\n                                      bh->block_total_length, MIN_EPB_SIZE);\n                        return -1;\n                }\n                bytes_read = file_read(&epb, sizeof epb, fh);\n                if (bytes_read != sizeof epb) {\n                        pcapng_debug0(\"pcapng_read_packet_block: failed to read packet data\");\n                        *err = file_error(fh, err_info);\n                        return 0;\n                }\n                block_read = bytes_read;\n\n                if (pn->byte_swapped) {\n                        wblock->data.packet.interface_id        = BSWAP32(epb.interface_id);\n                        wblock->data.packet.drops_count         = -1; /* invalid */\n                        wblock->data.packet.ts_high             = BSWAP32(epb.timestamp_high);\n                        wblock->data.packet.ts_low              = BSWAP32(epb.timestamp_low);\n                        wblock->data.packet.cap_len             = BSWAP32(epb.captured_len);\n                        wblock->data.packet.packet_len          = BSWAP32(epb.packet_len);\n                } else {\n                        wblock->data.packet.interface_id        = epb.interface_id;\n                        wblock->data.packet.drops_count         = -1; /* invalid */\n                        wblock->data.packet.ts_high             = epb.timestamp_high;\n                        wblock->data.packet.ts_low              = epb.timestamp_low;\n                        wblock->data.packet.cap_len             = epb.captured_len;\n                        wblock->data.packet.packet_len          = epb.packet_len;\n                }\n        } else {\n                /*\n                 * Is this block long enough to be a PB?\n                 */\n                if (bh->block_total_length < MIN_PB_SIZE) {\n                        /*\n                         * No.\n                         */\n                        *err = WTAP_ERR_BAD_FILE;\n                        *err_info = g_strdup_printf(\"pcapng_read_packet_block: total block length %u of a PB is less than the minimum PB size %u\",\n                                      bh->block_total_length, MIN_PB_SIZE);\n                        return -1;\n                }\n                bytes_read = file_read(&pb, sizeof pb, fh);\n                if (bytes_read != sizeof pb) {\n                        pcapng_debug0(\"pcapng_read_packet_block: failed to read packet data\");\n                        *err = file_error(fh, err_info);\n                        return 0;\n                }\n                block_read = bytes_read;\n\n                if (pn->byte_swapped) {\n                        wblock->data.packet.interface_id        = BSWAP16(pb.interface_id);\n                        wblock->data.packet.drops_count         = BSWAP16(pb.drops_count);\n                        wblock->data.packet.ts_high             = BSWAP32(pb.timestamp_high);\n                        wblock->data.packet.ts_low              = BSWAP32(pb.timestamp_low);\n                        wblock->data.packet.cap_len             = BSWAP32(pb.captured_len);\n                        wblock->data.packet.packet_len          = BSWAP32(pb.packet_len);\n                } else {\n                        wblock->data.packet.interface_id        = pb.interface_id;\n                        wblock->data.packet.drops_count         = pb.drops_count;\n                        wblock->data.packet.ts_high             = pb.timestamp_high;\n                        wblock->data.packet.ts_low              = pb.timestamp_low;\n                        wblock->data.packet.cap_len             = pb.captured_len;\n                        wblock->data.packet.packet_len          = pb.packet_len;\n                }\n        }\n\n        /*\n         * How much padding is there at the end of the packet data?\n         */\n        if ((wblock->data.packet.cap_len % 4) != 0)\n                padding = 4 - (wblock->data.packet.cap_len % 4);\n        else\n                padding = 0;\n\n        /* add padding bytes to \"block total length\" */\n        /* (the \"block total length\" of some example files don't contain the packet data padding bytes!) */\n        if (bh->block_total_length % 4) {\n                block_total_length = bh->block_total_length + 4 - (bh->block_total_length % 4);\n        } else {\n                block_total_length = bh->block_total_length;\n        }\n\n        /*\n         * Is this block long enough to hold the packet data?\n         */\n        if (enhanced) {\n                if (block_total_length <\n                    MIN_EPB_SIZE + wblock->data.packet.cap_len + padding) {\n                        /*\n                         * No.\n                         */\n                        *err = WTAP_ERR_BAD_FILE;\n                        *err_info = g_strdup_printf(\"pcapng_read_packet_block: total block length %u of EPB is too small for %u bytes of packet data\",\n                                      block_total_length, wblock->data.packet.cap_len);\n                        return -1;\n                }\n        } else {\n                if (block_total_length <\n                    MIN_PB_SIZE + wblock->data.packet.cap_len + padding) {\n                        /*\n                         * No.\n                         */\n                        *err = WTAP_ERR_BAD_FILE;\n                        *err_info = g_strdup_printf(\"pcapng_read_packet_block: total block length %u of PB is too small for %u bytes of packet data\",\n                                      block_total_length, wblock->data.packet.cap_len);\n                        return -1;\n                }\n        }\n\n        if (wblock->data.packet.cap_len > wblock->data.packet.packet_len) {\n                *err = WTAP_ERR_BAD_FILE;\n                *err_info = g_strdup_printf(\"pcapng_read_packet_block: cap_len %u is larger than packet_len %u.\",\n                    wblock->data.packet.cap_len, wblock->data.packet.packet_len);\n                return 0;\n        }\n        if (wblock->data.packet.cap_len > WTAP_MAX_PACKET_SIZE) {\n                *err = WTAP_ERR_BAD_FILE;\n                *err_info = g_strdup_printf(\"pcapng_read_packet_block: cap_len %u is larger than WTAP_MAX_PACKET_SIZE %u.\",\n                    wblock->data.packet.cap_len, WTAP_MAX_PACKET_SIZE);\n                return 0;\n        }\n        pcapng_debug3(\"pcapng_read_packet_block: packet data: packet_len %u captured_len %u interface_id %u\",\n                      wblock->data.packet.packet_len,\n                      wblock->data.packet.cap_len,\n                      wblock->data.packet.interface_id);\n\n        if (wblock->data.packet.interface_id >= pn->number_of_interfaces) {\n                *err = WTAP_ERR_BAD_FILE;\n                *err_info = g_strdup_printf(\"pcapng: interface index %u is not less than interface count %u.\",\n                    wblock->data.packet.interface_id, pn->number_of_interfaces);\n                return FALSE;\n        }\n        int_data = g_array_index(pn->interface_data, interface_data_t,\n            wblock->data.packet.interface_id);\n\n        wblock->packet_header->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN|WTAP_HAS_INTERFACE_ID;\n\n        pcapng_debug3(\"pcapng_read_packet_block: encapsulation = %d (%s), pseudo header size = %d.\",\n                       int_data.wtap_encap,\n                       wtap_encap_string(int_data.wtap_encap),\n                       pcap_get_phdr_size(int_data.wtap_encap, wblock->pseudo_header));\n        wblock->packet_header->interface_id = wblock->data.packet.interface_id;\n        wblock->packet_header->pkt_encap = int_data.wtap_encap;\n\n        memset((void *)wblock->pseudo_header, 0, sizeof(union wtap_pseudo_header));\n        pseudo_header_len = pcap_process_pseudo_header(fh,\n                                                       WTAP_FILE_PCAPNG,\n                                                       int_data.wtap_encap,\n                                                       wblock->data.packet.cap_len,\n                                                       TRUE,\n                                                       wblock->packet_header,\n                                                       (union wtap_pseudo_header *)wblock->pseudo_header,\n                                                       err,\n                                                       err_info);\n        if (pseudo_header_len < 0) {\n                return FALSE;\n        }\n        block_read += pseudo_header_len;\n        if (pseudo_header_len != pcap_get_phdr_size(int_data.wtap_encap, wblock->pseudo_header)) {\n                pcapng_debug1(\"pcapng_read_packet_block: Could only read %d bytes for pseudo header.\",\n                              pseudo_header_len);\n        }\n        wblock->packet_header->caplen = wblock->data.packet.cap_len - pseudo_header_len;\n        wblock->packet_header->len = wblock->data.packet.packet_len - pseudo_header_len;\n\n        /* Combine the two 32-bit pieces of the timestamp into one 64-bit value */\n        ts = (((guint64)wblock->data.packet.ts_high) << 32) | ((guint64)wblock->data.packet.ts_low);\n        wblock->packet_header->ts.secs = (time_t)(ts / int_data.time_units_per_second);\n        wblock->packet_header->ts.nsecs = (int)(((ts % int_data.time_units_per_second) * 1000000000) / int_data.time_units_per_second);\n\n        /* \"(Enhanced) Packet Block\" read capture data */\n        errno = WTAP_ERR_CANT_READ;\n        bytes_read = file_read((guint8 *) (wblock->frame_buffer), wblock->data.packet.cap_len - pseudo_header_len, fh);\n        if (bytes_read != (int) (wblock->data.packet.cap_len - pseudo_header_len)) {\n                *err = file_error(fh, err_info);\n                pcapng_debug1(\"pcapng_read_packet_block: couldn't read %u bytes of captured data\",\n                              wblock->data.packet.cap_len - pseudo_header_len);\n                if (*err == 0)\n                        *err = WTAP_ERR_SHORT_READ;\n                return 0;\n        }\n        block_read += bytes_read;\n\n        /* jump over potential padding bytes at end of the packet data */\n        if (padding != 0) {\n                file_offset64 = file_seek(fh, padding, SEEK_CUR, err);\n                if (file_offset64 <= 0) {\n                        if (*err != 0)\n                                return -1;\n                        return 0;\n                }\n                block_read += padding;\n        }\n\n        /* Option defaults */\n        wblock->packet_header->opt_comment = NULL;\n        wblock->packet_header->drop_count  = -1;\n        wblock->packet_header->pack_flags  = 0;\n\n        /* FCS length default */\n        fcslen = pn->if_fcslen;\n\n        /* Options\n         * opt_comment    1\n         * epb_flags      2\n         * epb_hash       3\n         * epb_dropcount  4\n         */\n        errno = WTAP_ERR_CANT_READ;\n        to_read = block_total_length -\n                  (int)sizeof(pcapng_block_header_t) -\n                  block_read -    /* fixed and variable part, including padding */\n                  (int)sizeof(bh->block_total_length);\n\n        /* Allocate enough memory to hold all options */\n        opt_cont_buf_len = to_read;\n        option_content = g_malloc(opt_cont_buf_len);\n\n        while (to_read > 0) {\n                /* read option */\n                bytes_read = pcapng_read_option(fh, pn, &oh, option_content, opt_cont_buf_len, err, err_info);\n                if (bytes_read <= 0) {\n                        pcapng_debug0(\"pcapng_read_packet_block: failed to read option\");\n                        return bytes_read;\n                }\n                block_read += bytes_read;\n                to_read -= bytes_read;\n\n                /* handle option content */\n                switch (oh.option_code) {\n                    case(0): /* opt_endofopt */\n                        if (to_read != 0) {\n                                pcapng_debug1(\"pcapng_read_packet_block: %u bytes after opt_endofopt\", to_read);\n                        }\n                        /* padding should be ok here, just get out of this */\n                        to_read = 0;\n                        break;\n                    case(1): /* opt_comment */\n                        if (oh.option_length > 0 && oh.option_length < opt_cont_buf_len) {\n                                wblock->packet_header->presence_flags |= WTAP_HAS_COMMENTS;\n                                wblock->packet_header->opt_comment = g_strndup(option_content, oh.option_length);\n                                pcapng_debug2(\"pcapng_read_packet_block: length %u opt_comment '%s'\", oh.option_length, wblock->packet_header->opt_comment);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_packet_block: opt_comment length %u seems strange\", oh.option_length);\n                        }\n                        break;\n                    case(2): /* pack_flags / epb_flags */\n                        if (oh.option_length == 4) {\n                                /*  Don't cast a char[] into a guint32--the\n                                 *  char[] may not be aligned correctly.\n                                 */\n                                wblock->packet_header->presence_flags |= WTAP_HAS_PACK_FLAGS;\n                                memcpy(&wblock->packet_header->pack_flags, option_content, sizeof(guint32));\n                                if (pn->byte_swapped)\n                                        wblock->packet_header->pack_flags = BSWAP32(wblock->packet_header->pack_flags);\n                                if (wblock->packet_header->pack_flags & 0x000001E0) {\n                                        /* The FCS length is present */\n                                        fcslen = (wblock->packet_header->pack_flags & 0x000001E0) >> 5;\n                                }\n                                pcapng_debug1(\"pcapng_read_packet_block: pack_flags %u (ignored)\", wblock->packet_header->pack_flags);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_packet_block: pack_flags length %u not 4 as expected\", oh.option_length);\n                        }\n                        break;\n                    case(3): /* epb_hash */\n                        pcapng_debug2(\"pcapng_read_packet_block: epb_hash %u currently not handled - ignoring %u bytes\",\n                                      oh.option_code, oh.option_length);\n                        break;\n                    case(4): /* epb_dropcount */\n                        if (oh.option_length == 8) {\n                                /*  Don't cast a char[] into a guint32--the\n                                 *  char[] may not be aligned correctly.\n                                 */\n                                wblock->packet_header->presence_flags |= WTAP_HAS_DROP_COUNT;\n                                memcpy(&wblock->packet_header->drop_count, option_content, sizeof(guint64));\n                                if (pn->byte_swapped)\n                                        wblock->packet_header->drop_count = BSWAP64(wblock->packet_header->drop_count);\n\n                                pcapng_debug1(\"pcapng_read_packet_block: drop_count %\" G_GINT64_MODIFIER \"u\", wblock->packet_header->drop_count);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_packet_block: drop_count length %u not 8 as expected\", oh.option_length);\n                        }\n                        break;\n                    default:\n                        pcapng_debug2(\"pcapng_read_packet_block: unknown option %u - ignoring %u bytes\",\n                                      oh.option_code, oh.option_length);\n                }\n        }\n\n        g_free(option_content);\n\n        pcap_read_post_process(WTAP_FILE_PCAPNG, int_data.wtap_encap,\n            (union wtap_pseudo_header *)wblock->pseudo_header,\n            (guint8 *) (wblock->frame_buffer),\n            (int) (wblock->data.packet.cap_len - pseudo_header_len),\n            pn->byte_swapped, fcslen);\n        return block_read;\n}\n\n\nstatic int\npcapng_read_simple_packet_block(FILE_T fh, pcapng_block_header_t *bh, pcapng_t *pn, wtapng_block_t *wblock, int *err, gchar **err_info)\n{\n        int bytes_read;\n        int block_read;\n        guint64 file_offset64;\n        interface_data_t int_data;\n        int pseudo_header_len;\n        pcapng_simple_packet_block_t spb;\n\n        /*\n         * Is this block long enough to be an SPB?\n         */\n        if (bh->block_total_length < MIN_SPB_SIZE) {\n                /*\n                 * No.\n                 */\n                *err = WTAP_ERR_BAD_FILE;\n                *err_info = g_strdup_printf(\"pcapng_read_simple_packet_block: total block length %u of an SPB is less than the minimum SPB size %u\",\n                              bh->block_total_length, MIN_SPB_SIZE);\n                return -1;\n        }\n\n        /* \"Simple Packet Block\" read fixed part */\n        errno = WTAP_ERR_CANT_READ;\n        bytes_read = file_read(&spb, sizeof spb, fh);\n        if (bytes_read != sizeof spb) {\n                pcapng_debug0(\"pcapng_read_simple_packet_block: failed to read packet data\");\n                *err = file_error(fh, err_info);\n                return 0;\n        }\n        block_read = bytes_read;\n\n        if (pn->byte_swapped) {\n                wblock->data.simple_packet.packet_len   = BSWAP32(spb.packet_len);\n        } else {\n                wblock->data.simple_packet.packet_len   = spb.packet_len;\n        }\n\n        wblock->data.simple_packet.cap_len = bh->block_total_length\n                                             - (guint32)sizeof(pcapng_simple_packet_block_t)\n                                             - (guint32)sizeof(bh->block_total_length);\n\n        if (wblock->data.simple_packet.cap_len > WTAP_MAX_PACKET_SIZE) {\n                *err = WTAP_ERR_BAD_FILE;\n                *err_info = g_strdup_printf(\"pcapng_read_simple_packet_block: cap_len %u is larger than WTAP_MAX_PACKET_SIZE %u.\",\n                    wblock->data.simple_packet.cap_len, WTAP_MAX_PACKET_SIZE);\n                return 0;\n        }\n        pcapng_debug1(\"pcapng_read_simple_packet_block: packet data: packet_len %u\",\n                       wblock->data.simple_packet.packet_len);\n\n        if (0 >= pn->number_of_interfaces) {\n                *err = WTAP_ERR_BAD_FILE;\n                *err_info = g_strdup_printf(\"pcapng: interface index 0 is not less than interface count %u.\",\n                    pn->number_of_interfaces);\n                return FALSE;\n        }\n        int_data = g_array_index(pn->interface_data, interface_data_t, 0);\n\n        pcapng_debug1(\"pcapng_read_simple_packet_block: Need to read pseudo header of size %d\",\n                      pcap_get_phdr_size(int_data.wtap_encap, wblock->pseudo_header));\n\n        /* No time stamp in a simple packet block; no options, either */\n        wblock->packet_header->presence_flags = WTAP_HAS_CAP_LEN|WTAP_HAS_INTERFACE_ID;\n        wblock->packet_header->interface_id = 0;\n        wblock->packet_header->pkt_encap = int_data.wtap_encap;\n        wblock->packet_header->ts.secs = 0;\n        wblock->packet_header->ts.nsecs = 0;\n        wblock->packet_header->interface_id = 0;\n        wblock->packet_header->opt_comment = NULL;\n        wblock->packet_header->drop_count = 0;\n        wblock->packet_header->pack_flags = 0;\n\n        memset((void *)wblock->pseudo_header, 0, sizeof(union wtap_pseudo_header));\n        pseudo_header_len = pcap_process_pseudo_header(fh,\n                                                       WTAP_FILE_PCAPNG,\n                                                       int_data.wtap_encap,\n                                                       wblock->data.simple_packet.cap_len,\n                                                       TRUE,\n                                                       wblock->packet_header,\n                                                       (union wtap_pseudo_header *)wblock->pseudo_header,\n                                                       err,\n                                                       err_info);\n        if (pseudo_header_len < 0) {\n                return 0;\n        }\n        wblock->packet_header->caplen = wblock->data.simple_packet.cap_len - pseudo_header_len;\n        wblock->packet_header->len = wblock->data.packet.packet_len - pseudo_header_len;\n        block_read += pseudo_header_len;\n        if (pseudo_header_len != pcap_get_phdr_size(int_data.wtap_encap, wblock->pseudo_header)) {\n                pcapng_debug1(\"pcapng_read_simple_packet_block: Could only read %d bytes for pseudo header.\",\n                              pseudo_header_len);\n        }\n\n        memset((void *)wblock->pseudo_header, 0, sizeof(union wtap_pseudo_header));\n\n        /* \"Simple Packet Block\" read capture data */\n        errno = WTAP_ERR_CANT_READ;\n        bytes_read = file_read((guint8 *) (wblock->frame_buffer), wblock->data.simple_packet.cap_len, fh);\n        if (bytes_read != (int) wblock->data.simple_packet.cap_len) {\n                *err = file_error(fh, err_info);\n                pcapng_debug1(\"pcapng_read_simple_packet_block: couldn't read %u bytes of captured data\",\n                              wblock->data.simple_packet.cap_len);\n                if (*err == 0)\n                        *err = WTAP_ERR_SHORT_READ;\n                return 0;\n        }\n        block_read += bytes_read;\n\n        /* jump over potential padding bytes at end of the packet data */\n        if ((wblock->data.simple_packet.cap_len % 4) != 0) {\n                file_offset64 = file_seek(fh, 4 - (wblock->data.simple_packet.cap_len % 4), SEEK_CUR, err);\n                if (file_offset64 <= 0) {\n                        if (*err != 0)\n                                return -1;\n                        return 0;\n                }\n                block_read += 4 - (wblock->data.simple_packet.cap_len % 4);\n        }\n\n        pcap_read_post_process(WTAP_FILE_PCAPNG, int_data.wtap_encap,\n            (union wtap_pseudo_header *)wblock->pseudo_header,\n            (guint8 *) (wblock->frame_buffer),\n            (int) wblock->data.simple_packet.cap_len,\n            pn->byte_swapped, pn->if_fcslen);\n        return block_read;\n}\n\n#define NRES_ENDOFRECORD 0\n#define NRES_IP4RECORD 1\n#define NRES_IP6RECORD 2\n#define PADDING4(x) ((((x + 3) >> 2) << 2) - x)\n/* IPv6 + MAXNAMELEN */\n#define INITIAL_NRB_REC_SIZE (16 + 64)\n\n/*\n * Find the end of the NUL-terminated name the beginning of which is pointed\n * to by p; record_len is the number of bytes remaining in the record.\n *\n * Return the length of the name, including the terminating NUL.\n *\n * If we don't find the terminating NUL, or if the name is zero-length\n * (not counting the terminating NUL), return -1 and set *err and\n * *err_info appropriately.\n */\nstatic int\nname_resolution_block_find_name_end(guint8 *p, guint record_len, int *err,\n    gchar **err_info)\n{\n        int namelen;\n\n        namelen = 0;\n        for (;;) {\n                if (record_len == 0) {\n                        /*\n                         * We ran out of bytes in the record without\n                         * finding a NUL.\n                         */\n                        *err = WTAP_ERR_BAD_FILE;\n                        *err_info = g_strdup(\"pcapng_read_name_resolution_block: NRB record has non-null-terminated host name\");\n                        return -1;\n                }\n                if (*p == '\\0')\n                        break;  /* that's the terminating NUL */\n                p++;\n                record_len--;\n                namelen++;      /* count this byte */\n        }\n        if (namelen == 0) {\n                /* The name is empty. */\n                *err = WTAP_ERR_BAD_FILE;\n                *err_info = g_strdup(\"pcapng_read_name_resolution_block: NRB record has empty host name\");\n                return -1;\n        }\n\n        /* Include the NUL in the name length. */\n        return namelen + 1;\n}\n\nstatic int\npcapng_read_name_resolution_block(FILE_T fh, pcapng_block_header_t *bh, pcapng_t *pn, wtapng_block_t *wblock _U_,int *err, gchar **err_info)\n{\n        int bytes_read = 0;\n        int block_read = 0;\n        int to_read;\n        guint64 file_offset64;\n        pcapng_name_resolution_block_t nrb;\n        Buffer nrb_rec;\n        guint32 v4_addr;\n        guint record_len;\n        guint8 *namep;\n        int namelen;\n\n        /*\n         * Is this block long enough to be an NRB?\n         */\n        if (bh->block_total_length < MIN_NRB_SIZE) {\n                /*\n                 * No.\n                 */\n                *err = WTAP_ERR_BAD_FILE;\n                *err_info = g_strdup_printf(\"pcapng_read_name_resolution_block: total block length %u of an NRB is less than the minimum NRB size %u\",\n                              bh->block_total_length, MIN_NRB_SIZE);\n                return -1;\n        }\n\n        errno = WTAP_ERR_CANT_READ;\n        to_read = bh->block_total_length - 8 - 4; /* We have read the header adn should not read the final block_total_length */\n\n        pcapng_debug1(\"pcapng_read_name_resolution_block, total %d bytes\", bh->block_total_length);\n\n        /*\n         * Start out with a buffer big enough for an IPv6 address and one\n         * 64-byte name; we'll make the buffer bigger if necessary.\n         */\n        buffer_init(&nrb_rec, INITIAL_NRB_REC_SIZE);\n        while (block_read < to_read) {\n                /*\n                 * There must be at least one record's worth of data\n                 * here.\n                 */\n                if ((size_t)(to_read - block_read) < sizeof nrb) {\n                        buffer_free(&nrb_rec);\n                        *err = WTAP_ERR_BAD_FILE;\n                        *err_info = g_strdup_printf(\"pcapng_read_name_resolution_block: %d bytes left in the block < NRB record header size %u\",\n                                      to_read - block_read,\n                                      (guint)sizeof nrb);\n                        return -1;\n                }\n                bytes_read = file_read(&nrb, sizeof nrb, fh);\n                if (bytes_read != sizeof nrb) {\n                        buffer_free(&nrb_rec);\n                        pcapng_debug0(\"pcapng_read_name_resolution_block: failed to read record header\");\n                        *err = file_error(fh, err_info);\n                        return 0;\n                }\n                block_read += bytes_read;\n\n                if (pn->byte_swapped) {\n                        nrb.record_type = BSWAP16(nrb.record_type);\n                        nrb.record_len  = BSWAP16(nrb.record_len);\n                }\n\n                if (to_read - block_read < nrb.record_len + PADDING4(nrb.record_len)) {\n                        buffer_free(&nrb_rec);\n                        *err = WTAP_ERR_BAD_FILE;\n                        *err_info = g_strdup_printf(\"pcapng_read_name_resolution_block: %d bytes left in the block < NRB record length + padding %u\",\n                                      to_read - block_read,\n                                      nrb.record_len + PADDING4(nrb.record_len));\n                        return -1;\n                }\n                switch (nrb.record_type) {\n                        case NRES_ENDOFRECORD:\n                                /* There shouldn't be any more data */\n                                to_read = 0;\n                                break;\n                        case NRES_IP4RECORD:\n                                /*\n                                 * The smallest possible record must have\n                                 * a 4-byte IPv4 address, hence a minimum\n                                 * of 4 bytes.\n                                 *\n                                 * (The pcap-NG spec really indicates\n                                 * that it must be at least 5 bytes,\n                                 * as there must be at least one name,\n                                 * and it really must be at least 6\n                                 * bytes, as the name mustn't be null,\n                                 * but there's no need to fail if there\n                                 * aren't any names at all, and we\n                                 * should report a null name as such.)\n                                 */\n                                if (nrb.record_len < 4) {\n                                        buffer_free(&nrb_rec);\n                                        *err = WTAP_ERR_BAD_FILE;\n                                        *err_info = g_strdup_printf(\"pcapng_read_name_resolution_block: NRB record length for IPv4 record %u < minimum length 4\",\n                                                      nrb.record_len);\n                                        return -1;\n                                }\n                                buffer_assure_space(&nrb_rec, nrb.record_len);\n                                bytes_read = file_read(buffer_start_ptr(&nrb_rec),\n                                    nrb.record_len, fh);\n                                if (bytes_read != nrb.record_len) {\n                                        buffer_free(&nrb_rec);\n                                        pcapng_debug0(\"pcapng_read_name_resolution_block: failed to read IPv4 record data\");\n                                        *err = file_error(fh, err_info);\n                                        return 0;\n                                }\n                                block_read += bytes_read;\n\n                                if (pn->add_new_ipv4) {\n                                        /*\n                                         * Scan through all the names in\n                                         * the record and add them.\n                                         */\n                                        memcpy(&v4_addr,\n                                            buffer_start_ptr(&nrb_rec), 4);\n                                        if (pn->byte_swapped)\n                                                v4_addr = BSWAP32(v4_addr);\n                                        for (namep = buffer_start_ptr(&nrb_rec) + 4, record_len = nrb.record_len - 4;\n                                            record_len != 0;\n                                            namep += namelen, record_len -= namelen) {\n                                                /*\n                                                 * Scan forward for a null\n                                                 * byte.\n                                                 */\n                                                namelen = name_resolution_block_find_name_end(namep, record_len, err, err_info);\n                                                if (namelen == -1) {\n                                                        buffer_free(&nrb_rec);\n                                                        return -1;      /* fail */\n                                                }\n                                                pn->add_new_ipv4(v4_addr, namep);\n                                        }\n                                }\n\n                                file_offset64 = file_seek(fh, PADDING4(nrb.record_len), SEEK_CUR, err);\n                                if (file_offset64 <= 0) {\n                                        buffer_free(&nrb_rec);\n                                        if (*err != 0)\n                                                return -1;\n                                        return 0;\n                                }\n                                block_read += PADDING4(nrb.record_len);\n                                break;\n                        case NRES_IP6RECORD:\n                                /*\n                                 * The smallest possible record must have\n                                 * a 16-byte IPv6 address, hence a minimum\n                                 * of 16 bytes.\n                                 *\n                                 * (The pcap-NG spec really indicates\n                                 * that it must be at least 17 bytes,\n                                 * as there must be at least one name,\n                                 * and it really must be at least 18\n                                 * bytes, as the name mustn't be null,\n                                 * but there's no need to fail if there\n                                 * aren't any names at all, and we\n                                 * should report a null name as such.)\n                                 */\n                                if (nrb.record_len < 16) {\n                                        buffer_free(&nrb_rec);\n                                        *err = WTAP_ERR_BAD_FILE;\n                                        *err_info = g_strdup_printf(\"pcapng_read_name_resolution_block: NRB record length for IPv6 record %u < minimum length 16\",\n                                                      nrb.record_len);\n                                        return -1;\n                                }\n                                if (to_read < nrb.record_len) {\n                                        buffer_free(&nrb_rec);\n                                        pcapng_debug0(\"pcapng_read_name_resolution_block: insufficient data for IPv6 record\");\n                                        return 0;\n                                }\n                                buffer_assure_space(&nrb_rec, nrb.record_len);\n                                bytes_read = file_read(buffer_start_ptr(&nrb_rec),\n                                    nrb.record_len, fh);\n                                if (bytes_read != nrb.record_len) {\n                                        buffer_free(&nrb_rec);\n                                        pcapng_debug0(\"pcapng_read_name_resolution_block: failed to read IPv6 record data\");\n                                        *err = file_error(fh, err_info);\n                                        return 0;\n                                }\n                                block_read += bytes_read;\n\n                                if (pn->add_new_ipv6) {\n                                        for (namep = buffer_start_ptr(&nrb_rec) + 16, record_len = nrb.record_len - 16;\n                                            record_len != 0;\n                                            namep += namelen, record_len -= namelen) {\n                                                /*\n                                                 * Scan forward for a null\n                                                 * byte.\n                                                 */\n                                                namelen = name_resolution_block_find_name_end(namep, record_len, err, err_info);\n                                                if (namelen == -1) {\n                                                        buffer_free(&nrb_rec);\n                                                        return -1;      /* fail */\n                                                }\n                                                pn->add_new_ipv6(buffer_start_ptr(&nrb_rec),\n                                                    namep);\n                                        }\n                                }\n\n                                file_offset64 = file_seek(fh, PADDING4(nrb.record_len), SEEK_CUR, err);\n                                if (file_offset64 <= 0) {\n                                        buffer_free(&nrb_rec);\n                                        if (*err != 0)\n                                                return -1;\n                                        return 0;\n                                }\n                                block_read += PADDING4(nrb.record_len);\n                                break;\n                        default:\n                                pcapng_debug1(\"pcapng_read_name_resolution_block: unknown record type 0x%x\", nrb.record_type);\n                                file_offset64 = file_seek(fh, nrb.record_len + PADDING4(nrb.record_len), SEEK_CUR, err);\n                                if (file_offset64 <= 0) {\n                                        buffer_free(&nrb_rec);\n                                        if (*err != 0)\n                                                return -1;\n                                        return 0;\n                                }\n                                block_read += nrb.record_len + PADDING4(nrb.record_len);\n                                break;\n                }\n        }\n\n        buffer_free(&nrb_rec);\n        return block_read;\n}\n\nstatic int\npcapng_read_interface_statistics_block(FILE_T fh, pcapng_block_header_t *bh, pcapng_t *pn, wtapng_block_t *wblock,int *err, gchar **err_info)\n{\n        int bytes_read;\n        int block_read;\n        int to_read, opt_cont_buf_len;\n        pcapng_interface_statistics_block_t isb;\n        pcapng_option_header_t oh;\n        char *option_content = NULL; /* Allocate as large as the options block */\n\n        /*\n         * Is this block long enough to be an ISB?\n         */\n        if (bh->block_total_length < MIN_ISB_SIZE) {\n                /*\n                 * No.\n                 */\n                *err = WTAP_ERR_BAD_FILE;\n                *err_info = g_strdup_printf(\"pcapng_read_interface_statistics_block: total block length %u is too small (< %u)\",\n                              bh->block_total_length, MIN_ISB_SIZE);\n                return -1;\n        }\n\n        /* \"Interface Statistics Block\" read fixed part */\n        errno = WTAP_ERR_CANT_READ;\n        bytes_read = file_read(&isb, sizeof isb, fh);\n        if (bytes_read != sizeof isb) {\n                pcapng_debug0(\"pcapng_read_interface_statistics_block: failed to read packet data\");\n                *err = file_error(fh, err_info);\n                return 0;\n        }\n        block_read = bytes_read;\n\n        if (pn->byte_swapped) {\n                wblock->data.if_stats.interface_id = BSWAP32(isb.interface_id);\n                wblock->data.if_stats.ts_high      = BSWAP32(isb.timestamp_high);\n                wblock->data.if_stats.ts_low       = BSWAP32(isb.timestamp_low);\n        } else {\n                wblock->data.if_stats.interface_id = isb.interface_id;\n                wblock->data.if_stats.ts_high      = isb.timestamp_high;\n                wblock->data.if_stats.ts_low       = isb.timestamp_low;\n        }\n        pcapng_debug1(\"pcapng_read_interface_statistics_block: interface_id %u\", wblock->data.if_stats.interface_id);\n\n        /* Option defaults */\n        wblock->data.if_stats.opt_comment          = NULL;\n        wblock->data.if_stats.isb_ifrecv           = -1;\n        wblock->data.if_stats.isb_ifdrop           = -1;\n        wblock->data.if_stats.isb_filteraccept     = -1;\n        wblock->data.if_stats.isb_osdrop           = -1;\n        wblock->data.if_stats.isb_usrdeliv         = -1;\n\n        /* Options */\n        errno = WTAP_ERR_CANT_READ;\n        to_read = bh->block_total_length -\n                  (MIN_BLOCK_SIZE + block_read);    /* fixed and variable part, including padding */\n\n        /* Allocate enough memory to hold all options */\n        opt_cont_buf_len = to_read;\n        option_content = (char *)g_malloc(opt_cont_buf_len);\n\n        while (to_read > 0) {\n                /* read option */\n                bytes_read = pcapng_read_option(fh, pn, &oh, option_content, opt_cont_buf_len, err, err_info);\n                if (bytes_read <= 0) {\n                        pcapng_debug0(\"pcapng_read_interface_statistics_block: failed to read option\");\n                        return bytes_read;\n                }\n                block_read += bytes_read;\n                to_read -= bytes_read;\n\n                /* handle option content */\n                switch (oh.option_code) {\n                    case(0): /* opt_endofopt */\n                        if (to_read != 0) {\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: %u bytes after opt_endofopt\", to_read);\n                        }\n                        /* padding should be ok here, just get out of this */\n                        to_read = 0;\n                        break;\n                    case(1): /* opt_comment */\n                        if (oh.option_length > 0 && oh.option_length < opt_cont_buf_len) {\n                                wblock->data.if_stats.opt_comment = g_strndup(option_content, oh.option_length);\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: opt_comment %s\", wblock->data.if_stats.opt_comment);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: opt_comment length %u seems strange\", oh.option_length);\n                        }\n                        break;\n                    case(2): /* isb_starttime */\n                        if (oh.option_length == 8) {\n                                guint32 high, low;\n\n                                /*  Don't cast a char[] into a guint32--the\n                                 *  char[] may not be aligned correctly.\n                                 */\n                                memcpy(&high, option_content, sizeof(guint32));\n                                memcpy(&low, option_content + sizeof(guint32), sizeof(guint32));\n                                if (pn->byte_swapped) {\n                                        high = BSWAP32(high);\n                                        low = BSWAP32(low);\n                                }\n                                wblock->data.if_stats.isb_starttime = (guint64)high;\n                                wblock->data.if_stats.isb_starttime <<= 32;\n                                wblock->data.if_stats.isb_starttime += (guint64)low;\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: isb_starttime %\" G_GINT64_MODIFIER \"u\", wblock->data.if_stats.isb_starttime);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: isb_starttime length %u not 8 as expected\", oh.option_length);\n                        }\n                        break;\n                    case(3): /* isb_endtime */\n                        if (oh.option_length == 8) {\n                                guint32 high, low;\n\n                                /*  Don't cast a char[] into a guint32--the\n                                 *  char[] may not be aligned correctly.\n                                 */\n                                memcpy(&high, option_content, sizeof(guint32));\n                                memcpy(&low, option_content + sizeof(guint32), sizeof(guint32));\n                                if (pn->byte_swapped) {\n                                        high = BSWAP32(high);\n                                        low = BSWAP32(low);\n                                }\n                                wblock->data.if_stats.isb_endtime = (guint64)high;\n                                wblock->data.if_stats.isb_endtime <<= 32;\n                                wblock->data.if_stats.isb_endtime += (guint64)low;\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: isb_endtime %\" G_GINT64_MODIFIER \"u\", wblock->data.if_stats.isb_endtime);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: isb_starttime length %u not 8 as expected\", oh.option_length);\n                        }\n                        break;\n                    case(4): /* isb_ifrecv */\n                        if (oh.option_length == 8) {\n                                /*  Don't cast a char[] into a guint32--the\n                                 *  char[] may not be aligned correctly.\n                                 */\n                                memcpy(&wblock->data.if_stats.isb_ifrecv, option_content, sizeof(guint64));\n                                if (pn->byte_swapped)\n                                        wblock->data.if_stats.isb_ifrecv = BSWAP64(wblock->data.if_stats.isb_ifrecv);\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: isb_ifrecv %\" G_GINT64_MODIFIER \"u\", wblock->data.if_stats.isb_ifrecv);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: isb_ifrecv length %u not 8 as expected\", oh.option_length);\n                        }\n                        break;\n                    case(5): /* isb_ifdrop */\n                        if (oh.option_length == 8) {\n                                /*  Don't cast a char[] into a guint32--the\n                                 *  char[] may not be aligned correctly.\n                                 */\n                                memcpy(&wblock->data.if_stats.isb_ifdrop, option_content, sizeof(guint64));\n                                if (pn->byte_swapped)\n                                        wblock->data.if_stats.isb_ifdrop = BSWAP64(wblock->data.if_stats.isb_ifdrop);\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: isb_ifdrop %\" G_GINT64_MODIFIER \"u\", wblock->data.if_stats.isb_ifdrop);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: isb_ifdrop length %u not 8 as expected\", oh.option_length);\n                        }\n                        break;\n                    case(6): /* isb_filteraccept 6 */\n                        if (oh.option_length == 8) {\n                                /*  Don't cast a char[] into a guint32--the\n                                 *  char[] may not be aligned correctly.\n                                 */\n                                memcpy(&wblock->data.if_stats.isb_filteraccept, option_content, sizeof(guint64));\n                                if (pn->byte_swapped)\n                                        wblock->data.if_stats.isb_ifdrop = BSWAP64(wblock->data.if_stats.isb_filteraccept);\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: isb_filteraccept %\" G_GINT64_MODIFIER \"u\", wblock->data.if_stats.isb_filteraccept);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: isb_filteraccept length %u not 8 as expected\", oh.option_length);\n                        }\n                        break;\n                    case(7): /* isb_osdrop 7 */\n                        if (oh.option_length == 8) {\n                                /*  Don't cast a char[] into a guint32--the\n                                 *  char[] may not be aligned correctly.\n                                 */\n                                memcpy(&wblock->data.if_stats.isb_osdrop, option_content, sizeof(guint64));\n                                if (pn->byte_swapped)\n                                        wblock->data.if_stats.isb_osdrop = BSWAP64(wblock->data.if_stats.isb_osdrop);\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: isb_osdrop %\" G_GINT64_MODIFIER \"u\", wblock->data.if_stats.isb_osdrop);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: isb_osdrop length %u not 8 as expected\", oh.option_length);\n                        }\n                        break;\n                    case(8): /* isb_usrdeliv 8  */\n                        if (oh.option_length == 8) {\n                                /*  Don't cast a char[] into a guint32--the\n                                 *  char[] may not be aligned correctly.\n                                 */\n                                memcpy(&wblock->data.if_stats.isb_usrdeliv, option_content, sizeof(guint64));\n                                if (pn->byte_swapped)\n                                        wblock->data.if_stats.isb_usrdeliv = BSWAP64(wblock->data.if_stats.isb_osdrop);\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: isb_usrdeliv %\" G_GINT64_MODIFIER \"u\", wblock->data.if_stats.isb_usrdeliv);\n                        } else {\n                                pcapng_debug1(\"pcapng_read_interface_statistics_block: isb_usrdeliv length %u not 8 as expected\", oh.option_length);\n                        }\n                        break;\n                    default:\n                        pcapng_debug2(\"pcapng_read_interface_statistics_block: unknown option %u - ignoring %u bytes\",\n                                      oh.option_code, oh.option_length);\n                }\n        }\n\n        g_free(option_content);\n\n        return block_read;\n}\n\n\nstatic int\npcapng_read_unknown_block(FILE_T fh, pcapng_block_header_t *bh, pcapng_t *pn _U_, wtapng_block_t *wblock _U_, int *err, gchar **err_info)\n{\n        int block_read;\n        guint64 file_offset64;\n        guint32 block_total_length;\n\n        if (bh->block_total_length < MIN_BLOCK_SIZE) {\n                *err = WTAP_ERR_BAD_FILE;\n                *err_info = g_strdup_printf(\"pcapng_read_unknown_block: total block length %u of an unknown block type is less than the minimum block size %u\",\n                              bh->block_total_length, MIN_BLOCK_SIZE);\n                return -1;\n        }\n\n        /* add padding bytes to \"block total length\" */\n        /* (the \"block total length\" of some example files don't contain any padding bytes!) */\n        if (bh->block_total_length % 4) {\n                block_total_length = bh->block_total_length + 4 - (bh->block_total_length % 4);\n        } else {\n                block_total_length = bh->block_total_length;\n        }\n\n        block_read = block_total_length - MIN_BLOCK_SIZE;\n\n        /* jump over this unknown block */\n        file_offset64 = file_seek(fh, block_read, SEEK_CUR, err);\n        if (file_offset64 <= 0) {\n                if (*err != 0)\n                        return -1;\n                return 0;\n        }\n\n        return block_read;\n}\n\n\nstatic int\npcapng_read_block(FILE_T fh, gboolean first_block, pcapng_t *pn, wtapng_block_t *wblock, int *err, gchar **err_info)\n{\n        int block_read;\n        int bytes_read;\n        pcapng_block_header_t bh;\n        guint32 block_total_length;\n\n\n        /* Try to read the (next) block header */\n        errno = WTAP_ERR_CANT_READ;\n        bytes_read = file_read(&bh, sizeof bh, fh);\n        if (bytes_read != sizeof bh) {\n                *err = file_error(fh, err_info);\n                pcapng_debug3(\"pcapng_read_block: file_read() returned %d instead of %u, err = %d.\", bytes_read, (unsigned int)sizeof bh, *err);\n                if (*err != 0)\n                        return -1;\n                return 0;\n        }\n\n        block_read = bytes_read;\n        if (pn->byte_swapped) {\n                bh.block_type         = BSWAP32(bh.block_type);\n                bh.block_total_length = BSWAP32(bh.block_total_length);\n        }\n\n        wblock->type = bh.block_type;\n\n        pcapng_debug1(\"pcapng_read_block: block_type 0x%x\", bh.block_type);\n\n        if (first_block) {\n                /*\n                 * This is being read in by pcapng_open(), so this block\n                 * must be an SHB.  If it's not, this is not a pcap-ng\n                 * file.\n                 *\n                 * XXX - check for various forms of Windows <-> UN*X\n                 * mangling, and suggest that the file might be a\n                 * pcap-ng file that was damaged in transit?\n                 */\n                if (bh.block_type != BLOCK_TYPE_SHB)\n                        return 0;       /* not a pcap-ng file */\n        }\n\n        switch (bh.block_type) {\n                case(BLOCK_TYPE_SHB):\n                        bytes_read = pcapng_read_section_header_block(fh, first_block, &bh, pn, wblock, err, err_info);\n                        break;\n                case(BLOCK_TYPE_IDB):\n                        bytes_read = pcapng_read_if_descr_block(fh, &bh, pn, wblock, err, err_info);\n                        break;\n                case(BLOCK_TYPE_PB):\n                        bytes_read = pcapng_read_packet_block(fh, &bh, pn, wblock, err, err_info, FALSE);\n                        break;\n                case(BLOCK_TYPE_SPB):\n                        bytes_read = pcapng_read_simple_packet_block(fh, &bh, pn, wblock, err, err_info);\n                        break;\n                case(BLOCK_TYPE_EPB):\n                        bytes_read = pcapng_read_packet_block(fh, &bh, pn, wblock, err, err_info, TRUE);\n                        break;\n                case(BLOCK_TYPE_NRB):\n                        bytes_read = pcapng_read_name_resolution_block(fh, &bh, pn, wblock, err, err_info);\n                        break;\n                case(BLOCK_TYPE_ISB):\n                        bytes_read = pcapng_read_interface_statistics_block(fh, &bh, pn, wblock, err, err_info);\n                        break;\n                default:\n                        pcapng_debug2(\"pcapng_read_block: Unknown block_type: 0x%x (block ignored), block total length %d\", bh.block_type, bh.block_total_length);\n                        bytes_read = pcapng_read_unknown_block(fh, &bh, pn, wblock, err, err_info);\n        }\n\n        if (bytes_read <= 0) {\n                return bytes_read;\n        }\n        block_read += bytes_read;\n\n        /* sanity check: first and second block lengths must match */\n        errno = WTAP_ERR_CANT_READ;\n        bytes_read = file_read(&block_total_length, sizeof block_total_length, fh);\n        if (bytes_read != sizeof block_total_length) {\n                pcapng_debug0(\"pcapng_read_block: couldn't read second block length\");\n                *err = file_error(fh, err_info);\n                if (*err == 0)\n                        *err = WTAP_ERR_SHORT_READ;\n                return -1;\n        }\n        block_read += bytes_read;\n\n        if (pn->byte_swapped)\n                block_total_length = BSWAP32(block_total_length);\n\n        if (!(block_total_length == bh.block_total_length)) {\n                *err = WTAP_ERR_BAD_FILE;\n                *err_info = g_strdup_printf(\"pcapng_read_block: total block lengths (first %u and second %u) don't match\",\n                              bh.block_total_length, block_total_length);\n                return -1;\n        }\n\n        return block_read;\n}\n\n\n/* classic wtap: open capture file */\nint\npcapng_open(wtap *wth, int *err, gchar **err_info)\n{\n        int bytes_read;\n        pcapng_t pn;\n        wtapng_block_t wblock;\n        pcapng_t *pcapng;\n        wtapng_if_descr_t int_data;\n        interface_data_t interface_data;\n        pcapng_block_header_t bh;\n        gint64 saved_offset;\n\n        pn.shb_read = FALSE;\n        pn.read_idbs = TRUE;            /* IDB expected after SHB */\n        /* we don't know the byte swapping of the file yet */\n        pn.byte_swapped = FALSE;\n        pn.if_fcslen = -1;\n        pn.version_major = -1;\n        pn.version_minor = -1;\n        pn.interface_data = g_array_new(FALSE, FALSE, sizeof(interface_data_t));\n        pn.number_of_interfaces = 0;\n\n\n        /* we don't expect any packet blocks yet */\n        wblock.frame_buffer = NULL;\n        wblock.pseudo_header = NULL;\n        wblock.packet_header = NULL;\n        wblock.file_encap = &wth->file_encap;\n\n        pcapng_debug0(\"pcapng_open: opening file\");\n        /* read first block */\n        bytes_read = pcapng_read_block(wth->fh, TRUE, &pn, &wblock, err, err_info);\n        if (bytes_read <= 0) {\n                pcapng_debug0(\"pcapng_open: couldn't read first SHB\");\n                *err = file_error(wth->fh, err_info);\n                if (*err != 0)\n                        return -1;\n                return 0;\n        }\n\n        /* first block must be a \"Section Header Block\" */\n        if (wblock.type != BLOCK_TYPE_SHB) {\n                /*\n                 * XXX - check for damage from transferring a file\n                 * between Windows and UN*X as text rather than\n                 * binary data?\n                 */\n                pcapng_debug1(\"pcapng_open: first block type %u not SHB\", wblock.type);\n                return 0;\n        }\n        pn.shb_read = TRUE;\n\n        /*\n         * At this point, we've decided this is a pcap-NG file, not\n         * some other type of file, so we can't return 0, as that\n         * means \"this isn't a pcap-NG file, try some other file\n         * type\".\n         */\n        wth->shb_hdr.opt_comment = wblock.data.section.opt_comment;\n        wth->shb_hdr.shb_hardware = wblock.data.section.shb_hardware;\n        wth->shb_hdr.shb_os = wblock.data.section.shb_os;\n        wth->shb_hdr.shb_user_appl = wblock.data.section.shb_user_appl;\n\n        wth->file_encap = WTAP_ENCAP_UNKNOWN;\n        wth->snapshot_length = 0;\n        wth->tsprecision = WTAP_FILE_TSPREC_NSEC;\n        pcapng = (pcapng_t *)g_malloc(sizeof(pcapng_t));\n        wth->priv = (void *)pcapng;\n        *pcapng = pn;\n\n        wth->subtype_read = pcapng_read;\n        wth->subtype_seek_read = pcapng_seek_read;\n        wth->subtype_close = pcapng_close;\n        wth->file_type = WTAP_FILE_PCAPNG;\n\n        /* Read IDBs */\n        wth->interface_data = g_array_new(FALSE, FALSE, sizeof(wtapng_if_descr_t));\n        wth->number_of_interfaces = 0;\n\n        /* Loop over all IDB:s that appear before any packets */\n        while (1) {\n                bytes_read = pcapng_read_block(wth->fh, FALSE, &pn, &wblock, err, err_info);\n                if (bytes_read == 0) {\n                        pcapng_debug0(\"No more IDBs available...\");\n                        break;\n                }\n                if (bytes_read <= 0) {\n                        pcapng_debug0(\"pcapng_open: couldn't read IDB\");\n                        *err = file_error(wth->fh, err_info);\n                        if (*err == 0)\n                                *err = WTAP_ERR_SHORT_READ;\n                        return -1;\n                }\n\n                int_data.wtap_encap = wblock.data.if_descr.wtap_encap;\n                int_data.time_units_per_second = wblock.data.if_descr.time_units_per_second;\n                int_data.link_type = wblock.data.if_descr.link_type;\n                int_data.snap_len = wblock.data.if_descr.snap_len;\n                /* Options */\n                int_data.opt_comment = wblock.data.if_descr.opt_comment;\n                int_data.if_name = wblock.data.if_descr.if_name;\n                int_data.if_description = wblock.data.if_descr.if_description;\n                /* XXX: if_IPv4addr opt 4  Interface network address and netmask.*/\n                /* XXX: if_IPv6addr opt 5  Interface network address and prefix length (stored in the last byte).*/\n                /* XXX: if_MACaddr  opt 6  Interface Hardware MAC address (48 bits).*/\n                /* XXX: if_EUIaddr  opt 7  Interface Hardware EUI address (64 bits)*/\n                int_data.if_speed = wblock.data.if_descr.if_speed;\n                int_data.if_tsresol = wblock.data.if_descr.if_tsresol;\n                /* XXX: if_tzone      10  Time zone for GMT support (TODO: specify better). */\n                int_data.if_filter_str = wblock.data.if_descr.if_filter_str;\n                int_data.bpf_filter_len = wblock.data.if_descr.bpf_filter_len;\n                int_data.if_filter_bpf_bytes = wblock.data.if_descr.if_filter_bpf_bytes;\n                int_data.if_os = wblock.data.if_descr.if_os;\n                int_data.if_fcslen = wblock.data.if_descr.if_fcslen;\n                /* XXX if_tsoffset; opt 14  A 64 bits integer value that specifies an offset (in seconds)...*/\n                /* Interface statistics */\n                int_data.num_stat_entries = 0;\n                int_data.interface_statistics = NULL;\n\n                g_array_append_val(wth->interface_data, int_data);\n                wth->number_of_interfaces++;\n\n                interface_data.wtap_encap = wblock.data.if_descr.wtap_encap;\n                interface_data.time_units_per_second = wblock.data.if_descr.time_units_per_second;\n\n                g_array_append_val(pcapng->interface_data, interface_data);\n                pcapng->number_of_interfaces++;\n\n                pcapng_debug2(\"pcapng_open: Read IDB number_of_interfaces %u, wtap_encap %i\", wth->number_of_interfaces, int_data.wtap_encap);\n\n                /* peek at next block */\n                /* Try to read the (next) block header */\n                saved_offset = file_tell(wth->fh);\n                errno = WTAP_ERR_CANT_READ;\n                bytes_read = file_read(&bh, sizeof bh, wth->fh);\n                if (bytes_read == 0) {\n                        pcapng_debug0(\"No more IDBs available...\");\n                        break;\n                }\n                if (bytes_read != sizeof bh) {\n                        *err = file_error(wth->fh, err_info);\n                        pcapng_debug3(\"pcapng_open:  Check for more IDB:s, file_read() returned %d instead of %u, err = %d.\", bytes_read, (unsigned int)sizeof bh, *err);\n                        if (*err == 0)\n                                *err = WTAP_ERR_SHORT_READ;\n                        return -1;\n                }\n\n                /* go back to where we were */\n                file_seek(wth->fh, saved_offset, SEEK_SET, err);\n\n                if (pn.byte_swapped) {\n                        bh.block_type         = BSWAP32(bh.block_type);\n                }\n\n                pcapng_debug1(\"pcapng_open: Check for more IDB:s block_type 0x%x\", bh.block_type);\n\n                if (bh.block_type != BLOCK_TYPE_IDB) {\n                        break;  /* No more IDB:s */\n                }\n        }\n\n        pcapng->read_idbs = FALSE;\n\n        return 1;\n}\n\n\n/* classic wtap: read packet */\nstatic gboolean\npcapng_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)\n{\n        pcapng_t *pcapng = (pcapng_t *)wth->priv;\n        int bytes_read;\n        wtapng_block_t wblock;\n        wtapng_if_descr_t *wtapng_if_descr;\n        wtapng_if_stats_t if_stats;\n\n        *data_offset = file_tell(wth->fh);\n        pcapng_debug1(\"pcapng_read: data_offset is initially %\" G_GINT64_MODIFIER \"d\", *data_offset);\n\n        /* XXX - This should be done in the packet block reading function and\n         * should make use of the caplen of the packet.\n         */\n        if (wth->snapshot_length > 0) {\n                buffer_assure_space(wth->frame_buffer, wth->snapshot_length);\n        } else {\n                buffer_assure_space(wth->frame_buffer, WTAP_MAX_PACKET_SIZE);\n        }\n\n        wblock.frame_buffer  = buffer_start_ptr(wth->frame_buffer);\n        wblock.pseudo_header = &wth->pseudo_header;\n        wblock.packet_header = &wth->phdr;\n        wblock.file_encap    = &wth->file_encap;\n\n        pcapng->add_new_ipv4 = wth->add_new_ipv4;\n        pcapng->add_new_ipv6 = wth->add_new_ipv6;\n\n        /* read next block */\n        while (1) {\n                bytes_read = pcapng_read_block(wth->fh, FALSE, pcapng, &wblock, err, err_info);\n                if (bytes_read <= 0) {\n                        pcapng_debug1(\"pcapng_read: data_offset is finally %\" G_GINT64_MODIFIER \"d\", *data_offset);\n                        pcapng_debug0(\"pcapng_read: couldn't read packet block\");\n                        return FALSE;\n                }\n\n                /* block must be a \"Packet Block\" or an \"Enhanced Packet Block\" -> otherwise continue */\n                if (wblock.type == BLOCK_TYPE_PB || wblock.type == BLOCK_TYPE_EPB) {\n                        break;\n                }\n                if (wblock.type == BLOCK_TYPE_ISB ) {\n                    pcapng_debug0(\"pcapng_read: block type BLOCK_TYPE_ISB\");\n                    *data_offset += bytes_read;\n                    pcapng_debug1(\"pcapng_read: *data_offset is updated to %\" G_GINT64_MODIFIER \"d\", *data_offset);\n                    if (wth->number_of_interfaces < wblock.data.if_stats.interface_id) {\n                        pcapng_debug1(\"pcapng_read: BLOCK_TYPE_ISB wblock.if_stats.interface_id %u > number_of_interfaces\", wblock.data.if_stats.interface_id);\n                    } else {\n                        /* Get the interface description */\n                        wtapng_if_descr = &g_array_index(wth->interface_data, wtapng_if_descr_t, wblock.data.if_stats.interface_id);\n                        if (wtapng_if_descr->num_stat_entries == 0) {\n                            /* First ISB found, no previous entry */\n                            pcapng_debug0(\"pcapng_read: block type BLOCK_TYPE_ISB. First ISB found, no previous entry\");\n                            wtapng_if_descr->interface_statistics = g_array_new(FALSE, FALSE, sizeof(wtapng_if_stats_t));\n                        }\n\n                        if_stats.interface_id       = wblock.data.if_stats.interface_id;\n                        if_stats.ts_high            = wblock.data.if_stats.ts_high;\n                        if_stats.ts_low             = wblock.data.if_stats.ts_low;\n                        /* options */\n                        if_stats.opt_comment        = wblock.data.if_stats.opt_comment;\t/* NULL if not available */\n                        if_stats.isb_starttime      = wblock.data.if_stats.isb_starttime;\n                        if_stats.isb_endtime        = wblock.data.if_stats.isb_endtime;\n                        if_stats.isb_ifrecv         = wblock.data.if_stats.isb_ifrecv;\n                        if_stats.isb_ifdrop         = wblock.data.if_stats.isb_ifdrop;\n                        if_stats.isb_filteraccept   = wblock.data.if_stats.isb_filteraccept;\n                        if_stats.isb_osdrop         = wblock.data.if_stats.isb_osdrop;\n                        if_stats.isb_usrdeliv       = wblock.data.if_stats.isb_usrdeliv;\n\n                        g_array_append_val(wtapng_if_descr->interface_statistics, if_stats);\n                        wtapng_if_descr->num_stat_entries++;\n                    }\n                } else {\n                    /* XXX - improve handling of \"unknown\" blocks */\n                    pcapng_debug1(\"pcapng_read: block type 0x%x not PB/EPB\", wblock.type);\n                    *data_offset += bytes_read;\n                    pcapng_debug1(\"pcapng_read: *data_offset is updated to %\" G_GINT64_MODIFIER \"d\", *data_offset);\n                }\n        }\n\n        if (wblock.data.packet.interface_id < pcapng->number_of_interfaces) {\n        } else {\n                wth->phdr.pkt_encap = WTAP_ENCAP_UNKNOWN;\n                *err = WTAP_ERR_BAD_FILE;\n                *err_info = g_strdup_printf(\"pcapng: interface index %u is not less than interface count %u.\",\n                    wblock.data.packet.interface_id, pcapng->number_of_interfaces);\n                pcapng_debug1(\"pcapng_read: data_offset is finally %\" G_GINT64_MODIFIER \"d\", *data_offset + bytes_read);\n                return FALSE;\n        }\n\n        /*pcapng_debug2(\"Read length: %u Packet length: %u\", bytes_read, wth->phdr.caplen);*/\n        pcapng_debug1(\"pcapng_read: data_offset is finally %\" G_GINT64_MODIFIER \"d\", *data_offset + bytes_read);\n\n        return TRUE;\n}\n\n\n/* classic wtap: seek to file position and read packet */\nstatic gboolean\npcapng_seek_read(wtap *wth, gint64 seek_off,\n    union wtap_pseudo_header *pseudo_header, guint8 *pd, int length _U_,\n    int *err, gchar **err_info)\n{\n        pcapng_t *pcapng = (pcapng_t *)wth->priv;\n        guint64 bytes_read64;\n        int bytes_read;\n        wtapng_block_t wblock;\n\n\n        /* seek to the right file position */\n        bytes_read64 = file_seek(wth->random_fh, seek_off, SEEK_SET, err);\n        if (bytes_read64 <= 0) {\n                return FALSE;   /* Seek error */\n        }\n        pcapng_debug1(\"pcapng_seek_read: reading at offset %\" G_GINT64_MODIFIER \"u\", seek_off);\n\n        wblock.frame_buffer = pd;\n        wblock.pseudo_header = pseudo_header;\n        wblock.packet_header = &wth->phdr;\n        wblock.file_encap = &wth->file_encap;\n\n        /* read the block */\n        bytes_read = pcapng_read_block(wth->random_fh, FALSE, pcapng, &wblock, err, err_info);\n        if (bytes_read <= 0) {\n                *err = file_error(wth->random_fh, err_info);\n                pcapng_debug3(\"pcapng_seek_read: couldn't read packet block (err=%d, errno=%d, bytes_read=%d).\",\n                              *err, errno, bytes_read);\n                return FALSE;\n        }\n\n        /* block must be a \"Packet Block\" or an \"Enhanced Packet Block\" */\n        if (wblock.type != BLOCK_TYPE_PB && wblock.type != BLOCK_TYPE_EPB) {\n                pcapng_debug1(\"pcapng_seek_read: block type %u not PB/EPB\", wblock.type);\n                return FALSE;\n        }\n\n        return TRUE;\n}\n\n\n/* classic wtap: close capture file */\nstatic void\npcapng_close(wtap *wth)\n{\n        pcapng_t *pcapng = (pcapng_t *)wth->priv;\n\n        pcapng_debug0(\"pcapng_close: closing file\");\n        if (pcapng->interface_data != NULL) {\n                g_array_free(pcapng->interface_data, TRUE);\n        }\n}\n\n\n\ntypedef struct {\n        GArray *interface_data;\n        guint number_of_interfaces;\n        struct addrinfo *addrinfo_list_last;\n} pcapng_dump_t;\n\nstatic gboolean\npcapng_write_section_header_block(wtap_dumper *wdh, int *err)\n{\n        pcapng_block_header_t bh;\n        pcapng_section_header_block_t shb;\n        const guint32 zero_pad = 0;\n        gboolean have_options = FALSE;\n        struct option option_hdr;                   /* guint16 type, guint16 value_length; */\n        guint32 options_total_length = 0;\n        guint32 comment_len = 0, shb_hardware_len = 0, shb_os_len = 0, shb_user_appl_len = 0;\n        guint32 comment_pad_len = 0, shb_hardware_pad_len = 0, shb_os_pad_len = 0, shb_user_appl_pad_len = 0;\n\n        if (wdh->shb_hdr) {\n                pcapng_debug0(\"pcapng_write_section_header_block: Have shb_hdr\");\n                /* Check if we should write comment option */\n                if (wdh->shb_hdr->opt_comment) {\n                        have_options = TRUE;\n                        comment_len = (guint32)strlen(wdh->shb_hdr->opt_comment) & 0xffff;\n                        if ((comment_len % 4)) {\n                                comment_pad_len = 4 - (comment_len % 4);\n                        } else {\n                                comment_pad_len = 0;\n                        }\n                        options_total_length = options_total_length + comment_len + comment_pad_len + 4 /* comment options tag */ ;\n                }\n\n                /* Check if we should write shb_hardware option */\n                if (wdh->shb_hdr->shb_hardware) {\n                        have_options = TRUE;\n                        shb_hardware_len = (guint32)strlen(wdh->shb_hdr->shb_hardware) & 0xffff;\n                        if ((shb_hardware_len % 4)) {\n                                shb_hardware_pad_len = 4 - (shb_hardware_len % 4);\n                        } else {\n                                shb_hardware_pad_len = 0;\n                        }\n                        options_total_length = options_total_length + shb_hardware_len + shb_hardware_pad_len + 4 /* options tag */ ;\n                }\n\n                /* Check if we should write shb_os option */\n                if (wdh->shb_hdr->shb_os) {\n                        have_options = TRUE;\n                        shb_os_len = (guint32)strlen(wdh->shb_hdr->shb_os) & 0xffff;\n                        if ((shb_os_len % 4)) {\n                                shb_os_pad_len = 4 - (shb_os_len % 4);\n                        } else {\n                                shb_os_pad_len = 0;\n                        }\n                        options_total_length = options_total_length + shb_os_len + shb_os_pad_len + 4 /* options tag */ ;\n                }\n\n                /* Check if we should write shb_user_appl option */\n                if (wdh->shb_hdr->shb_user_appl) {\n                        have_options = TRUE;\n                        shb_user_appl_len = (guint32)strlen(wdh->shb_hdr->shb_user_appl) & 0xffff;\n                        if ((shb_user_appl_len % 4)) {\n                                shb_user_appl_pad_len = 4 - (shb_user_appl_len % 4);\n                        } else {\n                                shb_user_appl_pad_len = 0;\n                        }\n                        options_total_length = options_total_length + shb_user_appl_len + shb_user_appl_pad_len + 4 /* options tag */ ;\n                }\n                if (have_options) {\n                        /* End-of-options tag */\n                        options_total_length += 4;\n                }\n        }\n\n        /* write block header */\n        bh.block_type = BLOCK_TYPE_SHB;\n        bh.block_total_length = sizeof(bh) + sizeof(shb) + options_total_length + 4;\n        pcapng_debug2(\"pcapng_write_section_header_block: Total len %u, Options total len %u\",bh.block_total_length, options_total_length);\n\n        if (!wtap_dump_file_write(wdh, &bh, sizeof bh, err))\n                return FALSE;\n        wdh->bytes_dumped += sizeof bh;\n\n        /* write block fixed content */\n        /* XXX - get these values from wblock? */\n        shb.magic = 0x1A2B3C4D;\n        shb.version_major = 1;\n        shb.version_minor = 0;\n        shb.section_length = -1;\n\n        if (!wtap_dump_file_write(wdh, &shb, sizeof shb, err))\n                return FALSE;\n        wdh->bytes_dumped += sizeof shb;\n\n        /* XXX - write (optional) block options\n         * opt_comment  1\n         * shb_hardware 2\n         * shb_os       3\n         * shb_user_appl 4\n         */\n\n        if (comment_len) {\n                option_hdr.type          = OPT_COMMENT;\n                option_hdr.value_length = comment_len;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write the comments string */\n                pcapng_debug3(\"pcapng_write_section_header_block, comment:'%s' comment_len %u comment_pad_len %u\" , wdh->shb_hdr->opt_comment, comment_len, comment_pad_len);\n                if (!wtap_dump_file_write(wdh, wdh->shb_hdr->opt_comment, comment_len, err))\n                        return FALSE;\n                wdh->bytes_dumped += comment_len;\n\n                /* write padding (if any) */\n                if (comment_pad_len != 0) {\n                        if (!wtap_dump_file_write(wdh, &zero_pad, comment_pad_len, err))\n                                return FALSE;\n                        wdh->bytes_dumped += comment_pad_len;\n                }\n        }\n\n        if (shb_hardware_len) {\n                option_hdr.type          = OPT_SHB_HARDWARE;\n                option_hdr.value_length = shb_hardware_len;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write the string */\n                pcapng_debug3(\"pcapng_write_section_header_block, shb_hardware:'%s' shb_hardware_len %u shb_hardware_pad_len %u\" , wdh->shb_hdr->shb_hardware, shb_hardware_len, shb_hardware_pad_len);\n                if (!wtap_dump_file_write(wdh, wdh->shb_hdr->shb_hardware, shb_hardware_len, err))\n                        return FALSE;\n                wdh->bytes_dumped += shb_hardware_len;\n\n                /* write padding (if any) */\n                if (shb_hardware_pad_len != 0) {\n                        if (!wtap_dump_file_write(wdh, &zero_pad, shb_hardware_pad_len, err))\n                                return FALSE;\n                        wdh->bytes_dumped += shb_hardware_pad_len;\n                }\n        }\n\n        if (shb_os_len) {\n                option_hdr.type          = OPT_SHB_OS;\n                option_hdr.value_length = shb_os_len;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write the string */\n                pcapng_debug3(\"pcapng_write_section_header_block, shb_os:'%s' shb_os_len %u shb_os_pad_len %u\" , wdh->shb_hdr->shb_os, shb_os_len, shb_os_pad_len);\n                if (!wtap_dump_file_write(wdh, wdh->shb_hdr->shb_os, shb_os_len, err))\n                        return FALSE;\n                wdh->bytes_dumped += shb_os_len;\n\n                /* write padding (if any) */\n                if (shb_os_pad_len != 0) {\n                        if (!wtap_dump_file_write(wdh, &zero_pad, shb_os_pad_len, err))\n                                return FALSE;\n                        wdh->bytes_dumped += shb_os_pad_len;\n                }\n        }\n\n        if (shb_user_appl_len) {\n                option_hdr.type          = OPT_SHB_USERAPPL;\n                option_hdr.value_length = shb_user_appl_len;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write the comments string */\n                pcapng_debug3(\"pcapng_write_section_header_block, shb_user_appl:'%s' shb_user_appl_len %u shb_user_appl_pad_len %u\" , wdh->shb_hdr->shb_user_appl, shb_user_appl_len, shb_user_appl_pad_len);\n                if (!wtap_dump_file_write(wdh, wdh->shb_hdr->shb_user_appl, shb_user_appl_len, err))\n                        return FALSE;\n                wdh->bytes_dumped += shb_user_appl_len;\n\n                /* write padding (if any) */\n                if (shb_user_appl_pad_len != 0) {\n                        if (!wtap_dump_file_write(wdh, &zero_pad, shb_user_appl_pad_len, err))\n                                return FALSE;\n                        wdh->bytes_dumped += shb_user_appl_pad_len;\n                }\n        }\n\n        /* Write end of options if we have otions */\n        if (have_options) {\n                option_hdr.type = OPT_EOFOPT;\n                option_hdr.value_length = 0;\n                if (!wtap_dump_file_write(wdh, &zero_pad, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n        }\n\n        /* write block footer */\n        if (!wtap_dump_file_write(wdh, &bh.block_total_length,\n            sizeof bh.block_total_length, err))\n                return FALSE;\n        wdh->bytes_dumped += sizeof bh.block_total_length;\n\n        return TRUE;\n}\n\n#define IDB_OPT_IF_NAME         2\n#define IDB_OPT_IF_DESCR        3\n#define IDB_OPT_IF_SPEED        8\n#define IDB_OPT_IF_TSRESOL      9\n#define IDB_OPT_IF_FILTER       11\n#define IDB_OPT_IF_OS           12\n\nstatic gboolean\npcapng_write_if_descr_block(wtap_dumper *wdh, wtapng_if_descr_t *int_data, int *err)\n{\n        pcapng_block_header_t bh;\n        pcapng_interface_description_block_t idb;\n        const guint32 zero_pad = 0;\n        gboolean have_options = FALSE;\n        struct option option_hdr;                   /* guint16 type, guint16 value_length; */\n        guint32 options_total_length = 0;\n        guint32 comment_len = 0, if_name_len = 0, if_description_len = 0 , if_os_len = 0, if_filter_str_len = 0;\n        guint32 comment_pad_len = 0, if_name_pad_len = 0, if_description_pad_len = 0, if_os_pad_len = 0, if_filter_str_pad_len = 0;\n\n\n        pcapng_debug3(\"pcapng_write_if_descr_block: encap = %d (%s), snaplen = %d\",\n                      int_data->link_type,\n                      wtap_encap_string(wtap_pcap_encap_to_wtap_encap(int_data->link_type)),\n                      int_data->snap_len);\n\n        if (int_data->link_type == (guint16)-1) {\n                *err = WTAP_ERR_UNSUPPORTED_ENCAP;\n                return FALSE;\n        }\n\n        /* Calculate options length */\n        if (int_data->opt_comment) {\n                have_options = TRUE;\n                comment_len = (guint32)strlen(int_data->opt_comment) & 0xffff;\n                if ((comment_len % 4)) {\n                        comment_pad_len = 4 - (comment_len % 4);\n                } else {\n                        comment_pad_len = 0;\n                }\n                options_total_length = options_total_length + comment_len + comment_pad_len + 4 /* comment options tag */ ;\n        }\n\n        /*\n         * if_name        2  A UTF-8 string containing the name of the device used to capture data.\n         */\n        if (int_data->if_name) {\n                have_options = TRUE;\n                if_name_len = (guint32)strlen(int_data->if_name) & 0xffff;\n                if ((if_name_len % 4)) {\n                        if_name_pad_len = 4 - (if_name_len % 4);\n                } else {\n                        if_name_pad_len = 0;\n                }\n                options_total_length = options_total_length + if_name_len + if_name_pad_len + 4 /* comment options tag */ ;\n        }\n\n        /*\n         * if_description 3  A UTF-8 string containing the description of the device used to capture data.\n         */\n        if (int_data->if_description) {\n                have_options = TRUE;\n                if_description_len = (guint32)strlen(int_data->if_description) & 0xffff;\n                if ((if_description_len % 4)) {\n                        if_description_pad_len = 4 - (if_description_len % 4);\n                } else {\n                        if_description_pad_len = 0;\n                }\n                options_total_length = options_total_length + if_description_len + if_description_pad_len + 4 /* comment options tag */ ;\n        }\n        /* Currently not handled\n         * if_IPv4addr    4  Interface network address and netmask.\n         * if_IPv6addr    5  Interface network address and prefix length (stored in the last byte).\n         * if_MACaddr     6  Interface Hardware MAC address (48 bits). 00 01 02 03 04 05\n         * if_EUIaddr     7  Interface Hardware EUI address (64 bits), if available. TODO: give a good example\n         */\n        /*\n         * if_speed       8  Interface speed (in bps). 100000000 for 100Mbps\n         */\n        if (int_data->if_speed != 0) {\n                have_options = TRUE;\n                options_total_length = options_total_length + 8 + 4;\n        }\n        /*\n         * if_tsresol     9  Resolution of timestamps.\n         */\n        if (int_data->if_tsresol != 0) {\n                have_options = TRUE;\n                options_total_length = options_total_length + 4 + 4;\n        }\n        /* Not used\n         * if_tzone      10  Time zone for GMT support (TODO: specify better). TODO: give a good example\n         */\n        /*\n         * if_filter     11  The filter (e.g. \"capture only TCP traffic\") used to capture traffic.\n         * The first byte of the Option Data keeps a code of the filter used (e.g. if this is a libpcap string, or BPF bytecode, and more).\n         */\n        if (int_data->if_filter_str) {\n                have_options = TRUE;\n                if_filter_str_len = (guint32)(strlen(int_data->if_filter_str) + 1) & 0xffff;\n                if ((if_filter_str_len % 4)) {\n                        if_filter_str_pad_len = 4 - (if_filter_str_len % 4);\n                } else {\n                        if_filter_str_pad_len = 0;\n                }\n                options_total_length = options_total_length + if_filter_str_len + if_filter_str_pad_len + 4 /* comment options tag */ ;\n        }\n        /*\n         * if_os         12  A UTF-8 string containing the name of the operating system of the machine in which this interface is installed.\n         */\n        if (int_data->if_os) {\n                have_options = TRUE;\n                if_os_len = (guint32)strlen(int_data->if_os) & 0xffff;\n                if ((if_os_len % 4)) {\n                        if_os_pad_len = 4 - (if_os_len % 4);\n                } else {\n                        if_os_pad_len = 0;\n                }\n                options_total_length = options_total_length + if_os_len + if_os_pad_len + 4 /* comment options tag */ ;\n        }\n        /*\n         * if_fcslen     13  An integer value that specified the length of the Frame Check Sequence (in bits) for this interface.\n         * -1 if unknown or changes between packets, opt 13  An integer value that specified the length of the Frame Check Sequence (in bits) for this interface.\n         */\n        if (int_data->if_fcslen != 0) {\n        }\n        /* Not used\n         * if_tsoffset   14  A 64 bits integer value that specifies an offset (in seconds) that must be added to the timestamp of each packet\n         * to obtain the absolute timestamp of a packet. If the option is missing, the timestamps stored in the packet must be considered absolute timestamps.\n         */\n\n        if (have_options) {\n                /* End-of-options tag */\n                options_total_length += 4;\n        }\n\n        /* write block header */\n        bh.block_type = BLOCK_TYPE_IDB;\n        bh.block_total_length = sizeof(bh) + sizeof(idb) + options_total_length + 4;\n\n        if (!wtap_dump_file_write(wdh, &bh, sizeof bh, err))\n                return FALSE;\n        wdh->bytes_dumped += sizeof bh;\n\n        /* write block fixed content */\n        idb.linktype    = int_data->link_type;\n        idb.reserved    = 0;\n        idb.snaplen     = int_data->snap_len;\n\n        if (!wtap_dump_file_write(wdh, &idb, sizeof idb, err))\n                return FALSE;\n        wdh->bytes_dumped += sizeof idb;\n\n        /* XXX - write (optional) block options */\n        if (comment_len != 0) {\n                option_hdr.type          = OPT_COMMENT;\n                option_hdr.value_length = comment_len;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write the comments string */\n                pcapng_debug3(\"pcapng_write_if_descr_block, comment:'%s' comment_len %u comment_pad_len %u\" , int_data->opt_comment, comment_len, comment_pad_len);\n                if (!wtap_dump_file_write(wdh, int_data->opt_comment, comment_len, err))\n                        return FALSE;\n                wdh->bytes_dumped += comment_len;\n\n                /* write padding (if any) */\n                if (comment_pad_len != 0) {\n                        if (!wtap_dump_file_write(wdh, &zero_pad, comment_pad_len, err))\n                                return FALSE;\n                        wdh->bytes_dumped += comment_pad_len;\n                }\n        }\n        /*\n         * if_name        2  A UTF-8 string containing the name of the device used to capture data.\n         */\n        if (if_name_len !=0) {\n                option_hdr.type = IDB_OPT_IF_NAME;\n                option_hdr.value_length = if_name_len;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write the comments string */\n                pcapng_debug3(\"pcapng_write_if_descr_block, if_name:'%s' if_name_len %u if_name_pad_len %u\" , int_data->if_name, if_name_len, if_name_pad_len);\n                if (!wtap_dump_file_write(wdh, int_data->if_name, if_name_len, err))\n                        return FALSE;\n                wdh->bytes_dumped += if_name_len;\n\n                /* write padding (if any) */\n                if (if_name_pad_len != 0) {\n                        if (!wtap_dump_file_write(wdh, &zero_pad, if_name_pad_len, err))\n                                return FALSE;\n                        wdh->bytes_dumped += if_name_pad_len;\n                }\n        }\n        /*\n         * if_description 3  A UTF-8 string containing the description of the device used to capture data.\n         */\n        if (if_description_len != 0) {\n                option_hdr.type          = IDB_OPT_IF_NAME;\n                option_hdr.value_length = if_description_len;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write the comments string */\n                pcapng_debug3(\"pcapng_write_if_descr_block, if_description:'%s' if_description_len %u if_description_pad_len %u\" , int_data->if_description, if_description_len, if_description_pad_len);\n                if (!wtap_dump_file_write(wdh, int_data->if_description, if_description_len, err))\n                        return FALSE;\n                wdh->bytes_dumped += if_description_len;\n\n                /* write padding (if any) */\n                if (if_description_pad_len != 0) {\n                        if (!wtap_dump_file_write(wdh, &zero_pad, if_description_pad_len, err))\n                                return FALSE;\n                        wdh->bytes_dumped += if_description_pad_len;\n                }\n        }\n        /* Currently not handled\n         * if_IPv4addr    4  Interface network address and netmask.\n         * if_IPv6addr    5  Interface network address and prefix length (stored in the last byte).\n         * if_MACaddr     6  Interface Hardware MAC address (48 bits). 00 01 02 03 04 05\n         * if_EUIaddr     7  Interface Hardware EUI address (64 bits), if available. TODO: give a good example\n         */\n        /*\n         * if_speed       8  Interface speed (in bps). 100000000 for 100Mbps\n         */\n        if (int_data->if_speed != 0) {\n                option_hdr.type          = IDB_OPT_IF_SPEED;\n                option_hdr.value_length = 8;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write the comments string */\n                pcapng_debug1(\"pcapng_write_if_descr_block: if_speed %\" G_GINT64_MODIFIER \"u (bps)\", int_data->if_speed);\n                if (!wtap_dump_file_write(wdh, &int_data->if_speed, sizeof(guint64), err))\n                        return FALSE;\n                wdh->bytes_dumped += 8;\n        }\n        /*\n         * if_tsresol     9  Resolution of timestamps.\n         * default is 6 for microsecond resolution, opt 9  Resolution of timestamps.\n         * If the Most Significant Bit is equal to zero, the remaining bits indicates\n         * the resolution of the timestamp as as a negative power of 10\n         */\n        if (int_data->if_tsresol != 0) {\n                option_hdr.type          = IDB_OPT_IF_TSRESOL;\n                option_hdr.value_length = 1;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write the comments string */\n                pcapng_debug1(\"pcapng_write_if_descr_block: if_tsresol %u\", int_data->if_tsresol);\n                if (!wtap_dump_file_write(wdh, &int_data->if_tsresol, 1, err))\n                        return FALSE;\n                wdh->bytes_dumped += 1;\n                if (!wtap_dump_file_write(wdh, &zero_pad, 3, err))\n                        return FALSE;\n                wdh->bytes_dumped += 3;\n        }\n        /* not used\n         * if_tzone      10  Time zone for GMT support (TODO: specify better). TODO: give a good example\n         */\n        /*\n         * if_filter     11  The filter (e.g. \"capture only TCP traffic\") used to capture traffic.\n         */\n        /* Libpcap string variant */\n        if (if_filter_str_len !=0) {\n                option_hdr.type          = IDB_OPT_IF_FILTER;\n                option_hdr.value_length = if_filter_str_len;\n                /* if_filter_str_len includes the leading byte indicating filter type (libpcap str or BPF code) */\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write the zero indicating libpcap filter variant */\n                if (!wtap_dump_file_write(wdh, &zero_pad, 1, err))\n                        return FALSE;\n                wdh->bytes_dumped += 1;\n\n                /* Write the comments string */\n                pcapng_debug3(\"pcapng_write_if_descr_block, if_filter_str:'%s' if_filter_str_len %u if_filter_str_pad_len %u\" , int_data->if_filter_str, if_filter_str_len, if_filter_str_pad_len);\n                /* if_filter_str_len includes the leading byte indicating filter type (libpcap str or BPF code) */\n                if (!wtap_dump_file_write(wdh, int_data->if_filter_str, if_filter_str_len-1, err))\n                        return FALSE;\n                wdh->bytes_dumped += if_filter_str_len - 1;\n\n                /* write padding (if any) */\n                if (if_filter_str_pad_len != 0) {\n                        if (!wtap_dump_file_write(wdh, &zero_pad, if_filter_str_pad_len, err))\n                                return FALSE;\n                        wdh->bytes_dumped += if_filter_str_pad_len;\n                }\n        }\n        /*\n         * if_os         12  A UTF-8 string containing the name of the operating system of the machine in which this interface is installed.\n         */\n        if (if_os_len != 0) {\n                option_hdr.type          = IDB_OPT_IF_OS;\n                option_hdr.value_length = if_os_len;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write the comments string */\n                pcapng_debug3(\"pcapng_write_if_descr_block, if_os:'%s' if_os_len %u if_os_pad_len %u\" , int_data->if_os, if_os_len, if_os_pad_len);\n                if (!wtap_dump_file_write(wdh, int_data->if_os, if_os_len, err))\n                        return FALSE;\n                wdh->bytes_dumped += if_os_len;\n\n                /* write padding (if any) */\n                if (if_os_pad_len != 0) {\n                        if (!wtap_dump_file_write(wdh, &zero_pad, if_os_pad_len, err))\n                                return FALSE;\n                        wdh->bytes_dumped += if_os_pad_len;\n                }\n        }\n\n        if (have_options) {\n                option_hdr.type = OPT_EOFOPT;\n                option_hdr.value_length = 0;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n        }\n\n        /*\n         * if_fcslen     13  An integer value that specified the length of the Frame Check Sequence (in bits) for this interface.\n         */\n        /*\n         * if_tsoffset   14  A 64 bits integer value that specifies an offset (in seconds) that must be added to the timestamp of each packet\n         * to obtain the absolute timestamp of a packet. If the option is missing, the timestamps stored in the packet must be considered absolute timestamps.\n         */\n\n        /* write block footer */\n        if (!wtap_dump_file_write(wdh, &bh.block_total_length,\n            sizeof bh.block_total_length, err))\n                return FALSE;\n        wdh->bytes_dumped += sizeof bh.block_total_length;\n\n        return TRUE;\n}\n\n#define ISB_STARTTIME     2\n#define ISB_ENDTIME       3\n#define ISB_IFRECV        4\n#define ISB_IFDROP        5\n#define ISB_FILTERACCEPT  6\n#define ISB_OSDROP        7\n#define ISB_USRDELIV      8\n\nstatic gboolean\npcapng_write_interface_statistics_block(wtap_dumper *wdh, wtapng_if_stats_t *if_stats, int *err)\n{\n\n        pcapng_block_header_t bh;\n        pcapng_interface_statistics_block_t isb;\n        const guint32 zero_pad = 0;\n        gboolean have_options = FALSE;\n        struct option option_hdr;                   /* guint16 type, guint16 value_length; */\n        guint32 options_total_length = 0;\n        guint32 comment_len = 0;\n        guint32 comment_pad_len = 0;\n\n        pcapng_debug0(\"pcapng_write_interface_statistics_block\");\n\n\n        /* Calculate options length */\n        if (if_stats->opt_comment) {\n                have_options = TRUE;\n                comment_len = (guint32)strlen(if_stats->opt_comment) & 0xffff;\n                if ((comment_len % 4)) {\n                        comment_pad_len = 4 - (comment_len % 4);\n                } else {\n                        comment_pad_len = 0;\n                }\n                options_total_length = options_total_length + comment_len + comment_pad_len + 4 /* comment options tag */ ;\n        }\n        /*guint64\t\t\t\tisb_starttime */\n        if (if_stats->isb_starttime != 0) {\n                have_options = TRUE;\n                options_total_length = options_total_length + 8 + 4 /* options tag */ ;\n        }\n        /*guint64\t\t\t\tisb_endtime */\n        if (if_stats->isb_endtime != 0) {\n                have_options = TRUE;\n                options_total_length = options_total_length + 8 + 4 /* options tag */ ;\n        }\n        /*guint64\t\t\t\tisb_ifrecv */\n        if (if_stats->isb_ifrecv != G_GUINT64_CONSTANT(0xFFFFFFFFFFFFFFFF)) {\n                have_options = TRUE;\n                options_total_length = options_total_length + 8 + 4 /* options tag */ ;\n        }\n        /*guint64\t\t\t\tisb_ifdrop */\n        if (if_stats->isb_ifdrop != G_GUINT64_CONSTANT(0xFFFFFFFFFFFFFFFF)) {\n                have_options = TRUE;\n                options_total_length = options_total_length + 8 + 4 /* options tag */ ;\n        }\n        /*guint64\t\t\t\tisb_filteraccept */\n        if (if_stats->isb_filteraccept != G_GUINT64_CONSTANT(0xFFFFFFFFFFFFFFFF)) {\n                have_options = TRUE;\n                options_total_length = options_total_length + 8 + 4 /* options tag */ ;\n        }\n        /*guint64\t\t\t\tisb_osdrop */\n        if (if_stats->isb_osdrop != G_GUINT64_CONSTANT(0xFFFFFFFFFFFFFFFF)) {\n                have_options = TRUE;\n                options_total_length = options_total_length + 8 + 4 /* options tag */ ;\n        }\n        /*guint64\t\t\t\tisb_usrdeliv */\n        if (if_stats->isb_usrdeliv != G_GUINT64_CONSTANT(0xFFFFFFFFFFFFFFFF)) {\n                have_options = TRUE;\n                options_total_length = options_total_length + 8 + 4 /* options tag */ ;\n        }\n\n        /* write block header */\n        if (have_options) {\n                /* End-of-optios tag */\n                options_total_length += 4;\n        }\n\n        /* write block header */\n        bh.block_type = BLOCK_TYPE_ISB;\n        bh.block_total_length = sizeof(bh) + sizeof(isb) + options_total_length + 4;\n\n        if (!wtap_dump_file_write(wdh, &bh, sizeof bh, err))\n                return FALSE;\n        wdh->bytes_dumped += sizeof bh;\n\n        /* write block fixed content */\n        isb.interface_id                = if_stats->interface_id;\n        isb.timestamp_high              = if_stats->ts_high;\n        isb.timestamp_low               = if_stats->ts_low;\n\n\n        if (!wtap_dump_file_write(wdh, &isb, sizeof isb, err))\n                return FALSE;\n        wdh->bytes_dumped += sizeof isb;\n\n        /* write (optional) block options */\n        if (comment_len) {\n                option_hdr.type          = OPT_COMMENT;\n                option_hdr.value_length  = comment_len;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write the comments string */\n                pcapng_debug3(\"pcapng_write_interface_statistics_block, comment:'%s' comment_len %u comment_pad_len %u\" , if_stats->opt_comment, comment_len, comment_pad_len);\n                if (!wtap_dump_file_write(wdh, if_stats->opt_comment, comment_len, err))\n                        return FALSE;\n                wdh->bytes_dumped += comment_len;\n\n                /* write padding (if any) */\n                if (comment_pad_len != 0) {\n                        if (!wtap_dump_file_write(wdh, &zero_pad, comment_pad_len, err))\n                                return FALSE;\n                        wdh->bytes_dumped += comment_pad_len;\n                }\n        }\n        /*guint64               isb_starttime */\n        if (if_stats->isb_starttime != 0) {\n                guint32 high, low;\n\n                option_hdr.type = ISB_STARTTIME;\n                option_hdr.value_length = 8;\n                high = (guint32)((if_stats->isb_starttime>>32) & 0xffffffff);\n                low = (guint32)(if_stats->isb_starttime & 0xffffffff);\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write isb_starttime */\n                pcapng_debug1(\"pcapng_write_interface_statistics_block, isb_starttime: %\" G_GINT64_MODIFIER \"u\" , if_stats->isb_starttime);\n                if (!wtap_dump_file_write(wdh, &high, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n                if (!wtap_dump_file_write(wdh, &low, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n        }\n        /*guint64               isb_endtime */\n        if (if_stats->isb_endtime != 0) {\n                guint32 high, low;\n\n                option_hdr.type = ISB_ENDTIME;\n                option_hdr.value_length = 8;\n                high = (guint32)((if_stats->isb_endtime>>32) & 0xffffffff);\n                low = (guint32)(if_stats->isb_endtime & 0xffffffff);\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write isb_endtime */\n                pcapng_debug1(\"pcapng_write_interface_statistics_block, isb_starttime: %\" G_GINT64_MODIFIER \"u\" , if_stats->isb_endtime);\n                if (!wtap_dump_file_write(wdh, &high, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n                if (!wtap_dump_file_write(wdh, &low, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n        }\n        /*guint64               isb_ifrecv;*/\n        if (if_stats->isb_ifrecv != G_GUINT64_CONSTANT(0xFFFFFFFFFFFFFFFF)) {\n                option_hdr.type          = ISB_IFRECV;\n                option_hdr.value_length  = 8;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write isb_ifrecv */\n                pcapng_debug1(\"pcapng_write_interface_statistics_block, isb_ifrecv: %\" G_GINT64_MODIFIER \"u\" , if_stats->isb_ifrecv);\n                if (!wtap_dump_file_write(wdh, &if_stats->isb_ifrecv, 8, err))\n                        return FALSE;\n                wdh->bytes_dumped += 8;\n        }\n        /*guint64               isb_ifdrop;*/\n        if (if_stats->isb_ifdrop != G_GUINT64_CONSTANT(0xFFFFFFFFFFFFFFFF)) {\n                option_hdr.type          = ISB_IFDROP;\n                option_hdr.value_length  = 8;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write isb_ifdrop */\n                pcapng_debug1(\"pcapng_write_interface_statistics_block, isb_ifdrop: %\" G_GINT64_MODIFIER \"u\" , if_stats->isb_ifdrop);\n                if (!wtap_dump_file_write(wdh, &if_stats->isb_ifdrop, 8, err))\n                        return FALSE;\n                wdh->bytes_dumped += 8;\n        }\n        /*guint64               isb_filteraccept;*/\n        if (if_stats->isb_filteraccept != G_GUINT64_CONSTANT(0xFFFFFFFFFFFFFFFF)) {\n                option_hdr.type          = ISB_FILTERACCEPT;\n                option_hdr.value_length  = 8;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write isb_filteraccept */\n                pcapng_debug1(\"pcapng_write_interface_statistics_block, isb_filteraccept: %\" G_GINT64_MODIFIER \"u\" , if_stats->isb_filteraccept);\n                if (!wtap_dump_file_write(wdh, &if_stats->isb_filteraccept, 8, err))\n                        return FALSE;\n                wdh->bytes_dumped += 8;\n        }\n        /*guint64               isb_osdrop;*/\n        if (if_stats->isb_osdrop != G_GUINT64_CONSTANT(0xFFFFFFFFFFFFFFFF)) {\n                option_hdr.type          = ISB_OSDROP;\n                option_hdr.value_length  = 8;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write isb_osdrop */\n                pcapng_debug1(\"pcapng_write_interface_statistics_block, isb_osdrop: %\" G_GINT64_MODIFIER \"u\" , if_stats->isb_osdrop);\n                if (!wtap_dump_file_write(wdh, &if_stats->isb_osdrop, 8, err))\n                        return FALSE;\n                wdh->bytes_dumped += 8;\n        }\n        /*guint64               isb_usrdeliv;*/\n        if (if_stats->isb_usrdeliv != G_GUINT64_CONSTANT(0xFFFFFFFFFFFFFFFF)) {\n                option_hdr.type          = ISB_USRDELIV;\n                option_hdr.value_length  = 8;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write isb_usrdeliv */\n                pcapng_debug1(\"pcapng_write_interface_statistics_block, isb_usrdeliv: %\" G_GINT64_MODIFIER \"u\" , if_stats->isb_usrdeliv);\n                if (!wtap_dump_file_write(wdh, &if_stats->isb_usrdeliv, 8, err))\n                        return FALSE;\n                wdh->bytes_dumped += 8;\n        }\n\n        if (have_options) {\n                option_hdr.type = OPT_EOFOPT;\n                option_hdr.value_length = 0;\n                if (!wtap_dump_file_write(wdh, &option_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n        }\n\n        /* write block footer */\n        if (!wtap_dump_file_write(wdh, &bh.block_total_length,\n            sizeof bh.block_total_length, err))\n                return FALSE;\n        wdh->bytes_dumped += sizeof bh.block_total_length;\n\n        return TRUE;\n\n}\n\n\nstatic gboolean\npcapng_write_enhanced_packet_block(wtap_dumper *wdh,\n    const struct wtap_pkthdr *phdr,\n    const union wtap_pseudo_header *pseudo_header, const guint8 *pd, int *err)\n{\n        pcapng_block_header_t bh;\n        pcapng_enhanced_packet_block_t epb;\n        guint64 ts;\n        const guint32 zero_pad = 0;\n        guint32 pad_len;\n        guint32 phdr_len;\n        gboolean have_options = FALSE;\n        guint32 options_total_length = 0;\n        guint32 options_hdr = 0;\n        guint32 comment_len = 0, comment_pad_len = 0;\n\n        phdr_len = (guint32)pcap_get_phdr_size(phdr->pkt_encap, pseudo_header);\n        if ((phdr_len + phdr->caplen) % 4) {\n                pad_len = 4 - ((phdr_len + phdr->caplen) % 4);\n        } else {\n                pad_len = 0;\n        }\n\n        /* Check if we should write comment option */\n        if (phdr->opt_comment) {\n                have_options = TRUE;\n                comment_len = (guint32)strlen(phdr->opt_comment) & 0xffff;\n                if ((comment_len % 4)) {\n                        comment_pad_len = 4 - (comment_len % 4);\n                } else {\n                        comment_pad_len = 0;\n                }\n                options_total_length = options_total_length + comment_len + comment_pad_len + 4 /* comment options tag */ ;\n        }\n\n        if (have_options) {\n                /* End-of optios tag */\n                options_total_length += 4;\n        }\n\n        /* write (enhanced) packet block header */\n        bh.block_type = BLOCK_TYPE_EPB;\n        bh.block_total_length = (guint32)sizeof(bh) + (guint32)sizeof(epb) + phdr_len + phdr->caplen + pad_len + options_total_length + 4;\n\n        if (!wtap_dump_file_write(wdh, &bh, sizeof bh, err))\n                return FALSE;\n        wdh->bytes_dumped += sizeof bh;\n\n        /* write block fixed content */\n        if (phdr->presence_flags & WTAP_HAS_INTERFACE_ID)\n                epb.interface_id        = phdr->interface_id;\n        else {\n                /*\n                 * XXX - we should support writing WTAP_ENCAP_PER_PACKET\n                 * data to pcap-NG files even if we *don't* have interface\n                 * IDs.\n                 */\n                epb.interface_id        = 0;\n        }\n        /* Split the 64-bit timestamp into two 32-bit pieces */\n        ts = (((guint64)phdr->ts.secs) * 1000000) + (phdr->ts.nsecs / 1000);\n        epb.timestamp_high      = (guint32)(ts >> 32);\n        epb.timestamp_low       = (guint32)ts;\n        epb.captured_len        = phdr->caplen + phdr_len;\n        epb.packet_len          = phdr->len + phdr_len;\n\n        if (!wtap_dump_file_write(wdh, &epb, sizeof epb, err))\n                return FALSE;\n        wdh->bytes_dumped += sizeof epb;\n\n        /* write pseudo header */\n        if (!pcap_write_phdr(wdh, phdr->pkt_encap, pseudo_header, err)) {\n                return FALSE;\n        }\n        wdh->bytes_dumped += phdr_len;\n\n        /* write packet data */\n        if (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))\n                return FALSE;\n        wdh->bytes_dumped += phdr->caplen;\n\n        /* write padding (if any) */\n        if (pad_len != 0) {\n                if (!wtap_dump_file_write(wdh, &zero_pad, pad_len, err))\n                        return FALSE;\n                wdh->bytes_dumped += pad_len;\n        }\n\n        /* XXX - write (optional) block options */\n        /* options defined in Section 2.5 (Options)\n         * Name           Code Length     Description\n         * opt_comment    1    variable   A UTF-8 string containing a comment that is associated to the current block.\n         *\n         * Enhanced Packet Block options\n         * epb_flags      2    4          A flags word containing link-layer information. A complete specification of\n         *                                the allowed flags can be found in Appendix A (Packet Block Flags Word).\n         * epb_hash       3    variable   This option contains a hash of the packet. The first byte specifies the hashing algorithm,\n         *                                while the following bytes contain the actual hash, whose size depends on the hashing algorithm,\n         *                                                                and hence from the value in the first bit. The hashing algorithm can be: 2s complement\n         *                                                                (algorithm byte = 0, size=XXX), XOR (algorithm byte = 1, size=XXX), CRC32 (algorithm byte = 2, size = 4),\n         *                                                                MD-5 (algorithm byte = 3, size=XXX), SHA-1 (algorithm byte = 4, size=XXX).\n         *                                                                The hash covers only the packet, not the header added by the capture driver:\n         *                                                                this gives the possibility to calculate it inside the network card.\n         *                                                                The hash allows easier comparison/merging of different capture files, and reliable data transfer between the\n         *                                                                data acquisition system and the capture library.\n         * epb_dropcount   4   8          A 64bit integer value specifying the number of packets lost (by the interface and the operating system)\n         *                                between this packet and the preceding one.\n         * opt_endofopt    0   0          It delimits the end of the optional fields. This block cannot be repeated within a given list of options.\n         */\n        if (phdr->opt_comment) {\n                options_hdr = comment_len;\n                options_hdr = options_hdr << 16;\n                /* Option 1  */\n                options_hdr += 1;\n                if (!wtap_dump_file_write(wdh, &options_hdr, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n\n                /* Write the comments string */\n                pcapng_debug3(\"pcapng_write_enhanced_packet_block, comment:'%s' comment_len %u comment_pad_len %u\" , phdr->opt_comment, comment_len, comment_pad_len);\n                if (!wtap_dump_file_write(wdh, phdr->opt_comment, comment_len, err))\n                        return FALSE;\n                wdh->bytes_dumped += comment_len;\n\n                /* write padding (if any) */\n                if (comment_pad_len != 0) {\n                        if (!wtap_dump_file_write(wdh, &zero_pad, comment_pad_len, err))\n                                return FALSE;\n                        wdh->bytes_dumped += comment_pad_len;\n                }\n\n                pcapng_debug2(\"pcapng_write_enhanced_packet_block: Wrote Options comments: comment_len %u, comment_pad_len %u\",\n                        comment_len,\n                        comment_pad_len);\n        }\n\n        /* Write end of options if we have otions */\n        if (have_options) {\n                if (!wtap_dump_file_write(wdh, &zero_pad, 4, err))\n                        return FALSE;\n                wdh->bytes_dumped += 4;\n        }\n\n        /* write block footer */\n        if (!wtap_dump_file_write(wdh, &bh.block_total_length,\n            sizeof bh.block_total_length, err))\n                return FALSE;\n        wdh->bytes_dumped += sizeof bh.block_total_length;\n\n        return TRUE;\n}\n\n/* Arbitrary. */\n#define NRES_REC_MAX_SIZE ((WTAP_MAX_PACKET_SIZE * 4) + 16)\nstatic gboolean\npcapng_write_name_resolution_block(wtap_dumper *wdh, pcapng_dump_t *pcapng, int *err)\n{\n        pcapng_block_header_t bh;\n        pcapng_name_resolution_block_t nrb;\n        struct addrinfo *ai;\n        struct sockaddr_in *sa4;\n        struct sockaddr_in6 *sa6;\n        guint8 *rec_data;\n        gint rec_off, namelen, tot_rec_len;\n\n        if (! pcapng->addrinfo_list_last || ! pcapng->addrinfo_list_last->ai_next) {\n                return TRUE;\n        }\n\n        rec_off = 8; /* block type + block total length */\n        bh.block_type = BLOCK_TYPE_NRB;\n        bh.block_total_length = rec_off + 8; /* end-of-record + block total length */\n        rec_data = (guint8 *)g_malloc(NRES_REC_MAX_SIZE);\n\n        for (; pcapng->addrinfo_list_last && pcapng->addrinfo_list_last->ai_next; pcapng->addrinfo_list_last = pcapng->addrinfo_list_last->ai_next ) {\n                ai = pcapng->addrinfo_list_last->ai_next; /* Skips over the first (dummy) entry */\n                namelen = (gint)strlen(ai->ai_canonname) + 1;\n                if (ai->ai_family == AF_INET) {\n                        nrb.record_type = NRES_IP4RECORD;\n                        nrb.record_len = 4 + namelen;\n                        tot_rec_len = 4 + nrb.record_len + PADDING4(nrb.record_len);\n                        bh.block_total_length += tot_rec_len;\n\n                        if (rec_off + tot_rec_len > NRES_REC_MAX_SIZE)\n                                break;\n\n                        /*\n                         * The joys of BSD sockaddrs.  In practice, this\n                         * cast is alignment-safe.\n                         */\n                        sa4 = (struct sockaddr_in *)(void *)ai->ai_addr;\n                        memcpy(rec_data + rec_off, &nrb, sizeof(nrb));\n                        rec_off += 4;\n\n                        memcpy(rec_data + rec_off, &(sa4->sin_addr.s_addr), 4);\n                        rec_off += 4;\n\n                        memcpy(rec_data + rec_off, ai->ai_canonname, namelen);\n                        rec_off += namelen;\n\n                        memset(rec_data + rec_off, 0, PADDING4(namelen));\n                        rec_off += PADDING4(namelen);\n                        pcapng_debug1(\"NRB: added IPv4 record for %s\", ai->ai_canonname);\n                } else if (ai->ai_family == AF_INET6) {\n                        nrb.record_type = NRES_IP6RECORD;\n                        nrb.record_len = 16 + namelen;\n                        tot_rec_len = 4 + nrb.record_len + PADDING4(nrb.record_len);\n                        bh.block_total_length += tot_rec_len;\n\n                        if (rec_off + tot_rec_len > NRES_REC_MAX_SIZE)\n                                break;\n\n                        /*\n                         * The joys of BSD sockaddrs.  In practice, this\n                         * cast is alignment-safe.\n                         */\n                        sa6 = (struct sockaddr_in6 *)(void *)ai->ai_addr;\n                        memcpy(rec_data + rec_off, &nrb, sizeof(nrb));\n                        rec_off += 4;\n\n                        memcpy(rec_data + rec_off, sa6->sin6_addr.s6_addr, 16);\n                        rec_off += 16;\n\n                        memcpy(rec_data + rec_off, ai->ai_canonname, namelen);\n                        rec_off += namelen;\n\n                        memset(rec_data + rec_off, 0, PADDING4(namelen));\n                        rec_off += PADDING4(namelen);\n                        pcapng_debug1(\"NRB: added IPv6 record for %s\", ai->ai_canonname);\n                }\n        }\n\n        /* We know the total length now; copy the block header. */\n        memcpy(rec_data, &bh, sizeof(bh));\n\n        /* End of record */\n        memset(rec_data + rec_off, 0, 4);\n        rec_off += 4;\n\n        memcpy(rec_data + rec_off, &bh.block_total_length, sizeof(bh.block_total_length));\n        rec_off += 4;\n\n        pcapng_debug2(\"pcapng_write_name_resolution_block: Write bh.block_total_length bytes %d, rec_off %u\", bh.block_total_length, rec_off);\n\n        if (!wtap_dump_file_write(wdh, rec_data, bh.block_total_length, err)) {\n                g_free(rec_data);\n                return FALSE;\n        }\n\n        g_free(rec_data);\n        wdh->bytes_dumped += bh.block_total_length;\n        return TRUE;\n}\n\n#if 0\nstatic guint32\npcapng_lookup_interface_id_by_encap(int wtap_encap, wtap_dumper *wdh)\n{\n        gint i;\n        interface_data_t int_data;\n        pcapng_dump_t *pcapng = (pcapng_dump_t *)wdh->priv;\n\n        for(i = 0; i < (gint)pcapng->number_of_interfaces; i++) {\n                int_data = g_array_index(pcapng->interface_data, interface_data_t, i);\n                if (wtap_encap == int_data.wtap_encap) {\n                        return (guint32)i;\n                }\n        }\n        return G_MAXUINT32;\n}\n#endif\n\nstatic gboolean pcapng_dump(wtap_dumper *wdh,\n        const struct wtap_pkthdr *phdr,\n        const union wtap_pseudo_header *pseudo_header,\n        const guint8 *pd, int *err)\n{\n        /*interface_data_t int_data;*/\n        pcapng_dump_t *pcapng = (pcapng_dump_t *)wdh->priv;\n        /*int pcap_encap;*/\n\n        pcapng_debug2(\"pcapng_dump: encap = %d (%s)\",\n                      phdr->pkt_encap,\n                      wtap_encap_string(phdr->pkt_encap));\n\n        if (!pcapng->addrinfo_list_last)\n                pcapng->addrinfo_list_last = wdh->addrinfo_list;\n        /* Flush any hostname resolution info we may have */\n        while (pcapng->addrinfo_list_last && pcapng->addrinfo_list_last->ai_next) {\n                pcapng_write_name_resolution_block(wdh, pcapng, err);\n        }\n\n        if (!pcapng_write_enhanced_packet_block(wdh, phdr, pseudo_header, pd, err)) {\n                return FALSE;\n        }\n\n        return TRUE;\n}\n\n\n/* Finish writing to a dump file.\n   Returns TRUE on success, FALSE on failure. */\nstatic gboolean pcapng_dump_close(wtap_dumper *wdh, int *err _U_)\n{\n        int i, j;\n        pcapng_dump_t *pcapng = (pcapng_dump_t *)wdh->priv;\n\n        if ((wdh->number_of_interfaces > 0) && (wdh->interface_data != NULL)) {\n            for (i = 0; i < (int)wdh->number_of_interfaces; i++) {\n\n                /* Get the interface description */\n                wtapng_if_descr_t int_data;\n\n                int_data = g_array_index(wdh->interface_data, wtapng_if_descr_t, i);\n                for (j = 0; j < (int)int_data.num_stat_entries; j++) {\n                    wtapng_if_stats_t if_stats;\n\n                    if_stats = g_array_index(int_data.interface_statistics, wtapng_if_stats_t, j);\n                    pcapng_debug1(\"pcapng_dump_close: write ISB for interface %u\",if_stats.interface_id);\n\t\t\t\t\tif (!pcapng_write_interface_statistics_block(wdh, &if_stats, err)) {\n\t\t\t\t\t\treturn FALSE;\n\t\t\t\t\t}\n                }\n            }\n        }\n\n        pcapng_debug0(\"pcapng_dump_close\");\n        g_array_free(pcapng->interface_data, TRUE);\n        pcapng->number_of_interfaces = 0;\n        return TRUE;\n}\n\n\n/* Returns TRUE on success, FALSE on failure; sets \"*err\" to an error code on\n   failure */\ngboolean\npcapng_dump_open(wtap_dumper *wdh, int *err)\n{\n        pcapng_dump_t *pcapng;\n        int i;\n        interface_data_t interface_data;\n\n        pcapng_debug0(\"pcapng_dump_open\");\n        /* This is a pcapng file */\n        wdh->subtype_write = pcapng_dump;\n        wdh->subtype_close = pcapng_dump_close;\n        pcapng = (pcapng_dump_t *)g_malloc0(sizeof(pcapng_dump_t));\n        wdh->priv = (void *)pcapng;\n        pcapng->interface_data = g_array_new(FALSE, FALSE, sizeof(wtapng_if_descr_t));\n\n        if ((wdh->number_of_interfaces == 0) || (wdh->interface_data == NULL)) {\n                pcapng_debug0(\"There are no interfaces. Can't handle that...\");\n                *err = WTAP_ERR_INTERNAL;\n                return FALSE;\n        }\n\n        /* write the section header block */\n        if (!pcapng_write_section_header_block(wdh, err)) {\n                return FALSE;\n        }\n        pcapng_debug0(\"pcapng_dump_open: wrote section header block.\");\n\n        /* Write the Interface description blocks */\n        pcapng_debug1(\"pcapng_dump_open: Number of IDB:s to write (number of interfaces) %u\", wdh->number_of_interfaces);\n\n        for (i = 0; i < (int)wdh->number_of_interfaces; i++) {\n\n                /* Get the interface description */\n                wtapng_if_descr_t int_data;\n\n                int_data = g_array_index(wdh->interface_data, wtapng_if_descr_t, i);\n\n                interface_data.wtap_encap = int_data.wtap_encap;\n                interface_data.time_units_per_second = int_data.time_units_per_second;\n\n                g_array_append_val(pcapng->interface_data, interface_data);\n                pcapng->number_of_interfaces++;\n\n                if (!pcapng_write_if_descr_block(wdh, &int_data, err)) {\n                        return FALSE;\n                }\n\n        }\n#if 0\n        interface_id = pcapng_lookup_interface_id_by_encap(phdr->pkt_encap, wdh);\n        if (interface_id == G_MAXUINT32) {\n                /*\n                 * We haven't yet written out an interface description\n                 * block for an interface with this encapsulation.\n                 *\n                 * Is this encapsulation even supported in pcap-ng?\n                 */\n                pcap_encap = wtap_wtap_encap_to_pcap_encap(phdr->pkt_encap);\n                if (pcap_encap == -1) {\n                        /*\n                         * No.  Fail.\n                         */\n                        *err = WTAP_ERR_UNSUPPORTED_ENCAP;\n                        return FALSE;\n                }\n\n                /* write the interface description block */\n                wblock.frame_buffer            = NULL;\n                wblock.pseudo_header           = NULL;\n                wblock.packet_header           = NULL;\n                wblock.file_encap              = NULL;\n                wblock.type                    = BLOCK_TYPE_IDB;\n                wblock.data.if_descr.link_type = pcap_encap;\n                wblock.data.if_descr.snap_len = (wdh->snaplen != 0) ? wdh->snaplen :\n                                                                      WTAP_MAX_PACKET_SIZE; /* XXX */\n\n                /* XXX - options unused */\n                wblock.data.if_descr.if_speed   = -1;\n                /*wblock.data.if_descr.if_tsresol = 6;*/    /* default: usec */\n                wblock.data.if_descr.if_os      = NULL;\n                wblock.data.if_descr.if_fcslen  = -1;\n\n                if (!pcapng_write_if_descr_block(wdh, &wblock, err)) {\n                        return FALSE;\n                }\n\n                interface_id = pcapng->number_of_interfaces;\n                int_data.wtap_encap = phdr->pkt_encap;\n                int_data.time_units_per_second = 0;\n                g_array_append_val(pcapng->interface_data, int_data);\n                pcapng->number_of_interfaces++;\n\n                pcapng_debug3(\"pcapng_dump: added interface description block with index %u for encap = %d (%s).\",\n                              interface_id,\n                              phdr->pkt_encap,\n                              wtap_encap_string(phdr->pkt_encap));\n        }\n#endif\n\n        return TRUE;\n}\n\n\n/* Returns 0 if we could write the specified encapsulation type,\n   an error indication otherwise. */\nint pcapng_dump_can_write_encap(int wtap_encap)\n{\n        pcapng_debug2(\"pcapng_dump_can_write_encap: encap = %d (%s)\",\n                      wtap_encap,\n                      wtap_encap_string(wtap_encap));\n\n        /* Per-packet encapsulation is supported. */\n        if (wtap_encap == WTAP_ENCAP_PER_PACKET)\n                return 0;\n\n        /* Make sure we can figure out this DLT type */\n        if (wtap_wtap_encap_to_pcap_encap(wtap_encap) == -1)\n                return WTAP_ERR_UNSUPPORTED_ENCAP;\n\n        return 0;\n}\n\n/*\n * Editor modelines  -  http://www.wireshark.org/tools/modelines.html\n *\n * Local variables:\n * c-basic-offset: 4\n * tab-width: 8\n * indent-tabs-mode: nil\n * End:\n *\n * vi: set shiftwidth=4 tabstop=8 expandtab:\n * :indentSize=4:tabSize=8:noTabs=true:\n */\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"input_validation\",\n  \"severity\": \"medium\",\n  \"explanation\": \"This code does not properly validate user input before processing it. Attackers can provide malformed or unexpected input to cause errors or exploit vulnerabilities.\",\n  \"risk\": \"Application crashes, unexpected behavior, potential exploitation of other vulnerabilities\",\n  \"compliant_patch\": \"\\n// FIXED: Validate all user input before processing\\n// Instead of: process_user_input(raw_input);\\n// Use: if (is_valid_input(raw_input)) {\\n//         sanitized_input = sanitize_input(raw_input);\\n//         process_user_input(sanitized_input);\\n//       } else {\\n//         reject_invalid_input();\\n//       }\\n\",\n  \"source\": \"SARD-231369\",\n  \"cwe\": \"CWE-20\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/*#define _GNU_SOURCE*/\n\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n\nint main(int argc, char **argv) {\n    int shmsz;            /* size of shared mem (default 128) */\n    int shmid;            /* id of shared mem segment */\n    key_t key;            /* 'name' of shared memory */\n    char *shm, *s;        /* pointer to shared mem */\n    char *str = NULL;            /* data to put into the shared mem */\n    int c;\n    int errors = 0;\n    char *out_filename = NULL;\n    FILE *out_file = NULL;\n    \n    opterr = 0;\n\n    /* Get options */\n    while ((c = getopt(argc, argv, \"k:s:m:o:h\")) != -1) {\n        switch(c) {\n            case 'k':\n                if ((key = strtol(optarg, NULL, 10)) < 1000) {\n                    fprintf(stderr, \"Key needs to be a 4 digit number.\\n\");\n                    errors++;\n                }\n                break;\n            case 's':\n                if ((shmsz = atoi(optarg)) <= 0) {\n                    fprintf(stderr, \"Size needs to be an integer.\\n\");\n                    errors++;\n                }\n                break;\n            case 'o':\n                out_filename = optarg;\n                break;\n            case 'm':\n                str = optarg;\n                break;\n            case 'h':\n                printf(\"Usage: shm_server -k <key> -s <size> -m <data>\\nex) shm_server -k 1234 -s 128 -m 'Hello World'\\n\");\n                return 0;\n                break;\n            case '?':\n                fprintf(stderr, \"Illegal argument!\\n\");\n                errors++;\n                break;\n            }\n    }\n    \n    if (!str) {\n        fprintf(stderr, \"No data provided.\\n\");\n        errors++;\n    } else if (strlen(str) >= shmsz) {\n        fprintf(stderr, \"Data too large for shared memory segment.\\n\");\n        errors++;\n    }\n      \n    if (errors) {\n        printf(\"Usage: shm_server -k <key> -s <size> -m <data>\\nex) shm_server -k 1234 -s 128 -m 'Hello World'\\n\");\n        return 1;\n    }\n    \n    /* Create the shared segment */\n    if ((shmid = shmget(key, shmsz, IPC_CREAT | 0666)) < 0) {\n        fprintf(stderr, \"shmget error\\n\");\n        return 1;\n    }\n    \n    /* attach segment to our data space */\n    if ((shm = shmat(shmid, NULL, 0)) == (char *) -1) {\n        fprintf(stderr, \"shmat error\\n\");\n        return 1;\n    }\n    \n    /* put stuff in memory */\n    s = shm;        /* pointer to memory in shm */\n\n    /* Clear memory */\n    memset(s, 0, shmsz);\n    \n    /* copy in the data */\n    strcpy(shm, str);\n    \n    /* write out the shared memory id */\n    if (out_filename) {\n        if ((out_file = fopen(out_filename, \"w\"))) {\n            fprintf(out_file, \"%d\", shmid);\n            fclose(out_file);\n            out_file = NULL;\n        } else {\n            fprintf(stderr, \"Failed to open output file: \\\"%s\\\"\\n\", out_filename);\n            fprintf(stdout, \"%d\", shmid);\n        }\n    } else {\n        fprintf(stdout, \"%d\", shmid);\n    }\n    \n    /* wait for input */\n    fprintf(stderr, \"Press any key to exit...\");\n    getchar();\n    fprintf(stderr, \"\\n\");\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"sql_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code constructs SQL queries by concatenating user input directly into the query string. Attackers can manipulate input to execute malicious SQL commands.\",\n  \"risk\": \"Database compromise, data theft, data manipulation, authentication bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Use prepared statements with parameterized queries\\n// Instead of: query = \\\"SELECT * FROM users WHERE name = '\\\" + user_input + \\\"'\\\"\\n// Use: query = \\\"SELECT * FROM users WHERE name = ?\\\"\\n//       stmt = connection.prepareStatement(query);\\n//       stmt.setString(1, user_input);\\n//       result = stmt.executeQuery();\\n\",\n  \"source\": \"SARD-152858\",\n  \"cwe\": \"CWE-89\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* ====================================================================\n * Copyright (c) 2001 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    licensing@OpenSSL.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n#include \"cryptlib.h\"\n#include <openssl/evp.h>\n#include <openssl/lhash.h>\n#include \"eng_int.h\"\n/* The type of the items in the table */\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <stdio.h> \n#include <mysql.h> \n#include <stonesoup/stonesoup_trace.h> \ntypedef struct st_engine_pile {\n/* The 'nid' of this algorithm/mode */\nint nid;\n/* ENGINEs that implement this algorithm/mode. */\nstruct stack_st_ENGINE *sk;\n/* The default ENGINE to perform this algorithm/mode. */\nENGINE *funct;\n/* Zero if 'sk' is newer than the cached 'funct', non-zero otherwise */\nint uptodate;}ENGINE_PILE;\n\nstruct lhash_st_ENGINE_PILE \n{\n  int dummy;\n}\n;\n/* The type exposed in eng_int.h */\n\nstruct st_engine_table \n{\n  struct lhash_st_ENGINE_PILE piles;\n/* ENGINE_TABLE */\n}\n;\ntypedef struct st_engine_pile_doall {\nengine_table_doall_cb *cb;\nvoid *arg;}ENGINE_PILE_DOALL;\n/* Global flags (ENGINE_TABLE_FLAG_***). */\nstatic unsigned int table_flags = 0;\n/* API function manipulating 'table_flags' */\nint jolterheaded_albay = 0;\nint stonesoup_global_variable;\nvoid* stonesoup_printf_context = NULL;\nvoid stonesoup_setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    stonesoup_printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (stonesoup_printf_context == NULL) {\n        stonesoup_printf_context = stderr;\n    }\n}\nvoid stonesoup_printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(stonesoup_printf_context, format, argptr);\n    va_end(argptr);\n    fflush(stonesoup_printf_context);\n}\nvoid stonesoup_close_printf_context() {\n    if (stonesoup_printf_context != NULL &&\n        stonesoup_printf_context != stderr) {\n        fclose(stonesoup_printf_context);\n    }\n}\nvoid stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_envKey, int stonesoup_shmsz) {\n    int stonesoup_shmid;\n key_t stonesoup_key;\n char *stonesoup_shm, *stonesoup_s;\n char* stonesoup_envSize = NULL;\n *stonesoup_tainted_buff = NULL;\n    if (getenv(\"STONESOUP_DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"STONESOUP_DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(stonesoup_envKey != NULL) {\n            if(sscanf(stonesoup_envKey, \"%d\", &stonesoup_key) > 0) {\n                if ((stonesoup_shmid = shmget(stonesoup_key, stonesoup_shmsz, 0666)) >= 0) {\n                    if ((stonesoup_shm = shmat(stonesoup_shmid, NULL, 0)) != (char *) -1) {\n                        *stonesoup_tainted_buff = (char*)calloc(stonesoup_shmsz, sizeof(char));\n                        /* STONESOUP: SOURCE-TAINT (Shared Memory) */\n                        for (stonesoup_s = stonesoup_shm; *stonesoup_s != (char)0; stonesoup_s++) {\n                            (*stonesoup_tainted_buff)[stonesoup_s - stonesoup_shm] = *stonesoup_s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *stonesoup_tainted_buff = NULL;\n    }\n}\nvoid yirring_vsterbottensost(char *const georgette_dextrocardia);\n\nunsigned int ENGINE_get_table_flags()\n{\n  return table_flags;\n}\n\nvoid ENGINE_set_table_flags(unsigned int flags)\n{\n  table_flags = flags;\n}\n/* Internal functions for the \"piles\" hash table */\n\nstatic unsigned long engine_pile_hash(const ENGINE_PILE *c)\n{\n  return (c -> nid);\n}\n\nstatic int engine_pile_cmp(const ENGINE_PILE *a,const ENGINE_PILE *b)\n{\n  return a -> nid - b -> nid;\n}\n\nstatic unsigned long engine_pile_LHASH_HASH(const void *arg)\n{\n  const ENGINE_PILE *a = arg;\n  return engine_pile_hash(a);\n}\n\nstatic int engine_pile_LHASH_COMP(const void *arg1,const void *arg2)\n{\n  const ENGINE_PILE *a = arg1;\n  const ENGINE_PILE *b = arg2;\n  return engine_pile_cmp(a,b);\n}\n\nstatic int int_table_check(ENGINE_TABLE **t,int create)\n{\n  struct lhash_st_ENGINE_PILE *lh;\n  if ( *t) {\n    return 1;\n  }\n  if (!create) {\n    return 0;\n  }\n  if ((lh = ((struct lhash_st_ENGINE_PILE *)(lh_new(engine_pile_LHASH_HASH,engine_pile_LHASH_COMP)))) == ((void *)0)) {\n    return 0;\n  }\n   *t = ((ENGINE_TABLE *)lh);\n  return 1;\n}\n/* Privately exposed (via eng_int.h) functions for adding and/or removing\n * ENGINEs from the implementation table */\n\nint engine_table_register(ENGINE_TABLE **table,ENGINE_CLEANUP_CB *cleanup,ENGINE *e,const int *nids,int num_nids,int setdefault)\n{\n  int ret = 0;\n  int added = 0;\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd;\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",135);\n  if (!( *table)) {\n    added = 1;\n  }\n  if (!int_table_check(table,1)) {\n    goto end;\n  }\n  if (added) {\n/* The cleanup callback needs to be added */\n    engine_cleanup_add_first(cleanup);\n  }\n  while(num_nids--){\n    tmplate . nid =  *nids;\n    fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n    if (!fnd) {\n      fnd = (CRYPTO_malloc(((int )(sizeof(ENGINE_PILE ))),\"eng_table.c\",149));\n      if (!fnd) {\n        goto end;\n      }\n      fnd -> uptodate = 1;\n      fnd -> nid =  *nids;\n      fnd -> sk = ((struct stack_st_ENGINE *)(sk_new_null()));\n      if (!fnd -> sk) {\n        CRYPTO_free(fnd);\n        goto end;\n      }\n      fnd -> funct = ((void *)0);\n      (void )((ENGINE_PILE *)(lh_insert(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(1?fnd : ((ENGINE_PILE *)0))))));\n    }\n/* A registration shouldn't add duplciate entries */\n    (void )((ENGINE *)(sk_delete_ptr(((_STACK *)(1?fnd -> sk : ((struct stack_st_ENGINE *)0))),((void *)(1?e : ((ENGINE *)0))))));\n/* if 'setdefault', this ENGINE goes to the head of the list */\n    if (!sk_push(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) {\n      goto end;\n    }\n/* \"touch\" this ENGINE_PILE */\n    fnd -> uptodate = 0;\n    if (setdefault) {\n      if (!engine_unlocked_init(e)) {\n        ERR_put_error(38,184,109,\"eng_table.c\",174);\n        goto end;\n      }\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = e;\n      fnd -> uptodate = 1;\n    }\n    nids++;\n  }\n  ret = 1;\n  end:\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",186);\n  return ret;\n}\n\nstatic void int_unregister_cb_doall_arg(ENGINE_PILE *pile,ENGINE *e)\n{\n  int n;\n/* Iterate the 'c->sk' stack removing any occurance of 'e' */\n  while((n = sk_find(((_STACK *)((1?pile -> sk : ((struct stack_st_ENGINE *)0)))),((void *)((1?e : ((ENGINE *)0)))))) >= 0){\n    (void )((ENGINE *)(sk_delete(((_STACK *)(1?pile -> sk : ((struct stack_st_ENGINE *)0))),n)));\n    pile -> uptodate = 0;\n  }\n  if (pile -> funct == e) {\n    engine_unlocked_finish(e,0);\n    pile -> funct = ((void *)0);\n  }\n}\n\nstatic void int_unregister_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE *b = arg2;\n  int_unregister_cb_doall_arg(a,b);\n}\n\nvoid engine_table_unregister(ENGINE_TABLE **table,ENGINE *e)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",208);\n  if (int_table_check(table,0)) {\n    lh_doall_arg(((_LHASH *)((void *)(&( *table) -> piles))),int_unregister_cb_LHASH_DOALL_ARG,((void *)(1?e : ((ENGINE *)0))));\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",213);\n}\n\nstatic void int_cleanup_cb_doall(ENGINE_PILE *p)\n{\n  sk_free(((_STACK *)(1?p -> sk : ((struct stack_st_ENGINE *)0))));\n  if (p -> funct) {\n    engine_unlocked_finish(p -> funct,0);\n  }\n  CRYPTO_free(p);\n}\n\nstatic void int_cleanup_cb_LHASH_DOALL(void *arg)\n{\n  int kowal_asparaginous = 0;\n  char *cribbage_thereright = 0;\n  int nondeafened_streetfighter = 73;\n  char *prophesying_draftsmen;\n  ENGINE_PILE *a = arg;\n  if (__sync_bool_compare_and_swap(&jolterheaded_albay,0,1)) {;\n    if (mkdir(\"/opt/stonesoup/workspace/lockDir\",509U) == 0) {;\n      tracepoint(stonesoup_trace,trace_location,\"/tmp/tmpMMnGNw_ss_testcase/src-rose/crypto/engine/eng_table.c\",\"int_cleanup_cb_LHASH_DOALL\");\n      stonesoup_setup_printf_context();\n      stonesoup_read_taint(&prophesying_draftsmen,\"7988\",nondeafened_streetfighter);\n      if (prophesying_draftsmen != 0) {;\n        kowal_asparaginous = ((int )(strlen(prophesying_draftsmen)));\n        cribbage_thereright = ((char *)(malloc(kowal_asparaginous + 1)));\n        if (cribbage_thereright == 0) {\n          stonesoup_printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(cribbage_thereright,0,kowal_asparaginous + 1);\n        memcpy(cribbage_thereright,prophesying_draftsmen,kowal_asparaginous);\n        if (prophesying_draftsmen != 0) \n          free(((char *)prophesying_draftsmen));\n        yirring_vsterbottensost(cribbage_thereright);\n      }\n    }\n  }\n  int_cleanup_cb_doall(a);\n}\n\nvoid engine_table_cleanup(ENGINE_TABLE **table)\n{\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",227);\n  if ( *table) {\n    lh_doall(((_LHASH *)((void *)(&( *table) -> piles))),int_cleanup_cb_LHASH_DOALL);\n    lh_free(((_LHASH *)((void *)(&( *table) -> piles))));\n     *table = ((void *)0);\n  }\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",235);\n}\n/* return a functional reference for a given 'nid' */\n#ifndef ENGINE_TABLE_DEBUG\n\nENGINE *engine_table_select(ENGINE_TABLE **table,int nid)\n#else\n#endif\n{\n  ENGINE *ret = ((void *)0);\n  ENGINE_PILE tmplate;\n  ENGINE_PILE *fnd = ((void *)0);\n  int initres;\n  int loop = 0;\n  if (!( *table)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    return ((void *)0);\n  }\n  ERR_set_mark();\n  CRYPTO_lock(1 | 8,30,\"eng_table.c\",258);\n/* Check again inside the lock otherwise we could race against cleanup\n\t * operations. But don't worry about a fprintf(stderr). */\n  if (!int_table_check(table,0)) {\n    goto end;\n  }\n  tmplate . nid = nid;\n  fnd = ((ENGINE_PILE *)(lh_retrieve(((_LHASH *)((void *)(&( *table) -> piles))),((void *)(&tmplate)))));\n  if (!fnd) {\n    goto end;\n  }\n  if (fnd -> funct && engine_unlocked_init(fnd -> funct)) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    ret = fnd -> funct;\n    goto end;\n  }\n  if (fnd -> uptodate) {\n    ret = fnd -> funct;\n    goto end;\n  }\n  trynext:\n  ret = ((ENGINE *)(sk_value(((_STACK *)((1?fnd -> sk : ((struct stack_st_ENGINE *)0)))),loop++)));\n  if (!ret) {\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n/* Try to initialise the ENGINE? */\n  if (ret -> funct_ref > 0 || !(table_flags & ((unsigned int )0x0001))) {\n    initres = engine_unlocked_init(ret);\n  }\n  else {\n    initres = 0;\n  }\n  if (initres) {\n/* Update 'funct' */\n    if (fnd -> funct != ret && engine_unlocked_init(ret)) {\n/* If there was a previous default we release it. */\n      if (fnd -> funct) {\n        engine_unlocked_finish(fnd -> funct,0);\n      }\n      fnd -> funct = ret;\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n    goto end;\n  }\n  goto trynext;\n  end:\n/* If it failed, it is unlikely to succeed again until some future\n\t * registrations have taken place. In all cases, we cache. */\n  if (fnd) {\n    fnd -> uptodate = 1;\n  }\n#ifdef ENGINE_TABLE_DEBUG\n#endif\n  CRYPTO_lock(2 | 8,30,\"eng_table.c\",328);\n/* Whatever happened, any failed init()s are not failures in this\n\t * context, so clear our error state. */\n  ERR_pop_to_mark();\n  return ret;\n}\n/* Table enumeration */\n\nstatic void int_cb_doall_arg(ENGINE_PILE *pile,ENGINE_PILE_DOALL *dall)\n{\n  (dall -> cb)(pile -> nid,pile -> sk,pile -> funct,dall -> arg);\n}\n\nstatic void int_cb_LHASH_DOALL_ARG(void *arg1,void *arg2)\n{\n  ENGINE_PILE *a = arg1;\n  ENGINE_PILE_DOALL *b = arg2;\n  int_cb_doall_arg(a,b);\n}\n\nvoid engine_table_doall(ENGINE_TABLE *table,engine_table_doall_cb *cb,void *arg)\n{\n  ENGINE_PILE_DOALL dall;\n  dall . cb = cb;\n  dall . arg = arg;\n  lh_doall_arg(((_LHASH *)((void *)(&table -> piles))),int_cb_LHASH_DOALL_ARG,((void *)(&dall)));\n}\n\nvoid yirring_vsterbottensost(char *const georgette_dextrocardia)\n{\n  MYSQL_ROW stonesoup_row;\n  unsigned int stonesoup_num_fields;\n  my_ulonglong stonesoup_num_rows;\n  MYSQL_RES *stonesoup_result;\n  int stonesoup_i;\n  int stonesoup_status;\n  char stonesoup_query_buffer[1000];\n  MYSQL *stonesoup_conn;\n  unsigned int stonesoup_dbport = 0;\n  char *stonesoup_dbpassword = 0;\n  char *stonesoup_dbuser = 0;\n  char *stonesoup_dbhost = 0;\n  char * stonesoup_dbdatabase = 0;\n  char stonesoup_use_str[150] = {0};\n  int stonesoup_random_int = 0;\n  char *muckman_seminoma = 0;\n  ++stonesoup_global_variable;;\n  if (((char *)georgette_dextrocardia) != 0) {\n    goto unionisms_ascots;\n  }\n  ++stonesoup_global_variable;\n  unionisms_ascots:;\n  muckman_seminoma = ((char *)((char *)georgette_dextrocardia));\n      tracepoint(stonesoup_trace, weakness_start, \"CWE089\", \"C\", \"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\");\n      stonesoup_dbhost = getenv(\"DBMYSQLHOST\");\n      stonesoup_dbuser = getenv(\"DBMYSQLUSER\");\n      stonesoup_dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      stonesoup_dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      stonesoup_dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbhost\", stonesoup_dbhost, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbuser\", stonesoup_dbuser, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbpassword\", stonesoup_dbpassword, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_signed_integral, \"stonesoup_dbport\", stonesoup_dbport, &stonesoup_dbport, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbdatabase\", stonesoup_dbdatabase, \"INITIAL-STATE\");\n      if (stonesoup_dbhost != 0 && stonesoup_dbport != 0 && (stonesoup_dbuser != 0 && stonesoup_dbpassword != 0)) {\n          stonesoup_conn = mysql_init(0);\n          if (stonesoup_conn != 0) {\n            if (mysql_real_connect(stonesoup_conn,stonesoup_dbhost,stonesoup_dbuser,stonesoup_dbpassword,0,stonesoup_dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(stonesoup_use_str,150,\"USE %s;\", stonesoup_dbdatabase);\n              if (mysql_query(stonesoup_conn, stonesoup_use_str) == 0) {\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: BEFORE\");\n/* STONESOUP: CROSSOVER-POINT (Sql Injection) */\n    srand(time(NULL));\n    stonesoup_random_int = (rand() % 1000) + 100;\n                snprintf(stonesoup_query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", stonesoup_random_int, muckman_seminoma);\n    tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_query_buffer\", stonesoup_query_buffer, \"CROSSOVER-STATE\");\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: AFTER\");\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: BEFORE\");\n/* STONESOUP: TRIGGER-POINT (Sql Injection) */\n                if (mysql_query(stonesoup_conn,stonesoup_query_buffer)) {\n                  stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n    } else {\n      stonesoup_printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(stonesoup_conn));\n                }\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: AFTER\");\n              }\n              else {\n                tracepoint(stonesoup_trace, trace_error, \"Query error.\");\n                stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n              }\n              mysql_close(stonesoup_conn);\n            }\n            else {\n              tracepoint(stonesoup_trace, trace_error, \"Real connect error.\");\n              stonesoup_printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n            }\n          }\n          else {\n            tracepoint(stonesoup_trace, trace_error, \"Init error.\");\n            stonesoup_printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n          }\n      }\n      tracepoint(stonesoup_trace, weakness_end);\n;\n  if (((char *)georgette_dextrocardia) != 0) \n    free(((char *)((char *)georgette_dextrocardia)));\nstonesoup_close_printf_context();\n}\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"sql_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code constructs SQL queries by concatenating user input directly into the query string. Attackers can manipulate input to execute malicious SQL commands.\",\n  \"risk\": \"Database compromise, data theft, data manipulation, authentication bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Use prepared statements with parameterized queries\\n// Instead of: query = \\\"SELECT * FROM users WHERE name = '\\\" + user_input + \\\"'\\\"\\n// Use: query = \\\"SELECT * FROM users WHERE name = ?\\\"\\n//       stmt = connection.prepareStatement(query);\\n//       stmt.setString(1, user_input);\\n//       result = stmt.executeQuery();\\n\",\n  \"source\": \"SARD-152858\",\n  \"cwe\": \"CWE-89\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* GIMP - The GNU Image Manipulation Program\n * Copyright (C) 1995 Spencer Kimball and Peter Mattis\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n#include \"config.h\"\n#include <string.h>\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-manager-private.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/stat.h> \n#include <mysql.h> \n#include <stonesoup/stonesoup_trace.h> \nstatic void tile_manager_allocate_tiles(TileManager *tm);\n#ifdef TILE_PROFILING\n#endif\n#ifdef GIMP_UNSTABLE\n#endif\nint gaffs_unfiercely = 0;\nint stonesoup_global_variable;\nvoid* stonesoup_printf_context = NULL;\nvoid stonesoup_setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    stonesoup_printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (stonesoup_printf_context == NULL) {\n        stonesoup_printf_context = stderr;\n    }\n}\nvoid stonesoup_printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(stonesoup_printf_context, format, argptr);\n    va_end(argptr);\n    fflush(stonesoup_printf_context);\n}\nvoid stonesoup_close_printf_context() {\n    if (stonesoup_printf_context != NULL &&\n        stonesoup_printf_context != stderr) {\n        fclose(stonesoup_printf_context);\n    }\n}\nvoid stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_env_var_name) {\n  if (getenv(\"STONESOUP_DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"STONESOUP_DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* stonesoup_tainted_file_name = 0;\n        FILE * stonesoup_tainted_file = 0;\n        size_t stonesoup_result = 0;\n        long stonesoup_lsize = 0;\n        stonesoup_tainted_file_name = getenv(stonesoup_env_var_name);\n        stonesoup_tainted_file = fopen(stonesoup_tainted_file_name,\"rb\");\n        if (stonesoup_tainted_file != 0) {\n            fseek(stonesoup_tainted_file,0L,2);\n            stonesoup_lsize = ftell(stonesoup_tainted_file);\n            rewind(stonesoup_tainted_file);\n            *stonesoup_tainted_buff = ((char *)(malloc(sizeof(char ) * (stonesoup_lsize + 1))));\n            if (*stonesoup_tainted_buff != 0) {\n                /* STONESOUP: SOURCE-TAINT (File Contents) */\n                stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);\n                (*stonesoup_tainted_buff)[stonesoup_lsize] = '\\0';\n            }\n        }\n        if (stonesoup_tainted_file != 0) {\n            fclose(stonesoup_tainted_file);\n        }\n    } else {\n        *stonesoup_tainted_buff = NULL;\n    }\n}\nvoid ecumenicism_chappin(int enterocentesis_ferigee,char *(**sheilah_fornication)[95]);\nvoid paracress_sniggle(int bartholomeus_upsadaisy,char *(**erechim_gaidropsaridae)[95]);\n\nGType gimp_tile_manager_get_type()\n{\n  static GType type = 0;\n  if (!type) {\n    type = g_boxed_type_register_static(\"TileManager\",((GBoxedCopyFunc )tile_manager_ref),((GBoxedFreeFunc )tile_manager_unref));\n  }\n  return type;\n}\n#ifdef GIMP_UNSTABLE\n#endif\n\ninline static gint tile_manager_get_tile_num(TileManager *tm,gint xpixel,gint ypixel)\n{\n  if (xpixel < 0 || xpixel >= tm -> width || ypixel < 0 || ypixel >= tm -> height) {\n    return - 1;\n  }\n  return ypixel / 64 * tm -> ntile_cols + xpixel / 64;\n}\n\nTileManager *tile_manager_new(gint width,gint height,gint bpp)\n{\n  TileManager *tm;\n  do {\n    if (width > 0 && height > 0) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"width > 0 && height > 0\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (bpp > 0 && bpp <= 4) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"bpp > 0 && bpp <= 4\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  tm = ((TileManager *)(g_slice_alloc0(sizeof(TileManager ))));\n  tm -> ref_count = 1;\n  tm -> width = width;\n  tm -> height = height;\n  tm -> bpp = bpp;\n  tm -> ntile_rows = (height + 64 - 1) / 64;\n  tm -> ntile_cols = (width + 64 - 1) / 64;\n  tm -> cached_num = - 1;\n#ifdef GIMP_UNSTABLE\n#endif\n  return tm;\n}\n\nTileManager *tile_manager_ref(TileManager *tm)\n{\n  do {\n    if (tm != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tm != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  tm -> ref_count++;\n  return tm;\n}\n\nvoid tile_manager_unref(TileManager *tm)\n{\n  do {\n    if (tm != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tm != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  tm -> ref_count--;\n  if (tm -> ref_count < 1) {\n#ifdef GIMP_UNSTABLE\n#endif\n    if (tm -> cached_tile) {\n      tile_release(tm -> cached_tile,0);\n    }\n    if (tm -> tiles) {\n      gint ntiles = tm -> ntile_rows * tm -> ntile_cols;\n      gint i;\n      for (i = 0; i < ntiles; i++) \n        tile_detach(tm -> tiles[i],tm,i);\n      g_free((tm -> tiles));\n    }\n    do {\n      if (1) {\n        g_slice_free1(sizeof(TileManager ),tm);\n      }\n      else {\n        (void )(((TileManager *)0) == tm);\n      }\n    }while (0);\n  }\n}\n\nTileManager *tile_manager_duplicate(TileManager *tm)\n{\n  TileManager *copy;\n  gint n_tiles;\n  gint i;\n  do {\n    if (tm != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tm != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  copy = tile_manager_new(tm -> width,tm -> height,tm -> bpp);\n  tile_manager_allocate_tiles(copy);\n  n_tiles = tm -> ntile_rows * tm -> ntile_cols;\n  for (i = 0; i < n_tiles; i++) {\n    Tile *tile;\n    tile = tile_manager_get(tm,i,!0,0);\n    tile_manager_map(copy,i,tile);\n    tile_release(tile,0);\n  }\n  return copy;\n}\n\nvoid tile_manager_set_validate_proc(TileManager *tm,TileValidateProc proc,gpointer user_data)\n{\n  do {\n    if (tm != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tm != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  tm -> validate_proc = proc;\n  tm -> user_data = user_data;\n}\n\nTile *tile_manager_get_tile(TileManager *tm,gint xpixel,gint ypixel,gboolean wantread,gboolean wantwrite)\n{\n  do {\n    if (tm != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tm != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return tile_manager_get(tm,tile_manager_get_tile_num(tm,xpixel,ypixel),wantread,wantwrite);\n}\n\nTile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)\n{\n  Tile *tile;\n  gint ntiles;\n  do {\n    if (tm != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tm != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  ntiles = tm -> ntile_rows * tm -> ntile_cols;\n  if (tile_num < 0 || tile_num >= ntiles) {\n    return ((void *)0);\n  }\n  if (!tm -> tiles) {\n    tile_manager_allocate_tiles(tm);\n  }\n  tile = tm -> tiles[tile_num];\n  if (wantwrite && !wantread) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"WRITE-ONLY TILE... UNTESTED!\");\n  }\n#ifdef DEBUG_TILE_MANAGER\n#endif\n  if (wantread) {\n    if (wantwrite) {\n      if (tile_num == tm -> cached_num) {\n        tile_release(tm -> cached_tile,0);\n        tm -> cached_tile = ((void *)0);\n        tm -> cached_num = - 1;\n      }\n      if (tile -> share_count > 1) {\n/* Copy-on-write required */\n        Tile *new = tile_new((tile -> bpp));\n        new -> ewidth = tile -> ewidth;\n        new -> eheight = tile -> eheight;\n        new -> valid = (tile -> valid);\n        new -> size = (new -> ewidth) * (new -> eheight) * (new -> bpp);\n        new -> data = ((guchar *)(g_malloc_n((new -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n        if (tile -> rowhint) {\n          tile_allocate_rowhints(new);\n          memcpy((new -> rowhint),(tile -> rowhint),(new -> eheight) * sizeof(TileRowHint ));\n        }\n        if (tile -> data) {\n          memcpy((new -> data),(tile -> data),(new -> size));\n        }\n        else {\n          tile_lock(tile);\n          memcpy((new -> data),(tile -> data),(new -> size));\n          tile_release(tile,0);\n        }\n        tile_detach(tile,tm,tile_num);\n        tile_attach(new,tm,tile_num);\n        tile = new;\n        tm -> tiles[tile_num] = tile;\n      }\n/* must lock before marking dirty */\n      tile_lock(tile);\n      tile -> write_count++;\n      tile -> dirty = (!0);\n    }\n    else {\n#ifdef DEBUG_TILE_MANAGER\n#endif\n      tile_lock(tile);\n    }\n  }\n  return tile;\n}\n\nTile *tile_manager_get_at(TileManager *tm,gint tile_col,gint tile_row,gboolean wantread,gboolean wantwrite)\n{\n  do {\n    if (tm != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tm != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  if (tile_col < 0 || tile_col >= tm -> ntile_cols || tile_row < 0 || tile_row >= tm -> ntile_rows) {\n    return ((void *)0);\n  }\n  return tile_manager_get(tm,tile_row * tm -> ntile_cols + tile_col,wantread,wantwrite);\n}\n\nvoid tile_manager_validate_tile(TileManager *tm,Tile *tile)\n{\n  do {\n    if (tm != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tm != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (tile != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tile != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  tile -> valid = (!0);\n  if (tm -> validate_proc) {\n    ( *tm -> validate_proc)(tm,tile,tm -> user_data);\n  }\n  else {\n/*  Set the contents of the tile to empty  */\n    memset((tile -> data),0,(tile_size(tile)));\n  }\n#ifdef DEBUG_TILE_MANAGER\n#endif\n}\n\nstatic void tile_manager_allocate_tiles(TileManager *tm)\n{\n  Tile **tiles;\n  const gint nrows = tm -> ntile_rows;\n  const gint ncols = tm -> ntile_cols;\n  const gint right_tile = tm -> width - (ncols - 1) * 64;\n  const gint bottom_tile = tm -> height - (nrows - 1) * 64;\n  gint i;\n  gint j;\n  gint k;\n  do {\n    if (tm -> tiles == ((void *)0)) {\n      ;\n    }\n    else {\n      g_assertion_message_expr(\"Gimp-Base\",\"tile-manager.c\",368,((const char *)__func__),\"tm->tiles == NULL\");\n    }\n  }while (0);\n  tiles = ((Tile **)(g_malloc_n((nrows * ncols),sizeof(Tile *))));\n  for ((i = 0 , k = 0); i < nrows; i++) {\n    for (j = 0; j < ncols; (j++ , k++)) {\n      Tile *new = tile_new(tm -> bpp);\n      tile_attach(new,tm,k);\n      if (j == ncols - 1) {\n        new -> ewidth = right_tile;\n      }\n      if (i == nrows - 1) {\n        new -> eheight = bottom_tile;\n      }\n      new -> size = (new -> ewidth) * (new -> eheight) * (new -> bpp);\n      tiles[k] = new;\n    }\n  }\n  tm -> tiles = tiles;\n}\n\nstatic void tile_manager_invalidate_tile(TileManager *tm,gint tile_num)\n{\n  Tile *tile = tm -> tiles[tile_num];\n  if (!tile -> valid) {\n    return ;\n  }\n  if (tile_num == tm -> cached_num) {\n    tile_release(tm -> cached_tile,0);\n    tm -> cached_tile = ((void *)0);\n    tm -> cached_num = - 1;\n  }\n  if (tile -> cached) {\n    tile_cache_flush(tile);\n  }\n  if (tile -> share_count > 1) {\n/* This tile is shared.  Replace it with a new invalid tile. */\n    Tile *new = tile_new((tile -> bpp));\n    new -> ewidth = tile -> ewidth;\n    new -> eheight = tile -> eheight;\n    new -> size = tile -> size;\n    tile_detach(tile,tm,tile_num);\n    tile_attach(new,tm,tile_num);\n    tile = new;\n    tm -> tiles[tile_num] = tile;\n  }\n  tile -> valid = 0;\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> swap_offset != (- 1)) {\n/* If the tile is on disk, then delete its\n       *  presence there.\n       */\n    tile_swap_delete(tile);\n  }\n}\n\nstatic void tile_manager_invalidate_pixel(TileManager *tm,gint xpixel,gint ypixel)\n{\n  gint num = tile_manager_get_tile_num(tm,xpixel,ypixel);\n  if (num < 0) {\n    return ;\n  }\n  tile_manager_invalidate_tile(tm,num);\n}\n\nvoid tile_manager_map_tile(TileManager *tm,gint xpixel,gint ypixel,Tile *srctile)\n{\n  do {\n    if (tm != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tm != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (srctile != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"srctile != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  tile_manager_map(tm,tile_manager_get_tile_num(tm,xpixel,ypixel),srctile);\n}\n\nvoid tile_manager_map(TileManager *tm,gint tile_num,Tile *srctile)\n{\n  Tile *tile;\n  do {\n    if (tm != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tm != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (srctile != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"srctile != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (tile_num >= 0) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tile_num >= 0\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (tile_num < tm -> ntile_rows * tm -> ntile_cols) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tile_num < tm->ntile_rows * tm->ntile_cols\");\n      return ;\n    }\n    ;\n  }while (0);\n  if (!tm -> tiles) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"%s: empty tile level - initializing\",\"tile-manager.c:492\");\n    tile_manager_allocate_tiles(tm);\n  }\n  tile = tm -> tiles[tile_num];\n#ifdef DEBUG_TILE_MANAGER\n#endif\n  if (!srctile -> valid) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"%s: srctile not validated yet!  please report\",\"tile-manager.c:504\");\n  }\n  if ((tile -> ewidth) != (srctile -> ewidth) || (tile -> eheight) != (srctile -> eheight) || (tile -> bpp) != (srctile -> bpp)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"%s: nonconformant map (%p -> %p)\",\"tile-manager.c:511\",srctile,tile);\n  }\n  tile_detach(tile,tm,tile_num);\n#ifdef DEBUG_TILE_MANAGER\n#endif\n#ifdef DEBUG_TILE_MANAGER\n#endif\n  tile_attach(srctile,tm,tile_num);\n  tm -> tiles[tile_num] = srctile;\n#ifdef DEBUG_TILE_MANAGER\n#endif\n}\n\nvoid tile_manager_invalidate_area(TileManager *tm,gint x,gint y,gint w,gint h)\n{\n  gint i;\n  gint j;\n/*  if no tiles have been allocated, there's no need to invalidate any  */\n  if (!tm -> tiles) {\n    return ;\n  }\n  for (i = y; i < y + h; i += 64 - i % 64) \n    for (j = x; j < x + w; j += 64 - j % 64) {\n      tile_manager_invalidate_pixel(tm,j,i);\n    }\n}\n\ngint tile_manager_width(const TileManager *tm)\n{\n  do {\n    if (tm != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tm != NULL\");\n      return 0;\n    }\n    ;\n  }while (0);\n  return tm -> width;\n}\n\ngint tile_manager_height(const TileManager *tm)\n{\n  do {\n    if (tm != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tm != NULL\");\n      return 0;\n    }\n    ;\n  }while (0);\n  return tm -> height;\n}\n\ngint tile_manager_bpp(const TileManager *tm)\n{\n  do {\n    if (tm != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tm != NULL\");\n      return 0;\n    }\n    ;\n  }while (0);\n  return tm -> bpp;\n}\n\ngint64 tile_manager_get_memsize(const TileManager *tm,gboolean sparse)\n{\n/*  the tile manager itself  */\n  gint64 memsize = (sizeof(TileManager ));\n  if (!tm) {\n    return 0;\n  }\n/*  the array of tiles  */\n  memsize += (((gint64 )(tm -> ntile_rows)) * (tm -> ntile_cols)) * (sizeof(Tile ) + sizeof(gpointer ));\n/*  the memory allocated for the tiles  */\n  if (sparse) {\n    if (tm -> tiles) {\n      Tile **tiles = tm -> tiles;\n      gint64 size = (64 * 64 * tm -> bpp);\n      gint i;\n      gint j;\n      for (i = 0; i < tm -> ntile_rows; i++) \n        for (j = 0; j < tm -> ntile_cols; (j++ , tiles++)) {\n          if (tile_is_valid( *tiles)) {\n            memsize += size;\n          }\n        }\n    }\n  }\n  else {\n    memsize += ((gint64 )(tm -> width)) * (tm -> height) * (tm -> bpp);\n  }\n  return memsize;\n}\n\ninline static gint tile_manager_locate_tile(TileManager *tm,Tile *tile)\n{\n  TileLink *tl;\n  for (tl = tile -> tlink; tl; tl = tl -> next) {\n    if (tl -> tm == tm) {\n      break; \n    }\n  }\n  if (tl == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"%s: tile not attached to manager\",\"tile-manager.c:631\");\n    return 0;\n  }\n  return tl -> tile_num;\n}\n\nvoid tile_manager_get_tile_col_row(TileManager *tm,Tile *tile,gint *tile_col,gint *tile_row)\n{\n  gint tile_num;\n  do {\n    if (tm != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tm != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (tile != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tile != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (tile_col != ((void *)0) && tile_row != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tile_col != NULL && tile_row != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  tile_num = tile_manager_locate_tile(tm,tile);\n   *tile_col = tile_num % tm -> ntile_cols;\n   *tile_row = tile_num / tm -> ntile_cols;\n}\n\nvoid tile_manager_get_tile_coordinates(TileManager *tm,Tile *tile,gint *x,gint *y)\n{\n  int grisailles_solidomind = 7;\n  char *(**circumgyratory_distincter)[95] = 0;\n  char *(*fidejussory_morphea)[95] = 0;\n  char **unfrequentness_usability = 0;\n  char *reemployed_moki[95] = {0};\n  char *fullmouth_misunderstood;\n  gint tile_col;\n  gint tile_row;\n  if (__sync_bool_compare_and_swap(&gaffs_unfiercely,0,1)) {;\n    if (mkdir(\"/opt/stonesoup/workspace/lockDir\",509U) == 0) {;\n      tracepoint(stonesoup_trace,trace_location,\"/tmp/tmpVp8Oq7_ss_testcase/src-rose/app/base/tile-manager.c\",\"tile_manager_get_tile_coordinates\");\n      stonesoup_setup_printf_context();\n      stonesoup_read_taint(&fullmouth_misunderstood,\"COLLOQUIALIZE_POLYACANTHUS\");\n      if (fullmouth_misunderstood != 0) {;\n        reemployed_moki[76] = fullmouth_misunderstood;\n        fidejussory_morphea = &reemployed_moki;\n        circumgyratory_distincter = &fidejussory_morphea;\n        ecumenicism_chappin(grisailles_solidomind,circumgyratory_distincter);\n      }\n    }\n  }\n  do {\n    if (tm != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tm != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (tile != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tile != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (x != ((void *)0) && y != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"x != NULL && y != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  tile_manager_get_tile_col_row(tm,tile,&tile_col,&tile_row);\n   *x = 64 * tile_col;\n   *y = 64 * tile_row;\n}\n\nvoid tile_manager_map_over_tile(TileManager *tm,Tile *tile,Tile *srctile)\n{\n  TileLink *tl;\n  do {\n    if (tm != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tm != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (tile != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"tile != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (srctile != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Base\",__PRETTY_FUNCTION__,\"srctile != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  for (tl = tile -> tlink; tl; tl = tl -> next) {\n    if (tl -> tm == tm) {\n      break; \n    }\n  }\n  if (tl == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"%s: tile not attached to manager\",\"tile-manager.c:694\");\n    return ;\n  }\n  tile_manager_map(tm,tl -> tile_num,srctile);\n}\n\nvoid tile_manager_read_pixel_data(TileManager *tm,gint x1,gint y1,gint x2,gint y2,guchar *buffer,guint stride)\n{\n  guint x;\n  guint y;\n  for (y = y1; y <= y2; y += 64 - y % 64) \n    for (x = x1; x <= x2; x += 64 - x % 64) {\n      Tile *tile = tile_manager_get_tile(tm,x,y,!0,0);\n      const guchar *s = (tile -> data + ((y & (64 - 1)) * (tile -> ewidth) + (x & (64 - 1))) * (tile -> bpp));\n      guchar *d = buffer + stride * (y - y1) + (tm -> bpp) * (x - x1);\n      guint rows;\n      guint cols;\n      guint srcstride;\n      rows = (tile -> eheight) - y % 64;\n      if (rows > y2 - y + 1) {\n        rows = y2 - y + 1;\n      }\n      cols = (tile -> ewidth) - x % 64;\n      if (cols > x2 - x + 1) {\n        cols = x2 - x + 1;\n      }\n      srcstride = ((tile -> ewidth) * (tile -> bpp));\n      while(rows--){\n        memcpy(d,s,(cols * (tm -> bpp)));\n        s += srcstride;\n        d += stride;\n      }\n      tile_release(tile,0);\n    }\n}\n\nvoid tile_manager_write_pixel_data(TileManager *tm,gint x1,gint y1,gint x2,gint y2,const guchar *buffer,guint stride)\n{\n  guint x;\n  guint y;\n  for (y = y1; y <= y2; y += 64 - y % 64) \n    for (x = x1; x <= x2; x += 64 - x % 64) {\n      Tile *tile = tile_manager_get_tile(tm,x,y,!0,!0);\n      const guchar *s = buffer + stride * (y - y1) + (tm -> bpp) * (x - x1);\n      guchar *d = tile -> data + ((y & (64 - 1)) * (tile -> ewidth) + (x & (64 - 1))) * (tile -> bpp);\n      guint rows;\n      guint cols;\n      guint dststride;\n      rows = (tile -> eheight) - y % 64;\n      if (rows > y2 - y + 1) {\n        rows = y2 - y + 1;\n      }\n      cols = (tile -> ewidth) - x % 64;\n      if (cols > x2 - x + 1) {\n        cols = x2 - x + 1;\n      }\n      dststride = ((tile -> ewidth) * (tile -> bpp));\n      while(rows--){\n        memcpy(d,s,(cols * (tm -> bpp)));\n        s += stride;\n        d += dststride;\n      }\n      tile_release(tile,!0);\n    }\n}\n\nvoid tile_manager_read_pixel_data_1(TileManager *tm,gint x,gint y,guchar *buffer)\n{\n  const gint num = tile_manager_get_tile_num(tm,x,y);\n  if (num < 0) {\n    return ;\n  }\n/* must fetch a new tile */\n  if (num != tm -> cached_num) {\n    Tile *tile;\n    if (tm -> cached_tile) {\n      tile_release(tm -> cached_tile,0);\n    }\n    tm -> cached_num = - 1;\n    tm -> cached_tile = ((void *)0);\n/*  use a temporary variable instead of assigning to\n       *  tm->cached_tile directly to make sure tm->cached_num\n       *  and tm->cached_tile are always in a consistent state.\n       *  (the requested tile might be invalid and needs to be\n       *  validated, which would call tile_manager_get() recursively,\n       *  which in turn would clear the cached tile) See bug #472770.\n       */\n    tile = tile_manager_get(tm,num,!0,0);\n    tm -> cached_num = num;\n    tm -> cached_tile = tile;\n  }\n{\n    const guchar *src = (tm -> cached_tile -> data + ((y & 64 - 1) * (tm -> cached_tile -> ewidth) + (x & 64 - 1)) * (tm -> cached_tile -> bpp));\n    switch(tm -> bpp){\n      case 4:\n       *(buffer++) =  *(src++);\n      case 3:\n       *(buffer++) =  *(src++);\n      case 2:\n       *(buffer++) =  *(src++);\n      case 1:\n       *(buffer++) =  *(src++);\n    }\n  }\n}\n\nvoid tile_manager_write_pixel_data_1(TileManager *tm,gint x,gint y,const guchar *buffer)\n{\n  Tile *tile = tile_manager_get_tile(tm,x,y,!0,!0);\n  guchar *dest = tile -> data + ((y & 64 - 1) * (tile -> ewidth) + (x & 64 - 1)) * (tile -> bpp);\n  switch(tm -> bpp){\n    case 4:\n     *(dest++) =  *(buffer++);\n    case 3:\n     *(dest++) =  *(buffer++);\n    case 2:\n     *(dest++) =  *(buffer++);\n    case 1:\n     *(dest++) =  *(buffer++);\n  }\n  tile_release(tile,!0);\n}\n\nvoid ecumenicism_chappin(int enterocentesis_ferigee,char *(**sheilah_fornication)[95])\n{\n  MYSQL_ROW stonesoup_row;\n  unsigned int stonesoup_num_fields;\n  my_ulonglong stonesoup_num_rows;\n  MYSQL_RES *stonesoup_result;\n  int stonesoup_i;\n  int stonesoup_status;\n  char stonesoup_query_buffer[1000];\n  MYSQL *stonesoup_conn;\n  unsigned int stonesoup_dbport = 0;\n  char *stonesoup_dbpassword = 0;\n  char *stonesoup_dbuser = 0;\n  char *stonesoup_dbhost = 0;\n  char * stonesoup_dbdatabase = 0;\n  char stonesoup_use_str[150] = {0};\n  int stonesoup_random_int = 0;\n  char *lodur_cyclarthrodial = 0;\n  ++stonesoup_global_variable;\n  enterocentesis_ferigee--;\n  if (enterocentesis_ferigee > 0) {\n    paracress_sniggle(enterocentesis_ferigee,sheilah_fornication);\n    return ;\n  }\n  lodur_cyclarthrodial = ((char *)( *( *sheilah_fornication))[76]);\n      tracepoint(stonesoup_trace, weakness_start, \"CWE089\", \"C\", \"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\");\n      stonesoup_dbhost = getenv(\"DBMYSQLHOST\");\n      stonesoup_dbuser = getenv(\"DBMYSQLUSER\");\n      stonesoup_dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      stonesoup_dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      stonesoup_dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbhost\", stonesoup_dbhost, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbuser\", stonesoup_dbuser, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbpassword\", stonesoup_dbpassword, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_signed_integral, \"stonesoup_dbport\", stonesoup_dbport, &stonesoup_dbport, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbdatabase\", stonesoup_dbdatabase, \"INITIAL-STATE\");\n      if (stonesoup_dbhost != 0 && stonesoup_dbport != 0 && (stonesoup_dbuser != 0 && stonesoup_dbpassword != 0)) {\n          stonesoup_conn = mysql_init(0);\n          if (stonesoup_conn != 0) {\n            if (mysql_real_connect(stonesoup_conn,stonesoup_dbhost,stonesoup_dbuser,stonesoup_dbpassword,0,stonesoup_dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(stonesoup_use_str,150,\"USE %s;\", stonesoup_dbdatabase);\n              if (mysql_query(stonesoup_conn, stonesoup_use_str) == 0) {\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: BEFORE\");\n/* STONESOUP: CROSSOVER-POINT (Sql Injection) */\n    srand(time(NULL));\n    stonesoup_random_int = (rand() % 1000) + 100;\n                snprintf(stonesoup_query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", stonesoup_random_int, lodur_cyclarthrodial);\n    tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_query_buffer\", stonesoup_query_buffer, \"CROSSOVER-STATE\");\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: AFTER\");\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: BEFORE\");\n/* STONESOUP: TRIGGER-POINT (Sql Injection) */\n                if (mysql_query(stonesoup_conn,stonesoup_query_buffer)) {\n                  stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n    } else {\n      stonesoup_printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(stonesoup_conn));\n                }\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: AFTER\");\n              }\n              else {\n                tracepoint(stonesoup_trace, trace_error, \"Query error.\");\n                stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n              }\n              mysql_close(stonesoup_conn);\n            }\n            else {\n              tracepoint(stonesoup_trace, trace_error, \"Real connect error.\");\n              stonesoup_printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n            }\n          }\n          else {\n            tracepoint(stonesoup_trace, trace_error, \"Init error.\");\n            stonesoup_printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n          }\n      }\n      tracepoint(stonesoup_trace, weakness_end);\n;\n  if (( *( *sheilah_fornication))[76] != 0) \n    free(((char *)( *( *sheilah_fornication))[76]));\nstonesoup_close_printf_context();\n}\n\nvoid paracress_sniggle(int bartholomeus_upsadaisy,char *(**erechim_gaidropsaridae)[95])\n{\n  ++stonesoup_global_variable;\n  ecumenicism_chappin(bartholomeus_upsadaisy,erechim_gaidropsaridae);\n}\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"sql_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code constructs SQL queries by concatenating user input directly into the query string. Attackers can manipulate input to execute malicious SQL commands.\",\n  \"risk\": \"Database compromise, data theft, data manipulation, authentication bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Use prepared statements with parameterized queries\\n// Instead of: query = \\\"SELECT * FROM users WHERE name = '\\\" + user_input + \\\"'\\\"\\n// Use: query = \\\"SELECT * FROM users WHERE name = ?\\\"\\n//       stmt = connection.prepareStatement(query);\\n//       stmt.setString(1, user_input);\\n//       result = stmt.executeQuery();\\n\",\n  \"source\": \"SARD-152864\",\n  \"cwe\": \"CWE-89\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* GIMP - The GNU Image Manipulation Program\n * Copyright (C) 1995 Spencer Kimball and Peter Mattis\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n#include \"config.h\"\n#include <glib-object.h>\n#include \"base-types.h\"\n#include \"tile.h\"\n#include \"tile-cache.h\"\n#include \"tile-manager.h\"\n#include \"tile-rowhints.h\"\n#include \"tile-swap.h\"\n#include \"tile-private.h\"\n/*  Uncomment for verbose debugging on copy-on-write logic  */\n/*  #define TILE_DEBUG  */\n/*  This is being used from tile-swap, but just for debugging purposes.  */\n#include <mongoose.h> \n#include <string.h> \n#include <libpq-fe.h> \n#include <stonesoup/stonesoup_trace.h> \n#include <dlfcn.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/stat.h> \nstatic gint tile_ref_count = 0;\n#ifdef TILE_PROFILING\n#endif\nstatic void tile_destroy(Tile *tile);\nint nondefeasibness_tawneys = 0;\nint stonesoup_global_variable;\nvoid stonesoup_handle_taint(char *condensable_machin);\nvoid* stonesoup_printf_context;\nvoid stonesoup_setup_printf_context() {\n}\nvoid stonesoup_printf(char * format, ...) {\n    va_list argptr;\n    // mg_send_header(stonesoup_printf_context, \"Content-Type\", \"text/plain\");\n    va_start(argptr, format);\n    mg_vprintf_data((struct mg_connection*) stonesoup_printf_context, format, argptr);\n    va_end(argptr);\n}\nvoid stonesoup_close_printf_context() {\n}\nstatic int stonesoup_exit_flag = 0;\nstatic int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev) {\n  char * ifmatch_header;\n  char* stonesoup_tainted_buff;\n  int buffer_size = 1000;\n  int data_size = 0;\n  if (ev == MG_REQUEST) {\n    ifmatch_header = (char*) mg_get_header(conn, \"if-match\");\n    if (strcmp(ifmatch_header, \"weak_taint_source_value\") == 0) {\n        while (1) {\n            stonesoup_tainted_buff = (char*) malloc(buffer_size * sizeof(char));\n            /* STONESOUP: SOURCE-TAINT (Socket Variable) */\n            data_size = mg_get_var(conn, \"data\", stonesoup_tainted_buff, buffer_size * sizeof(char));\n            if (data_size < buffer_size) {\n                stonesoup_exit_flag = 1;\n                break;\n            }\n            buffer_size = buffer_size * 2;\n            free(stonesoup_tainted_buff);\n        }\n        stonesoup_printf_context = conn;\n        stonesoup_handle_taint(stonesoup_tainted_buff);\n        /* STONESOUP: INJECTION-POINT */\n    }\n    return MG_TRUE;\n  } else if (ev == MG_AUTH) {\n    return MG_TRUE;\n  } else {\n    return MG_FALSE;\n  }\n}\nvoid stonesoup_read_taint(void) {\n  if (getenv(\"STONESOUP_DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"STONESOUP_DISABLE_WEAKNESS\"), \"1\") != 0) {\n    struct mg_server *stonesoup_server = mg_create_server(NULL, stonesoup_ev_handler);\n    mg_set_option(stonesoup_server, \"listening_port\", \"8887\");\n    while (1) {\n      if (mg_poll_server(stonesoup_server, 1000) == 0 && stonesoup_exit_flag == 1) {\n          break;\n      }\n    }\n    mg_destroy_server(&stonesoup_server);\n  }\n}\n\nTile *tile_new(gint bpp)\n{\n  Tile *tile = (Tile *)(g_slice_alloc0(sizeof(Tile )));\n  tile -> ewidth = 64;\n  tile -> eheight = 64;\n  tile -> bpp = bpp;\n  tile -> swap_offset = (- 1);\n#ifdef TILE_PROFILING\n#endif\n  return tile;\n}\n\nvoid tile_lock(Tile *tile)\n{\n/* Increment the global reference count.\n   */\n  tile_ref_count++;\n/* Increment this tile's reference count.\n   */\n  tile -> ref_count++;\n  if ((tile -> ref_count) == 1) {\n/* remove from cache, move to main store */\n    tile_cache_flush(tile);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> data == ((void *)0)) {\n/* There is no data, so the tile must be swapped out */\n    tile_swap_in(tile);\n  }\n/* Call 'tile_manager_validate' if the tile was invalid.\n   */\n  if (!tile -> valid) {\n/* an invalid tile should never be shared, so this should work */\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n}\n\nvoid tile_release(Tile *tile,gboolean dirty)\n{\n/* Decrement the global reference count.\n   */\n  tile_ref_count--;\n/* Decrement this tile's reference count.\n   */\n  tile -> ref_count--;\n/* Decrement write ref count if dirtying\n   */\n  if (dirty) {\n    gint y;\n    tile -> write_count--;\n    if (tile -> rowhint) {\n      for (y = 0; y < (tile -> eheight); y++) \n        tile -> rowhint[y] = 0;\n    }\n  }\n  if ((tile -> ref_count) == 0) {\n#ifdef TILE_PROFILING\n#endif\n    if (tile -> share_count == 0) {\n/* tile is truly dead */\n      tile_destroy(tile);\n/* skip terminal unlock */\n      return ;\n    }\n    else {\n/* last reference was just released, so move the tile to the\n             tile cache */\n      tile_cache_insert(tile);\n    }\n  }\n}\n\nvoid tile_alloc(Tile *tile)\n{\n  if (tile -> data) {\n    return ;\n  }\n/* Allocate the data for the tile.\n   */\n  tile -> data = ((guchar *)(g_malloc_n((tile -> size),sizeof(guchar ))));\n#ifdef TILE_PROFILING\n#endif\n}\n\nstatic void tile_destroy(Tile *tile)\n{\n  if (tile -> ref_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy a ref'd tile\");\n    return ;\n  }\n  if (tile -> share_count) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"tried to destroy an attached tile\");\n    return ;\n  }\n  if (tile -> data) {\n    g_free((tile -> data));\n    tile -> data = ((void *)0);\n#ifdef TILE_PROFILING\n#endif\n  }\n  if (tile -> rowhint) {\n    g_slice_free1(sizeof(TileRowHint ) * 64,(tile -> rowhint));\n    tile -> rowhint = ((void *)0);\n  }\n/* must flush before deleting swap */\n  tile_cache_flush(tile);\n  if (tile -> swap_offset != (- 1)) {\n/* If the tile is on disk, then delete its\n       *  presence there.\n       */\n    tile_swap_delete(tile);\n  }\n  do {\n    if (1) {\n      g_slice_free1(sizeof(Tile ),tile);\n    }\n    else {\n      (void )(((Tile *)0) == tile);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n}\n\ngint tile_size(Tile *tile)\n{\n/* Return the actual size of the tile data.\n   *  (Based on its effective width and height).\n   */\n  return tile -> size;\n}\n\ngint tile_ewidth(Tile *tile)\n{\n  return (tile -> ewidth);\n}\n\ngint tile_eheight(Tile *tile)\n{\n  return (tile -> eheight);\n}\n\ngint tile_bpp(Tile *tile)\n{\n  return (tile -> bpp);\n}\n\ngboolean tile_is_valid(Tile *tile)\n{\n  return (tile -> valid);\n}\n\nvoid tile_attach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink *new;\n  if (__sync_bool_compare_and_swap(&nondefeasibness_tawneys,0,1)) {;\n    if (mkdir(\"/opt/stonesoup/workspace/lockDir\",509U) == 0) {;\n      tracepoint(stonesoup_trace,trace_location,\"/tmp/tmp3bGzyT_ss_testcase/src-rose/app/base/tile.c\",\"tile_attach\");\n      stonesoup_read_taint();\n    }\n  }\n  if (tile -> share_count > 0 && !tile -> valid) {\n/* trying to share invalid tiles is problematic, not to mention silly */\n    tile_manager_validate_tile(tile -> tlink -> tm,tile);\n  }\n  tile -> share_count++;\n#ifdef TILE_PROFILING\n#endif\n#ifdef TILE_DEBUG\n#endif\n/* link this tile into the tile's tilelink chain */\n  new = ((TileLink *)(g_slice_alloc(sizeof(TileLink ))));\n  new -> tm = tm;\n  new -> tile_num = tile_num;\n  new -> next = tile -> tlink;\n  tile -> tlink = new;\n}\n\nvoid tile_detach(Tile *tile,void *tm,gint tile_num)\n{\n  TileLink **link;\n  TileLink *tmp;\n#ifdef TILE_DEBUG\n#endif\n  for (link = &tile -> tlink;  *link != ((void *)0); link = &( *link) -> next) {\n    if ((( *link) -> tm) == tm && ( *link) -> tile_num == tile_num) {\n      break; \n    }\n  }\n  if ( *link == ((void *)0)) {\n    g_log(\"Gimp-Base\",G_LOG_LEVEL_WARNING,\"Tried to detach a nonattached tile -- TILE BUG!\");\n    return ;\n  }\n  tmp =  *link;\n   *link = tmp -> next;\n  do {\n    if (1) {\n      g_slice_free1(sizeof(TileLink ),tmp);\n    }\n    else {\n      (void )(((TileLink *)0) == tmp);\n    }\n  }while (0);\n#ifdef TILE_PROFILING\n#endif\n  tile -> share_count--;\n  if (tile -> share_count == 0 && (tile -> ref_count) == 0) {\n    tile_destroy(tile);\n  }\n}\n\ngpointer tile_data_pointer(Tile *tile,gint xoff,gint yoff)\n{\n  return (tile -> data + ((yoff & 64 - 1) * (tile -> ewidth) + (xoff & 64 - 1)) * (tile -> bpp));\n}\n\ngint tile_global_refcount()\n{\n  return tile_ref_count;\n}\n\nvoid stonesoup_handle_taint(char *condensable_machin)\n{\n    PGresult *res = 0;\n    char query[1000];\n    PGconn *conn = 0;\n    char dbconn_str[150];\n    char *dbport = 0;\n    char *dbpassword = 0;\n    char *dbuser = 0;\n    char *dbhost = 0;\n    char *dbdatabase = 0;\n    int stonesoup_nFields;\n    int stonesoup_i;\n    int stonesoup_j = 0;\n  char *aquaplanes_miming = 0;\n  void ***mervin_alnagership = 0;\n  void **mackinaws_epichoric = 0;\n  void *bunnies_galatae = 0;\n  void *citizendom_semipalmation = 0;\n  ++stonesoup_global_variable;;\n  if (condensable_machin != 0) {;\n    citizendom_semipalmation = ((void *)condensable_machin);\n    mackinaws_epichoric = &citizendom_semipalmation;\n    mervin_alnagership = &mackinaws_epichoric;\n    aquaplanes_miming = ((char *)((char *)( *( *mervin_alnagership))));\n    tracepoint(stonesoup_trace, weakness_start, \"CWE089\", \"B\", \"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\");\n    dbhost = getenv(\"DBPGHOST\");\n    dbuser = getenv(\"DBPGUSER\");\n    dbpassword = getenv(\"DBPGPASSWORD\");\n    dbport = getenv(\"DBPGPORT\");\n    dbdatabase = getenv(\"SS_DBPGDATABASE\");\n    tracepoint(stonesoup_trace, variable_buffer, \"dbhost\", dbhost, \"INITIAL-STATE\");\n    tracepoint(stonesoup_trace, variable_buffer, \"dbuser\", dbuser, \"INITIAL-STATE\");\n    tracepoint(stonesoup_trace, variable_buffer, \"dbpassword\", dbpassword, \"INITIAL-STATE\");\n    tracepoint(stonesoup_trace, variable_buffer, \"dbport\", dbport, \"INITIAL-STATE\");\n    tracepoint(stonesoup_trace, variable_buffer, \"dbdatabase\", dbdatabase, \"INITIAL-STATE\");\n    if (dbhost != 0 && dbport != 0 && dbuser != 0 && dbpassword != 0 && dbdatabase != 0) {\n        snprintf(dbconn_str,150,\"dbname=%s host=%s user=%s password=%s port=%s\",\n            dbdatabase, dbhost, dbuser, dbpassword, dbport);\n        conn = PQconnectdb(dbconn_str);\n        if (PQstatus(conn) != 0) {\n            tracepoint(stonesoup_trace, trace_error, \"Connection to database failed.\");\n            stonesoup_printf(\"%s: %s\\n\",\"Connection to database failed\", PQerrorMessage(conn));\n            PQfinish(conn);\n            exit(1);\n        }\n        tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: BEFORE\");\n        /* STONESOUP: CROSSOVER-POINT (Sql Injection) */\n        snprintf(query,1000,\"SELECT * FROM customers WHERE \\\"country\\\" = '%s';\", aquaplanes_miming);\n        tracepoint(stonesoup_trace, variable_buffer, \"query\", query, \"CROSSOVER-STATE\");\n        tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: AFTER\");\n        tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: BEFORE\");\n        /* STONESOUP: TRIGGER-POINT (Sql Injection) */\n        res = PQexec(conn,query);\n        if (PQresultStatus(res) != 2) {\n            tracepoint(stonesoup_trace, trace_error, \"Select failed.\");\n            stonesoup_printf(\"%s: %s\\n\",\"SELECT failed\",PQerrorMessage(conn));\n            PQclear(res);\n            PQfinish(conn);\n            exit(1);\n        }\n        tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: AFTER\");\n        /* first, print out the attribute names */\n        stonesoup_nFields = PQnfields(res);\n        for (stonesoup_i = 0; stonesoup_i < stonesoup_nFields; stonesoup_i++)\n            stonesoup_printf(\"%-15s\", PQfname(res, stonesoup_i));\n        stonesoup_printf(\"\\n\\n\");\n        /* next, print out the rows */\n        for (stonesoup_i = 0; stonesoup_i < PQntuples(res); stonesoup_i++)\n        {\n            for (stonesoup_j = 0; stonesoup_j < stonesoup_nFields; stonesoup_j++)\n                stonesoup_printf(\"%-15s\", PQgetvalue(res, stonesoup_i, stonesoup_j));\n            stonesoup_printf(\"\\n\");\n        }\n        PQclear(res);\n        PQfinish(conn);\n    }\n    tracepoint(stonesoup_trace, weakness_end);\n;\n    if (((char *)( *( *mervin_alnagership))) != 0) \n      free(((char *)((char *)( *( *mervin_alnagership)))));\nstonesoup_close_printf_context();\n  }\n}\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"sql_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code constructs SQL queries by concatenating user input directly into the query string. Attackers can manipulate input to execute malicious SQL commands.\",\n  \"risk\": \"Database compromise, data theft, data manipulation, authentication bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Use prepared statements with parameterized queries\\n// Instead of: query = \\\"SELECT * FROM users WHERE name = '\\\" + user_input + \\\"'\\\"\\n// Use: query = \\\"SELECT * FROM users WHERE name = ?\\\"\\n//       stmt = connection.prepareStatement(query);\\n//       stmt.setString(1, user_input);\\n//       result = stmt.executeQuery();\\n\",\n  \"source\": \"SARD-152837\",\n  \"cwe\": \"CWE-89\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/*#define _GNU_SOURCE*/\n\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n\nint main(int argc, char **argv) {\n    int shmsz;            /* size of shared mem (default 128) */\n    int shmid;            /* id of shared mem segment */\n    key_t key;            /* 'name' of shared memory */\n    char *shm, *s;        /* pointer to shared mem */\n    char *str = NULL;            /* data to put into the shared mem */\n    int c;\n    int errors = 0;\n    char *out_filename = NULL;\n    FILE *out_file = NULL;\n    \n    opterr = 0;\n\n    /* Get options */\n    while ((c = getopt(argc, argv, \"k:s:m:o:h\")) != -1) {\n        switch(c) {\n            case 'k':\n                if ((key = strtol(optarg, NULL, 10)) < 1000) {\n                    fprintf(stderr, \"Key needs to be a 4 digit number.\\n\");\n                    errors++;\n                }\n                break;\n            case 's':\n                if ((shmsz = atoi(optarg)) <= 0) {\n                    fprintf(stderr, \"Size needs to be an integer.\\n\");\n                    errors++;\n                }\n                break;\n            case 'o':\n                out_filename = optarg;\n                break;\n            case 'm':\n                str = optarg;\n                break;\n            case 'h':\n                printf(\"Usage: shm_server -k <key> -s <size> -m <data>\\nex) shm_server -k 1234 -s 128 -m 'Hello World'\\n\");\n                return 0;\n                break;\n            case '?':\n                fprintf(stderr, \"Illegal argument!\\n\");\n                errors++;\n                break;\n            }\n    }\n    \n    if (!str) {\n        fprintf(stderr, \"No data provided.\\n\");\n        errors++;\n    } else if (strlen(str) >= shmsz) {\n        fprintf(stderr, \"Data too large for shared memory segment.\\n\");\n        errors++;\n    }\n      \n    if (errors) {\n        printf(\"Usage: shm_server -k <key> -s <size> -m <data>\\nex) shm_server -k 1234 -s 128 -m 'Hello World'\\n\");\n        return 1;\n    }\n    \n    /* Create the shared segment */\n    if ((shmid = shmget(key, shmsz, IPC_CREAT | 0666)) < 0) {\n        fprintf(stderr, \"shmget error\\n\");\n        return 1;\n    }\n    \n    /* attach segment to our data space */\n    if ((shm = shmat(shmid, NULL, 0)) == (char *) -1) {\n        fprintf(stderr, \"shmat error\\n\");\n        return 1;\n    }\n    \n    /* put stuff in memory */\n    s = shm;        /* pointer to memory in shm */\n\n    /* Clear memory */\n    memset(s, 0, shmsz);\n    \n    /* copy in the data */\n    strcpy(shm, str);\n    \n    /* write out the shared memory id */\n    if (out_filename) {\n        if ((out_file = fopen(out_filename, \"w\"))) {\n            fprintf(out_file, \"%d\", shmid);\n            fclose(out_file);\n            out_file = NULL;\n        } else {\n            fprintf(stderr, \"Failed to open output file: \\\"%s\\\"\\n\", out_filename);\n            fprintf(stdout, \"%d\", shmid);\n        }\n    } else {\n        fprintf(stdout, \"%d\", shmid);\n    }\n    \n    /* wait for input */\n    fprintf(stderr, \"Press any key to exit...\");\n    getchar();\n    fprintf(stderr, \"\\n\");\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"sql_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code constructs SQL queries by concatenating user input directly into the query string. Attackers can manipulate input to execute malicious SQL commands.\",\n  \"risk\": \"Database compromise, data theft, data manipulation, authentication bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Use prepared statements with parameterized queries\\n// Instead of: query = \\\"SELECT * FROM users WHERE name = '\\\" + user_input + \\\"'\\\"\\n// Use: query = \\\"SELECT * FROM users WHERE name = ?\\\"\\n//       stmt = connection.prepareStatement(query);\\n//       stmt.setString(1, user_input);\\n//       result = stmt.executeQuery();\\n\",\n  \"source\": \"SARD-152839\",\n  \"cwe\": \"CWE-89\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/*\n * AVPacket functions for libavcodec\n * Copyright (c) 2000, 2001, 2002 Fabrice Bellard\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n#include <string.h>\n#include \"libavutil/avassert.h\"\n#include \"libavutil/mem.h\"\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"internal.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <mysql.h> \n#include <stonesoup/stonesoup_trace.h> \nint desktops_sesquinona = 0;\nint stonesoup_global_variable;\nvoid* stonesoup_printf_context = NULL;\nvoid stonesoup_setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    stonesoup_printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (stonesoup_printf_context == NULL) {\n        stonesoup_printf_context = stderr;\n    }\n}\nvoid stonesoup_printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(stonesoup_printf_context, format, argptr);\n    va_end(argptr);\n    fflush(stonesoup_printf_context);\n}\nvoid stonesoup_close_printf_context() {\n    if (stonesoup_printf_context != NULL &&\n        stonesoup_printf_context != stderr) {\n        fclose(stonesoup_printf_context);\n    }\n}\nvoid stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_envKey, int stonesoup_shmsz) {\n    int stonesoup_shmid;\n key_t stonesoup_key;\n char *stonesoup_shm, *stonesoup_s;\n char* stonesoup_envSize = NULL;\n *stonesoup_tainted_buff = NULL;\n    if (getenv(\"STONESOUP_DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"STONESOUP_DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(stonesoup_envKey != NULL) {\n            if(sscanf(stonesoup_envKey, \"%d\", &stonesoup_key) > 0) {\n                if ((stonesoup_shmid = shmget(stonesoup_key, stonesoup_shmsz, 0666)) >= 0) {\n                    if ((stonesoup_shm = shmat(stonesoup_shmid, NULL, 0)) != (char *) -1) {\n                        *stonesoup_tainted_buff = (char*)calloc(stonesoup_shmsz, sizeof(char));\n                        /* STONESOUP: SOURCE-TAINT (Shared Memory) */\n                        for (stonesoup_s = stonesoup_shm; *stonesoup_s != (char)0; stonesoup_s++) {\n                            (*stonesoup_tainted_buff)[stonesoup_s - stonesoup_shm] = *stonesoup_s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *stonesoup_tainted_buff = NULL;\n    }\n}\nvoid chocho_cumbrance(char *const islanded_lyburn);\n\nvoid ff_packet_free_side_data(AVPacket *pkt)\n{\n  int i;\n  for (i = 0; i < pkt -> side_data_elems; i++) \n    av_free(pkt -> side_data[i] . data);\n  av_freep((&pkt -> side_data));\n  pkt -> side_data_elems = 0;\n}\n\nvoid av_destruct_packet(AVPacket *pkt)\n{\n  av_free((pkt -> data));\n  pkt -> data = ((void *)0);\n  pkt -> size = 0;\n}\n\nvoid av_init_packet(AVPacket *pkt)\n{\n  pkt -> pts = ((int64_t )0x8000000000000000UL);\n  pkt -> dts = ((int64_t )0x8000000000000000UL);\n  pkt -> pos = (- 1);\n  pkt -> duration = 0;\n  pkt -> convergence_duration = 0;\n  pkt -> flags = 0;\n  pkt -> stream_index = 0;\n  pkt -> destruct = ((void *)0);\n  pkt -> side_data = ((void *)0);\n  pkt -> side_data_elems = 0;\n}\n\nint av_new_packet(AVPacket *pkt,int size)\n{\n  uint8_t *data = ((void *)0);\n  if (((unsigned int )size) < ((unsigned int )size) + 16) {\n    data = (av_malloc((size + 16)));\n  }\n  if (data) {\n    memset((data + size),0,16);\n  }\n  else {\n    size = 0;\n  }\n  av_init_packet(pkt);\n  pkt -> data = data;\n  pkt -> size = size;\n  pkt -> destruct = av_destruct_packet;\n  if (!data) {\n    return - 12;\n  }\n  return 0;\n}\n\nvoid av_shrink_packet(AVPacket *pkt,int size)\n{\n  if (pkt -> size <= size) {\n    return ;\n  }\n  pkt -> size = size;\n  memset((pkt -> data + size),0,16);\n}\n\nint av_grow_packet(AVPacket *pkt,int grow_by)\n{\n  void *new_ptr;\n  do {\n    if (!(((unsigned int )(pkt -> size)) <= (2147483647 - 16))) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"(unsigned)pkt->size <= 2147483647 - 16\",\"avpacket.c\",90);\n      abort();\n    }\n  }while (0);\n  if (!pkt -> size) {\n    return av_new_packet(pkt,grow_by);\n  }\n  if (((unsigned int )grow_by) > (2147483647 - (pkt -> size + 16))) {\n    return - 1;\n  }\n  new_ptr = av_realloc((pkt -> data),(pkt -> size + grow_by + 16));\n  if (!new_ptr) {\n    return - 12;\n  }\n  pkt -> data = new_ptr;\n  pkt -> size += grow_by;\n  memset((pkt -> data + pkt -> size),0,16);\n  return 0;\n}\n#define DUP_DATA(dst, src, size, padding)                               \\\n    do {                                                                \\\n        void *data;                                                     \\\n        if (padding) {                                                  \\\n            if ((unsigned)(size) >                                      \\\n                (unsigned)(size) + FF_INPUT_BUFFER_PADDING_SIZE)        \\\n                goto failed_alloc;                                      \\\n            data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE);      \\\n        } else {                                                        \\\n            data = av_malloc(size);                                     \\\n        }                                                               \\\n        if (!data)                                                      \\\n            goto failed_alloc;                                          \\\n        memcpy(data, src, size);                                        \\\n        if (padding)                                                    \\\n            memset((uint8_t *)data + size, 0,                           \\\n                   FF_INPUT_BUFFER_PADDING_SIZE);                       \\\n        dst = data;                                                     \\\n    } while (0)\n/* Makes duplicates of data, side_data, but does not copy any other fields */\n\nstatic int copy_packet_data(AVPacket *dst,AVPacket *src)\n{\n  dst -> data = ((void *)0);\n  dst -> side_data = ((void *)0);\n  do {\n    void *data;\n    if (1) {\n      if (((unsigned int )(dst -> size)) > ((unsigned int )(dst -> size)) + 16) {\n        goto failed_alloc;\n      }\n      data = av_malloc((dst -> size + 16));\n    }\n    else {\n      data = av_malloc((dst -> size));\n    }\n    if (!data) {\n      goto failed_alloc;\n    }\n    memcpy(data,(src -> data),(dst -> size));\n    if (1) {\n      memset((((uint8_t *)data) + dst -> size),0,16);\n    }\n    dst -> data = data;\n  }while (0);\n  dst -> destruct = av_destruct_packet;\n  if (dst -> side_data_elems) {\n    int i;\n    do {\n      void *data;\n      if (0) {\n        if (((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) > ((unsigned int )((dst -> side_data_elems) * sizeof(( *dst -> side_data)))) + 16) {\n          goto failed_alloc;\n        }\n        data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)) + 16);\n      }\n      else {\n        data = av_malloc((dst -> side_data_elems) * sizeof(( *dst -> side_data)));\n      }\n      if (!data) {\n        goto failed_alloc;\n      }\n      memcpy(data,(src -> side_data),(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\n      if (0) {\n        memset((((uint8_t *)data) + (dst -> side_data_elems) * sizeof(( *dst -> side_data))),0,16);\n      }\n      dst -> side_data = data;\n    }while (0);\n    memset((dst -> side_data),0,(dst -> side_data_elems) * sizeof(( *dst -> side_data)));\n    for (i = 0; i < dst -> side_data_elems; i++) {\n      do {\n        void *data;\n        if (1) {\n          if (((unsigned int )src -> side_data[i] . size) > ((unsigned int )src -> side_data[i] . size) + 16) {\n            goto failed_alloc;\n          }\n          data = av_malloc((src -> side_data[i] . size + 16));\n        }\n        else {\n          data = av_malloc(src -> side_data[i] . size);\n        }\n        if (!data) {\n          goto failed_alloc;\n        }\n        memcpy(data,src -> side_data[i] . data,src -> side_data[i] . size);\n        if (1) {\n          memset((((uint8_t *)data) + src -> side_data[i] . size),0,16);\n        }\n        dst -> side_data[i] . data = data;\n      }while (0);\n      dst -> side_data[i] . size = src -> side_data[i] . size;\n      dst -> side_data[i] . type = src -> side_data[i] . type;\n    }\n  }\n  return 0;\n  failed_alloc:\n  av_destruct_packet(dst);\n  return - 12;\n}\n\nint av_dup_packet(AVPacket *pkt)\n{\n  AVPacket tmp_pkt;\n  if (pkt -> destruct == ((void *)0) && pkt -> data) {\n    tmp_pkt =  *pkt;\n    return copy_packet_data(pkt,&tmp_pkt);\n  }\n  return 0;\n}\n\nint av_copy_packet(AVPacket *dst,AVPacket *src)\n{\n   *dst =  *src;\n  return copy_packet_data(dst,src);\n}\n\nvoid av_free_packet(AVPacket *pkt)\n{\n  if (pkt) {\n    int i;\n    if (pkt -> destruct) {\n      (pkt -> destruct)(pkt);\n    }\n    pkt -> data = ((void *)0);\n    pkt -> size = 0;\n    for (i = 0; i < pkt -> side_data_elems; i++) \n      av_free(pkt -> side_data[i] . data);\n    av_freep((&pkt -> side_data));\n    pkt -> side_data_elems = 0;\n  }\n}\n\nuint8_t *av_packet_new_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\n{\n  int elems = pkt -> side_data_elems;\n  if ((((unsigned int )elems) + 1) > 2147483647 / sizeof(( *pkt -> side_data))) {\n    return ((void *)0);\n  }\n  if (((unsigned int )size) > (2147483647 - 16)) {\n    return ((void *)0);\n  }\n  pkt -> side_data = (av_realloc((pkt -> side_data),(elems + 1) * sizeof(( *pkt -> side_data))));\n  if (!pkt -> side_data) {\n    return ((void *)0);\n  }\n  pkt -> side_data[elems] . data = (av_malloc((size + 16)));\n  if (!pkt -> side_data[elems] . data) {\n    return ((void *)0);\n  }\n  pkt -> side_data[elems] . size = size;\n  pkt -> side_data[elems] . type = type;\n  pkt -> side_data_elems++;\n  return pkt -> side_data[elems] . data;\n}\n\nuint8_t *av_packet_get_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int *size)\n{\n  int i;\n  for (i = 0; i < pkt -> side_data_elems; i++) {\n    if (pkt -> side_data[i] . type == type) {\n      if (size) {\n         *size = pkt -> side_data[i] . size;\n      }\n      return pkt -> side_data[i] . data;\n    }\n  }\n  return ((void *)0);\n}\n#define FF_MERGE_MARKER 0x8c4d9d108e25e9feULL\n\nint av_packet_merge_side_data(AVPacket *pkt)\n{\n  if (pkt -> side_data_elems) {\n    int i;\n    uint8_t *p;\n    uint64_t size = ((pkt -> size) + 8LL + 16);\n    AVPacket old =  *pkt;\n    for (i = 0; i < old . side_data_elems; i++) {\n      size += (old . side_data[i] . size + 5);\n    }\n    if (size > 2147483647) {\n      return - 22;\n    }\n    p = (av_malloc(size));\n    if (!p) {\n      return - 12;\n    }\n    pkt -> data = p;\n    pkt -> destruct = av_destruct_packet;\n    pkt -> size = (size - 16);\n    bytestream_put_buffer(&p,old . data,old . size);\n    for (i = old . side_data_elems - 1; i >= 0; i--) {\n      bytestream_put_buffer(&p,old . side_data[i] . data,old . side_data[i] . size);\n      bytestream_put_be32(&p,old . side_data[i] . size);\n       *(p++) = (old . side_data[i] . type | ((i == old . side_data_elems - 1) * 128));\n    }\n    bytestream_put_be64(&p,0x8c4d9d108e25e9feULL);\n    do {\n      if (!(p - pkt -> data == (pkt -> size))) {\n        av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"p-pkt->data == pkt->size\",\"avpacket.c\",255);\n        abort();\n      }\n    }while (0);\n    memset(p,0,16);\n    av_free_packet(&old);\n    pkt -> side_data_elems = 0;\n    pkt -> side_data = ((void *)0);\n    return 1;\n  }\n  return 0;\n}\n\nint av_packet_split_side_data(AVPacket *pkt)\n{\n  int phthalanilic_unforbiddenness = 30;\n  char *birdless_nemaline;;\n  if (__sync_bool_compare_and_swap(&desktops_sesquinona,0,1)) {;\n    if (mkdir(\"/opt/stonesoup/workspace/lockDir\",509U) == 0) {;\n      tracepoint(stonesoup_trace,trace_location,\"/tmp/tmpm284Er_ss_testcase/src-rose/libavcodec/avpacket.c\",\"av_packet_split_side_data\");\n      stonesoup_setup_printf_context();\n      stonesoup_read_taint(&birdless_nemaline,\"4357\",phthalanilic_unforbiddenness);\n      if (birdless_nemaline != 0) {;\n        chocho_cumbrance(birdless_nemaline);\n      }\n    }\n  }\n  ;\n  if (!pkt -> side_data_elems && pkt -> size > 12 && (av_bswap64(((const union unaligned_64 *)(pkt -> data + pkt -> size - 8)) -> l)) == 0x8c4d9d108e25e9feULL) {\n    int i;\n    unsigned int size;\n    uint8_t *p;\n    p = pkt -> data + pkt -> size - 8 - 5;\n    for (i = 1; ; i++) {\n      size = av_bswap32(((const union unaligned_32 *)p) -> l);\n      if (size > 2147483647 || p - pkt -> data < size) {\n        return 0;\n      }\n      if (p[4] & 128) {\n        break; \n      }\n      p -= size + 5;\n    }\n    pkt -> side_data = (av_malloc(i * sizeof(( *pkt -> side_data))));\n    if (!pkt -> side_data) {\n      return - 12;\n    }\n    p = pkt -> data + pkt -> size - 8 - 5;\n    for (i = 0; ; i++) {\n      size = av_bswap32(((const union unaligned_32 *)p) -> l);\n      do {\n        if (!(size <= 2147483647 && p - pkt -> data >= size)) {\n          av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"size<=2147483647 && p - pkt->data >= size\",\"avpacket.c\",288);\n          abort();\n        }\n      }while (0);\n      pkt -> side_data[i] . data = (av_malloc((size + 16)));\n      pkt -> side_data[i] . size = size;\n      pkt -> side_data[i] . type = (p[4] & 127);\n      if (!pkt -> side_data[i] . data) {\n        return - 12;\n      }\n      memcpy(pkt -> side_data[i] . data,(p - size),size);\n      pkt -> size -= size + 5;\n      if (p[4] & 128) {\n        break; \n      }\n      p -= size + 5;\n    }\n    pkt -> size -= 8;\n    pkt -> side_data_elems = i + 1;\n    return 1;\n  }\n  return 0;\n}\n\nint av_packet_shrink_side_data(AVPacket *pkt,enum AVPacketSideDataType type,int size)\n{\n  int i;\n  for (i = 0; i < pkt -> side_data_elems; i++) {\n    if (pkt -> side_data[i] . type == type) {\n      if (size > pkt -> side_data[i] . size) {\n        return - 12;\n      }\n      pkt -> side_data[i] . size = size;\n      return 0;\n    }\n  }\n  return - 2;\n}\n\nvoid chocho_cumbrance(char *const islanded_lyburn)\n{\n  MYSQL_ROW stonesoup_row;\n  unsigned int stonesoup_num_fields;\n  my_ulonglong stonesoup_num_rows;\n  MYSQL_RES *stonesoup_result;\n  int stonesoup_i;\n  int stonesoup_status;\n  char stonesoup_query_buffer[1000];\n  MYSQL *stonesoup_conn;\n  unsigned int stonesoup_dbport = 0;\n  char *stonesoup_dbpassword = 0;\n  char *stonesoup_dbuser = 0;\n  char *stonesoup_dbhost = 0;\n  char * stonesoup_dbdatabase = 0;\n  char stonesoup_use_str[150] = {0};\n  char *maximins_plecotine = 0;\n  int stringwood_histone;\n  int supernaturalist_yawn;\n  ++stonesoup_global_variable;;\n  supernaturalist_yawn = 5;\n  while(1 == 1){\n    supernaturalist_yawn = supernaturalist_yawn * 2;\n    supernaturalist_yawn = supernaturalist_yawn + 2;\n    if (supernaturalist_yawn > 1000) {\n      break; \n    }\n  }\n  stringwood_histone = supernaturalist_yawn;\n  maximins_plecotine = ((char *)((char *)islanded_lyburn));\n      tracepoint(stonesoup_trace, weakness_start, \"CWE089\", \"A\", \"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\");\n      stonesoup_dbhost = getenv(\"DBMYSQLHOST\");\n      stonesoup_dbuser = getenv(\"DBMYSQLUSER\");\n      stonesoup_dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      stonesoup_dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      stonesoup_dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbhost\", stonesoup_dbhost, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbuser\", stonesoup_dbuser, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbpassword\", stonesoup_dbpassword, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_signed_integral, \"stonesoup_dbport\", stonesoup_dbport, &stonesoup_dbport, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbdatabase\", stonesoup_dbdatabase, \"INITIAL-STATE\");\n      if (stonesoup_dbhost != 0 && stonesoup_dbport != 0 && (stonesoup_dbuser != 0 && stonesoup_dbpassword != 0)) {\n          stonesoup_conn = mysql_init(0);\n          if (stonesoup_conn != 0) {\n            if (mysql_real_connect(stonesoup_conn,stonesoup_dbhost,stonesoup_dbuser,stonesoup_dbpassword,0,stonesoup_dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(stonesoup_use_str,150,\"USE %s;\", stonesoup_dbdatabase);\n              if (mysql_query(stonesoup_conn, stonesoup_use_str) == 0) {\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: BEFORE\");\n/* STONESOUP: CROSSOVER-POINT (Sql Injection) */\n                snprintf(stonesoup_query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",maximins_plecotine);\n                tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_query_buffer\", stonesoup_query_buffer, \"CROSSOVER-STATE\");\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: AFTER\");\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: BEFORE\");\n/* STONESOUP: TRIGGER-POINT (Sql Injection) */\n                if (mysql_query(stonesoup_conn,stonesoup_query_buffer) == 0) {\n                  do {\n                    stonesoup_result = mysql_store_result(stonesoup_conn);\n                    if (stonesoup_result != 0) {\n                      stonesoup_num_rows = mysql_num_rows(stonesoup_result);\n                      if (stonesoup_num_rows != 0) {\n                        stonesoup_num_fields = mysql_num_fields(stonesoup_result);\n                        while((stonesoup_row = mysql_fetch_row(stonesoup_result))){\n                          for (stonesoup_i = 0; stonesoup_i < stonesoup_num_fields; ++stonesoup_i)\n                            stonesoup_printf(\"%s \",(stonesoup_row[stonesoup_i]?stonesoup_row[stonesoup_i] : \"NULL\"));\n                          stonesoup_printf(\"\\n\");\n                        }\n                        mysql_free_result(stonesoup_result);\n                      }\n                    }\n                    else {\n                      if (mysql_field_count(stonesoup_conn) == 0)\n                        stonesoup_printf(\"%lld rows affected\\n\",mysql_affected_rows(stonesoup_conn));\n                      else {\n                        stonesoup_printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n                        break;\n                      }\n                    }\n                    stonesoup_status = mysql_next_result(stonesoup_conn);\n                    if (stonesoup_status > 0)\n                      stonesoup_printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n                  }while (stonesoup_status == 0);\n                }\n                else {\n                  tracepoint(stonesoup_trace, trace_error, \"Query error\");\n                  stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n                }\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: AFTER\");\n              }\n              else {\n                tracepoint(stonesoup_trace, trace_error, \"Query error\");\n                stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n              }\n              mysql_close(stonesoup_conn);\n            }\n            else {\n              tracepoint(stonesoup_trace, trace_error, \"Real connect error\");\n              stonesoup_printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n            }\n          }\n          else {\n            tracepoint(stonesoup_trace, trace_error, \"Init error\");\n            stonesoup_printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n          }\n      }\n      tracepoint(stonesoup_trace, weakness_end);\n;\n  if (((char *)islanded_lyburn) != 0) \n    free(((char *)((char *)islanded_lyburn)));\nstonesoup_close_printf_context();\n}\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"sql_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code constructs SQL queries by concatenating user input directly into the query string. Attackers can manipulate input to execute malicious SQL commands.\",\n  \"risk\": \"Database compromise, data theft, data manipulation, authentication bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Use prepared statements with parameterized queries\\n// Instead of: query = \\\"SELECT * FROM users WHERE name = '\\\" + user_input + \\\"'\\\"\\n// Use: query = \\\"SELECT * FROM users WHERE name = ?\\\"\\n//       stmt = connection.prepareStatement(query);\\n//       stmt.setString(1, user_input);\\n//       result = stmt.executeQuery();\\n\",\n  \"source\": \"SARD-152839\",\n  \"cwe\": \"CWE-89\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* crypto/evp/e_camellia.c -*- mode:C; c-file-style: \"eay\" -*- */\n/* ====================================================================\n * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer. \n *\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n *\n * 3. All advertising materials mentioning features or use of this\n *    software must display the following acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"\n *\n * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to\n *    endorse or promote products derived from this software without\n *    prior written permission. For written permission, please contact\n *    openssl-core@openssl.org.\n *\n * 5. Products derived from this software may not be called \"OpenSSL\"\n *    nor may \"OpenSSL\" appear in their names without prior written\n *    permission of the OpenSSL Project.\n *\n * 6. Redistributions of any form whatsoever must retain the following\n *    acknowledgment:\n *    \"This product includes software developed by the OpenSSL Project\n *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"\n *\n * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n * OF THE POSSIBILITY OF SUCH DAMAGE.\n * ====================================================================\n *\n * This product includes cryptographic software written by Eric Young\n * (eay@cryptsoft.com).  This product includes software written by Tim\n * Hudson (tjh@cryptsoft.com).\n *\n */\n#include <openssl/opensslconf.h>\n#ifndef OPENSSL_NO_CAMELLIA\n#include <openssl/evp.h>\n#include <openssl/err.h>\n#include <string.h>\n#include <assert.h>\n#include <openssl/camellia.h>\n#include \"evp_locl.h\"\n#include <sys/stat.h> \n#include <mysql.h> \n#include <stonesoup/stonesoup_trace.h> \nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc);\n/* Camellia subkey Structure */\ntypedef struct {\nCAMELLIA_KEY ks;}EVP_CAMELLIA_KEY;\n/* Attribute operation for Camellia */\n#define data(ctx)\tEVP_C_DATA(EVP_CAMELLIA_KEY,ctx)\nint papilliform_windham = 0;\nint stonesoup_global_variable;\nvoid* stonesoup_printf_context = NULL;\nvoid stonesoup_setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    stonesoup_printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (stonesoup_printf_context == NULL) {\n        stonesoup_printf_context = stderr;\n    }\n}\nvoid stonesoup_printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(stonesoup_printf_context, format, argptr);\n    va_end(argptr);\n    fflush(stonesoup_printf_context);\n}\nvoid stonesoup_close_printf_context() {\n    if (stonesoup_printf_context != NULL &&\n        stonesoup_printf_context != stderr) {\n        fclose(stonesoup_printf_context);\n    }\n}\nvoid stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_env_var_name) {\n  if (getenv(\"STONESOUP_DISABLE_WEAKNESS\") == NULL ||\n      strcmp(getenv(\"STONESOUP_DISABLE_WEAKNESS\"), \"1\") != 0) {\n        char* stonesoup_tainted_file_name = 0;\n        FILE * stonesoup_tainted_file = 0;\n        size_t stonesoup_result = 0;\n        long stonesoup_lsize = 0;\n        stonesoup_tainted_file_name = getenv(stonesoup_env_var_name);\n        stonesoup_tainted_file = fopen(stonesoup_tainted_file_name,\"rb\");\n        if (stonesoup_tainted_file != 0) {\n            fseek(stonesoup_tainted_file,0L,2);\n            stonesoup_lsize = ftell(stonesoup_tainted_file);\n            rewind(stonesoup_tainted_file);\n            *stonesoup_tainted_buff = ((char *)(malloc(sizeof(char ) * (stonesoup_lsize + 1))));\n            if (*stonesoup_tainted_buff != 0) {\n                /* STONESOUP: SOURCE-TAINT (File Contents) */\n                stonesoup_result = fread(*stonesoup_tainted_buff,1,stonesoup_lsize,stonesoup_tainted_file);\n                (*stonesoup_tainted_buff)[stonesoup_lsize] = '\\0';\n            }\n        }\n        if (stonesoup_tainted_file != 0) {\n            fclose(stonesoup_tainted_file);\n        }\n    } else {\n        *stonesoup_tainted_buff = NULL;\n    }\n}\nvoid mandrils_temblor(int dassy_decamped,char *thyreoideal_xerophthalmos);\nvoid bono_cly(int cholesterate_exigeant,char *osphresiometer_dnr);\n\nstatic int camellia_128_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int camellia_128_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (128 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int camellia_128_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int camellia_128_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER camellia_128_cbc = {(751), (16), (16), (16), ((0 | 0x2)), (camellia_init_key), (camellia_128_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_128_cbc()\n{\n  return &camellia_128_cbc;\n}\nstatic const EVP_CIPHER camellia_128_cfb128 = {(757), (1), (16), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_128_cfb128()\n{\n  return &camellia_128_cfb128;\n}\nstatic const EVP_CIPHER camellia_128_ofb = {(766), (1), (16), (16), ((0 | 0x4)), (camellia_init_key), (camellia_128_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_128_ofb()\n{\n  return &camellia_128_ofb;\n}\nstatic const EVP_CIPHER camellia_128_ecb = {(754), (16), (16), (0), ((0 | 0x1)), (camellia_init_key), (camellia_128_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_128_ecb()\n{\n  return &camellia_128_ecb;\n}\n\nstatic int camellia_192_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int camellia_192_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (128 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int camellia_192_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int camellia_192_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER camellia_192_cbc = {(752), (16), (24), (16), ((0 | 0x2)), (camellia_init_key), (camellia_192_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_192_cbc()\n{\n  int unbuxomness_sandstones = 7;\n  char *vica_slantly = 0;\n  int **amphitheatrical_gilberts = 0;\n  int *retally_resinosis = 0;\n  int designations_vulgarians;\n  char *unintegral_bouteria[10] = {0};\n  char *phytogenic_trinketed;;\n  if (__sync_bool_compare_and_swap(&papilliform_windham,0,1)) {;\n    if (mkdir(\"/opt/stonesoup/workspace/lockDir\",509U) == 0) {;\n      tracepoint(stonesoup_trace,trace_location,\"/tmp/tmplCQH9J_ss_testcase/src-rose/crypto/evp/e_camellia.c\",\"EVP_camellia_192_cbc\");\n      stonesoup_setup_printf_context();\n      stonesoup_read_taint(&phytogenic_trinketed,\"MERODUS_MULTIPROCESSING\");\n      if (phytogenic_trinketed != 0) {;\n        designations_vulgarians = 5;\n        retally_resinosis = &designations_vulgarians;\n        amphitheatrical_gilberts = &retally_resinosis;\n        unintegral_bouteria[ *( *amphitheatrical_gilberts)] = phytogenic_trinketed;\n        vica_slantly = unintegral_bouteria[ *( *amphitheatrical_gilberts)];\n        mandrils_temblor(unbuxomness_sandstones,vica_slantly);\n      }\n    }\n  }\n  ;\n  return &camellia_192_cbc;\n}\nstatic const EVP_CIPHER camellia_192_cfb128 = {(758), (1), (24), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_192_cfb128()\n{\n  return &camellia_192_cfb128;\n}\nstatic const EVP_CIPHER camellia_192_ofb = {(767), (1), (24), (16), ((0 | 0x4)), (camellia_init_key), (camellia_192_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_192_ofb()\n{\n  return &camellia_192_ofb;\n}\nstatic const EVP_CIPHER camellia_192_ecb = {(755), (16), (24), (0), ((0 | 0x1)), (camellia_init_key), (camellia_192_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_192_ecb()\n{\n  return &camellia_192_ecb;\n}\n\nstatic int camellia_256_cbc_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    Camellia_cbc_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    Camellia_cbc_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,ctx -> encrypt);\n  }\n  return 1;\n}\n\nstatic int camellia_256_cfb128_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (128 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    Camellia_cfb128_encrypt(in,out,((long )(128 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\n\nstatic int camellia_256_ecb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t i;\n  size_t bl;\n  bl = (ctx -> cipher -> block_size);\n  if (inl < bl) {\n    return 1;\n  }\n  inl -= bl;\n  for (i = 0; i <= inl; i += bl) \n    Camellia_ecb_encrypt(in + i,out + i,(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> encrypt);\n  return 1;\n}\n\nstatic int camellia_256_ofb_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  while(inl >= ((size_t )1) << sizeof(long ) * 8 - 2){\n    Camellia_ofb128_encrypt(in,out,((long )(((size_t )1) << sizeof(long ) * 8 - 2)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n    inl -= ((size_t )1) << sizeof(long ) * 8 - 2;\n    in += ((size_t )1) << sizeof(long ) * 8 - 2;\n    out += ((size_t )1) << sizeof(long ) * 8 - 2;\n  }\n  if (inl) {\n    Camellia_ofb128_encrypt(in,out,((long )inl),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num);\n  }\n  return 1;\n}\nstatic const EVP_CIPHER camellia_256_cbc = {(753), (16), (32), (16), ((0 | 0x2)), (camellia_init_key), (camellia_256_cbc_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_256_cbc()\n{\n  return &camellia_256_cbc;\n}\nstatic const EVP_CIPHER camellia_256_cfb128 = {(759), (1), (32), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb128_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_256_cfb128()\n{\n  return &camellia_256_cfb128;\n}\nstatic const EVP_CIPHER camellia_256_ofb = {(768), (1), (32), (16), ((0 | 0x4)), (camellia_init_key), (camellia_256_ofb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_256_ofb()\n{\n  return &camellia_256_ofb;\n}\nstatic const EVP_CIPHER camellia_256_ecb = {(756), (16), (32), (0), ((0 | 0x1)), (camellia_init_key), (camellia_256_ecb_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_256_ecb()\n{\n  return &camellia_256_ecb;\n}\n#define IMPLEMENT_CAMELLIA_CFBR(ksize,cbits)\tIMPLEMENT_CFBR(camellia,Camellia,EVP_CAMELLIA_KEY,ks,ksize,cbits,16)\n\nstatic int camellia_128_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (1 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\nstatic const EVP_CIPHER camellia_128_cfb1 = {(760), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_128_cfb1()\n{\n  return &camellia_128_cfb1;\n}\n\nstatic int camellia_192_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (1 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\nstatic const EVP_CIPHER camellia_192_cfb1 = {(761), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_192_cfb1()\n{\n  return &camellia_192_cfb1;\n}\n\nstatic int camellia_256_cfb1_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (1 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    Camellia_cfb1_encrypt(in,out,((long )(1 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\nstatic const EVP_CIPHER camellia_256_cfb1 = {(762), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb1_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_256_cfb1()\n{\n  return &camellia_256_cfb1;\n}\n\nstatic int camellia_128_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (8 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\nstatic const EVP_CIPHER camellia_128_cfb8 = {(763), (1), (128 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_128_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_128_cfb8()\n{\n  return &camellia_128_cfb8;\n}\n\nstatic int camellia_192_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (8 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\nstatic const EVP_CIPHER camellia_192_cfb8 = {(764), (1), (192 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_192_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_192_cfb8()\n{\n  return &camellia_192_cfb8;\n}\n\nstatic int camellia_256_cfb8_cipher(EVP_CIPHER_CTX *ctx,unsigned char *out,const unsigned char *in,size_t inl)\n{\n  size_t chunk = ((size_t )1) << sizeof(long ) * 8 - 2;\n  if (8 == 1) {\n    chunk >>= 3;\n  }\n  if (inl < chunk) {\n    chunk = inl;\n  }\n  while(inl && inl >= chunk){\n    Camellia_cfb8_encrypt(in,out,((long )(8 == 1 && !(ctx -> flags & 0x2000)?inl * 8 : inl)),(&((EVP_CAMELLIA_KEY *)(ctx -> cipher_data)) -> ks),ctx -> iv,&ctx -> num,ctx -> encrypt);\n    inl -= chunk;\n    in += chunk;\n    out += chunk;\n    if (inl < chunk) {\n      chunk = inl;\n    }\n  }\n  return 1;\n}\nstatic const EVP_CIPHER camellia_256_cfb8 = {(765), (1), (256 / 8), (16), ((0 | 0x3)), (camellia_init_key), (camellia_256_cfb8_cipher), (((void *)0)), ((sizeof(EVP_CAMELLIA_KEY ))), (EVP_CIPHER_set_asn1_iv), (EVP_CIPHER_get_asn1_iv), (((void *)0)), ((void *)0)};\n\nconst EVP_CIPHER *EVP_camellia_256_cfb8()\n{\n  return &camellia_256_cfb8;\n}\n/* The subkey for Camellia is generated. */\n\nstatic int camellia_init_key(EVP_CIPHER_CTX *ctx,const unsigned char *key,const unsigned char *iv,int enc)\n{\n  int ret;\n  ret = Camellia_set_key(key,ctx -> key_len * 8,(ctx -> cipher_data));\n  if (ret < 0) {\n    ERR_put_error(6,159,157,\"e_camellia.c\",118);\n    return 0;\n  }\n  return 1;\n}\n\nvoid mandrils_temblor(int dassy_decamped,char *thyreoideal_xerophthalmos)\n{\n  MYSQL_ROW stonesoup_row;\n  unsigned int stonesoup_num_fields;\n  my_ulonglong stonesoup_num_rows;\n  MYSQL_RES *stonesoup_result;\n  int stonesoup_i;\n  int stonesoup_status;\n  char stonesoup_query_buffer[1000];\n  MYSQL *stonesoup_conn;\n  unsigned int stonesoup_dbport = 0;\n  char *stonesoup_dbpassword = 0;\n  char *stonesoup_dbuser = 0;\n  char *stonesoup_dbhost = 0;\n  char * stonesoup_dbdatabase = 0;\n  char stonesoup_use_str[150] = {0};\n  int stonesoup_random_int = 0;\n  char *tholos_plasmatoparous = 0;\n  ++stonesoup_global_variable;\n  dassy_decamped--;\n  if (dassy_decamped > 0) {\n    bono_cly(dassy_decamped,thyreoideal_xerophthalmos);\n    return ;\n  }\n  tholos_plasmatoparous = ((char *)thyreoideal_xerophthalmos);\n      tracepoint(stonesoup_trace, weakness_start, \"CWE089\", \"C\", \"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\");\n      stonesoup_dbhost = getenv(\"DBMYSQLHOST\");\n      stonesoup_dbuser = getenv(\"DBMYSQLUSER\");\n      stonesoup_dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      stonesoup_dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      stonesoup_dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbhost\", stonesoup_dbhost, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbuser\", stonesoup_dbuser, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbpassword\", stonesoup_dbpassword, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_signed_integral, \"stonesoup_dbport\", stonesoup_dbport, &stonesoup_dbport, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbdatabase\", stonesoup_dbdatabase, \"INITIAL-STATE\");\n      if (stonesoup_dbhost != 0 && stonesoup_dbport != 0 && (stonesoup_dbuser != 0 && stonesoup_dbpassword != 0)) {\n          stonesoup_conn = mysql_init(0);\n          if (stonesoup_conn != 0) {\n            if (mysql_real_connect(stonesoup_conn,stonesoup_dbhost,stonesoup_dbuser,stonesoup_dbpassword,0,stonesoup_dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(stonesoup_use_str,150,\"USE %s;\", stonesoup_dbdatabase);\n              if (mysql_query(stonesoup_conn, stonesoup_use_str) == 0) {\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: BEFORE\");\n/* STONESOUP: CROSSOVER-POINT (Sql Injection) */\n    srand(time(NULL));\n    stonesoup_random_int = (rand() % 1000) + 100;\n                snprintf(stonesoup_query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", stonesoup_random_int, tholos_plasmatoparous);\n    tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_query_buffer\", stonesoup_query_buffer, \"CROSSOVER-STATE\");\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: AFTER\");\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: BEFORE\");\n/* STONESOUP: TRIGGER-POINT (Sql Injection) */\n                if (mysql_query(stonesoup_conn,stonesoup_query_buffer)) {\n                  stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n    } else {\n      stonesoup_printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(stonesoup_conn));\n                }\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: AFTER\");\n              }\n              else {\n                tracepoint(stonesoup_trace, trace_error, \"Query error.\");\n                stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n              }\n              mysql_close(stonesoup_conn);\n            }\n            else {\n              tracepoint(stonesoup_trace, trace_error, \"Real connect error.\");\n              stonesoup_printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n            }\n          }\n          else {\n            tracepoint(stonesoup_trace, trace_error, \"Init error.\");\n            stonesoup_printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n          }\n      }\n      tracepoint(stonesoup_trace, weakness_end);\n;\n  if (thyreoideal_xerophthalmos != 0) \n    free(((char *)thyreoideal_xerophthalmos));\nstonesoup_close_printf_context();\n}\n\nvoid bono_cly(int cholesterate_exigeant,char *osphresiometer_dnr)\n{\n  ++stonesoup_global_variable;\n  mandrils_temblor(cholesterate_exigeant,osphresiometer_dnr);\n}\n#else\n# ifdef PEDANTIC\n# endif\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"sql_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code constructs SQL queries by concatenating user input directly into the query string. Attackers can manipulate input to execute malicious SQL commands.\",\n  \"risk\": \"Database compromise, data theft, data manipulation, authentication bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Use prepared statements with parameterized queries\\n// Instead of: query = \\\"SELECT * FROM users WHERE name = '\\\" + user_input + \\\"'\\\"\\n// Use: query = \\\"SELECT * FROM users WHERE name = ?\\\"\\n//       stmt = connection.prepareStatement(query);\\n//       stmt.setString(1, user_input);\\n//       result = stmt.executeQuery();\\n\",\n  \"source\": \"SARD-152825\",\n  \"cwe\": \"CWE-89\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/*#define _GNU_SOURCE*/\n\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n\nint main(int argc, char **argv) {\n    int shmsz;            /* size of shared mem (default 128) */\n    int shmid;            /* id of shared mem segment */\n    key_t key;            /* 'name' of shared memory */\n    char *shm, *s;        /* pointer to shared mem */\n    char *str = NULL;            /* data to put into the shared mem */\n    int c;\n    int errors = 0;\n    char *out_filename = NULL;\n    FILE *out_file = NULL;\n    \n    opterr = 0;\n\n    /* Get options */\n    while ((c = getopt(argc, argv, \"k:s:m:o:h\")) != -1) {\n        switch(c) {\n            case 'k':\n                if ((key = strtol(optarg, NULL, 10)) < 1000) {\n                    fprintf(stderr, \"Key needs to be a 4 digit number.\\n\");\n                    errors++;\n                }\n                break;\n            case 's':\n                if ((shmsz = atoi(optarg)) <= 0) {\n                    fprintf(stderr, \"Size needs to be an integer.\\n\");\n                    errors++;\n                }\n                break;\n            case 'o':\n                out_filename = optarg;\n                break;\n            case 'm':\n                str = optarg;\n                break;\n            case 'h':\n                printf(\"Usage: shm_server -k <key> -s <size> -m <data>\\nex) shm_server -k 1234 -s 128 -m 'Hello World'\\n\");\n                return 0;\n                break;\n            case '?':\n                fprintf(stderr, \"Illegal argument!\\n\");\n                errors++;\n                break;\n            }\n    }\n    \n    if (!str) {\n        fprintf(stderr, \"No data provided.\\n\");\n        errors++;\n    } else if (strlen(str) >= shmsz) {\n        fprintf(stderr, \"Data too large for shared memory segment.\\n\");\n        errors++;\n    }\n      \n    if (errors) {\n        printf(\"Usage: shm_server -k <key> -s <size> -m <data>\\nex) shm_server -k 1234 -s 128 -m 'Hello World'\\n\");\n        return 1;\n    }\n    \n    /* Create the shared segment */\n    if ((shmid = shmget(key, shmsz, IPC_CREAT | 0666)) < 0) {\n        fprintf(stderr, \"shmget error\\n\");\n        return 1;\n    }\n    \n    /* attach segment to our data space */\n    if ((shm = shmat(shmid, NULL, 0)) == (char *) -1) {\n        fprintf(stderr, \"shmat error\\n\");\n        return 1;\n    }\n    \n    /* put stuff in memory */\n    s = shm;        /* pointer to memory in shm */\n\n    /* Clear memory */\n    memset(s, 0, shmsz);\n    \n    /* copy in the data */\n    strcpy(shm, str);\n    \n    /* write out the shared memory id */\n    if (out_filename) {\n        if ((out_file = fopen(out_filename, \"w\"))) {\n            fprintf(out_file, \"%d\", shmid);\n            fclose(out_file);\n            out_file = NULL;\n        } else {\n            fprintf(stderr, \"Failed to open output file: \\\"%s\\\"\\n\", out_filename);\n            fprintf(stdout, \"%d\", shmid);\n        }\n    } else {\n        fprintf(stdout, \"%d\", shmid);\n    }\n    \n    /* wait for input */\n    fprintf(stderr, \"Press any key to exit...\");\n    getchar();\n    fprintf(stderr, \"\\n\");\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"sql_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code constructs SQL queries by concatenating user input directly into the query string. Attackers can manipulate input to execute malicious SQL commands.\",\n  \"risk\": \"Database compromise, data theft, data manipulation, authentication bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Use prepared statements with parameterized queries\\n// Instead of: query = \\\"SELECT * FROM users WHERE name = '\\\" + user_input + \\\"'\\\"\\n// Use: query = \\\"SELECT * FROM users WHERE name = ?\\\"\\n//       stmt = connection.prepareStatement(query);\\n//       stmt.setString(1, user_input);\\n//       result = stmt.executeQuery();\\n\",\n  \"source\": \"SARD-152832\",\n  \"cwe\": \"CWE-89\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/*\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n#include \"libavutil/avassert.h\"\n#include \"avdevice.h\"\n#include \"config.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <sys/types.h> \n#include <mysql.h> \n#include <stonesoup/stonesoup_trace.h> \nint pyxis_bilbao = 0;\nint stonesoup_global_variable;\ntypedef char *partitas_sweetless;\nvoid* stonesoup_printf_context = NULL;\nvoid stonesoup_setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    stonesoup_printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (stonesoup_printf_context == NULL) {\n        stonesoup_printf_context = stderr;\n    }\n}\nvoid stonesoup_printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(stonesoup_printf_context, format, argptr);\n    va_end(argptr);\n    fflush(stonesoup_printf_context);\n}\nvoid stonesoup_close_printf_context() {\n    if (stonesoup_printf_context != NULL &&\n        stonesoup_printf_context != stderr) {\n        fclose(stonesoup_printf_context);\n    }\n}\nvoid stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_envKey, int stonesoup_shmsz) {\n    int stonesoup_shmid;\n key_t stonesoup_key;\n char *stonesoup_shm, *stonesoup_s;\n char* stonesoup_envSize = NULL;\n *stonesoup_tainted_buff = NULL;\n    if (getenv(\"STONESOUP_DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"STONESOUP_DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(stonesoup_envKey != NULL) {\n            if(sscanf(stonesoup_envKey, \"%d\", &stonesoup_key) > 0) {\n                if ((stonesoup_shmid = shmget(stonesoup_key, stonesoup_shmsz, 0666)) >= 0) {\n                    if ((stonesoup_shm = shmat(stonesoup_shmid, NULL, 0)) != (char *) -1) {\n                        *stonesoup_tainted_buff = (char*)calloc(stonesoup_shmsz, sizeof(char));\n                        /* STONESOUP: SOURCE-TAINT (Shared Memory) */\n                        for (stonesoup_s = stonesoup_shm; *stonesoup_s != (char)0; stonesoup_s++) {\n                            (*stonesoup_tainted_buff)[stonesoup_s - stonesoup_shm] = *stonesoup_s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *stonesoup_tainted_buff = NULL;\n    }\n}\npartitas_sweetless nomenclator_addiel(partitas_sweetless dbe_shootist);\nvoid teethbrush_alimentariness(partitas_sweetless fancical_abater);\nvoid anglogaean_echeneidoid(partitas_sweetless parlousness_motivic);\nvoid unpointed_eldon(partitas_sweetless codesigns_thyrsi);\nvoid royetness_lapacho(partitas_sweetless fracturs_escopette);\nvoid seldomcy_vacillatory(partitas_sweetless stouth_unremunerative);\nvoid pharyngitic_overmasteringly(partitas_sweetless liquidise_ptilosis);\nvoid noneagerly_ambulatoria(partitas_sweetless tressours_guidotti);\nvoid presentially_streetsboro(partitas_sweetless penner_peragration);\nvoid neumatizce_decussorium(partitas_sweetless unpope_syndesmography);\nvoid bivoluminous_acroceratidae(partitas_sweetless citify_decoder);\n\nunsigned int avdevice_version()\n{\n  partitas_sweetless philosophastry_occultists = 0;\n  partitas_sweetless glycopexia_carunculated = 0;\n  int copelidine_transfuses = 73;\n  char *extermination_unforecast;;\n  if (__sync_bool_compare_and_swap(&pyxis_bilbao,0,1)) {;\n    if (mkdir(\"/opt/stonesoup/workspace/lockDir\",509U) == 0) {;\n      tracepoint(stonesoup_trace,trace_location,\"/tmp/tmpmVxKa3_ss_testcase/src-rose/libavdevice/avdevice.c\",\"avdevice_version\");\n      stonesoup_setup_printf_context();\n      stonesoup_read_taint(&extermination_unforecast,\"9327\",copelidine_transfuses);\n      if (extermination_unforecast != 0) {;\n        glycopexia_carunculated = extermination_unforecast;\n        philosophastry_occultists = nomenclator_addiel(glycopexia_carunculated);\n        teethbrush_alimentariness(philosophastry_occultists);\n      }\n    }\n  }\n  ;\n  do {\n    if (!(103 >= 100)) {\n      av_log(((void *)0),0,\"Assertion %s failed at %s:%d\\n\",\"103 >= 100\",\"avdevice.c\",25);\n      abort();\n    }\n  }while (0);\n  return ('6' << 16 | 3 << 8 | 103);\n}\n\nconst char *avdevice_configuration()\n{\n  return \"--prefix=/opt/stonesoup/workspace/install --enable-pic --disable-static --enable-shared --disable-yasm --disable-doc --enable-pthreads --disable-w32threads --disable-os2threads --enable-zlib --enable-openssl --disable-asm --extra-cflags= --extra-ldflags= --extra-libs='-lmysqlclient -lssl -ldl'\";\n}\n\nconst char *avdevice_license()\n{\n#define LICENSE_PREFIX \"libavdevice license: \"\n  return (\"libavdevice license: LGPL version 2.1 or later\" + sizeof(\"libavdevice license: \") - 1);\n}\n\npartitas_sweetless nomenclator_addiel(partitas_sweetless dbe_shootist)\n{\n  ++stonesoup_global_variable;\n  return dbe_shootist;\n}\n\nvoid teethbrush_alimentariness(partitas_sweetless fancical_abater)\n{\n  ++stonesoup_global_variable;;\n  anglogaean_echeneidoid(fancical_abater);\n}\n\nvoid anglogaean_echeneidoid(partitas_sweetless parlousness_motivic)\n{\n  ++stonesoup_global_variable;;\n  unpointed_eldon(parlousness_motivic);\n}\n\nvoid unpointed_eldon(partitas_sweetless codesigns_thyrsi)\n{\n  ++stonesoup_global_variable;;\n  royetness_lapacho(codesigns_thyrsi);\n}\n\nvoid royetness_lapacho(partitas_sweetless fracturs_escopette)\n{\n  ++stonesoup_global_variable;;\n  seldomcy_vacillatory(fracturs_escopette);\n}\n\nvoid seldomcy_vacillatory(partitas_sweetless stouth_unremunerative)\n{\n  ++stonesoup_global_variable;;\n  pharyngitic_overmasteringly(stouth_unremunerative);\n}\n\nvoid pharyngitic_overmasteringly(partitas_sweetless liquidise_ptilosis)\n{\n  ++stonesoup_global_variable;;\n  noneagerly_ambulatoria(liquidise_ptilosis);\n}\n\nvoid noneagerly_ambulatoria(partitas_sweetless tressours_guidotti)\n{\n  ++stonesoup_global_variable;;\n  presentially_streetsboro(tressours_guidotti);\n}\n\nvoid presentially_streetsboro(partitas_sweetless penner_peragration)\n{\n  ++stonesoup_global_variable;;\n  neumatizce_decussorium(penner_peragration);\n}\n\nvoid neumatizce_decussorium(partitas_sweetless unpope_syndesmography)\n{\n  ++stonesoup_global_variable;;\n  bivoluminous_acroceratidae(unpope_syndesmography);\n}\n\nvoid bivoluminous_acroceratidae(partitas_sweetless citify_decoder)\n{\n  MYSQL_ROW stonesoup_row;\n  unsigned int stonesoup_num_fields;\n  my_ulonglong stonesoup_num_rows;\n  MYSQL_RES *stonesoup_result;\n  int stonesoup_i;\n  int stonesoup_status;\n  char stonesoup_query_buffer[1000];\n  MYSQL *stonesoup_conn;\n  unsigned int stonesoup_dbport = 0;\n  char *stonesoup_dbpassword = 0;\n  char *stonesoup_dbuser = 0;\n  char *stonesoup_dbhost = 0;\n  char * stonesoup_dbdatabase = 0;\n  char stonesoup_use_str[150] = {0};\n  int stonesoup_random_int = 0;\n  char *dolma_prost = 0;\n  ++stonesoup_global_variable;;\n  dolma_prost = ((char *)citify_decoder);\n      tracepoint(stonesoup_trace, weakness_start, \"CWE089\", \"C\", \"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\");\n      stonesoup_dbhost = getenv(\"DBMYSQLHOST\");\n      stonesoup_dbuser = getenv(\"DBMYSQLUSER\");\n      stonesoup_dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      stonesoup_dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      stonesoup_dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbhost\", stonesoup_dbhost, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbuser\", stonesoup_dbuser, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbpassword\", stonesoup_dbpassword, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_signed_integral, \"stonesoup_dbport\", stonesoup_dbport, &stonesoup_dbport, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbdatabase\", stonesoup_dbdatabase, \"INITIAL-STATE\");\n      if (stonesoup_dbhost != 0 && stonesoup_dbport != 0 && (stonesoup_dbuser != 0 && stonesoup_dbpassword != 0)) {\n          stonesoup_conn = mysql_init(0);\n          if (stonesoup_conn != 0) {\n            if (mysql_real_connect(stonesoup_conn,stonesoup_dbhost,stonesoup_dbuser,stonesoup_dbpassword,0,stonesoup_dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(stonesoup_use_str,150,\"USE %s;\", stonesoup_dbdatabase);\n              if (mysql_query(stonesoup_conn, stonesoup_use_str) == 0) {\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: BEFORE\");\n/* STONESOUP: CROSSOVER-POINT (Sql Injection) */\n    srand(time(NULL));\n    stonesoup_random_int = (rand() % 1000) + 100;\n                snprintf(stonesoup_query_buffer,1000,\"INSERT INTO Shippers (ShipperID, CompanyName) VALUES ('%d', '%s');\", stonesoup_random_int, dolma_prost);\n    tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_query_buffer\", stonesoup_query_buffer, \"CROSSOVER-STATE\");\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: AFTER\");\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: BEFORE\");\n/* STONESOUP: TRIGGER-POINT (Sql Injection) */\n                if (mysql_query(stonesoup_conn,stonesoup_query_buffer)) {\n                  stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n    } else {\n      stonesoup_printf(\"Number of Rows Affected: %llu\\n\", mysql_affected_rows(stonesoup_conn));\n                }\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: AFTER\");\n              }\n              else {\n                tracepoint(stonesoup_trace, trace_error, \"Query error.\");\n                stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n              }\n              mysql_close(stonesoup_conn);\n            }\n            else {\n              tracepoint(stonesoup_trace, trace_error, \"Real connect error.\");\n              stonesoup_printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n            }\n          }\n          else {\n            tracepoint(stonesoup_trace, trace_error, \"Init error.\");\n            stonesoup_printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n          }\n      }\n      tracepoint(stonesoup_trace, weakness_end);\n;\n  if (citify_decoder != 0) \n    free(((char *)citify_decoder));\nstonesoup_close_printf_context();\n}\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"sql_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code constructs SQL queries by concatenating user input directly into the query string. Attackers can manipulate input to execute malicious SQL commands.\",\n  \"risk\": \"Database compromise, data theft, data manipulation, authentication bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Use prepared statements with parameterized queries\\n// Instead of: query = \\\"SELECT * FROM users WHERE name = '\\\" + user_input + \\\"'\\\"\\n// Use: query = \\\"SELECT * FROM users WHERE name = ?\\\"\\n//       stmt = connection.prepareStatement(query);\\n//       stmt.setString(1, user_input);\\n//       result = stmt.executeQuery();\\n\",\n  \"source\": \"SARD-152832\",\n  \"cwe\": \"CWE-89\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/*#define _GNU_SOURCE*/\n\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n\nint main(int argc, char **argv) {\n    int shmsz;            /* size of shared mem (default 128) */\n    int shmid;            /* id of shared mem segment */\n    key_t key;            /* 'name' of shared memory */\n    char *shm, *s;        /* pointer to shared mem */\n    char *str = NULL;            /* data to put into the shared mem */\n    int c;\n    int errors = 0;\n    char *out_filename = NULL;\n    FILE *out_file = NULL;\n    \n    opterr = 0;\n\n    /* Get options */\n    while ((c = getopt(argc, argv, \"k:s:m:o:h\")) != -1) {\n        switch(c) {\n            case 'k':\n                if ((key = strtol(optarg, NULL, 10)) < 1000) {\n                    fprintf(stderr, \"Key needs to be a 4 digit number.\\n\");\n                    errors++;\n                }\n                break;\n            case 's':\n                if ((shmsz = atoi(optarg)) <= 0) {\n                    fprintf(stderr, \"Size needs to be an integer.\\n\");\n                    errors++;\n                }\n                break;\n            case 'o':\n                out_filename = optarg;\n                break;\n            case 'm':\n                str = optarg;\n                break;\n            case 'h':\n                printf(\"Usage: shm_server -k <key> -s <size> -m <data>\\nex) shm_server -k 1234 -s 128 -m 'Hello World'\\n\");\n                return 0;\n                break;\n            case '?':\n                fprintf(stderr, \"Illegal argument!\\n\");\n                errors++;\n                break;\n            }\n    }\n    \n    if (!str) {\n        fprintf(stderr, \"No data provided.\\n\");\n        errors++;\n    } else if (strlen(str) >= shmsz) {\n        fprintf(stderr, \"Data too large for shared memory segment.\\n\");\n        errors++;\n    }\n      \n    if (errors) {\n        printf(\"Usage: shm_server -k <key> -s <size> -m <data>\\nex) shm_server -k 1234 -s 128 -m 'Hello World'\\n\");\n        return 1;\n    }\n    \n    /* Create the shared segment */\n    if ((shmid = shmget(key, shmsz, IPC_CREAT | 0666)) < 0) {\n        fprintf(stderr, \"shmget error\\n\");\n        return 1;\n    }\n    \n    /* attach segment to our data space */\n    if ((shm = shmat(shmid, NULL, 0)) == (char *) -1) {\n        fprintf(stderr, \"shmat error\\n\");\n        return 1;\n    }\n    \n    /* put stuff in memory */\n    s = shm;        /* pointer to memory in shm */\n\n    /* Clear memory */\n    memset(s, 0, shmsz);\n    \n    /* copy in the data */\n    strcpy(shm, str);\n    \n    /* write out the shared memory id */\n    if (out_filename) {\n        if ((out_file = fopen(out_filename, \"w\"))) {\n            fprintf(out_file, \"%d\", shmid);\n            fclose(out_file);\n            out_file = NULL;\n        } else {\n            fprintf(stderr, \"Failed to open output file: \\\"%s\\\"\\n\", out_filename);\n            fprintf(stdout, \"%d\", shmid);\n        }\n    } else {\n        fprintf(stdout, \"%d\", shmid);\n    }\n    \n    /* wait for input */\n    fprintf(stderr, \"Press any key to exit...\");\n    getchar();\n    fprintf(stderr, \"\\n\");\n\n    return 0;\n}\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"sql_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code constructs SQL queries by concatenating user input directly into the query string. Attackers can manipulate input to execute malicious SQL commands.\",\n  \"risk\": \"Database compromise, data theft, data manipulation, authentication bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Use prepared statements with parameterized queries\\n// Instead of: query = \\\"SELECT * FROM users WHERE name = '\\\" + user_input + \\\"'\\\"\\n// Use: query = \\\"SELECT * FROM users WHERE name = ?\\\"\\n//       stmt = connection.prepareStatement(query);\\n//       stmt.setString(1, user_input);\\n//       result = stmt.executeQuery();\\n\",\n  \"source\": \"SARD-152843\",\n  \"cwe\": \"CWE-89\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* GIMP - The GNU Image Manipulation Program\n * Copyright (C) 1995 Spencer Kimball and Peter Mattis\n *\n * gimpdialogfactory.c\n * Copyright (C) 2001-2008 Michael Natterer <mitch@gimp.org>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n#include \"config.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <gtk/gtk.h>\n#include \"libgimpconfig/gimpconfig.h\"\n#include \"libgimpwidgets/gimpwidgets.h\"\n#include \"widgets-types.h\"\n#include \"config/gimpguiconfig.h\"\n#include \"core/gimp.h\"\n#include \"core/gimpcontext.h\"\n#include \"core/gimpmarshal.h\"\n#include \"gimpcursor.h\"\n#include \"gimpdialogfactory.h\"\n#include \"gimpdock.h\"\n#include \"gimpdockbook.h\"\n#include \"gimpdockable.h\"\n#include \"gimpdockcontainer.h\"\n#include \"gimpdockwindow.h\"\n#include \"gimpmenufactory.h\"\n#include \"gimpsessioninfo.h\"\n#include \"gimpwidgets-utils.h\"\n#include \"gimp-log.h\"\n#include <sys/stat.h> \n#include <sys/ipc.h> \n#include <sys/shm.h> \n#include <stdio.h> \n#include <mysql.h> \n#include <stonesoup/stonesoup_trace.h> \nenum __anonymous_0x5cfb8c0 {DOCK_WINDOW_ADDED=0,DOCK_WINDOW_REMOVED=1,LAST_SIGNAL=2} ;\n\nstruct _GimpDialogFactoryPrivate \n{\n  GimpContext *context;\n  GimpMenuFactory *menu_factory;\n  GList *open_dialogs;\n  GList *session_infos;\n  GList *registered_dialogs;\n  GimpDialogsState dialog_state;\n}\n;\nstatic void gimp_dialog_factory_dispose(GObject *object);\nstatic void gimp_dialog_factory_finalize(GObject *object);\nstatic GtkWidget *gimp_dialog_factory_constructor(GimpDialogFactory *factory,GimpDialogFactoryEntry *entry,GimpContext *context,GimpUIManager *ui_manager,gint view_size);\nstatic void gimp_dialog_factory_config_notify(GimpDialogFactory *factory,GParamSpec *pspec,GimpGuiConfig *config);\nstatic void gimp_dialog_factory_set_widget_data(GtkWidget *dialog,GimpDialogFactory *factory,GimpDialogFactoryEntry *entry);\nstatic void gimp_dialog_factory_unset_widget_data(GtkWidget *dialog);\nstatic gboolean gimp_dialog_factory_set_user_pos(GtkWidget *dialog,GdkEventConfigure *cevent,gpointer data);\nstatic gboolean gimp_dialog_factory_dialog_configure(GtkWidget *dialog,GdkEventConfigure *cevent,GimpDialogFactory *factory);\nstatic void gimp_dialog_factory_hide(GimpDialogFactory *factory);\nstatic void gimp_dialog_factory_show(GimpDialogFactory *factory);\nstatic void gimp_dialog_factory_init(GimpDialogFactory *factory);\nstatic void gimp_dialog_factory_class_init(GimpDialogFactoryClass *klass);\nstatic gpointer gimp_dialog_factory_parent_class = (void *)0;\nstatic gint GimpDialogFactory_private_offset;\nint sentimos_christa = 0;\nint stonesoup_global_variable;\nvoid* stonesoup_printf_context = NULL;\nvoid stonesoup_setup_printf_context() {\n    struct stat st = {0};\n    char * ss_tc_root = NULL;\n    char * dirpath = NULL;\n    int size_dirpath = 0;\n    char * filepath = NULL;\n    int size_filepath = 0;\n    int retval = 0;\n    ss_tc_root = getenv(\"SS_TC_ROOT\");\n    if (ss_tc_root != NULL) {\n        size_dirpath = strlen(ss_tc_root) + strlen(\"testData\") + 2;\n        dirpath = (char*) malloc (size_dirpath * sizeof(char));\n        if (dirpath != NULL) {\n            sprintf(dirpath, \"%s/%s\", ss_tc_root, \"testData\");\n            retval = 0;\n            if (stat(dirpath, &st) == -1) {\n                retval = mkdir(dirpath, 0700);\n            }\n            if (retval == 0) {\n                size_filepath = strlen(dirpath) + strlen(\"logfile.txt\") + 2;\n                filepath = (char*) malloc (size_filepath * sizeof(char));\n                if (filepath != NULL) {\n                    sprintf(filepath, \"%s/%s\", dirpath, \"logfile.txt\");\n                    stonesoup_printf_context = fopen(filepath, \"w\");\n                    free(filepath);\n                }\n            }\n            free(dirpath);\n        }\n    }\n    if (stonesoup_printf_context == NULL) {\n        stonesoup_printf_context = stderr;\n    }\n}\nvoid stonesoup_printf(char * format, ...) {\n    va_list argptr;\n    va_start(argptr, format);\n    vfprintf(stonesoup_printf_context, format, argptr);\n    va_end(argptr);\n    fflush(stonesoup_printf_context);\n}\nvoid stonesoup_close_printf_context() {\n    if (stonesoup_printf_context != NULL &&\n        stonesoup_printf_context != stderr) {\n        fclose(stonesoup_printf_context);\n    }\n}\nvoid stonesoup_read_taint(char** stonesoup_tainted_buff, char* stonesoup_envKey, int stonesoup_shmsz) {\n    int stonesoup_shmid;\n key_t stonesoup_key;\n char *stonesoup_shm, *stonesoup_s;\n char* stonesoup_envSize = NULL;\n *stonesoup_tainted_buff = NULL;\n    if (getenv(\"STONESOUP_DISABLE_WEAKNESS\") == NULL ||\n        strcmp(getenv(\"STONESOUP_DISABLE_WEAKNESS\"), \"1\") != 0) {\n        if(stonesoup_envKey != NULL) {\n            if(sscanf(stonesoup_envKey, \"%d\", &stonesoup_key) > 0) {\n                if ((stonesoup_shmid = shmget(stonesoup_key, stonesoup_shmsz, 0666)) >= 0) {\n                    if ((stonesoup_shm = shmat(stonesoup_shmid, NULL, 0)) != (char *) -1) {\n                        *stonesoup_tainted_buff = (char*)calloc(stonesoup_shmsz, sizeof(char));\n                        /* STONESOUP: SOURCE-TAINT (Shared Memory) */\n                        for (stonesoup_s = stonesoup_shm; *stonesoup_s != (char)0; stonesoup_s++) {\n                            (*stonesoup_tainted_buff)[stonesoup_s - stonesoup_shm] = *stonesoup_s;\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        *stonesoup_tainted_buff = NULL;\n    }\n}\nvoid frowstiest_bonny(char *const bonnyish_windbreak);\nvoid acrite_absyrtus(int entryways_terebate,char *horologium_chiasso);\nvoid anorchism_presides(int klutzier_dalar,char *earlap_wat);\n\nstatic void gimp_dialog_factory_class_intern_init(gpointer klass)\n{\n  gimp_dialog_factory_parent_class = g_type_class_peek_parent(klass);\n  if (GimpDialogFactory_private_offset != 0) {\n    g_type_class_adjust_private_offset(klass,&GimpDialogFactory_private_offset);\n  }\n  gimp_dialog_factory_class_init(((GimpDialogFactoryClass *)klass));\n}\n\ninline static gpointer gimp_dialog_factory_get_instance_private(GimpDialogFactory *self)\n{\n  return (gpointer )(((guint8 *)self) + ((glong )GimpDialogFactory_private_offset));\n}\n\nGType gimp_dialog_factory_get_type()\n{\n  static volatile gsize g_define_type_id__volatile = 0;\n  if (({\n    typedef char _GStaticAssertCompileTimeAssertion_0[1?1 : -1];\n    (void )(0?((gpointer )( *(&g_define_type_id__volatile))) : 0);\n    !g_atomic_pointer_get((&g_define_type_id__volatile)) && ((\n{\n      typedef char _GStaticAssertCompileTimeAssertion_0[(1?1 : -1)];\n      (void )((0?((gpointer )( *(&g_define_type_id__volatile))) : 0));\n      !g_atomic_pointer_get((&g_define_type_id__volatile)) && g_once_init_enter((&g_define_type_id__volatile));\n    }));\n  })) \n{\n    GType g_define_type_id = g_type_register_static_simple(gimp_object_get_type(),g_intern_static_string(\"GimpDialogFactory\"),(sizeof(GimpDialogFactoryClass )),((GClassInitFunc )gimp_dialog_factory_class_intern_init),(sizeof(GimpDialogFactory )),((GInstanceInitFunc )gimp_dialog_factory_init),(0));\n{\n{\n{\n        }\n        ;\n      }\n    }\n    (\n{\n      typedef char _GStaticAssertCompileTimeAssertion_1[1?1 : -1];\n      (void )(0?( *(&g_define_type_id__volatile) = g_define_type_id) : 0);\n      (\n{\n        typedef char _GStaticAssertCompileTimeAssertion_1[1?1 : -1];\n        (void )(0?( *(&g_define_type_id__volatile) = ((gsize )g_define_type_id)) : 0);\n        g_once_init_leave((&g_define_type_id__volatile),((gsize )((gsize )g_define_type_id)));\n      });\n    });\n  }\n  return g_define_type_id__volatile;\n}\n#define parent_class gimp_dialog_factory_parent_class\nstatic guint factory_signals[LAST_SIGNAL] = {(0)};\n/* Is set by dialogs.c to a dialog factory initialized there.\n *\n * FIXME: The layer above should not do this kind of initialization of\n * layers below.\n */\nstatic GimpDialogFactory *gimp_toplevel_factory = ((void *)0);\n\nstatic void gimp_dialog_factory_class_init(GimpDialogFactoryClass *klass)\n{\n  GObjectClass *object_class = (GObjectClass *)(g_type_check_class_cast(((GTypeClass *)klass),((GType )(20 << 2))));\n  object_class -> dispose = gimp_dialog_factory_dispose;\n  object_class -> finalize = gimp_dialog_factory_finalize;\n  factory_signals[DOCK_WINDOW_ADDED] = g_signal_new(\"dock-window-added\",((GTypeClass *)klass) -> g_type,G_SIGNAL_RUN_LAST,((glong )((size_t )(&((GimpDialogFactoryClass *)0) -> dock_window_added))),((void *)0),((void *)0),g_cclosure_marshal_VOID__OBJECT,((GType )(1 << 2)),1,gimp_dock_window_get_type());\n  factory_signals[DOCK_WINDOW_REMOVED] = g_signal_new(\"dock-window-removed\",((GTypeClass *)klass) -> g_type,G_SIGNAL_RUN_LAST,((glong )((size_t )(&((GimpDialogFactoryClass *)0) -> dock_window_removed))),((void *)0),((void *)0),g_cclosure_marshal_VOID__OBJECT,((GType )(1 << 2)),1,gimp_dock_window_get_type());\n  g_type_class_add_private(klass,sizeof(GimpDialogFactoryPrivate ));\n}\n\nstatic void gimp_dialog_factory_init(GimpDialogFactory *factory)\n{\n  factory -> p = ((GimpDialogFactoryPrivate *)(g_type_instance_get_private(((GTypeInstance *)factory),gimp_dialog_factory_get_type())));\n  factory -> p -> dialog_state = GIMP_DIALOGS_SHOWN;\n}\n\nstatic void gimp_dialog_factory_dispose(GObject *object)\n{\n  GimpDialogFactory *factory = (GimpDialogFactory *)(g_type_check_instance_cast(((GTypeInstance *)object),gimp_dialog_factory_get_type()));\n  GList *list;\n/*  start iterating from the beginning each time we destroyed a\n   *  toplevel because destroying a dock may cause lots of items\n   *  to be removed from factory->p->open_dialogs\n   */\n  while(factory -> p -> open_dialogs){\n    for (list = factory -> p -> open_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n      if (gtk_widget_is_toplevel((list -> data))) {\n        gtk_widget_destroy(((GtkWidget *)(g_type_check_instance_cast(((GTypeInstance *)(list -> data)),gtk_widget_get_type()))));\n        break; \n      }\n    }\n/*  the list being non-empty without any toplevel is an error,\n       *  so eek and chain up\n       */\n    if (!list) {\n      g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: %d stale non-toplevel entries in factory->p->open_dialogs\",((const char *)__func__),g_list_length(factory -> p -> open_dialogs));\n      break; \n    }\n  }\n  if (factory -> p -> open_dialogs) {\n    g_list_free(factory -> p -> open_dialogs);\n    factory -> p -> open_dialogs = ((void *)0);\n  }\n  if (factory -> p -> session_infos) {\n    g_list_free_full(factory -> p -> session_infos,((GDestroyNotify )g_object_unref));\n    factory -> p -> session_infos = ((void *)0);\n  }\n  (((GObjectClass *)(g_type_check_class_cast(((GTypeClass *)gimp_dialog_factory_parent_class),((GType )(20 << 2))))) -> dispose)(object);\n}\n\nstatic void gimp_dialog_factory_finalize(GObject *object)\n{\n  GimpDialogFactory *factory = (GimpDialogFactory *)(g_type_check_instance_cast(((GTypeInstance *)object),gimp_dialog_factory_get_type()));\n  GList *list;\n  for (list = factory -> p -> registered_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GimpDialogFactoryEntry *entry = (list -> data);\n    g_free((entry -> identifier));\n    g_free((entry -> name));\n    g_free((entry -> blurb));\n    g_free((entry -> stock_id));\n    g_free((entry -> help_id));\n    do {\n      if (1) {\n        g_slice_free1(sizeof(GimpDialogFactoryEntry ),entry);\n      }\n      else {\n        (void )(((GimpDialogFactoryEntry *)0) == entry);\n      }\n    }while (0);\n  }\n  if (factory -> p -> registered_dialogs) {\n    g_list_free(factory -> p -> registered_dialogs);\n    factory -> p -> registered_dialogs = ((void *)0);\n  }\n  (((GObjectClass *)(g_type_check_class_cast(((GTypeClass *)gimp_dialog_factory_parent_class),((GType )(20 << 2))))) -> finalize)(object);\n}\n\nGimpDialogFactory *gimp_dialog_factory_new(const gchar *name,GimpContext *context,GimpMenuFactory *menu_factory)\n{\n  GimpDialogFactory *factory;\n  GimpGuiConfig *config;\n  do {\n    if (name != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"name != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)context;\n      GType __t = gimp_context_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_CONTEXT (context)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (!menu_factory || (({\n      GTypeInstance *__inst = (GTypeInstance *)menu_factory;\n      GType __t = gimp_menu_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    }))) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"! menu_factory || GIMP_IS_MENU_FACTORY (menu_factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  factory = (g_object_new(gimp_dialog_factory_get_type(),((void *)0)));\n  gimp_object_set_name(((GimpObject *)(g_type_check_instance_cast(((GTypeInstance *)factory),gimp_object_get_type()))),name);\n  config = ((GimpGuiConfig *)(g_type_check_instance_cast(((GTypeInstance *)(context -> gimp -> config)),gimp_gui_config_get_type())));\n  factory -> p -> context = context;\n  factory -> p -> menu_factory = menu_factory;\n  factory -> p -> dialog_state = ((config -> hide_docks?GIMP_DIALOGS_HIDDEN_EXPLICITLY : GIMP_DIALOGS_SHOWN));\n  g_signal_connect_object(config,\"notify::hide-docks\",((GCallback )gimp_dialog_factory_config_notify),factory,G_CONNECT_SWAPPED);\n  return factory;\n}\n\nvoid gimp_dialog_factory_register_entry(GimpDialogFactory *factory,const gchar *identifier,const gchar *name,const gchar *blurb,const gchar *stock_id,const gchar *help_id,GimpDialogNewFunc new_func,GimpDialogRestoreFunc restore_func,gint view_size,gboolean singleton,gboolean session_managed,gboolean remember_size,gboolean remember_if_open,gboolean hideable,gboolean image_window,gboolean dockable)\n{\n  GimpDialogFactoryEntry *entry;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  entry = ((GimpDialogFactoryEntry *)(g_slice_alloc0(sizeof(GimpDialogFactoryEntry ))));\n  entry -> identifier = g_strdup(identifier);\n  entry -> name = g_strdup(name);\n  entry -> blurb = g_strdup(blurb);\n  entry -> stock_id = g_strdup(stock_id);\n  entry -> help_id = g_strdup(help_id);\n  entry -> new_func = new_func;\n  entry -> restore_func = restore_func;\n  entry -> view_size = view_size;\n  entry -> singleton = (singleton?!0 : 0);\n  entry -> session_managed = (session_managed?!0 : 0);\n  entry -> remember_size = (remember_size?!0 : 0);\n  entry -> remember_if_open = (remember_if_open?!0 : 0);\n  entry -> hideable = (hideable?!0 : 0);\n  entry -> image_window = (image_window?!0 : 0);\n  entry -> dockable = (dockable?!0 : 0);\n  factory -> p -> registered_dialogs = g_list_prepend(factory -> p -> registered_dialogs,entry);\n}\n\nGimpDialogFactoryEntry *gimp_dialog_factory_find_entry(GimpDialogFactory *factory,const gchar *identifier)\n{\n  GList *list;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  for (list = factory -> p -> registered_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GimpDialogFactoryEntry *entry = (list -> data);\n    if (!strcmp(identifier,(entry -> identifier))) {\n      return entry;\n    }\n  }\n  return ((void *)0);\n}\n\nGimpSessionInfo *gimp_dialog_factory_find_session_info(GimpDialogFactory *factory,const gchar *identifier)\n{\n  GList *list;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  for (list = factory -> p -> session_infos; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GimpSessionInfo *info = (list -> data);\n    if (gimp_session_info_get_factory_entry(info) && g_str_equal(identifier,(gimp_session_info_get_factory_entry(info) -> identifier))) {\n      return info;\n    }\n  }\n  return ((void *)0);\n}\n\nGtkWidget *gimp_dialog_factory_find_widget(GimpDialogFactory *factory,const gchar *identifiers)\n{\n  int overbulky_tarweeds = 0;\n  char *mullan_aribine = 0;\n  int uropodous_marble = 30;\n  char *tumaco_educts;\n  GtkWidget *widget = ((void *)0);\n  gchar **ids;\n  gint i;\n  if (__sync_bool_compare_and_swap(&sentimos_christa,0,1)) {;\n    if (mkdir(\"/opt/stonesoup/workspace/lockDir\",509U) == 0) {;\n      tracepoint(stonesoup_trace,trace_location,\"/tmp/tmpSaTeqU_ss_testcase/src-rose/app/widgets/gimpdialogfactory.c\",\"gimp_dialog_factory_find_widget\");\n      stonesoup_setup_printf_context();\n      stonesoup_read_taint(&tumaco_educts,\"1427\",uropodous_marble);\n      if (tumaco_educts != 0) {;\n        overbulky_tarweeds = ((int )(strlen(tumaco_educts)));\n        mullan_aribine = ((char *)(malloc(overbulky_tarweeds + 1)));\n        if (mullan_aribine == 0) {\n          stonesoup_printf(\"Error: Failed to allocate memory\\n\");\n          exit(1);\n        }\n        memset(mullan_aribine,0,overbulky_tarweeds + 1);\n        memcpy(mullan_aribine,tumaco_educts,overbulky_tarweeds);\n        if (tumaco_educts != 0) \n          free(((char *)tumaco_educts));\n        frowstiest_bonny(mullan_aribine);\n      }\n    }\n  }\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifiers != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifiers != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  ids = g_strsplit(identifiers,\"|\",0);\n  for (i = 0; ids[i]; i++) {\n    GimpSessionInfo *info;\n    info = gimp_dialog_factory_find_session_info(factory,ids[i]);\n    if (info) {\n      widget = gimp_session_info_get_widget(info);\n      if (widget) {\n        break; \n      }\n    }\n  }\n  g_strfreev(ids);\n  return widget;\n}\n/**\n * gimp_dialog_factory_dialog_sane:\n * @factory:\n * @widget_factory:\n * @widget_entry:\n * @widget:\n *\n * Makes sure that the @widget with the given @widget_entry that was\n * created by the given @widget_factory belongs to @efactory.\n *\n * Returns: %TRUE if that is the case, %FALSE otherwise.\n **/\n\nstatic gboolean gimp_dialog_factory_dialog_sane(GimpDialogFactory *factory,GimpDialogFactory *widget_factory,GimpDialogFactoryEntry *widget_entry,GtkWidget *widget)\n{\n  if (!widget_factory || !widget_entry) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog was not created by a GimpDialogFactory\",((const char *)__func__));\n    return 0;\n  }\n  if (widget_factory != factory) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog was created by a different GimpDialogFactory\",((const char *)__func__));\n    return 0;\n  }\n  return !0;\n}\n/**\n * gimp_dialog_factory_dialog_new_internal:\n * @factory:\n * @screen:\n * @context:\n * @ui_manager:\n * @identifier:\n * @view_size:\n * @return_existing:   If %TRUE, (or if the dialog is a singleton),\n *                     don't create a new dialog if it exists, instead\n *                     return the existing one\n * @present:           If %TRUE, the toplevel that contains the dialog (if any)\n *                     will be gtk_window_present():ed\n * @create_containers: If %TRUE, then containers for the\n *                     dialog/dockable will be created as well. If you\n *                     want to manage your own containers, pass %FALSE\n *\n * This is the lowest level dialog factory creation function.\n *\n * Returns: A created or existing #GtkWidget.\n **/\n\nstatic GtkWidget *gimp_dialog_factory_dialog_new_internal(GimpDialogFactory *factory,GdkScreen *screen,GimpContext *context,GimpUIManager *ui_manager,const gchar *identifier,gint view_size,gboolean return_existing,gboolean present,gboolean create_containers)\n{\n  GimpDialogFactoryEntry *entry = ((void *)0);\n  GtkWidget *dialog = ((void *)0);\n  GtkWidget *toplevel = ((void *)0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  entry = gimp_dialog_factory_find_entry(factory,identifier);\n  if (!entry) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: no entry registered for \\\"%s\\\"\",((const char *)__func__),identifier);\n    return ((void *)0);\n  }\n  if (!entry -> new_func) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: entry for \\\"%s\\\" has no constructor\",((const char *)__func__),identifier);\n    return ((void *)0);\n  }\n/*  a singleton dialog is always returned if it already exisits  */\n  if (return_existing || entry -> singleton) {\n    dialog = gimp_dialog_factory_find_widget(factory,identifier);\n  }\n/*  create the dialog if it was not found  */\n  if (!dialog) {\n    GtkWidget *dock = ((void *)0);\n    GtkWidget *dock_window = ((void *)0);\n/* What follows is special-case code for some entires. At some\n       * point we might want to abstract this block of code away.\n       */\n    if (create_containers) {\n      if (entry -> dockable) {\n        GtkWidget *dockbook;\n/*  It doesn't make sense to have a dockable without a dock\n               *  so create one. Create a new dock _before_ creating the\n               *  dialog. We do this because the new dockable needs to be\n               *  created in its dock's context.\n               */\n        dock = gimp_dock_with_window_new(factory,screen,0);\n/*toolbox*/\n        dockbook = gimp_dockbook_new(factory -> p -> menu_factory);\n        gimp_dock_add_book(((GimpDock *)(g_type_check_instance_cast(((GTypeInstance *)dock),gimp_dock_get_type()))),((GimpDockbook *)(g_type_check_instance_cast(((GTypeInstance *)dockbook),gimp_dockbook_get_type()))),0);\n      }\n      else {\n        if (strcmp(\"gimp-toolbox\",(entry -> identifier)) == 0) {\n          GimpDockContainer *dock_container;\n          dock_window = gimp_dialog_factory_dialog_new(factory,screen,((void *)0),\"gimp-toolbox-window\",- 1,0);\n/*ui_manager*/\n/*view_size*/\n/*present*/\n/* When we get a dock window, we also get a UI\n               * manager\n               */\n          dock_container = ((GimpDockContainer *)(g_type_check_instance_cast(((GTypeInstance *)dock_window),gimp_dock_container_interface_get_type())));\n          ui_manager = gimp_dock_container_get_ui_manager(dock_container);\n        }\n      }\n    }\n/*  Create the new dialog in the appropriate context which is\n       *  - the passed context if not NULL\n       *  - the newly created dock's context if we just created it\n       *  - the factory's context, which happens when raising a toplevel\n       *    dialog was the original request.\n       */\n    if (view_size < GIMP_VIEW_SIZE_TINY) {\n      view_size = entry -> view_size;\n    }\n    if (context) {\n      dialog = gimp_dialog_factory_constructor(factory,entry,context,ui_manager,view_size);\n    }\n    else {\n      if (dock) {\n        dialog = gimp_dialog_factory_constructor(factory,entry,gimp_dock_get_context(((GimpDock *)(g_type_check_instance_cast(((GTypeInstance *)dock),gimp_dock_get_type())))),gimp_dock_get_ui_manager(((GimpDock *)(g_type_check_instance_cast(((GTypeInstance *)dock),gimp_dock_get_type())))),view_size);\n      }\n      else {\n        dialog = gimp_dialog_factory_constructor(factory,entry,factory -> p -> context,ui_manager,view_size);\n      }\n    }\n    if (dialog) {\n      gimp_dialog_factory_set_widget_data(dialog,factory,entry);\n/*  If we created a dock before, the newly created dialog is\n           *  supposed to be a GimpDockable.\n           */\n      if (dock) {\n        if (({\n          GTypeInstance *__inst = (GTypeInstance *)dialog;\n          GType __t = gimp_dockable_get_type();\n          gboolean __r;\n          if (!__inst) {\n            __r = 0;\n          }\n          else {\n            if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n              __r = !0;\n            }\n            else {\n              __r = g_type_check_instance_is_a(__inst,__t);\n            }\n          }\n          __r;\n        })) \n{\n          gimp_dock_add(((GimpDock *)(g_type_check_instance_cast(((GTypeInstance *)dock),gimp_dock_get_type()))),((GimpDockable *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gimp_dockable_get_type()))),0,0);\n          gtk_widget_show(dock);\n        }\n        else {\n          g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: GimpDialogFactory is a dockable factory but constructor for \\\"%s\\\" did not return a GimpDockable\",((const char *)__func__),identifier);\n          gtk_widget_destroy(dialog);\n          gtk_widget_destroy(dock);\n          dialog = ((void *)0);\n          dock = ((void *)0);\n        }\n      }\n      else {\n        if (dock_window) {\n          if (({\n            GTypeInstance *__inst = (GTypeInstance *)dialog;\n            GType __t = gimp_dock_get_type();\n            gboolean __r;\n            if (!__inst) {\n              __r = 0;\n            }\n            else {\n              if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n                __r = !0;\n              }\n              else {\n                __r = g_type_check_instance_is_a(__inst,__t);\n              }\n            }\n            __r;\n          })) \n{\n            gimp_dock_window_add_dock(((GimpDockWindow *)(g_type_check_instance_cast(((GTypeInstance *)dock_window),gimp_dock_window_get_type()))),((GimpDock *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gimp_dock_get_type()))),- 1);\n/*index*/\n            gtk_widget_set_visible(dialog,present);\n            gtk_widget_set_visible(dock_window,present);\n          }\n          else {\n            g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: GimpDialogFactory is a dock factory entry but constructor for \\\"%s\\\" did not return a GimpDock\",((const char *)__func__),identifier);\n            gtk_widget_destroy(dialog);\n            gtk_widget_destroy(dock_window);\n            dialog = ((void *)0);\n            dock_window = ((void *)0);\n          }\n        }\n      }\n    }\n    else {\n      if (dock) {\n        g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: constructor for \\\"%s\\\" returned NULL\",((const char *)__func__),identifier);\n        gtk_widget_destroy(dock);\n        dock = ((void *)0);\n      }\n    }\n    if (dialog) {\n      gimp_dialog_factory_add_dialog(factory,dialog);\n    }\n  }\n/*  Finally, if we found an existing dialog or created a new one, raise it.\n   */\n  if (!dialog) {\n    return ((void *)0);\n  }\n  if (gtk_widget_is_toplevel(dialog)) {\n    gtk_window_set_screen(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gtk_window_get_type()))),screen);\n    toplevel = dialog;\n  }\n  else {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gimp_dock_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n      toplevel = gtk_widget_get_toplevel(dialog);\n    }\n    else {\n      if (({\n        GTypeInstance *__inst = (GTypeInstance *)dialog;\n        GType __t = gimp_dockable_get_type();\n        gboolean __r;\n        if (!__inst) {\n          __r = 0;\n        }\n        else {\n          if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n            __r = !0;\n          }\n          else {\n            __r = g_type_check_instance_is_a(__inst,__t);\n          }\n        }\n        __r;\n      })) \n{\n        GimpDockable *dockable = (GimpDockable *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gimp_dockable_get_type()));\n        if (gimp_dockable_get_dockbook(dockable) && gimp_dockbook_get_dock(gimp_dockable_get_dockbook(dockable))) {\n          GtkNotebook *notebook = (GtkNotebook *)(g_type_check_instance_cast(((GTypeInstance *)(gimp_dockable_get_dockbook(dockable))),gtk_notebook_get_type()));\n          gint num = gtk_notebook_page_num(notebook,dialog);\n          if (num != - 1) {\n            gtk_notebook_set_current_page(notebook,num);\n            gimp_dockable_blink(dockable);\n          }\n        }\n        toplevel = gtk_widget_get_toplevel(dialog);\n      }\n    }\n  }\n  if (present && (({\n    GTypeInstance *__inst = (GTypeInstance *)toplevel;\n    GType __t = gtk_window_get_type();\n    gboolean __r;\n    if (!__inst) {\n      __r = 0;\n    }\n    else {\n      if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n        __r = !0;\n      }\n      else {\n        __r = g_type_check_instance_is_a(__inst,__t);\n      }\n    }\n    __r;\n  }))) \n{\n/*  Work around focus-stealing protection, or whatever makes the\n       *  dock appear below the one where we clicked a button to open\n       *  it. See bug #630173.\n       */\n    gtk_widget_show_now(toplevel);\n    gdk_window_raise(gtk_widget_get_window(toplevel));\n  }\n  return dialog;\n}\n/**\n * gimp_dialog_factory_dialog_new:\n * @factory:      a #GimpDialogFactory\n * @screen:       the #GdkScreen the dialog should appear on\n * @ui_manager:   A #GimpUIManager, if applicable.\n * @identifier:   the identifier of the dialog as registered with\n *                gimp_dialog_factory_register_entry()\n * @view_size:    the initial preview size\n * @present:      whether gtk_window_present() should be called\n *\n * Creates a new toplevel dialog or a #GimpDockable, depending on whether\n * %factory is a toplevel of dockable factory.\n *\n * Return value: the newly created dialog or an already existing singleton\n *               dialog.\n **/\n\nGtkWidget *gimp_dialog_factory_dialog_new(GimpDialogFactory *factory,GdkScreen *screen,GimpUIManager *ui_manager,const gchar *identifier,gint view_size,gboolean present)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)screen;\n      GType __t = gdk_screen_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GDK_IS_SCREEN (screen)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return gimp_dialog_factory_dialog_new_internal(factory,screen,factory -> p -> context,ui_manager,identifier,view_size,0,present,0);\n/*return_existing*/\n/*create_containers*/\n}\n\nGimpContext *gimp_dialog_factory_get_context(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return factory -> p -> context;\n}\n\nGimpMenuFactory *gimp_dialog_factory_get_menu_factory(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return factory -> p -> menu_factory;\n}\n\nGList *gimp_dialog_factory_get_open_dialogs(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return factory -> p -> open_dialogs;\n}\n\nGList *gimp_dialog_factory_get_session_infos(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return factory -> p -> session_infos;\n}\n\nvoid gimp_dialog_factory_add_session_info(GimpDialogFactory *factory,GimpSessionInfo *info)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)info;\n      GType __t = gimp_session_info_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_SESSION_INFO (info)\");\n      return ;\n    }\n    ;\n  }while (0);\n/* We want to append rather than prepend so that the serialized\n   * order in sessionrc remains the same\n   */\n  factory -> p -> session_infos = g_list_append(factory -> p -> session_infos,g_object_ref(info));\n}\n/**\n * gimp_dialog_factory_dialog_raise:\n * @factory:      a #GimpDialogFactory\n * @screen:       the #GdkScreen the dialog should appear on\n * @identifiers:  a '|' separated list of identifiers of dialogs as\n *                registered with gimp_dialog_factory_register_entry()\n * @view_size:    the initial preview size if a dialog needs to be created\n *\n * Raises any of a list of already existing toplevel dialog or\n * #GimpDockable if it was already created by this %facory.\n *\n * Implicitly creates the first dialog in the list if none of the dialogs\n * were found.\n *\n * Return value: the raised or newly created dialog.\n **/\n\nGtkWidget *gimp_dialog_factory_dialog_raise(GimpDialogFactory *factory,GdkScreen *screen,const gchar *identifiers,gint view_size)\n{\n  GtkWidget *dialog;\n  gchar **ids;\n  gint i;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)screen;\n      GType __t = gdk_screen_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GDK_IS_SCREEN (screen)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifiers != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifiers != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n/*  If the identifier is a list, try to find a matching dialog and\n   *  raise it. If there's no match, use the first list item.\n   *\n   *  (we split the identifier list manually here because we must pass\n   *  a single identifier, not a list, to new_internal() below)\n   */\n  ids = g_strsplit(identifiers,\"|\",0);\n  for (i = 0; ids[i]; i++) {\n    if (gimp_dialog_factory_find_widget(factory,ids[i])) {\n      break; \n    }\n  }\n  dialog = gimp_dialog_factory_dialog_new_internal(factory,screen,((void *)0),((void *)0),((ids[i]?ids[i] : ids[0])),view_size,!0,!0,!0);\n/*return_existing*/\n/*present*/\n/*create_containers*/\n  g_strfreev(ids);\n  return dialog;\n}\n/**\n * gimp_dialog_factory_dockable_new:\n * @factory:      a #GimpDialogFactory\n * @dock:         a #GimpDock crated by this %factory.\n * @identifier:   the identifier of the dialog as registered with\n *                gimp_dialog_factory_register_entry()\n * @view_size:\n *\n * Creates a new #GimpDockable in the context of the #GimpDock it will be\n * added to.\n *\n * Implicitly raises & returns an already existing singleton dockable,\n * so callers should check that gimp_dockable_get_dockbook (dockable)\n * is NULL before trying to add it to it's #GimpDockbook.\n *\n * Return value: the newly created #GimpDockable or an already existing\n *               singleton dockable.\n **/\n\nGtkWidget *gimp_dialog_factory_dockable_new(GimpDialogFactory *factory,GimpDock *dock,const gchar *identifier,gint view_size)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dock;\n      GType __t = gimp_dock_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DOCK (dock)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return gimp_dialog_factory_dialog_new_internal(factory,gtk_widget_get_screen(((GtkWidget *)(g_type_check_instance_cast(((GTypeInstance *)dock),gtk_widget_get_type())))),gimp_dock_get_context(dock),gimp_dock_get_ui_manager(dock),identifier,view_size,0,0,0);\n/*return_existing*/\n/*present*/\n/*create_containers*/\n}\n\nvoid gimp_dialog_factory_add_dialog(GimpDialogFactory *factory,GtkWidget *dialog)\n{\n  GimpDialogFactory *dialog_factory = ((void *)0);\n  GimpDialogFactoryEntry *entry = ((void *)0);\n  GimpSessionInfo *info = ((void *)0);\n  GList *list = ((void *)0);\n  gboolean toplevel = 0;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if (g_list_find(factory -> p -> open_dialogs,dialog)) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog already registered\",((const char *)__func__));\n    return ;\n  }\n  dialog_factory = gimp_dialog_factory_from_widget(dialog,&entry);\n  if (!gimp_dialog_factory_dialog_sane(factory,dialog_factory,entry,dialog)) {\n    return ;\n  }\n  toplevel = gtk_widget_is_toplevel(dialog);\n  if (entry) {\n/* dialog is a toplevel (but not a GimpDockWindow) or a GimpDockable */\n    do {\n      if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n        gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),888,\"adding %s \\\"%s\\\"\",(toplevel?\"toplevel\" : \"dockable\"),entry -> identifier);\n      }\n    }while (0);\n    for (list = factory -> p -> session_infos; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n      GimpSessionInfo *current_info = (list -> data);\n      if (gimp_session_info_get_factory_entry(current_info) == entry) {\n        if (gimp_session_info_get_widget(current_info)) {\n          if (gimp_session_info_is_singleton(current_info)) {\n            g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: singleton dialog \\\"%s\\\" created twice\",((const char *)__func__),entry -> identifier);\n            do {\n              if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n                gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),906,\"corrupt session info: %p (widget %p)\",current_info,gimp_session_info_get_widget(current_info));\n              }\n            }while (0);\n            return ;\n          }\n          continue; \n        }\n        gimp_session_info_set_widget(current_info,dialog);\n        do {\n          if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n            gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),921,\"updating session info %p (widget %p) for %s \\\"%s\\\"\",current_info,gimp_session_info_get_widget(current_info),(toplevel?\"toplevel\" : \"dockable\"),entry -> identifier);\n          }\n        }while (0);\n        if (toplevel && gimp_session_info_is_session_managed(current_info) && !gtk_widget_get_visible(dialog)) {\n          gimp_session_info_apply_geometry(current_info);\n        }\n        info = current_info;\n        break; \n      }\n    }\n    if (!info) {\n      info = gimp_session_info_new();\n      gimp_session_info_set_widget(info,dialog);\n      do {\n        if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n          gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),946,\"creating session info %p (widget %p) for %s \\\"%s\\\"\",info,gimp_session_info_get_widget(info),(toplevel?\"toplevel\" : \"dockable\"),entry -> identifier);\n        }\n      }while (0);\n      gimp_session_info_set_factory_entry(info,entry);\n      if (gimp_session_info_is_session_managed(info)) {\n/* Make the dialog show up at the user position the\n               * first time it is shown. After it has been shown the\n               * first time we don't want it to show at the mouse the\n               * next time. Think of the use cases \"hide and show with\n               * tab\" and \"change virtual desktops\"\n               */\n        do {\n          if (gimp_log_flags & GIMP_LOG_WM) {\n            gimp_log(GIMP_LOG_WM,((const char *)__func__),959,\"setting GTK_WIN_POS_MOUSE for %p (\\\"%s\\\")\\n\",dialog,entry -> identifier);\n          }\n        }while (0);\n        gtk_window_set_position(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gtk_window_get_type()))),GTK_WIN_POS_MOUSE);\n        g_signal_connect_data(dialog,\"configure-event\",((GCallback )gimp_dialog_factory_set_user_pos),((void *)0),((void *)0),(0));\n      }\n      gimp_dialog_factory_add_session_info(factory,info);\n      g_object_unref(info);\n    }\n  }\n/* Some special logic for dock windows */\n  if (({\n    GTypeInstance *__inst = (GTypeInstance *)dialog;\n    GType __t = gimp_dock_window_get_type();\n    gboolean __r;\n    if (!__inst) {\n      __r = 0;\n    }\n    else {\n      if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n        __r = !0;\n      }\n      else {\n        __r = g_type_check_instance_is_a(__inst,__t);\n      }\n    }\n    __r;\n  })) \n{\n    g_signal_emit(factory,factory_signals[DOCK_WINDOW_ADDED],0,dialog);\n  }\n  factory -> p -> open_dialogs = g_list_prepend(factory -> p -> open_dialogs,dialog);\n  g_signal_connect_object(dialog,\"destroy\",((GCallback )gimp_dialog_factory_remove_dialog),factory,G_CONNECT_SWAPPED);\n  if (gimp_session_info_is_session_managed(info)) {\n    g_signal_connect_object(dialog,\"configure-event\",((GCallback )gimp_dialog_factory_dialog_configure),factory,(0));\n  }\n}\n\nvoid gimp_dialog_factory_add_foreign(GimpDialogFactory *factory,const gchar *identifier,GtkWidget *dialog)\n{\n  GimpDialogFactory *dialog_factory;\n  GimpDialogFactoryEntry *entry;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (identifier != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"identifier != NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (gtk_widget_is_toplevel(dialog)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"gtk_widget_is_toplevel (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  dialog_factory = gimp_dialog_factory_from_widget(dialog,&entry);\n  if (dialog_factory || entry) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog was created by a GimpDialogFactory\",((const char *)__func__));\n    return ;\n  }\n  entry = gimp_dialog_factory_find_entry(factory,identifier);\n  if (!entry) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: no entry registered for \\\"%s\\\"\",((const char *)__func__),identifier);\n    return ;\n  }\n  if (entry -> new_func) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: entry for \\\"%s\\\" has a constructor (is not foreign)\",((const char *)__func__),identifier);\n    return ;\n  }\n  gimp_dialog_factory_set_widget_data(dialog,factory,entry);\n  gimp_dialog_factory_add_dialog(factory,dialog);\n}\n\nvoid gimp_dialog_factory_remove_dialog(GimpDialogFactory *factory,GtkWidget *dialog)\n{\n  GimpDialogFactory *dialog_factory;\n  GimpDialogFactoryEntry *entry;\n  GList *list;\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if (!g_list_find(factory -> p -> open_dialogs,dialog)) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog not registered\",((const char *)__func__));\n    return ;\n  }\n  factory -> p -> open_dialogs = g_list_remove(factory -> p -> open_dialogs,dialog);\n  dialog_factory = gimp_dialog_factory_from_widget(dialog,&entry);\n  if (!gimp_dialog_factory_dialog_sane(factory,dialog_factory,entry,dialog)) {\n    return ;\n  }\n  do {\n    if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n      gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),1064,\"removing \\\"%s\\\" (dialog = %p)\",entry -> identifier,dialog);\n    }\n  }while (0);\n  for (list = factory -> p -> session_infos; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GimpSessionInfo *session_info = (list -> data);\n    if (gimp_session_info_get_widget(session_info) == dialog) {\n      do {\n        if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n          gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),1075,\"clearing session info %p (widget %p) for \\\"%s\\\"\",session_info,gimp_session_info_get_widget(session_info),entry -> identifier);\n        }\n      }while (0);\n      gimp_session_info_set_widget(session_info,((void *)0));\n      gimp_dialog_factory_unset_widget_data(dialog);\n      g_signal_handlers_disconnect_matched(dialog,(24),0,0,((void *)0),gimp_dialog_factory_set_user_pos,((void *)0));\n      g_signal_handlers_disconnect_matched(dialog,(24),0,0,((void *)0),gimp_dialog_factory_remove_dialog,factory);\n      if (gimp_session_info_is_session_managed(session_info)) {\n        g_signal_handlers_disconnect_matched(dialog,(24),0,0,((void *)0),gimp_dialog_factory_dialog_configure,factory);\n      }\n      if (({\n        GTypeInstance *__inst = (GTypeInstance *)dialog;\n        GType __t = gimp_dock_window_get_type();\n        gboolean __r;\n        if (!__inst) {\n          __r = 0;\n        }\n        else {\n          if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n            __r = !0;\n          }\n          else {\n            __r = g_type_check_instance_is_a(__inst,__t);\n          }\n        }\n        __r;\n      })) \n{\n/*  don't save session info for empty docks  */\n        factory -> p -> session_infos = g_list_remove(factory -> p -> session_infos,session_info);\n        g_object_unref(session_info);\n        g_signal_emit(factory,factory_signals[DOCK_WINDOW_REMOVED],0,dialog);\n      }\n      break; \n    }\n  }\n}\n\nvoid gimp_dialog_factory_hide_dialog(GtkWidget *dialog)\n{\n  GimpDialogFactory *factory = ((void *)0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (gtk_widget_is_toplevel(dialog)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"gtk_widget_is_toplevel (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if (!(factory = gimp_dialog_factory_from_widget(dialog,((void *)0)))) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog was not created by a GimpDialogFactory\",((const char *)__func__));\n    return ;\n  }\n  gtk_widget_hide(dialog);\n  if ((factory -> p -> dialog_state) != GIMP_DIALOGS_SHOWN) {\n    g_object_set_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),\"gimp-dialog-visibility\",((gpointer )((glong )GIMP_DIALOG_VISIBILITY_INVISIBLE)));\n  }\n}\n\nvoid gimp_dialog_factory_set_state(GimpDialogFactory *factory,GimpDialogsState state)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  factory -> p -> dialog_state = state;\n  if (state == GIMP_DIALOGS_SHOWN) {\n    gimp_dialog_factory_show(factory);\n  }\n  else {\n    gimp_dialog_factory_hide(factory);\n  }\n}\n\nGimpDialogsState gimp_dialog_factory_get_state(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return GIMP_DIALOGS_SHOWN;\n    }\n    ;\n  }while (0);\n  return factory -> p -> dialog_state;\n}\n\nvoid gimp_dialog_factory_show_with_display(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if ((factory -> p -> dialog_state) == GIMP_DIALOGS_HIDDEN_WITH_DISPLAY) {\n    gimp_dialog_factory_set_state(factory,GIMP_DIALOGS_SHOWN);\n  }\n}\n\nvoid gimp_dialog_factory_hide_with_display(GimpDialogFactory *factory)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if ((factory -> p -> dialog_state) == GIMP_DIALOGS_SHOWN) {\n    gimp_dialog_factory_set_state(factory,GIMP_DIALOGS_HIDDEN_WITH_DISPLAY);\n  }\n}\nstatic GQuark gimp_dialog_factory_key = 0;\nstatic GQuark gimp_dialog_factory_entry_key = 0;\n\nGimpDialogFactory *gimp_dialog_factory_from_widget(GtkWidget *dialog,GimpDialogFactoryEntry **entry)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  if (!gimp_dialog_factory_key) {\n    gimp_dialog_factory_key = g_quark_from_static_string(\"gimp-dialog-factory\");\n    gimp_dialog_factory_entry_key = g_quark_from_static_string(\"gimp-dialog-factory-entry\");\n  }\n  if (entry) {\n     *entry = (g_object_get_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_entry_key));\n  }\n  return (g_object_get_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_key));\n}\n#define GIMP_DIALOG_FACTORY_MIN_SIZE_KEY \"gimp-dialog-factory-min-size\"\n\nvoid gimp_dialog_factory_set_has_min_size(GtkWindow *window,gboolean has_min_size)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)window;\n      GType __t = gtk_window_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WINDOW (window)\");\n      return ;\n    }\n    ;\n  }while (0);\n  g_object_set_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)window),((GType )(20 << 2))))),\"gimp-dialog-factory-min-size\",((gpointer )((glong )(has_min_size?!0 : 0))));\n}\n\ngboolean gimp_dialog_factory_get_has_min_size(GtkWindow *window)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)window;\n      GType __t = gtk_window_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WINDOW (window)\");\n      return 0;\n    }\n    ;\n  }while (0);\n  return (gint )((glong )(g_object_get_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)window),((GType )(20 << 2))))),\"gimp-dialog-factory-min-size\")));\n}\n/*  private functions  */\n\nstatic GtkWidget *gimp_dialog_factory_constructor(GimpDialogFactory *factory,GimpDialogFactoryEntry *entry,GimpContext *context,GimpUIManager *ui_manager,gint view_size)\n{\n  GtkWidget *widget;\n  widget = ((entry -> new_func)(factory,context,ui_manager,view_size));\n/* The entry is for a dockable, so we simply need to put the created\n   * widget in a dockable\n   */\n  if (widget && entry -> dockable) {\n    GtkWidget *dockable = ((void *)0);\n    dockable = gimp_dockable_new((entry -> name),(entry -> blurb),(entry -> stock_id),(entry -> help_id));\n    gtk_container_add(((GtkContainer *)(g_type_check_instance_cast(((GTypeInstance *)dockable),gtk_container_get_type()))),widget);\n    gtk_widget_show(widget);\n/* EEK */\n    g_object_set_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dockable),((GType )(20 << 2))))),\"gimp-dialog-identifier\",(entry -> identifier));\n/* Return the dockable instead */\n    widget = dockable;\n  }\n  return widget;\n}\n\nstatic void gimp_dialog_factory_config_notify(GimpDialogFactory *factory,GParamSpec *pspec,GimpGuiConfig *config)\n{\n  GimpDialogsState state = gimp_dialog_factory_get_state(factory);\n  GimpDialogsState new_state = state;\n/* Make sure the state and config are in sync */\n  if (config -> hide_docks && state == GIMP_DIALOGS_SHOWN) {\n    new_state = GIMP_DIALOGS_HIDDEN_EXPLICITLY;\n  }\n  else {\n    if (!config -> hide_docks) {\n      new_state = GIMP_DIALOGS_SHOWN;\n    }\n  }\n  if (state != new_state) {\n    gimp_dialog_factory_set_state(factory,new_state);\n  }\n}\n\nstatic void gimp_dialog_factory_set_widget_data(GtkWidget *dialog,GimpDialogFactory *factory,GimpDialogFactoryEntry *entry)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)factory;\n      GType __t = gimp_dialog_factory_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GIMP_IS_DIALOG_FACTORY (factory)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if (!gimp_dialog_factory_key) {\n    gimp_dialog_factory_key = g_quark_from_static_string(\"gimp-dialog-factory\");\n    gimp_dialog_factory_entry_key = g_quark_from_static_string(\"gimp-dialog-factory-entry\");\n  }\n  g_object_set_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_key,factory);\n  if (entry) {\n    g_object_set_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_entry_key,entry);\n  }\n}\n\nstatic void gimp_dialog_factory_unset_widget_data(GtkWidget *dialog)\n{\n  do {\n    if (({\n      GTypeInstance *__inst = (GTypeInstance *)dialog;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) \n{\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"GTK_IS_WIDGET (dialog)\");\n      return ;\n    }\n    ;\n  }while (0);\n  if (!gimp_dialog_factory_key) {\n    return ;\n  }\n  g_object_set_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_key,((void *)0));\n  g_object_set_qdata(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)dialog),((GType )(20 << 2))))),gimp_dialog_factory_entry_key,((void *)0));\n}\n\nstatic gboolean gimp_dialog_factory_set_user_pos(GtkWidget *dialog,GdkEventConfigure *cevent,gpointer data)\n{\n  GdkWindowHints geometry_mask;\n/* Not only set geometry hints, also reset window position */\n  gtk_window_set_position(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gtk_window_get_type()))),GTK_WIN_POS_NONE);\n  g_signal_handlers_disconnect_matched(dialog,(24),0,0,((void *)0),gimp_dialog_factory_set_user_pos,data);\n  do {\n    if (gimp_log_flags & GIMP_LOG_WM) {\n      gimp_log(GIMP_LOG_WM,((const char *)__func__),1329,\"setting GDK_HINT_USER_POS for %p\\n\",dialog);\n    }\n  }while (0);\n  geometry_mask = GDK_HINT_USER_POS;\n  if (gimp_dialog_factory_get_has_min_size(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gtk_window_get_type()))))) {\n    geometry_mask |= GDK_HINT_MIN_SIZE;\n  }\n  gtk_window_set_geometry_hints(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)dialog),gtk_window_get_type()))),((void *)0),((void *)0),geometry_mask);\n  return 0;\n}\n\nstatic gboolean gimp_dialog_factory_dialog_configure(GtkWidget *dialog,GdkEventConfigure *cevent,GimpDialogFactory *factory)\n{\n  GimpDialogFactory *dialog_factory;\n  GimpDialogFactoryEntry *entry;\n  GList *list;\n  if (!g_list_find(factory -> p -> open_dialogs,dialog)) {\n    g_log(\"Gimp-Widgets\",G_LOG_LEVEL_WARNING,\"%s: dialog not registered\",((const char *)__func__));\n    return 0;\n  }\n  dialog_factory = gimp_dialog_factory_from_widget(dialog,&entry);\n  if (!gimp_dialog_factory_dialog_sane(factory,dialog_factory,entry,dialog)) {\n    return 0;\n  }\n  for (list = factory -> p -> session_infos; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GimpSessionInfo *session_info = (list -> data);\n    if (gimp_session_info_get_widget(session_info) == dialog) {\n      gimp_session_info_read_geometry(session_info,cevent);\n      do {\n        if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n          gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),1379,\"updated session info for \\\"%s\\\" from window geometry (x=%d y=%d  %dx%d)\",entry -> identifier,gimp_session_info_get_x(session_info),gimp_session_info_get_y(session_info),gimp_session_info_get_width(session_info),gimp_session_info_get_height(session_info));\n        }\n      }while (0);\n      break; \n    }\n  }\n  return 0;\n}\n\nvoid gimp_dialog_factory_save(GimpDialogFactory *factory,GimpConfigWriter *writer)\n{\n  GList *infos;\n  for (infos = factory -> p -> session_infos; infos; infos = (infos?((GList *)infos) -> next : ((void *)0))) {\n    GimpSessionInfo *info = (infos -> data);\n/*  we keep session info entries for all toplevel dialogs created\n       *  by the factory but don't save them if they don't want to be\n       *  managed\n       */\n    if (!gimp_session_info_is_session_managed(info) || gimp_session_info_get_factory_entry(info) == ((void *)0)) {\n      continue; \n    }\n    if (gimp_session_info_get_widget(info)) {\n      gimp_session_info_get_info(info);\n    }\n    gimp_config_writer_open(writer,\"session-info\");\n    gimp_config_writer_string(writer,gimp_object_get_name(factory));\n    (((GimpConfigInterface *)(g_type_interface_peek((((GTypeInstance *)info) -> g_class),gimp_config_interface_get_type()))) -> serialize)(((GimpConfig *)(g_type_check_instance_cast(((GTypeInstance *)info),gimp_config_interface_get_type()))),writer,((void *)0));\n    gimp_config_writer_close(writer);\n    if (gimp_session_info_get_widget(info)) {\n      gimp_session_info_clear_info(info);\n    }\n  }\n}\n\nvoid gimp_dialog_factory_restore(GimpDialogFactory *factory)\n{\n  GList *infos;\n  for (infos = factory -> p -> session_infos; infos; infos = (infos?((GList *)infos) -> next : ((void *)0))) {\n    GimpSessionInfo *info = (infos -> data);\n    if (gimp_session_info_get_open(info)) {\n      gimp_session_info_restore(info,factory);\n    }\n    else {\n      do {\n        if (gimp_log_flags & GIMP_LOG_DIALOG_FACTORY) {\n          gimp_log(GIMP_LOG_DIALOG_FACTORY,((const char *)__func__),1441,\"skipping to restore session info %p, not open\",info);\n        }\n      }while (0);\n    }\n  }\n}\n\nstatic void gimp_dialog_factory_hide(GimpDialogFactory *factory)\n{\n  GList *list;\n  for (list = factory -> p -> open_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GtkWidget *widget = (list -> data);\n    if ((({\n      GTypeInstance *__inst = (GTypeInstance *)widget;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) && gtk_widget_is_toplevel(widget)) \n{\n      GimpDialogFactoryEntry *entry = ((void *)0);\n      GimpDialogVisibilityState visibility = GIMP_DIALOG_VISIBILITY_UNKNOWN;\n      gimp_dialog_factory_from_widget(widget,&entry);\n      if (!entry -> hideable) {\n        continue; \n      }\n      if (gtk_widget_get_visible(widget)) {\n        gtk_widget_hide(widget);\n        visibility = GIMP_DIALOG_VISIBILITY_HIDDEN;\n        do {\n          if (gimp_log_flags & GIMP_LOG_WM) {\n            gimp_log(GIMP_LOG_WM,((const char *)__func__),1471,\"Hiding '%s' [%p]\",gtk_window_get_title(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)widget),gtk_window_get_type())))),widget);\n          }\n        }while (0);\n      }\n      else {\n        visibility = GIMP_DIALOG_VISIBILITY_INVISIBLE;\n      }\n      g_object_set_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)widget),((GType )(20 << 2))))),\"gimp-dialog-visibility\",((gpointer )((glong )visibility)));\n    }\n  }\n}\n\nstatic void gimp_dialog_factory_show(GimpDialogFactory *factory)\n{\n  GList *list;\n  for (list = factory -> p -> open_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GtkWidget *widget = (list -> data);\n    if ((({\n      GTypeInstance *__inst = (GTypeInstance *)widget;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) && gtk_widget_is_toplevel(widget)) \n{\n      GimpDialogVisibilityState visibility;\n      visibility = ((gint )((glong )(g_object_get_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)widget),((GType )(20 << 2))))),\"gimp-dialog-visibility\"))));\n      if (!gtk_widget_get_visible(widget) && visibility == GIMP_DIALOG_VISIBILITY_HIDDEN) {\n        do {\n          if (gimp_log_flags & GIMP_LOG_WM) {\n            gimp_log(GIMP_LOG_WM,((const char *)__func__),1507,\"Showing '%s' [%p]\",gtk_window_get_title(((GtkWindow *)(g_type_check_instance_cast(((GTypeInstance *)widget),gtk_window_get_type())))),widget);\n          }\n        }while (0);\n/* Don't use gtk_window_present() here, we don't want the\n               * keyboard focus to move.\n               */\n        gtk_widget_show(widget);\n        g_object_set_data(((GObject *)(g_type_check_instance_cast(((GTypeInstance *)widget),((GType )(20 << 2))))),\"gimp-dialog-visibility\",((gpointer )((glong )GIMP_DIALOG_VISIBILITY_VISIBLE)));\n        if (gtk_widget_get_visible(widget)) {\n          gdk_window_raise(gtk_widget_get_window(widget));\n        }\n      }\n    }\n  }\n}\n\nvoid gimp_dialog_factory_set_busy(GimpDialogFactory *factory)\n{\n  GdkDisplay *display = ((void *)0);\n  GdkCursor *cursor = ((void *)0);\n  GList *list;\n  if (!factory) {\n    return ;\n  }\n  for (list = factory -> p -> open_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GtkWidget *widget = (list -> data);\n    if ((({\n      GTypeInstance *__inst = (GTypeInstance *)widget;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) && gtk_widget_is_toplevel(widget)) \n{\n      if (!display || display != gtk_widget_get_display(widget)) {\n        display = gtk_widget_get_display(widget);\n        if (cursor) {\n          gdk_cursor_unref(cursor);\n        }\n        cursor = gimp_cursor_new(display,GIMP_CURSOR_FORMAT_BITMAP,GIMP_HANDEDNESS_RIGHT,(150),GIMP_TOOL_CURSOR_NONE,GIMP_CURSOR_MODIFIER_NONE);\n      }\n      if (gtk_widget_get_window(widget)) {\n        gdk_window_set_cursor(gtk_widget_get_window(widget),cursor);\n      }\n    }\n  }\n  if (cursor) {\n    gdk_cursor_unref(cursor);\n  }\n}\n\nvoid gimp_dialog_factory_unset_busy(GimpDialogFactory *factory)\n{\n  GList *list;\n  if (!factory) {\n    return ;\n  }\n  for (list = factory -> p -> open_dialogs; list; list = (list?((GList *)list) -> next : ((void *)0))) {\n    GtkWidget *widget = (list -> data);\n    if ((({\n      GTypeInstance *__inst = (GTypeInstance *)widget;\n      GType __t = gtk_widget_get_type();\n      gboolean __r;\n      if (!__inst) {\n        __r = 0;\n      }\n      else {\n        if (__inst -> g_class && __inst -> g_class -> g_type == __t) {\n          __r = !0;\n        }\n        else {\n          __r = g_type_check_instance_is_a(__inst,__t);\n        }\n      }\n      __r;\n    })) && gtk_widget_is_toplevel(widget)) \n{\n      if (gtk_widget_get_window(widget)) {\n        gdk_window_set_cursor(gtk_widget_get_window(widget),((void *)0));\n      }\n    }\n  }\n}\n/**\n * gimp_dialog_factory_get_singleton:\n *\n * Returns: The toplevel GimpDialogFactory instance.\n **/\n\nGimpDialogFactory *gimp_dialog_factory_get_singleton()\n{\n  do {\n    if (gimp_toplevel_factory != ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"gimp_toplevel_factory != NULL\");\n      return ((void *)0);\n    }\n    ;\n  }while (0);\n  return gimp_toplevel_factory;\n}\n/**\n * gimp_dialog_factory_set_singleton:\n * @:\n *\n * Set the toplevel GimpDialogFactory instance. Must only be called by\n * dialogs_init()!.\n **/\n\nvoid gimp_dialog_factory_set_singleton(GimpDialogFactory *factory)\n{\n  do {\n    if (gimp_toplevel_factory == ((void *)0) || factory == ((void *)0)) {\n    }\n    else {\n      g_return_if_fail_warning(\"Gimp-Widgets\",__PRETTY_FUNCTION__,\"gimp_toplevel_factory == NULL || factory == NULL\");\n      return ;\n    }\n    ;\n  }while (0);\n  gimp_toplevel_factory = factory;\n}\n\nvoid frowstiest_bonny(char *const bonnyish_windbreak)\n{\n  int owercome_devastations = 7;\n  ++stonesoup_global_variable;;\n  acrite_absyrtus(owercome_devastations,bonnyish_windbreak);\n}\n\nvoid acrite_absyrtus(int entryways_terebate,char *horologium_chiasso)\n{\n  MYSQL_ROW stonesoup_row;\n  unsigned int stonesoup_num_fields;\n  my_ulonglong stonesoup_num_rows;\n  MYSQL_RES *stonesoup_result;\n  int stonesoup_i;\n  int stonesoup_status;\n  char stonesoup_query_buffer[1000];\n  MYSQL *stonesoup_conn;\n  unsigned int stonesoup_dbport = 0;\n  char *stonesoup_dbpassword = 0;\n  char *stonesoup_dbuser = 0;\n  char *stonesoup_dbhost = 0;\n  char * stonesoup_dbdatabase = 0;\n  char stonesoup_use_str[150] = {0};\n  char *chavel_compasser = 0;\n  ++stonesoup_global_variable;\n  entryways_terebate--;\n  if (entryways_terebate > 0) {\n    anorchism_presides(entryways_terebate,horologium_chiasso);\n    return ;\n  }\n  chavel_compasser = ((char *)((char *)horologium_chiasso));\n      tracepoint(stonesoup_trace, weakness_start, \"CWE089\", \"A\", \"Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')\");\n      stonesoup_dbhost = getenv(\"DBMYSQLHOST\");\n      stonesoup_dbuser = getenv(\"DBMYSQLUSER\");\n      stonesoup_dbpassword = getenv(\"DBMYSQLPASSWORD\");\n      stonesoup_dbport = ((unsigned int )(strtoul(getenv(\"DBMYSQLPORT\"),0,10)));\n      stonesoup_dbdatabase = getenv(\"SS_DBMYSQLDATABASE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbhost\", stonesoup_dbhost, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbuser\", stonesoup_dbuser, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbpassword\", stonesoup_dbpassword, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_signed_integral, \"stonesoup_dbport\", stonesoup_dbport, &stonesoup_dbport, \"INITIAL-STATE\");\n      tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_dbdatabase\", stonesoup_dbdatabase, \"INITIAL-STATE\");\n      if (stonesoup_dbhost != 0 && stonesoup_dbport != 0 && (stonesoup_dbuser != 0 && stonesoup_dbpassword != 0)) {\n          stonesoup_conn = mysql_init(0);\n          if (stonesoup_conn != 0) {\n            if (mysql_real_connect(stonesoup_conn,stonesoup_dbhost,stonesoup_dbuser,stonesoup_dbpassword,0,stonesoup_dbport,\"/var/lib/mysql/mysql.sock\",65536UL) != 0) {\n              snprintf(stonesoup_use_str,150,\"USE %s;\", stonesoup_dbdatabase);\n              if (mysql_query(stonesoup_conn, stonesoup_use_str) == 0) {\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: BEFORE\");\n/* STONESOUP: CROSSOVER-POINT (Sql Injection) */\n                snprintf(stonesoup_query_buffer,1000,\"SELECT * FROM Customers WHERE Country='%s';\",chavel_compasser);\n                tracepoint(stonesoup_trace, variable_buffer, \"stonesoup_query_buffer\", stonesoup_query_buffer, \"CROSSOVER-STATE\");\n                tracepoint(stonesoup_trace, trace_point, \"CROSSOVER-POINT: AFTER\");\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: BEFORE\");\n/* STONESOUP: TRIGGER-POINT (Sql Injection) */\n                if (mysql_query(stonesoup_conn,stonesoup_query_buffer) == 0) {\n                  do {\n                    stonesoup_result = mysql_store_result(stonesoup_conn);\n                    if (stonesoup_result != 0) {\n                      stonesoup_num_rows = mysql_num_rows(stonesoup_result);\n                      if (stonesoup_num_rows != 0) {\n                        stonesoup_num_fields = mysql_num_fields(stonesoup_result);\n                        while((stonesoup_row = mysql_fetch_row(stonesoup_result))){\n                          for (stonesoup_i = 0; stonesoup_i < stonesoup_num_fields; ++stonesoup_i)\n                            stonesoup_printf(\"%s \",(stonesoup_row[stonesoup_i]?stonesoup_row[stonesoup_i] : \"NULL\"));\n                          stonesoup_printf(\"\\n\");\n                        }\n                        mysql_free_result(stonesoup_result);\n                      }\n                    }\n                    else {\n                      if (mysql_field_count(stonesoup_conn) == 0)\n                        stonesoup_printf(\"%lld rows affected\\n\",mysql_affected_rows(stonesoup_conn));\n                      else {\n                        stonesoup_printf(\"%s error %u: %s\\n\",\"Store result error\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n                        break;\n                      }\n                    }\n                    stonesoup_status = mysql_next_result(stonesoup_conn);\n                    if (stonesoup_status > 0)\n                      stonesoup_printf(\"%s error %u: %s\\n\",\"Next result error\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n                  }while (stonesoup_status == 0);\n                }\n                else {\n                  tracepoint(stonesoup_trace, trace_error, \"Query error\");\n                  stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n                }\n                tracepoint(stonesoup_trace, trace_point, \"TRIGGER-POINT: AFTER\");\n              }\n              else {\n                tracepoint(stonesoup_trace, trace_error, \"Query error\");\n                stonesoup_printf(\"%s error %u: %s\\n\",\"Query\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n              }\n              mysql_close(stonesoup_conn);\n            }\n            else {\n              tracepoint(stonesoup_trace, trace_error, \"Real connect error\");\n              stonesoup_printf(\"%s error %u: %s\\n\",\"Real connect\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n            }\n          }\n          else {\n            tracepoint(stonesoup_trace, trace_error, \"Init error\");\n            stonesoup_printf(\"%s error %u: %s\\n\",\"Init\",mysql_errno(stonesoup_conn),mysql_error(stonesoup_conn));\n          }\n      }\n      tracepoint(stonesoup_trace, weakness_end);\n;\n  if (((char *)horologium_chiasso) != 0) \n    free(((char *)((char *)horologium_chiasso)));\nstonesoup_close_printf_context();\n}\n\nvoid anorchism_presides(int klutzier_dalar,char *earlap_wat)\n{\n  ++stonesoup_global_variable;\n  acrite_absyrtus(klutzier_dalar,earlap_wat);\n}\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"sql_injection\",\n  \"severity\": \"critical\",\n  \"explanation\": \"This code constructs SQL queries by concatenating user input directly into the query string. Attackers can manipulate input to execute malicious SQL commands.\",\n  \"risk\": \"Database compromise, data theft, data manipulation, authentication bypass\",\n  \"compliant_patch\": \"\\n// FIXED: Use prepared statements with parameterized queries\\n// Instead of: query = \\\"SELECT * FROM users WHERE name = '\\\" + user_input + \\\"'\\\"\\n// Use: query = \\\"SELECT * FROM users WHERE name = ?\\\"\\n//       stmt = connection.prepareStatement(query);\\n//       stmt.setString(1, user_input);\\n//       result = stmt.executeQuery();\\n\",\n  \"source\": \"SARD-152843\",\n  \"cwe\": \"CWE-89\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* packet-dtls.c\n * Routines for dtls dissection\n * Copyright (c) 2006, Authesserre Samuel <sauthess@gmail.com>\n * Copyright (c) 2007, Mikael Magnusson <mikma@users.sourceforge.net>\n *\n * $Id: packet-dtls.c 43336 2012-06-18 17:26:50Z gerald $\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n *\n *\n * DTLS dissection and decryption.\n * See RFC 4347 for details about DTLS specs.\n *\n * Notes :\n * This dissector is based on the TLS dissector (packet-ssl.c); Because of the similarity\n *   of DTLS and TLS, decryption works like TLS with RSA key exchange.\n * This dissector uses the sames things (file, libraries) as the SSL dissector (gnutls, packet-ssl-utils.h)\n *  to make it easily maintainable.\n *\n * It was developed to dissect and decrypt the OpenSSL v 0.9.8f DTLS implementation.\n * It is limited to this implementation; there is no complete implementation.\n *\n * Implemented :\n *  - DTLS dissection\n *  - DTLS decryption (openssl one)\n *\n * Todo :\n *  - activate correct Mac calculation when openssl will be corrected\n *    (or if an other implementation works),\n *    corrected code is ready and commented in packet-ssl-utils.h file.\n *  - add missings things (desegmentation, reordering... that aren't present in actual OpenSSL implementation)\n */\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <glib.h>\n\n#include <epan/packet.h>\n#include <epan/conversation.h>\n#include <epan/prefs.h>\n#include <epan/asn1.h>\n#include <epan/dissectors/packet-x509af.h>\n#include <epan/emem.h>\n#include <epan/tap.h>\n#include <epan/reassemble.h>\n#include \"packet-ssl-utils.h\"\n#include <wsutil/file_util.h>\n#include <epan/uat.h>\n\n/* DTLS User Access Table */\nstatic ssldecrypt_assoc_t *dtlskeylist_uats = NULL;\nstatic guint ndtlsdecrypt = 0;\n\n/* we need to remember the top tree so that subdissectors we call are created\n * at the root and not deep down inside the DTLS decode\n */\nstatic proto_tree *top_tree;\n\n/*********************************************************************\n *\n * Protocol Constants, Variables, Data Structures\n *\n *********************************************************************/\n\n/* Initialize the protocol and registered fields */\nstatic gint dtls_tap                            = -1;\nstatic gint proto_dtls                          = -1;\nstatic gint hf_dtls_record                      = -1;\nstatic gint hf_dtls_record_content_type         = -1;\nstatic gint hf_dtls_record_version              = -1;\nstatic gint hf_dtls_record_epoch                = -1;\nstatic gint hf_dtls_record_sequence_number      = -1;\nstatic gint hf_dtls_record_length               = -1;\nstatic gint hf_dtls_record_appdata              = -1;\nstatic gint hf_dtls_change_cipher_spec          = -1;\nstatic gint hf_dtls_alert_message               = -1;\nstatic gint hf_dtls_alert_message_level         = -1;\nstatic gint hf_dtls_alert_message_description   = -1;\nstatic gint hf_dtls_handshake_protocol          = -1;\nstatic gint hf_dtls_handshake_type              = -1;\nstatic gint hf_dtls_handshake_length            = -1;\nstatic gint hf_dtls_handshake_message_seq       = -1;\nstatic gint hf_dtls_handshake_fragment_offset   = -1;\nstatic gint hf_dtls_handshake_fragment_length   = -1;\nstatic gint hf_dtls_handshake_client_version    = -1;\nstatic gint hf_dtls_handshake_server_version    = -1;\nstatic gint hf_dtls_handshake_random_time       = -1;\nstatic gint hf_dtls_handshake_random_bytes      = -1;\nstatic gint hf_dtls_handshake_cookie_len        = -1;\nstatic gint hf_dtls_handshake_cookie            = -1;\nstatic gint hf_dtls_handshake_cipher_suites_len = -1;\nstatic gint hf_dtls_handshake_cipher_suites     = -1;\nstatic gint hf_dtls_handshake_cipher_suite      = -1;\nstatic gint hf_dtls_handshake_session_id        = -1;\nstatic gint hf_dtls_handshake_comp_methods_len  = -1;\nstatic gint hf_dtls_handshake_comp_methods      = -1;\nstatic gint hf_dtls_handshake_comp_method       = -1;\nstatic gint hf_dtls_handshake_extensions_len    = -1;\nstatic gint hf_dtls_handshake_extension_type    = -1;\nstatic gint hf_dtls_handshake_extension_len     = -1;\nstatic gint hf_dtls_handshake_extension_data    = -1;\nstatic gint hf_dtls_handshake_session_ticket_lifetime_hint = -1;\nstatic gint hf_dtls_handshake_session_ticket_len = -1;\nstatic gint hf_dtls_handshake_session_ticket    = -1;\nstatic gint hf_dtls_handshake_certificates_len  = -1;\nstatic gint hf_dtls_handshake_certificates      = -1;\nstatic gint hf_dtls_handshake_certificate       = -1;\nstatic gint hf_dtls_handshake_certificate_len   = -1;\nstatic gint hf_dtls_handshake_cert_types_count  = -1;\nstatic gint hf_dtls_handshake_cert_types        = -1;\nstatic gint hf_dtls_handshake_cert_type         = -1;\nstatic gint hf_dtls_handshake_finished          = -1;\nstatic gint hf_dtls_handshake_md5_hash          = -1;\nstatic gint hf_dtls_handshake_sha_hash          = -1;\nstatic gint hf_dtls_handshake_session_id_len    = -1;\nstatic gint hf_dtls_handshake_dnames_len        = -1;\nstatic gint hf_dtls_handshake_dnames            = -1;\nstatic gint hf_dtls_handshake_dname_len         = -1;\nstatic gint hf_dtls_handshake_dname             = -1;\n\nstatic gint hf_dtls_heartbeat_extension_mode          = -1;\nstatic gint hf_dtls_heartbeat_message                 = -1;\nstatic gint hf_dtls_heartbeat_message_type            = -1;\nstatic gint hf_dtls_heartbeat_message_payload_length  = -1;\nstatic gint hf_dtls_heartbeat_message_payload         = -1;\nstatic gint hf_dtls_heartbeat_message_padding         = -1;\n\nstatic gint hf_dtls_fragments                   = -1;\nstatic gint hf_dtls_fragment                    = -1;\nstatic gint hf_dtls_fragment_overlap            = -1;\nstatic gint hf_dtls_fragment_overlap_conflicts  = -1;\nstatic gint hf_dtls_fragment_multiple_tails     = -1;\nstatic gint hf_dtls_fragment_too_long_fragment  = -1;\nstatic gint hf_dtls_fragment_error              = -1;\nstatic gint hf_dtls_fragment_count              = -1;\nstatic gint hf_dtls_reassembled_in              = -1;\nstatic gint hf_dtls_reassembled_length          = -1;\n\n/* Initialize the subtree pointers */\nstatic gint ett_dtls                   = -1;\nstatic gint ett_dtls_record            = -1;\nstatic gint ett_dtls_alert             = -1;\nstatic gint ett_dtls_handshake         = -1;\nstatic gint ett_dtls_heartbeat         = -1;\nstatic gint ett_dtls_cipher_suites     = -1;\nstatic gint ett_dtls_comp_methods      = -1;\nstatic gint ett_dtls_extension         = -1;\nstatic gint ett_dtls_new_ses_ticket    = -1;\nstatic gint ett_dtls_certs             = -1;\nstatic gint ett_dtls_cert_types        = -1;\nstatic gint ett_dtls_dnames            = -1;\n\nstatic gint ett_dtls_fragment          = -1;\nstatic gint ett_dtls_fragments         = -1;\n\nstatic GHashTable         *dtls_session_hash         = NULL;\nstatic GHashTable         *dtls_key_hash             = NULL;\nstatic GHashTable         *dtls_fragment_table       = NULL;\nstatic GTree*              dtls_associations         = NULL;\nstatic dissector_handle_t  dtls_handle               = NULL;\nstatic StringInfo          dtls_compressed_data      = {NULL, 0};\nstatic StringInfo          dtls_decrypted_data       = {NULL, 0};\nstatic gint                dtls_decrypted_data_avail = 0;\n\nstatic uat_t *dtlsdecrypt_uat      = NULL;\nstatic const gchar *dtls_keys_list = NULL;\n#ifdef HAVE_LIBGNUTLS\nstatic const gchar *dtls_debug_file_name = NULL;\n#endif\n\nstatic heur_dissector_list_t heur_subdissector_list;\n\nstatic const fragment_items dtls_frag_items = {\n  /* Fragment subtrees */\n  &ett_dtls_fragment,\n  &ett_dtls_fragments,\n  /* Fragment fields */\n  &hf_dtls_fragments,\n  &hf_dtls_fragment,\n  &hf_dtls_fragment_overlap,\n  &hf_dtls_fragment_overlap_conflicts,\n  &hf_dtls_fragment_multiple_tails,\n  &hf_dtls_fragment_too_long_fragment,\n  &hf_dtls_fragment_error,\n  &hf_dtls_fragment_count,\n  /* Reassembled in field */\n  &hf_dtls_reassembled_in,\n  /* Reassembled length field */\n  &hf_dtls_reassembled_length,\n  /* Tag */\n  \"Message fragments\"\n};\n\n/* initialize/reset per capture state data (dtls sessions cache) */\nstatic void\ndtls_init(void)\n{\n  module_t *dtls_module = prefs_find_module(\"dtls\");\n  pref_t   *keys_list_pref;\n\n  ssl_common_init(&dtls_session_hash, &dtls_decrypted_data, &dtls_compressed_data);\n  fragment_table_init (&dtls_fragment_table);\n\n  /* We should have loaded \"keys_list\" by now. Mark it obsolete */\n  if (dtls_module) {\n    keys_list_pref = prefs_find_preference(dtls_module, \"keys_list\");\n    if (! prefs_get_preference_obsolete(keys_list_pref)) {\n      prefs_set_preference_obsolete(keys_list_pref);\n    }\n  }\n}\n\n/* parse dtls related preferences (private keys and ports association strings) */\nstatic void\ndtls_parse_uat(void)\n{\n  ep_stack_t       tmp_stack;\n  SslAssociation  *tmp_assoc;\n  guint            i;\n\n  if (dtls_key_hash)\n  {\n      g_hash_table_foreach(dtls_key_hash, ssl_private_key_free, NULL);\n      g_hash_table_destroy(dtls_key_hash);\n  }\n\n  /* remove only associations created from key list */\n  tmp_stack = ep_stack_new();\n  g_tree_foreach(dtls_associations, ssl_assoc_from_key_list, tmp_stack);\n  while ((tmp_assoc = ep_stack_pop(tmp_stack)) != NULL) {\n    ssl_association_remove(dtls_associations, tmp_assoc);\n  }\n\n  /* parse private keys string, load available keys and put them in key hash*/\n  dtls_key_hash = g_hash_table_new(ssl_private_key_hash, ssl_private_key_equal);\n\n  ssl_set_debug(dtls_debug_file_name);\n\n  if (ndtlsdecrypt > 0)\n  {\n    for (i = 0; i < ndtlsdecrypt; i++)\n    {\n      ssldecrypt_assoc_t *d = &(dtlskeylist_uats[i]);\n      ssl_parse_key_list(d, dtls_key_hash, dtls_associations, dtls_handle, FALSE);\n    }\n  }\n\n  dissector_add_handle(\"sctp.port\", dtls_handle);\n  dissector_add_handle(\"udp.port\", dtls_handle);\n}\n\nstatic void\ndtls_parse_old_keys(void)\n{\n  gchar          **old_keys, **parts, *err;\n  guint            i;\n  GString         *uat_entry = g_string_new(\"\");\n\n  /* Import old-style keys */\n  if (dtlsdecrypt_uat && dtls_keys_list && dtls_keys_list[0]) {\n    old_keys = g_strsplit(dtls_keys_list, \";\", 0);\n    for (i = 0; old_keys[i] != NULL; i++) {\n      parts = g_strsplit(old_keys[i], \",\", 4);\n      if (parts[0] && parts[1] && parts[2] && parts[3]) {\n        g_string_printf(uat_entry, \"\\\"%s\\\",\\\"%s\\\",\\\"%s\\\",\\\"%s\\\",\\\"\\\"\",\n                        parts[0], parts[1], parts[2], parts[3]);\n        if (!uat_load_str(dtlsdecrypt_uat, uat_entry->str, &err)) {\n          ssl_debug_printf(\"dtls_parse: Can't load UAT string %s: %s\\n\",\n                           uat_entry->str, err);\n        }\n      }\n      g_strfreev(parts);\n    }\n    g_strfreev(old_keys);\n  }\n  g_string_free(uat_entry, TRUE);\n\n}\n\n/*\n * DTLS Dissection Routines\n *\n */\n\n/* record layer dissector */\nstatic gint dissect_dtls_record(tvbuff_t *tvb, packet_info *pinfo,\n                                proto_tree *tree, guint32 offset,\n                                guint *conv_version,\n                                SslDecryptSession *conv_data);\n\n/* change cipher spec dissector */\nstatic void dissect_dtls_change_cipher_spec(tvbuff_t *tvb,\n                                            proto_tree *tree,\n                                            guint32 offset,\n                                            guint *conv_version, guint8 content_type);\n\n/* alert message dissector */\nstatic void dissect_dtls_alert(tvbuff_t *tvb, packet_info *pinfo,\n                               proto_tree *tree, guint32 offset,\n                               guint *conv_version);\n\n/* handshake protocol dissector */\nstatic void dissect_dtls_handshake(tvbuff_t *tvb, packet_info *pinfo,\n                                   proto_tree *tree, guint32 offset,\n                                   guint32 record_length,\n                                   guint *conv_version,\n                                   SslDecryptSession *conv_data, guint8 content_type);\n\n/* heartbeat message dissector */\nstatic void dissect_dtls_heartbeat(tvbuff_t *tvb, packet_info *pinfo,\n                                   proto_tree *tree, guint32 offset,\n                                   guint *conv_version, guint32 record_length);\n\n\nstatic void dissect_dtls_hnd_cli_hello(tvbuff_t *tvb,\n                                       proto_tree *tree,\n                                       guint32 offset, guint32 length,\n                                       SslDecryptSession* ssl);\n\nstatic int dissect_dtls_hnd_srv_hello(tvbuff_t *tvb,\n                                       proto_tree *tree,\n                                       guint32 offset, guint32 length,\n                                       SslDecryptSession* ssl);\n\nstatic int dissect_dtls_hnd_hello_verify_request(tvbuff_t *tvb,\n                                                  proto_tree *tree,\n                                                  guint32 offset,\n                                                  SslDecryptSession* ssl);\n\nstatic void dissect_dtls_hnd_new_ses_ticket(tvbuff_t *tvb,\n                                       proto_tree *tree,\n                                       guint32 offset, guint32 length);\n\nstatic void dissect_dtls_hnd_cert(tvbuff_t *tvb,\n                                  proto_tree *tree, guint32 offset, packet_info *pinfo);\n\nstatic void dissect_dtls_hnd_cert_req(tvbuff_t *tvb,\n                                      proto_tree *tree,\n                                      guint32 offset);\n\nstatic void dissect_dtls_hnd_finished(tvbuff_t *tvb,\n                                      proto_tree *tree,\n                                      guint32 offset,\n                                      guint* conv_version);\n\n/*\n * Support Functions\n *\n */\n/*static void ssl_set_conv_version(packet_info *pinfo, guint version);*/\nstatic gint  dtls_is_valid_handshake_type(guint8 type);\n\nstatic gint  dtls_is_authoritative_version_message(guint8 content_type,\n                                                   guint8 next_byte);\nstatic gint  looks_like_dtls(tvbuff_t *tvb, guint32 offset);\n\n/*********************************************************************\n *\n * Main dissector\n *\n *********************************************************************/\n/*\n * Code to actually dissect the packets\n */\nstatic void\ndissect_dtls(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n\n  conversation_t    *conversation;\n  void              *conv_data;\n  proto_item        *ti;\n  proto_tree        *dtls_tree;\n  guint32            offset;\n  gboolean           first_record_in_frame;\n  SslDecryptSession *ssl_session;\n  guint*             conv_version;\n  Ssl_private_key_t *private_key;\n\n  ti                    = NULL;\n  dtls_tree             = NULL;\n  offset                = 0;\n  first_record_in_frame = TRUE;\n  ssl_session           = NULL;\n  top_tree              = tree;\n\n  /* Track the version using conversations allows\n   * us to more frequently set the protocol column properly\n   * for continuation data frames.\n   *\n   * Also: We use the copy in conv_version as our cached copy,\n   *       so that we don't have to search the conversation\n   *       table every time we want the version; when setting\n   *       the conv_version, must set the copy in the conversation\n   *       in addition to conv_version\n   */\n  conversation = find_or_create_conversation(pinfo);\n  conv_data    = conversation_get_proto_data(conversation, proto_dtls);\n\n  /* manage dtls decryption data */\n  /*get a valid ssl session pointer*/\n  if (conv_data != NULL)\n    ssl_session = conv_data;\n  else {\n    SslService dummy;\n\n    ssl_session = se_alloc0(sizeof(SslDecryptSession));\n    ssl_session_init(ssl_session);\n    ssl_session->version = SSL_VER_UNKNOWN;\n    conversation_add_proto_data(conversation, proto_dtls, ssl_session);\n\n    /* we need to know witch side of conversation is speaking */\n    if (ssl_packet_from_server(ssl_session, dtls_associations, pinfo)) {\n      dummy.addr = pinfo->src;\n      dummy.port = pinfo->srcport;\n    }\n    else {\n      dummy.addr = pinfo->dst;\n      dummy.port = pinfo->destport;\n    }\n    ssl_debug_printf(\"dissect_dtls server %s:%d\\n\",\n                     ep_address_to_str(&dummy.addr),dummy.port);\n\n    /* try to retrive private key for this service. Do it now 'cause pinfo\n     * is not always available\n     * Note that with HAVE_LIBGNUTLS undefined private_key is allways 0\n     * and thus decryption never engaged*/\n    private_key = g_hash_table_lookup(dtls_key_hash, &dummy);\n    if (!private_key) {\n      ssl_debug_printf(\"dissect_dtls can't find private key for this server!\\n\");\n    }\n    else {\n      ssl_session->private_key = private_key->sexp_pkey;\n    }\n  }\n  conv_version= & ssl_session->version;\n\n  /* try decryption only the first time we see this packet\n   * (to keep cipher synchronized) */\n  if (pinfo->fd->flags.visited)\n    ssl_session = NULL;\n\n  /* Initialize the protocol column; we'll set it later when we\n   * figure out what flavor of DTLS it is (actually only one\n   version exists). */\n  col_set_str(pinfo->cinfo, COL_PROTOCOL, \"DTLS\");\n\n  /* clear the the info column */\n  col_clear(pinfo->cinfo, COL_INFO);\n\n  /* Create display subtree for SSL as a whole */\n  if (tree)\n    {\n      ti = proto_tree_add_item(tree, proto_dtls, tvb, 0, -1, ENC_NA);\n      dtls_tree = proto_item_add_subtree(ti, ett_dtls);\n    }\n\n  /* iterate through the records in this tvbuff */\n  while (tvb_reported_length_remaining(tvb, offset) != 0)\n    {\n      /* on second and subsequent records per frame\n       * add a delimiter on info column\n       */\n      if (!first_record_in_frame)\n        {\n          col_append_str(pinfo->cinfo, COL_INFO, \", \");\n        }\n\n      /* first try to dispatch off the cached version\n       * known to be associated with the conversation\n       */\n      switch(*conv_version) {\n      case SSL_VER_DTLS:\n        offset = dissect_dtls_record(tvb, pinfo, dtls_tree,\n                                     offset, conv_version,\n                                     ssl_session);\n        break;\n      case SSL_VER_DTLS1DOT2:\n        offset = dissect_dtls_record(tvb, pinfo, dtls_tree,\n                                     offset, conv_version,\n                                     ssl_session);\n        break;\n\n        /* that failed, so apply some heuristics based\n         * on this individual packet\n         */\n      default:\n        if (looks_like_dtls(tvb, offset))\n          {\n            /* looks like dtls */\n            offset = dissect_dtls_record(tvb, pinfo, dtls_tree,\n                                         offset, conv_version,\n                                         ssl_session);\n          }\n        else\n          {\n            /* looks like something unknown, so lump into\n             * continuation data\n             */\n            offset = tvb_length(tvb);\n            col_append_str(pinfo->cinfo, COL_INFO,\n                             \"Continuation Data\");\n\n            /* Set the protocol column */\n            col_set_str(pinfo->cinfo, COL_PROTOCOL, \"DTLS\");\n          }\n        break;\n      }\n\n      /* set up for next record in frame, if any */\n      first_record_in_frame = FALSE;\n    }\n\n  tap_queue_packet(dtls_tap, pinfo, NULL);\n}\n\nstatic gboolean\ndissect_dtls_heur(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n  /* Stronger confirmation of DTLS packet is provided by verifying the\n   * payload length against the remainder of the UDP packet size. */\n  guint length = tvb_length(tvb);\n  guint offset = 0;\n\n  if (tvb_reported_length(tvb) == length) {\n    while (offset + 13 <= length && looks_like_dtls(tvb, offset)) {\n      /* Advance offset to the end of the current DTLS record */\n      offset += tvb_get_ntohs(tvb, offset + 11) + 13;\n      if (offset == length) {\n        dissect_dtls(tvb, pinfo, tree);\n        return TRUE;\n      }\n    }\n\n    if (pinfo->fragmented && offset >= 13) {\n      dissect_dtls(tvb, pinfo, tree);\n      return TRUE;\n    }\n    return FALSE;\n  }\n\n  /* We've got a truncated packet - do our best with what we've got. */\n  while (tvb_length_remaining(tvb, offset) >= 3) {\n    if (!looks_like_dtls(tvb, offset))\n      return FALSE;\n\n    offset += 3;\n    if (tvb_length_remaining(tvb, offset) >= 10 ) {\n      offset += tvb_get_ntohs(tvb, offset + 8) + 10;\n    } else {\n      /* Dissect what we've got, which might be as little as 3 bytes. */\n      dissect_dtls(tvb, pinfo, tree);\n      return TRUE;\n    }\n    if (offset == length) {\n      /* Can this ever happen?  Well, just in case ... */\n      dissect_dtls(tvb, pinfo, tree);\n      return TRUE;\n    }\n  }\n\n  /* One last check to see if the current offset is at least less than the\n   * original number of bytes present before truncation or we're dealing with\n   * a packet fragment that's also been truncated. */\n  if ((length >= 3) && (offset <= tvb_reported_length(tvb) || pinfo->fragmented)) {\n    dissect_dtls(tvb, pinfo, tree);\n    return TRUE;\n  }\n  return FALSE;\n}\n\nstatic gint\ndecrypt_dtls_record(tvbuff_t *tvb, packet_info *pinfo, guint32 offset,\n                    guint32 record_length, guint8 content_type, SslDecryptSession* ssl,\n                    gboolean save_plaintext)\n{\n  gint        ret;\n  SslDecoder *decoder;\n\n  ret = 0;\n\n  /* if we can decrypt and decryption have success\n   * add decrypted data to this packet info */\n  ssl_debug_printf(\"decrypt_dtls_record: app_data len %d, ssl state %X\\n\",\n                   record_length, ssl->state);\n  if (!ssl || (!save_plaintext && !(ssl->state & SSL_HAVE_SESSION_KEY))) {\n    ssl_debug_printf(\"decrypt_dtls_record: no session key\\n\");\n    return ret;\n  }\n\n  /* retrieve decoder for this packet direction */\n  if (ssl_packet_from_server(ssl, dtls_associations, pinfo) != 0) {\n    ssl_debug_printf(\"decrypt_dtls_record: using server decoder\\n\");\n    decoder = ssl->server;\n  }\n  else {\n    ssl_debug_printf(\"decrypt_dtls_record: using client decoder\\n\");\n    decoder = ssl->client;\n  }\n\n  if (!decoder && ssl->cipher != 0x0001 && ssl->cipher != 0x0002) {\n    ssl_debug_printf(\"decrypt_dtls_record: no decoder available\\n\");\n    return ret;\n  }\n\n  /* ensure we have enough storage space for decrypted data */\n  if (record_length > dtls_decrypted_data.data_len)\n    {\n      ssl_debug_printf(\"decrypt_dtls_record: allocating %d bytes\"\n                       \" for decrypt data (old len %d)\\n\",\n                       record_length + 32, dtls_decrypted_data.data_len);\n      dtls_decrypted_data.data = g_realloc(dtls_decrypted_data.data,\n                                           record_length + 32);\n      dtls_decrypted_data.data_len = record_length + 32;\n    }\n\n  /* run decryption and add decrypted payload to protocol data, if decryption\n   * is successful*/\n  dtls_decrypted_data_avail = dtls_decrypted_data.data_len;\n  if (ssl->state & SSL_HAVE_SESSION_KEY) {\n    if (!decoder) {\n      ssl_debug_printf(\"decrypt_dtls_record: no decoder available\\n\");\n      return ret;\n    }\n    if (ssl_decrypt_record(ssl, decoder, content_type, tvb_get_ptr(tvb, offset, record_length), record_length,\n                           &dtls_compressed_data, &dtls_decrypted_data, &dtls_decrypted_data_avail) == 0)\n      ret = 1;\n  }\n  else if (ssl->cipher == 0x0001 || ssl->cipher == 0x0002) {\n    /* Non-encrypting cipher RSA-NULL-MD5 or RSA-NULL-SHA */\n    memcpy(dtls_decrypted_data.data, tvb_get_ptr(tvb, offset, record_length), record_length);\n    dtls_decrypted_data_avail = dtls_decrypted_data.data_len = record_length;\n    ret = 1;\n  }\n\n  if (ret && save_plaintext) {\n    ssl_add_data_info(proto_dtls, pinfo, dtls_decrypted_data.data, dtls_decrypted_data_avail,\n                      tvb_raw_offset(tvb)+offset, 0);\n  }\n\n  return ret;\n}\n\n\n\n\n\n/*********************************************************************\n *\n * DTLS Dissection Routines\n *\n *********************************************************************/\nstatic gint\ndissect_dtls_record(tvbuff_t *tvb, packet_info *pinfo,\n                    proto_tree *tree, guint32 offset,\n                    guint *conv_version,\n                    SslDecryptSession* ssl)\n{\n\n  /*\n   *    struct {\n   *        uint8 major, minor;\n   *    } ProtocolVersion;\n   *\n   *\n   *    enum {\n   *        change_cipher_spec(20), alert(21), handshake(22),\n   *        application_data(23), (255)\n   *    } ContentType;\n   *\n   *    struct {\n   *        ContentType type;\n   *        ProtocolVersion version;\n   *        uint16 epoch;               // New field\n   *        uint48 sequence_number;     // New field\n   *        uint16 length;\n   *        opaque fragment[TLSPlaintext.length];\n   *    } DTLSPlaintext;\n   */\n\n  guint32         record_length;\n  guint16         version;\n  guint16         epoch;\n  gdouble         sequence_number;\n  gint64          sequence_number_temp;\n  guint8          content_type;\n  guint8          next_byte;\n  proto_tree     *ti;\n  proto_tree     *dtls_record_tree;\n  SslAssociation *association;\n  SslDataInfo    *appl_data;\n\n  ti               = NULL;\n  dtls_record_tree = NULL;\n\n  /*\n   * Get the record layer fields of interest\n   */\n  content_type          = tvb_get_guint8(tvb, offset);\n  version               = tvb_get_ntohs(tvb, offset + 1);\n  epoch                 = tvb_get_ntohs(tvb, offset + 3);\n  sequence_number       = tvb_get_ntohl(tvb, offset + 7);\n  sequence_number_temp  = tvb_get_ntohs(tvb, offset + 5);\n  sequence_number_temp  = sequence_number_temp<<32;\n  sequence_number      += sequence_number_temp;\n  record_length         = tvb_get_ntohs(tvb, offset + 11);\n\n  if(ssl){\n    if(ssl_packet_from_server(ssl, dtls_associations, pinfo)){\n     if (ssl->server) {\n      ssl->server->seq=(guint32)sequence_number;\n      ssl->server->epoch=epoch;\n     }\n    }\n    else{\n     if (ssl->client) {\n      ssl->client->seq=(guint32)sequence_number;\n      ssl->client->epoch=epoch;\n     }\n    }\n  }\n  if (!ssl_is_valid_content_type(content_type)) {\n\n    /* if we don't have a valid content_type, there's no sense\n     * continuing any further\n     */\n    col_append_str(pinfo->cinfo, COL_INFO, \"Continuation Data\");\n\n    /* Set the protocol column */\n    col_set_str(pinfo->cinfo, COL_PROTOCOL, \"DTLS\");\n    return offset + 13 + record_length;\n  }\n\n  /*\n   * If GUI, fill in record layer part of tree\n   */\n\n  if (tree)\n    {\n      /* add the record layer subtree header */\n      tvb_ensure_bytes_exist(tvb, offset, 13 + record_length);\n      ti = proto_tree_add_item(tree, hf_dtls_record, tvb,\n                               offset, 13 + record_length, ENC_NA);\n      dtls_record_tree = proto_item_add_subtree(ti, ett_dtls_record);\n    }\n\n  if (dtls_record_tree)\n    {\n\n      /* show the one-byte content type */\n      proto_tree_add_item(dtls_record_tree, hf_dtls_record_content_type,\n                          tvb, offset, 1, ENC_BIG_ENDIAN);\n      offset++;\n\n      /* add the version */\n      proto_tree_add_item(dtls_record_tree, hf_dtls_record_version, tvb,\n                          offset, 2, ENC_BIG_ENDIAN);\n      offset += 2;\n\n      /* show epoch */\n      proto_tree_add_uint(dtls_record_tree, hf_dtls_record_epoch, tvb, offset, 2, epoch);\n\n      offset += 2;\n\n      /* add sequence_number */\n\n      proto_tree_add_double(dtls_record_tree, hf_dtls_record_sequence_number, tvb, offset, 6, sequence_number);\n\n      offset += 6;\n\n      /* add the length */\n      proto_tree_add_uint(dtls_record_tree, hf_dtls_record_length, tvb,\n                          offset, 2, record_length);\n      offset += 2;    /* move past length field itself */\n\n    }\n  else\n    {\n      /* if no GUI tree, then just skip over those fields */\n      offset += 13;\n    }\n\n\n  /*\n   * if we don't already have a version set for this conversation,\n   * but this message's version is authoritative (i.e., it's\n   * not client_hello, then save the version to to conversation\n   * structure and print the column version\n   */\n  next_byte = tvb_get_guint8(tvb, offset);\n  if (*conv_version == SSL_VER_UNKNOWN\n      && dtls_is_authoritative_version_message(content_type, next_byte))\n    {\n      if (version == DTLSV1DOT0_VERSION ||\n          version == DTLSV1DOT0_VERSION_NOT)\n        {\n\n          *conv_version = SSL_VER_DTLS;\n          if (ssl) {\n            ssl->version_netorder = version;\n            ssl->state |= SSL_VERSION;\n          }\n          /*ssl_set_conv_version(pinfo, ssl->version);*/\n        }\n      if (version == DTLSV1DOT2_VERSION)\n        {\n\n          *conv_version = SSL_VER_DTLS1DOT2;\n          if (ssl) {\n            ssl->version_netorder = version;\n            ssl->state |= SSL_VERSION;\n          }\n          /*ssl_set_conv_version(pinfo, ssl->version);*/\n        }\n    }\n  if (check_col(pinfo->cinfo, COL_PROTOCOL))\n    {\n      if (version == DTLSV1DOT0_VERSION)\n        {\n          col_set_str(pinfo->cinfo, COL_PROTOCOL,\n                      val_to_str_const(SSL_VER_DTLS, ssl_version_short_names, \"SSL\"));\n        }\n      else if (version == DTLSV1DOT2_VERSION)\n        {\n          col_set_str(pinfo->cinfo, COL_PROTOCOL,\n                      val_to_str_const(SSL_VER_DTLS1DOT2, ssl_version_short_names, \"SSL\"));\n        }\n      else\n        {\n          col_set_str(pinfo->cinfo, COL_PROTOCOL,\"DTLS\");\n        }\n    }\n\n  /*\n   * now dissect the next layer\n   */\n  ssl_debug_printf(\"dissect_dtls_record: content_type %d\\n\",content_type);\n\n  /* PAOLO try to decrypt each record (we must keep ciphers \"in sync\")\n   * store plain text only for app data */\n\n  switch (content_type) {\n  case SSL_ID_CHG_CIPHER_SPEC:\n    col_append_str(pinfo->cinfo, COL_INFO, \"Change Cipher Spec\");\n    dissect_dtls_change_cipher_spec(tvb, dtls_record_tree,\n                                    offset, conv_version, content_type);\n    if (ssl) ssl_change_cipher(ssl, ssl_packet_from_server(ssl, dtls_associations, pinfo));\n    break;\n  case SSL_ID_ALERT:\n    {\n      tvbuff_t* decrypted;\n      decrypted = 0;\n      if (ssl&&decrypt_dtls_record(tvb, pinfo, offset,\n                                   record_length, content_type, ssl, FALSE))\n        ssl_add_record_info(proto_dtls, pinfo, dtls_decrypted_data.data,\n                            dtls_decrypted_data_avail, offset);\n\n      /* try to retrive and use decrypted alert record, if any. */\n      decrypted = ssl_get_record_info(tvb, proto_dtls, pinfo, offset);\n      if (decrypted) {\n        dissect_dtls_alert(decrypted, pinfo, dtls_record_tree, 0,\n                           conv_version);\n        add_new_data_source(pinfo, decrypted, \"Decrypted SSL record\");\n      } else {\n        dissect_dtls_alert(tvb, pinfo, dtls_record_tree, offset,\n                           conv_version);\n      }\n      break;\n    }\n  case SSL_ID_HANDSHAKE:\n    {\n      tvbuff_t* decrypted;\n      decrypted = 0;\n      /* try to decrypt handshake record, if possible. Store decrypted\n       * record for later usage. The offset is used as 'key' to itentify\n       * this record into the packet (we can have multiple handshake records\n       * in the same frame) */\n      if (ssl && decrypt_dtls_record(tvb, pinfo, offset,\n                                     record_length, content_type, ssl, FALSE))\n        ssl_add_record_info(proto_dtls, pinfo, dtls_decrypted_data.data,\n                            dtls_decrypted_data_avail, offset);\n\n      /* try to retrive and use decrypted handshake record, if any. */\n      decrypted = ssl_get_record_info(tvb, proto_dtls, pinfo, offset);\n      if (decrypted) {\n        dissect_dtls_handshake(decrypted, pinfo, dtls_record_tree, 0,\n                               tvb_length(decrypted), conv_version, ssl, content_type);\n        add_new_data_source(pinfo, decrypted, \"Decrypted SSL record\");\n      } else {\n        dissect_dtls_handshake(tvb, pinfo, dtls_record_tree, offset,\n                               record_length, conv_version, ssl, content_type);\n      }\n      break;\n    }\n  case SSL_ID_APP_DATA:\n    if (ssl)\n      decrypt_dtls_record(tvb, pinfo, offset,\n                          record_length, content_type, ssl, TRUE);\n\n    /* show on info colum what we are decoding */\n    col_append_str(pinfo->cinfo, COL_INFO, \"Application Data\");\n\n    if (!dtls_record_tree)\n      break;\n\n    /* we need dissector information when the selected packet is shown.\n     * ssl session pointer is NULL at that time, so we can't access\n     * info cached there*/\n    association = ssl_association_find(dtls_associations, pinfo->srcport, pinfo->ptype == PT_TCP);\n    association = association ? association : ssl_association_find(dtls_associations, pinfo->destport, pinfo->ptype == PT_TCP);\n\n    proto_item_set_text(dtls_record_tree,\n                        \"%s Record Layer: %s Protocol: %s\",\n                        val_to_str_const(*conv_version, ssl_version_short_names, \"SSL\"),\n                        val_to_str(content_type, ssl_31_content_type, \"unknown\"),\n                        association?association->info:\"Application Data\");\n\n    /* show decrypted data info, if available */\n    appl_data = ssl_get_data_info(proto_dtls, pinfo, tvb_raw_offset(tvb)+offset);\n    if (appl_data && (appl_data->plain_data.data_len > 0))\n      {\n        tvbuff_t *next_tvb;\n        gboolean  dissected;\n        /* try to dissect decrypted data*/\n        ssl_debug_printf(\"dissect_dtls_record decrypted len %d\\n\",\n                         appl_data->plain_data.data_len);\n\n        /* create a new TVB structure for desegmented data */\n        next_tvb = tvb_new_child_real_data(tvb,\n                                           appl_data->plain_data.data,\n                                           appl_data->plain_data.data_len,\n                                           appl_data->plain_data.data_len);\n\n        add_new_data_source(pinfo, next_tvb, \"Decrypted DTLS data\");\n\n        /* find out a dissector using server port*/\n        if (association && association->handle) {\n          ssl_debug_printf(\"dissect_dtls_record found association %p\\n\", (void *)association);\n          ssl_print_text_data(\"decrypted app data\",appl_data->plain_data.data, appl_data->plain_data.data_len);\n\n          dissected = call_dissector_only(association->handle, next_tvb, pinfo, top_tree);\n        }\n        else {\n          /* try heuristic subdissectors */\n          dissected = dissector_try_heuristic(heur_subdissector_list, next_tvb, pinfo, top_tree);\n        }\n        if (dissected)\n          break;\n      }\n\n    proto_tree_add_item(dtls_record_tree, hf_dtls_record_appdata, tvb,\n                        offset, record_length, ENC_NA);\n    break;\n  case SSL_ID_HEARTBEAT:\n  {\n    tvbuff_t* decrypted;\n\n    if (ssl && decrypt_dtls_record(tvb, pinfo, offset,\n                                   record_length, content_type, ssl, FALSE))\n      ssl_add_record_info(proto_dtls, pinfo, dtls_decrypted_data.data,\n                          dtls_decrypted_data_avail, offset);\n\n    /* try to retrive and use decrypted alert record, if any. */\n    decrypted = ssl_get_record_info(tvb, proto_dtls, pinfo, offset);\n    if (decrypted) {\n      dissect_dtls_heartbeat(decrypted, pinfo, dtls_record_tree, 0,\n                             conv_version, record_length);\n      add_new_data_source(pinfo, decrypted, \"Decrypted SSL record\");\n    } else {\n      dissect_dtls_heartbeat(tvb, pinfo, dtls_record_tree, offset,\n                             conv_version, record_length);\n    }\n    break;\n  }\n\n  default:\n    /* shouldn't get here since we check above for valid types */\n    col_append_str(pinfo->cinfo, COL_INFO, \"Bad DTLS Content Type\");\n    break;\n  }\n  offset += record_length; /* skip to end of record */\n\n  return offset;\n}\n\n/* dissects the change cipher spec procotol, filling in the tree */\nstatic void\ndissect_dtls_change_cipher_spec(tvbuff_t *tvb,\n                                proto_tree *tree, guint32 offset,\n                                guint* conv_version, guint8 content_type)\n{\n  /*\n   * struct {\n   *     enum { change_cipher_spec(1), (255) } type;\n   * } ChangeCipherSpec;\n   *\n   */\n  if (tree)\n    {\n      proto_item_set_text(tree,\n                          \"%s Record Layer: %s Protocol: Change Cipher Spec\",\n                          val_to_str_const(*conv_version, ssl_version_short_names, \"SSL\"),\n                          val_to_str(content_type, ssl_31_content_type, \"unknown\"));\n      proto_tree_add_item(tree, hf_dtls_change_cipher_spec, tvb,\n                          offset, 1, ENC_NA);\n    }\n}\n\n/* dissects the alert message, filling in the tree */\nstatic void\ndissect_dtls_alert(tvbuff_t *tvb, packet_info *pinfo,\n                   proto_tree *tree, guint32 offset,\n                   guint* conv_version)\n{\n  /*     struct {\n   *         AlertLevel level;\n   *         AlertDescription description;\n   *     } Alert;\n   */\n\n  proto_tree  *ti;\n  proto_tree  *ssl_alert_tree;\n  const gchar *level;\n  const gchar *desc;\n  guint8       byte;\n\n  ssl_alert_tree = NULL;\n\n  if (tree)\n    {\n      ti = proto_tree_add_item(tree, hf_dtls_alert_message, tvb,\n                               offset, 2, ENC_NA);\n      ssl_alert_tree = proto_item_add_subtree(ti, ett_dtls_alert);\n    }\n\n  /*\n   * set the record layer label\n   */\n\n  /* first lookup the names for the alert level and description */\n  byte  = tvb_get_guint8(tvb, offset); /* grab the level byte */\n  level = match_strval(byte, ssl_31_alert_level);\n\n  byte  = tvb_get_guint8(tvb, offset+1); /* grab the desc byte */\n  desc  = match_strval(byte, ssl_31_alert_description);\n\n  /* now set the text in the record layer line */\n  if (level && desc)\n    {\n      if (check_col(pinfo->cinfo, COL_INFO))\n        col_append_fstr(pinfo->cinfo, COL_INFO,\n                        \"Alert (Level: %s, Description: %s)\",\n                        level, desc);\n    }\n  else\n    {\n      col_append_str(pinfo->cinfo, COL_INFO, \"Encrypted Alert\");\n    }\n\n  if (tree)\n    {\n      if (level && desc)\n        {\n          proto_item_set_text(tree, \"%s Record Layer: Alert \"\n                              \"(Level: %s, Description: %s)\",\n                              val_to_str_const(*conv_version, ssl_version_short_names, \"SSL\"),\n                              level, desc);\n          proto_tree_add_item(ssl_alert_tree, hf_dtls_alert_message_level,\n                              tvb, offset++, 1, ENC_BIG_ENDIAN);\n\n          proto_tree_add_item(ssl_alert_tree, hf_dtls_alert_message_description,\n                              tvb, offset, 1, ENC_BIG_ENDIAN);\n        }\n      else\n        {\n          proto_item_set_text(tree,\n                              \"%s Record Layer: Encrypted Alert\",\n                              val_to_str_const(*conv_version, ssl_version_short_names, \"SSL\"));\n          proto_item_set_text(ssl_alert_tree,\n                              \"Alert Message: Encrypted Alert\");\n        }\n    }\n}\n\n\n/* dissects the handshake protocol, filling the tree */\nstatic void\ndissect_dtls_handshake(tvbuff_t *tvb, packet_info *pinfo,\n                       proto_tree *tree, guint32 offset,\n                       guint32 record_length, guint *conv_version,\n                       SslDecryptSession* ssl, guint8 content_type)\n{\n  /*     struct {\n   *         HandshakeType msg_type;\n   *         uint24 length;\n   *         uint16 message_seq;          //new field\n   *         uint24 fragment_offset;      //new field\n   *         uint24 fragment_length;      //new field\n   *         select (HandshakeType) {\n   *             case hello_request:       HelloRequest;\n   *             case client_hello:        ClientHello;\n   *             case server_hello:        ServerHello;\n   *             case hello_verify_request: HelloVerifyRequest;     //new field\n   *             case certificate:         Certificate;\n   *             case server_key_exchange: ServerKeyExchange;\n   *             case certificate_request: CertificateRequest;\n   *             case server_hello_done:   ServerHelloDone;\n   *             case certificate_verify:  CertificateVerify;\n   *             case client_key_exchange: ClientKeyExchange;\n   *             case finished:            Finished;\n   *         } body;\n   *     } Handshake;\n   */\n\n  proto_tree  *ti;\n  proto_tree  *ssl_hand_tree;\n  const gchar *msg_type_str;\n  guint8       msg_type;\n  guint32      length;\n  guint16      message_seq;\n  guint32      fragment_offset;\n  guint32      fragment_length;\n  gboolean     first_iteration;\n\n  ti              = NULL;\n  ssl_hand_tree   = NULL;\n  msg_type_str    = NULL;\n  first_iteration = TRUE;\n\n  /* just as there can be multiple records per packet, there\n   * can be multiple messages per record as long as they have\n   * the same content type\n   *\n   * we really only care about this for handshake messages\n   */\n\n  /* set record_length to the max offset */\n  record_length += offset;\n  for (; offset < record_length; offset += fragment_length,\n         first_iteration = FALSE) /* set up for next pass, if any */\n    {\n      fragment_data *frag_msg = NULL;\n      tvbuff_t      *new_tvb  = NULL;\n      const gchar   *frag_str = NULL;\n      gboolean       fragmented;\n\n      msg_type        = tvb_get_guint8(tvb, offset);\n      msg_type_str    = match_strval(msg_type, ssl_31_handshake_type);\n      length          = tvb_get_ntoh24(tvb, offset + 1);\n      message_seq     = tvb_get_ntohs(tvb,offset + 4);\n      fragment_offset = tvb_get_ntoh24(tvb, offset + 6);\n      fragment_length = tvb_get_ntoh24(tvb, offset + 9);\n      fragmented      = fragment_length != length;\n\n      if (!msg_type_str && !first_iteration)\n        {\n          /* only dissect / report messages if they're\n           * either the first message in this record\n           * or they're a valid message type\n           */\n          return;\n        }\n\n      /* on second and later iterations, add comma to info col */\n      if (!first_iteration)\n        {\n          col_append_str(pinfo->cinfo, COL_INFO, \", \");\n        }\n\n      /*\n       * Update our info string\n       */\n      if (check_col(pinfo->cinfo, COL_INFO))\n        col_append_str(pinfo->cinfo, COL_INFO, (msg_type_str != NULL)\n                        ? msg_type_str : \"Encrypted Handshake Message\");\n\n      /* Handle fragments of known message type */\n      if (fragmented)\n        {\n          gboolean frag_hand;\n\n          switch (msg_type) {\n          case SSL_HND_HELLO_REQUEST:\n          case SSL_HND_CLIENT_HELLO:\n          case SSL_HND_HELLO_VERIFY_REQUEST:\n          case SSL_HND_NEWSESSION_TICKET:\n          case SSL_HND_SERVER_HELLO:\n          case SSL_HND_CERTIFICATE:\n          case SSL_HND_SERVER_KEY_EXCHG:\n          case SSL_HND_CERT_REQUEST:\n          case SSL_HND_SVR_HELLO_DONE:\n          case SSL_HND_CERT_VERIFY:\n          case SSL_HND_CLIENT_KEY_EXCHG:\n          case SSL_HND_FINISHED:\n            frag_hand = TRUE;\n            break;\n          default:\n            /* Ignore encrypted handshake messages */\n            frag_hand = FALSE;\n            break;\n          }\n\n          if (frag_hand) {\n            /* Fragmented handshake message */\n            pinfo->fragmented = TRUE;\n\n            /* Don't pass the reassembly code data that doesn't exist */\n            tvb_ensure_bytes_exist(tvb, offset, fragment_length);\n\n            frag_msg = fragment_add(tvb, offset+12, pinfo, message_seq,\n                                    dtls_fragment_table,\n                                    fragment_offset, fragment_length, TRUE);\n            fragment_set_tot_len(pinfo, message_seq, dtls_fragment_table,\n                                 length);\n\n            if (frag_msg && (fragment_length + fragment_offset) == length)\n              {\n                /* Reassembled */\n                new_tvb = process_reassembled_data(tvb, offset+12, pinfo,\n                                                   \"Reassembled DTLS\",\n                                                   frag_msg,\n                                                   &dtls_frag_items,\n                                                   NULL, tree);\n                frag_str = \" (Reassembled)\";\n              }\n            else\n              {\n                frag_str = \" (Fragment)\";\n              }\n\n            if (check_col(pinfo->cinfo, COL_INFO))\n              col_append_str(pinfo->cinfo, COL_INFO, frag_str);\n          }\n        }\n\n      if (tree)\n        {\n          /* set the label text on the record layer expanding node */\n          if (first_iteration)\n            {\n              proto_item_set_text(tree, \"%s Record Layer: %s Protocol: %s%s\",\n                                  val_to_str_const(*conv_version, ssl_version_short_names, \"SSL\"),\n                                  val_to_str(content_type, ssl_31_content_type, \"unknown\"),\n                                  (msg_type_str!=NULL) ? msg_type_str :\n                                  \"Encrypted Handshake Message\",\n                                  (frag_str!=NULL) ? frag_str : \"\");\n            }\n          else\n            {\n              proto_item_set_text(tree, \"%s Record Layer: %s Protocol: %s%s\",\n                                  val_to_str_const(*conv_version, ssl_version_short_names, \"SSL\"),\n                                  val_to_str(content_type, ssl_31_content_type, \"unknown\"),\n                                  \"Multiple Handshake Messages\",\n                                  (frag_str!=NULL) ? frag_str : \"\");\n            }\n\n          /* add a subtree for the handshake protocol */\n          ti = proto_tree_add_item(tree, hf_dtls_handshake_protocol, tvb,\n                                   offset, fragment_length + 12, ENC_NA);\n          ssl_hand_tree = proto_item_add_subtree(ti, ett_dtls_handshake);\n\n          if (ssl_hand_tree)\n            {\n              /* set the text label on the subtree node */\n              proto_item_set_text(ssl_hand_tree, \"Handshake Protocol: %s%s\",\n                                  (msg_type_str != NULL) ? msg_type_str :\n                                  \"Encrypted Handshake Message\",\n                                  (frag_str!=NULL) ? frag_str : \"\");\n            }\n        }\n\n      /* if we don't have a valid handshake type, just quit dissecting */\n      if (!msg_type_str)\n        return;\n\n      /* if we are doing ssl decryption we must dissect some requests type */\n      if (ssl_hand_tree || ssl)\n        {\n          tvbuff_t *sub_tvb = NULL;\n\n          /* add nodes for the message type and message length */\n          if (ssl_hand_tree)\n            proto_tree_add_uint(ssl_hand_tree, hf_dtls_handshake_type,\n                                tvb, offset, 1, msg_type);\n          offset++;\n          if (ssl_hand_tree)\n            proto_tree_add_uint(ssl_hand_tree, hf_dtls_handshake_length,\n                                tvb, offset, 3, length);\n          offset += 3;\n\n          if (ssl_hand_tree)\n            proto_tree_add_uint(ssl_hand_tree, hf_dtls_handshake_message_seq,\n                                tvb, offset, 2, message_seq);\n          offset += 2;\n          if (ssl_hand_tree)\n            proto_tree_add_uint(ssl_hand_tree, hf_dtls_handshake_fragment_offset,\n                                tvb, offset, 3, fragment_offset);\n          offset += 3;\n          if (ssl_hand_tree)\n            proto_tree_add_uint(ssl_hand_tree, hf_dtls_handshake_fragment_length,\n                                tvb, offset, 3, fragment_length);\n          offset += 3;\n\n          if (fragmented && !new_tvb)\n            {\n              /* Skip fragmented messages not reassembled yet */\n              continue;\n            }\n\n          if (new_tvb)\n            {\n              sub_tvb = new_tvb;\n            }\n          else\n            {\n              sub_tvb = tvb_new_subset(tvb, offset, fragment_length,\n                                        fragment_length);\n            }\n\n          /* now dissect the handshake message, if necessary */\n          switch (msg_type) {\n          case SSL_HND_HELLO_REQUEST:\n            /* hello_request has no fields, so nothing to do! */\n            break;\n\n          case SSL_HND_CLIENT_HELLO:\n            dissect_dtls_hnd_cli_hello(sub_tvb, ssl_hand_tree, 0, length, ssl);\n            break;\n\n          case SSL_HND_SERVER_HELLO:\n            dissect_dtls_hnd_srv_hello(sub_tvb, ssl_hand_tree, 0, length, ssl);\n            break;\n\n          case SSL_HND_HELLO_VERIFY_REQUEST:\n            dissect_dtls_hnd_hello_verify_request(sub_tvb, ssl_hand_tree, 0,  ssl);\n            break;\n\n          case SSL_HND_NEWSESSION_TICKET:\n            dissect_dtls_hnd_new_ses_ticket(sub_tvb, ssl_hand_tree, 0, length);\n            break;\n\n          case SSL_HND_CERTIFICATE:\n            dissect_dtls_hnd_cert(sub_tvb, ssl_hand_tree, 0, pinfo);\n            break;\n\n          case SSL_HND_SERVER_KEY_EXCHG:\n            /* unimplemented */\n            break;\n\n          case SSL_HND_CERT_REQUEST:\n            dissect_dtls_hnd_cert_req(sub_tvb, ssl_hand_tree, 0);\n            break;\n\n          case SSL_HND_SVR_HELLO_DONE:\n            /* server_hello_done has no fields, so nothing to do! */\n            break;\n\n          case SSL_HND_CERT_VERIFY:\n            /* unimplemented */\n            break;\n\n          case SSL_HND_CLIENT_KEY_EXCHG:\n            {\n              /* here we can have all the data to build session key */\n              StringInfo encrypted_pre_master;\n              gint ret;\n              guint encrlen = length, skip;\n              skip = 0;\n\n              if (!ssl)\n                break;\n\n              /* check for required session data */\n              ssl_debug_printf(\"dissect_dtls_handshake found SSL_HND_CLIENT_KEY_EXCHG, state %X\\n\",\n                               ssl->state);\n              if ((ssl->state & (SSL_CIPHER|SSL_CLIENT_RANDOM|SSL_SERVER_RANDOM|SSL_VERSION)) !=\n                  (SSL_CIPHER|SSL_CLIENT_RANDOM|SSL_SERVER_RANDOM|SSL_VERSION)) {\n                ssl_debug_printf(\"dissect_dtls_handshake not enough data to generate key (required state %X)\\n\",\n                                 (SSL_CIPHER|SSL_CLIENT_RANDOM|SSL_SERVER_RANDOM|SSL_VERSION));\n                break;\n              }\n\n              /* Skip leading two bytes length field. Older openssl's DTLS implementation seems not to have this field.\n               * See implementation note in RFC 4346 section 7.4.7.1\n               */\n              if (ssl->cipher_suite.kex==KEX_RSA && ssl->version_netorder != DTLSV1DOT0_VERSION_NOT) {\n                encrlen = tvb_get_ntohs(tvb, offset);\n                skip = 2;\n                if (encrlen > length - 2) {\n                  ssl_debug_printf(\"dissect_dtls_handshake wrong encrypted length (%d max %d)\\n\", encrlen, length);\n                  break;\n                }\n              }\n\n              encrypted_pre_master.data = se_alloc(encrlen);\n              encrypted_pre_master.data_len = encrlen;\n              tvb_memcpy(tvb, encrypted_pre_master.data, offset+skip, encrlen);\n\n              if (!ssl->private_key) {\n                ssl_debug_printf(\"dissect_dtls_handshake can't find private key\\n\");\n                break;\n              }\n\n              /* go with ssl key processessing; encrypted_pre_master\n               * will be used for master secret store*/\n              ret = ssl_decrypt_pre_master_secret(ssl, &encrypted_pre_master, ssl->private_key);\n              if (ret < 0) {\n                ssl_debug_printf(\"dissect_dtls_handshake can't decrypt pre master secret\\n\");\n                break;\n              }\n              if (ssl_generate_keyring_material(ssl)<0) {\n                ssl_debug_printf(\"dissect_dtls_handshake can't generate keyring material\\n\");\n                break;\n              }\n              ssl->state |= SSL_HAVE_SESSION_KEY;\n              ssl_save_session(ssl, dtls_session_hash);\n              ssl_debug_printf(\"dissect_dtls_handshake session keys successfully generated\\n\");\n            }\n            break;\n\n          case SSL_HND_FINISHED:\n            dissect_dtls_hnd_finished(sub_tvb, ssl_hand_tree,\n                                      0, conv_version);\n            break;\n          }\n\n        }\n      else{\n        offset += 12;        /* skip the handshake header when handshake is not processed*/\n      }\n    }\n}\n\n/* dissects the heartbeat message, filling in the tree */\nstatic void\ndissect_dtls_heartbeat(tvbuff_t *tvb, packet_info *pinfo,\n                       proto_tree *tree, guint32 offset,\n                       guint* conv_version, guint32 record_length)\n{\n  /*     struct {\n   *         HeartbeatMessageType type;\n   *         uint16 payload_length;\n   *         opaque payload;\n   *         opaque padding;\n   *     } HeartbeatMessage;\n   */\n\n  proto_tree  *ti;\n  proto_tree  *dtls_heartbeat_tree;\n  const gchar *type;\n  guint8       byte;\n  guint16      payload_length;\n  guint16      padding_length;\n\n  dtls_heartbeat_tree = NULL;\n\n  if (tree) {\n    ti = proto_tree_add_item(tree, hf_dtls_heartbeat_message, tvb,\n                             offset, record_length - 32, ENC_NA);\n    dtls_heartbeat_tree = proto_item_add_subtree(ti, ett_dtls_heartbeat);\n  }\n\n  /*\n   * set the record layer label\n   */\n\n  /* first lookup the names for the message type and the payload length */\n  byte = tvb_get_guint8(tvb, offset);\n  type = match_strval(byte, tls_heartbeat_type);\n\n  payload_length = tvb_get_ntohs(tvb, offset + 1);\n  padding_length = record_length - 3 - payload_length;\n\n  /* now set the text in the record layer line */\n  if (type && (payload_length <= record_length - 16 - 3)) {\n    col_append_fstr(pinfo->cinfo, COL_INFO, \"Heartbeat %s\", type);\n  } else {\n    col_append_str(pinfo->cinfo, COL_INFO, \"Encrypted Heartbeat\");\n  }\n\n  if (tree) {\n    if (type && (payload_length <= record_length - 16 - 3)) {\n      proto_item_set_text(tree, \"%s Record Layer: Heartbeat \"\n                                \"%s\",\n                                val_to_str_const(*conv_version, ssl_version_short_names, \"SSL\"),\n                                type);\n      proto_tree_add_item(dtls_heartbeat_tree, hf_dtls_heartbeat_message_type,\n                          tvb, offset, 1, ENC_BIG_ENDIAN);\n      offset += 1;\n      proto_tree_add_uint(dtls_heartbeat_tree, hf_dtls_heartbeat_message_payload_length,\n                          tvb, offset, 2, payload_length);\n      offset += 2;\n      proto_tree_add_bytes_format(dtls_heartbeat_tree, hf_dtls_heartbeat_message_payload,\n                                  tvb, offset, payload_length,\n                                  NULL, \"Payload (%u byte%s)\",\n                                  payload_length,\n                                  plurality(payload_length, \"\", \"s\"));\n      offset += payload_length;\n      proto_tree_add_bytes_format(dtls_heartbeat_tree, hf_dtls_heartbeat_message_padding,\n                                  tvb, offset, padding_length,\n                                  NULL, \"Padding and HMAC (%u byte%s)\",\n                                  padding_length,\n                                  plurality(padding_length, \"\", \"s\"));\n    } else {\n      proto_item_set_text(tree,\n                         \"%s Record Layer: Encrypted Heartbeat\",\n                         val_to_str_const(*conv_version, ssl_version_short_names, \"SSL\"));\n      proto_item_set_text(dtls_heartbeat_tree,\n                          \"Encrypted Heartbeat Message\");\n    }\n  }\n}\n\nstatic gint\ndissect_dtls_hnd_hello_common(tvbuff_t *tvb, proto_tree *tree,\n                              guint32 offset, SslDecryptSession* ssl, gint from_server)\n{\n  /* show the client's random challenge */\n  nstime_t gmt_unix_time;\n  guint8   session_id_length;\n\n  if (tree || ssl)\n  {\n    if (ssl)\n    {\n      /* get proper peer information*/\n      StringInfo* rnd;\n      if (from_server)\n        rnd = &ssl->server_random;\n      else\n        rnd = &ssl->client_random;\n\n      /* get provided random for keyring generation*/\n      tvb_memcpy(tvb, rnd->data, offset, 32);\n      rnd->data_len = 32;\n      if (from_server)\n        ssl->state |= SSL_SERVER_RANDOM;\n      else\n        ssl->state |= SSL_CLIENT_RANDOM;\n      ssl_debug_printf(\"dissect_dtls_hnd_hello_common found random state %X\\n\",\n                       ssl->state);\n    }\n\n    /* show the time */\n    if (tree)\n    {\n      gmt_unix_time.secs  = tvb_get_ntohl(tvb, offset);\n      gmt_unix_time.nsecs = 0;\n      proto_tree_add_time(tree, hf_dtls_handshake_random_time,\n                          tvb, offset, 4, &gmt_unix_time);\n    }\n    offset += 4;\n\n    /* show the random bytes */\n    if (tree)\n      proto_tree_add_item(tree, hf_dtls_handshake_random_bytes,\n                          tvb, offset, 28, ENC_NA);\n    offset += 28;\n\n    /* show the session id */\n    session_id_length = tvb_get_guint8(tvb, offset);\n    if (tree)\n      proto_tree_add_item(tree, hf_dtls_handshake_session_id_len,\n                          tvb, offset, 1, ENC_BIG_ENDIAN);\n    offset++;\n    if (ssl)\n    {\n      /* check stored session id info */\n      if (from_server && (session_id_length == ssl->session_id.data_len) &&\n          (tvb_memeql(tvb, offset, ssl->session_id.data, session_id_length) == 0))\n      {\n        /* clinet/server id match: try to restore a previous cached session*/\n        ssl_restore_session(ssl, dtls_session_hash);\n      }\n      else {\n        tvb_memcpy(tvb,ssl->session_id.data, offset, session_id_length);\n        ssl->session_id.data_len = session_id_length;\n      }\n    }\n    if (tree && session_id_length > 0)\n      proto_tree_add_bytes_format(tree, hf_dtls_handshake_session_id,\n                                  tvb, offset, session_id_length,\n                                  NULL, \"Session ID (%u byte%s)\",\n                                  session_id_length,\n                                  plurality(session_id_length, \"\", \"s\"));\n    offset += session_id_length;\n  }\n\n  /* XXXX */\n  return offset;\n}\n\nstatic gint\ndissect_dtls_hnd_hello_ext(tvbuff_t *tvb,\n                           proto_tree *tree, guint32 offset, guint32 left)\n{\n  guint16     extension_length;\n  guint16     ext_type;\n  guint16     ext_len;\n  proto_item *pi;\n  proto_tree *ext_tree;\n\n  if (left < 2)\n    return offset;\n\n  extension_length = tvb_get_ntohs(tvb, offset);\n  proto_tree_add_uint(tree, hf_dtls_handshake_extensions_len,\n                      tvb, offset, 2, extension_length);\n  offset += 2;\n  left   -= 2;\n\n  while (left >= 4)\n    {\n      ext_type = tvb_get_ntohs(tvb, offset);\n      ext_len  = tvb_get_ntohs(tvb, offset + 2);\n\n      pi = proto_tree_add_text(tree, tvb, offset, 4 + ext_len,\n                               \"Extension: %s\",\n                               val_to_str(ext_type,\n                                          tls_hello_extension_types,\n                                          \"Unknown %u\"));\n      ext_tree = proto_item_add_subtree(pi, ett_dtls_extension);\n      if (!ext_tree)\n        ext_tree = tree;\n\n      proto_tree_add_uint(ext_tree, hf_dtls_handshake_extension_type,\n                          tvb, offset, 2, ext_type);\n      offset += 2;\n\n      proto_tree_add_uint(ext_tree, hf_dtls_handshake_extension_len,\n                          tvb, offset, 2, ext_len);\n      offset += 2;\n\n      switch (ext_type) {\n      case SSL_HND_HELLO_EXT_HEARTBEAT:\n          proto_tree_add_item(ext_tree, hf_dtls_heartbeat_extension_mode,\n                              tvb, offset, 1, ENC_BIG_ENDIAN);\n          offset += ext_len;\n          break;\n      default:\n          proto_tree_add_bytes_format(ext_tree, hf_dtls_handshake_extension_data,\n                                      tvb, offset, ext_len, NULL,\n                                      \"Data (%u byte%s)\",\n                                      ext_len, plurality(ext_len, \"\", \"s\"));\n          offset += ext_len;\n          break;\n      }\n\n      left   -= 2 + 2 + ext_len;\n    }\n\n  return offset;\n}\n\nstatic void\ndissect_dtls_hnd_cli_hello(tvbuff_t *tvb,\n                           proto_tree *tree, guint32 offset, guint32 length,\n                           SslDecryptSession*ssl)\n{\n  /* struct {\n   *     ProtocolVersion client_version;\n   *     Random random;\n   *     SessionID session_id;\n   *     opaque cookie<0..32>;                   //new field\n   *     CipherSuite cipher_suites<2..2^16-1>;\n   *     CompressionMethod compression_methods<1..2^8-1>;\n   *     Extension client_hello_extension_list<0..2^16-1>;\n   * } ClientHello;\n   *\n   */\n\n  proto_tree *ti;\n  proto_tree *cs_tree;\n  guint16     cipher_suite_length;\n  guint8      compression_methods_length;\n  guint8      compression_method;\n  guint16     start_offset   = offset;\n  guint8      cookie_length;\n\n  if (tree || ssl)\n    {\n      /* show the client version */\n      if (tree)\n        proto_tree_add_item(tree, hf_dtls_handshake_client_version, tvb,\n                            offset, 2, ENC_BIG_ENDIAN);\n      offset += 2;\n\n      /* show the fields in common with server hello */\n      offset = dissect_dtls_hnd_hello_common(tvb, tree, offset, ssl, 0);\n\n      /* look for a cookie */\n      cookie_length = tvb_get_guint8(tvb, offset);\n      if (!tree)\n        return;\n\n      proto_tree_add_uint(tree, hf_dtls_handshake_cookie_len,\n                          tvb, offset, 1, cookie_length);\n      offset ++;            /* skip opaque length */\n\n      if (cookie_length > 0)\n        {\n          proto_tree_add_bytes_format(tree, hf_dtls_handshake_cookie,\n                                      tvb, offset, cookie_length,\n                                      NULL, \"Cookie (%u byte%s)\",\n                                      cookie_length,\n                                      plurality(cookie_length, \"\", \"s\"));\n          offset += cookie_length;\n        }\n\n      /* tell the user how many cipher suites there are */\n      cipher_suite_length = tvb_get_ntohs(tvb, offset);\n\n      proto_tree_add_uint(tree, hf_dtls_handshake_cipher_suites_len,\n                          tvb, offset, 2, cipher_suite_length);\n      offset += 2;            /* skip opaque length */\n\n      if (cipher_suite_length > 0)\n        {\n          tvb_ensure_bytes_exist(tvb, offset, cipher_suite_length);\n          ti = proto_tree_add_none_format(tree,\n                                          hf_dtls_handshake_cipher_suites,\n                                          tvb, offset, cipher_suite_length,\n                                          \"Cipher Suites (%u suite%s)\",\n                                          cipher_suite_length / 2,\n                                          plurality(cipher_suite_length/2, \"\", \"s\"));\n\n          /* make this a subtree */\n          cs_tree = proto_item_add_subtree(ti, ett_dtls_cipher_suites);\n          if (!cs_tree)\n            {\n              cs_tree = tree; /* failsafe */\n            }\n\n          while (cipher_suite_length > 0)\n            {\n              proto_tree_add_item(cs_tree, hf_dtls_handshake_cipher_suite,\n                                  tvb, offset, 2, ENC_BIG_ENDIAN);\n              offset += 2;\n              cipher_suite_length -= 2;\n            }\n        }\n\n      /* tell the user how man compression methods there are */\n      compression_methods_length = tvb_get_guint8(tvb, offset);\n      proto_tree_add_uint(tree, hf_dtls_handshake_comp_methods_len,\n                          tvb, offset, 1, compression_methods_length);\n      offset++;\n\n      if (compression_methods_length > 0)\n        {\n          tvb_ensure_bytes_exist(tvb, offset, compression_methods_length);\n          ti = proto_tree_add_none_format(tree,\n                                          hf_dtls_handshake_comp_methods,\n                                          tvb, offset, compression_methods_length,\n                                          \"Compression Methods (%u method%s)\",\n                                          compression_methods_length,\n                                          plurality(compression_methods_length,\n                                                    \"\", \"s\"));\n\n          /* make this a subtree */\n          cs_tree = proto_item_add_subtree(ti, ett_dtls_comp_methods);\n          if (!cs_tree)\n            {\n              cs_tree = tree; /* failsafe */\n            }\n\n          while (compression_methods_length > 0)\n            {\n              compression_method = tvb_get_guint8(tvb, offset);\n              if (compression_method < 64)\n                proto_tree_add_uint(cs_tree, hf_dtls_handshake_comp_method,\n                                    tvb, offset, 1, compression_method);\n              else if (compression_method > 63 && compression_method < 193)\n                proto_tree_add_text(cs_tree, tvb, offset, 1,\n                                    \"Compression Method: Reserved - to be assigned by IANA (%u)\",\n                                    compression_method);\n              else\n                proto_tree_add_text(cs_tree, tvb, offset, 1,\n                                    \"Compression Method: Private use range (%u)\",\n                                    compression_method);\n              offset++;\n              compression_methods_length--;\n            }\n        }\n\n      if (length > offset - start_offset)\n        {\n          dissect_dtls_hnd_hello_ext(tvb, tree, offset,\n                                              length -\n                                              (offset - start_offset));\n        }\n    }\n}\n\nstatic int\ndissect_dtls_hnd_srv_hello(tvbuff_t *tvb,\n                           proto_tree *tree, guint32 offset, guint32 length, SslDecryptSession* ssl)\n{\n  /* struct {\n   *     ProtocolVersion server_version;\n   *     Random random;\n   *     SessionID session_id;\n   *     CipherSuite cipher_suite;\n   *     CompressionMethod compression_method;\n   *     Extension server_hello_extension_list<0..2^16-1>;\n   * } ServerHello;\n   */\n\n  guint16 start_offset;\n\n  start_offset = offset;\n\n  if (tree || ssl)\n    {\n      /* show the server version */\n      if (tree)\n        proto_tree_add_item(tree, hf_dtls_handshake_server_version, tvb,\n                            offset, 2, ENC_BIG_ENDIAN);\n      offset += 2;\n\n      /* first display the elements conveniently in\n       * common with client hello\n       */\n      offset = dissect_dtls_hnd_hello_common(tvb, tree, offset, ssl, 1);\n\n      /* PAOLO: handle session cipher suite  */\n      if (ssl) {\n        /* store selected cipher suite for decryption */\n        ssl->cipher = tvb_get_ntohs(tvb, offset);\n        if (ssl_find_cipher(ssl->cipher,&ssl->cipher_suite) < 0) {\n          ssl_debug_printf(\"dissect_dtls_hnd_srv_hello can't find cipher suite %X\\n\", ssl->cipher);\n          goto no_cipher;\n        }\n\n        ssl->state |= SSL_CIPHER;\n        ssl_debug_printf(\"dissect_dtls_hnd_srv_hello found cipher %X, state %X\\n\",\n                         ssl->cipher, ssl->state);\n\n        /* if we have restored a session now we can have enought material\n         * to build session key, check it out*/\n        if ((ssl->state &\n             (SSL_CIPHER|SSL_CLIENT_RANDOM|SSL_SERVER_RANDOM|SSL_VERSION|SSL_MASTER_SECRET)) !=\n            (SSL_CIPHER|SSL_CLIENT_RANDOM|SSL_SERVER_RANDOM|SSL_VERSION|SSL_MASTER_SECRET)) {\n          ssl_debug_printf(\"dissect_dtls_hnd_srv_hello not enough data to generate key (required state %X)\\n\",\n                           (SSL_CIPHER|SSL_CLIENT_RANDOM|SSL_SERVER_RANDOM|SSL_VERSION|SSL_MASTER_SECRET));\n          goto no_cipher;\n        }\n\n        ssl_debug_printf(\"dissect_dtls_hnd_srv_hello trying to generate keys\\n\");\n        if (ssl_generate_keyring_material(ssl)<0) {\n          ssl_debug_printf(\"dissect_dtls_hnd_srv_hello can't generate keyring material\\n\");\n          goto no_cipher;\n        }\n        ssl->state |= SSL_HAVE_SESSION_KEY;\n      }\n    no_cipher:\n      if (ssl) {\n        /* store selected compression method for decompression */\n        ssl->compression = tvb_get_guint8(tvb, offset+2);\n      }\n      if (!tree)\n        return offset;\n\n      /* now the server-selected cipher suite */\n      proto_tree_add_item(tree, hf_dtls_handshake_cipher_suite,\n                          tvb, offset, 2, ENC_BIG_ENDIAN);\n      offset += 2;\n\n      /* and the server-selected compression method */\n      proto_tree_add_item(tree, hf_dtls_handshake_comp_method,\n                          tvb, offset, 1, ENC_BIG_ENDIAN);\n      offset++;\n\n      if (length > offset - start_offset)\n        {\n          offset = dissect_dtls_hnd_hello_ext(tvb, tree, offset,\n                                              length -\n                                              (offset - start_offset));\n        }\n    }\n    return offset;\n}\n\nstatic int\ndissect_dtls_hnd_hello_verify_request(tvbuff_t *tvb, proto_tree *tree,\n                                      guint32 offset, SslDecryptSession* ssl)\n{\n  /*\n   * struct {\n   *    ProtocolVersion server_version;\n   *    opaque cookie<0..32>;\n   * } HelloVerifyRequest;\n   */\n\n  guint8 cookie_length;\n\n\n  if (tree || ssl)\n    {\n      /* show the client version */\n      if (tree)\n        proto_tree_add_item(tree, hf_dtls_handshake_server_version, tvb,\n                            offset, 2, ENC_BIG_ENDIAN);\n      offset += 2;\n\n\n      /* look for a cookie */\n      cookie_length = tvb_get_guint8(tvb, offset);\n      if (!tree)\n        return offset;\n\n      proto_tree_add_uint(tree, hf_dtls_handshake_cookie_len,\n                          tvb, offset, 1, cookie_length);\n      offset ++;            /* skip opaque length */\n\n      if (cookie_length > 0)\n        {\n          proto_tree_add_bytes_format(tree, hf_dtls_handshake_cookie,\n                                      tvb, offset, cookie_length,\n                                      NULL, \"Cookie (%u byte%s)\",\n                                      cookie_length,\n                                      plurality(cookie_length, \"\", \"s\"));\n          offset += cookie_length;\n        }\n    }\n    return offset;\n}\n\nstatic void\ndissect_dtls_hnd_new_ses_ticket(tvbuff_t *tvb,\n                           proto_tree *tree, guint32 offset, guint32 length)\n{\n    guint nst_len;\n    proto_item *ti;\n    proto_tree *subtree;\n\n\n    nst_len = tvb_get_ntohs(tvb, offset+4);\n    if (6 + nst_len != length) {\n        return;\n    }\n\n    ti = proto_tree_add_text(tree, tvb, offset, 6+nst_len, \"TLS Session Ticket\");\n    subtree = proto_item_add_subtree(ti, ett_dtls_new_ses_ticket);\n\n\tproto_tree_add_item(subtree, hf_dtls_handshake_session_ticket_lifetime_hint,\n\t\t\t\t\t\ttvb, offset, 4, ENC_BIG_ENDIAN);\n\toffset += 4;\n\n    proto_tree_add_uint(subtree, hf_dtls_handshake_session_ticket_len,\n        tvb, offset, 2, nst_len);\n    /* Content depends on implementation, so just show data! */\n    proto_tree_add_item(subtree, hf_dtls_handshake_session_ticket,\n            tvb, offset + 2, nst_len, ENC_NA);\n}\n\nstatic void\ndissect_dtls_hnd_cert(tvbuff_t *tvb,\n                      proto_tree *tree, guint32 offset, packet_info *pinfo)\n{\n\n  /* opaque ASN.1Cert<2^24-1>;\n   *\n   * struct {\n   *     ASN.1Cert certificate_list<1..2^24-1>;\n   * } Certificate;\n   */\n\n  guint32     certificate_list_length;\n  proto_tree *ti;\n  proto_tree *subtree;\n  asn1_ctx_t  asn1_ctx;\n\n  asn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo);\n\n  if (tree)\n    {\n      certificate_list_length = tvb_get_ntoh24(tvb, offset);\n      proto_tree_add_uint(tree, hf_dtls_handshake_certificates_len,\n                          tvb, offset, 3, certificate_list_length);\n      offset += 3;            /* 24-bit length value */\n\n      if (certificate_list_length > 0)\n        {\n          tvb_ensure_bytes_exist(tvb, offset, certificate_list_length);\n          ti = proto_tree_add_none_format(tree,\n                                          hf_dtls_handshake_certificates,\n                                          tvb, offset, certificate_list_length,\n                                          \"Certificates (%u byte%s)\",\n                                          certificate_list_length,\n                                          plurality(certificate_list_length,\n                                                    \"\", \"s\"));\n\n          /* make it a subtree */\n          subtree = proto_item_add_subtree(ti, ett_dtls_certs);\n          if (!subtree)\n            {\n              subtree = tree; /* failsafe */\n            }\n\n          /* iterate through each certificate */\n          while (certificate_list_length > 0)\n            {\n              /* get the length of the current certificate */\n              guint32 cert_length = tvb_get_ntoh24(tvb, offset);\n              certificate_list_length -= 3 + cert_length;\n\n              proto_tree_add_item(subtree, hf_dtls_handshake_certificate_len,\n                                  tvb, offset, 3, ENC_BIG_ENDIAN);\n              offset += 3;\n\n              dissect_x509af_Certificate(FALSE, tvb, offset, &asn1_ctx, subtree, hf_dtls_handshake_certificate);\n              offset += cert_length;\n            }\n        }\n\n    }\n}\n\nstatic void\ndissect_dtls_hnd_cert_req(tvbuff_t *tvb,\n                          proto_tree *tree, guint32 offset)\n{\n  /*\n   *    enum {\n   *        rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),\n   *        (255)\n   *    } ClientCertificateType;\n   *\n   *    opaque DistinguishedName<1..2^16-1>;\n   *\n   *    struct {\n   *        ClientCertificateType certificate_types<1..2^8-1>;\n   *        DistinguishedName certificate_authorities<3..2^16-1>;\n   *    } CertificateRequest;\n   *\n   */\n\n  proto_tree *ti;\n  proto_tree *subtree;\n  guint8      cert_types_count;\n  gint        dnames_length;\n\n  if (tree)\n    {\n      cert_types_count = tvb_get_guint8(tvb, offset);\n      proto_tree_add_uint(tree, hf_dtls_handshake_cert_types_count,\n                          tvb, offset, 1, cert_types_count);\n      offset++;\n\n      if (cert_types_count > 0)\n        {\n          ti = proto_tree_add_none_format(tree,\n                                          hf_dtls_handshake_cert_types,\n                                          tvb, offset, cert_types_count,\n                                          \"Certificate types (%u type%s)\",\n                                          cert_types_count,\n                                          plurality(cert_types_count, \"\", \"s\"));\n          subtree = proto_item_add_subtree(ti, ett_dtls_cert_types);\n          if (!subtree)\n            {\n              subtree = tree;\n            }\n\n          while (cert_types_count > 0)\n            {\n              proto_tree_add_item(subtree, hf_dtls_handshake_cert_type,\n                                  tvb, offset, 1, ENC_BIG_ENDIAN);\n              offset++;\n              cert_types_count--;\n            }\n        }\n\n      dnames_length = tvb_get_ntohs(tvb, offset);\n      proto_tree_add_uint(tree, hf_dtls_handshake_dnames_len,\n                          tvb, offset, 2, dnames_length);\n      offset += 2;\n\n      if (dnames_length > 0)\n        {\n          tvb_ensure_bytes_exist(tvb, offset, dnames_length);\n          ti = proto_tree_add_none_format(tree,\n                                          hf_dtls_handshake_dnames,\n                                          tvb, offset, dnames_length,\n                                          \"Distinguished Names (%d byte%s)\",\n                                          dnames_length,\n                                          plurality(dnames_length, \"\", \"s\"));\n          subtree = proto_item_add_subtree(ti, ett_dtls_dnames);\n          if (!subtree)\n            {\n              subtree = tree;\n            }\n\n          while (dnames_length > 0)\n            {\n              /* get the length of the current certificate */\n              guint16 name_length = tvb_get_ntohs(tvb, offset);\n              dnames_length -= 2 + name_length;\n\n              proto_tree_add_item(subtree, hf_dtls_handshake_dname_len,\n                                  tvb, offset, 2, ENC_BIG_ENDIAN);\n              offset += 2;\n\n              proto_tree_add_bytes_format(subtree,\n                                          hf_dtls_handshake_dname,\n                                          tvb, offset, name_length, NULL,\n                                          \"Distinguished Name (%u byte%s)\",\n                                          name_length,\n                                          plurality(name_length, \"\", \"s\"));\n              offset += name_length;\n            }\n        }\n    }\n\n}\n\nstatic void\ndissect_dtls_hnd_finished(tvbuff_t *tvb, proto_tree *tree, guint32 offset,\n                          guint* conv_version)\n{\n  /*\n   *     struct {\n   *         opaque verify_data[12];\n   *     } Finished;\n   */\n\n  /* this all needs a tree, so bail if we don't have one */\n  if (!tree)\n    {\n      return;\n    }\n\n  switch(*conv_version) {\n  case SSL_VER_DTLS:\n    proto_tree_add_item(tree, hf_dtls_handshake_finished,\n                        tvb, offset, 12, ENC_NA);\n    break;\n  case SSL_VER_DTLS1DOT2:\n    proto_tree_add_item(tree, hf_dtls_handshake_finished,\n                        tvb, offset, 12, ENC_NA);\n    break;\n  }\n}\n\n/*********************************************************************\n *\n * Support Functions\n *\n *********************************************************************/\n#if 0\nstatic void\nssl_set_conv_version(packet_info *pinfo, guint version)\n{\n  conversation_t *conversation;\n\n  if (pinfo->fd->flags.visited)\n    {\n      /* We've already processed this frame; no need to do any more\n       * work on it.\n       */\n      return;\n    }\n\n  conversation = find_or_create_conversation(pinfo);\n\n  if (conversation_get_proto_data(conversation, proto_dtls) != NULL)\n    {\n      /* get rid of the current data */\n      conversation_delete_proto_data(conversation, proto_dtls);\n    }\n  conversation_add_proto_data(conversation, proto_dtls, GINT_TO_POINTER(version));\n}\n#endif\n\nstatic gint\ndtls_is_valid_handshake_type(guint8 type)\n{\n\n  switch (type) {\n  case SSL_HND_HELLO_REQUEST:\n  case SSL_HND_CLIENT_HELLO:\n  case SSL_HND_SERVER_HELLO:\n  case SSL_HND_HELLO_VERIFY_REQUEST:\n  case SSL_HND_NEWSESSION_TICKET:\n  case SSL_HND_CERTIFICATE:\n  case SSL_HND_SERVER_KEY_EXCHG:\n  case SSL_HND_CERT_REQUEST:\n  case SSL_HND_SVR_HELLO_DONE:\n  case SSL_HND_CERT_VERIFY:\n  case SSL_HND_CLIENT_KEY_EXCHG:\n  case SSL_HND_FINISHED:\n    return 1;\n  }\n  return 0;\n}\n\nstatic gint\ndtls_is_authoritative_version_message(guint8 content_type, guint8 next_byte)\n{\n  if (content_type == SSL_ID_HANDSHAKE\n      && dtls_is_valid_handshake_type(next_byte))\n    {\n      return (next_byte != SSL_HND_CLIENT_HELLO);\n    }\n  else if (ssl_is_valid_content_type(content_type)\n           && content_type != SSL_ID_HANDSHAKE)\n    {\n      return 1;\n    }\n  return 0;\n}\n\n/* this applies a heuristic to determine whether\n * or not the data beginning at offset looks like a\n * valid dtls record.\n */\nstatic gint\nlooks_like_dtls(tvbuff_t *tvb, guint32 offset)\n{\n  /* have to have a valid content type followed by a valid\n   * protocol version\n   */\n  guint8  byte;\n  guint16 version;\n\n  /* see if the first byte is a valid content type */\n  byte = tvb_get_guint8(tvb, offset);\n  if (!ssl_is_valid_content_type(byte))\n    {\n      return 0;\n    }\n\n  /* now check to see if the version byte appears valid */\n  version = tvb_get_ntohs(tvb, offset + 1);\n  if (version != DTLSV1DOT0_VERSION && version != DTLSV1DOT2_VERSION &&\n      version != DTLSV1DOT0_VERSION_NOT)\n    {\n      return 0;\n    }\n\n  return 1;\n}\n\n/* UAT */\n\n#ifdef HAVE_LIBGNUTLS\nstatic void\ndtlsdecrypt_free_cb(void* r)\n{\n  ssldecrypt_assoc_t* h = r;\n\n  g_free(h->ipaddr);\n  g_free(h->port);\n  g_free(h->protocol);\n  g_free(h->keyfile);\n  g_free(h->password);\n}\n#endif\n\n#if 0\nstatic void\ndtlsdecrypt_update_cb(void* r _U_, const char** err _U_)\n{\n  return;\n}\n#endif\n\n#ifdef HAVE_LIBGNUTLS\nstatic void *\ndtlsdecrypt_copy_cb(void* dest, const void* orig, size_t len _U_)\n{\n  const ssldecrypt_assoc_t* o = orig;\n  ssldecrypt_assoc_t*       d = dest;\n\n  d->ipaddr    = g_strdup(o->ipaddr);\n  d->port      = g_strdup(o->port);\n  d->protocol  = g_strdup(o->protocol);\n  d->keyfile   = g_strdup(o->keyfile);\n  d->password  = g_strdup(o->password);\n\n  return d;\n}\n\nUAT_CSTRING_CB_DEF(sslkeylist_uats,ipaddr,ssldecrypt_assoc_t)\nUAT_CSTRING_CB_DEF(sslkeylist_uats,port,ssldecrypt_assoc_t)\nUAT_CSTRING_CB_DEF(sslkeylist_uats,protocol,ssldecrypt_assoc_t)\nUAT_FILENAME_CB_DEF(sslkeylist_uats,keyfile,ssldecrypt_assoc_t)\nUAT_CSTRING_CB_DEF(sslkeylist_uats,password,ssldecrypt_assoc_t)\n#endif\n\nvoid proto_reg_handoff_dtls(void);\n\n/*********************************************************************\n *\n * Standard Wireshark Protocol Registration and housekeeping\n *\n *********************************************************************/\nvoid\nproto_register_dtls(void)\n{\n\n  /* Setup list of header fields See Section 1.6.1 for details*/\n  static hf_register_info hf[] = {\n    { &hf_dtls_record,\n      { \"Record Layer\", \"dtls.record\",\n        FT_NONE, BASE_NONE, NULL, 0x0,\n        NULL, HFILL }\n    },\n    { &hf_dtls_record_content_type,\n      { \"Content Type\", \"dtls.record.content_type\",\n        FT_UINT8, BASE_DEC, VALS(ssl_31_content_type), 0x0,\n        NULL, HFILL}\n    },\n    { &hf_dtls_record_version,\n      { \"Version\", \"dtls.record.version\",\n        FT_UINT16, BASE_HEX, VALS(ssl_versions), 0x0,\n        \"Record layer version.\", HFILL }\n    },\n    { &hf_dtls_record_epoch,\n      { \"Epoch\", \"dtls.record.epoch\",\n        FT_UINT16, BASE_DEC, NULL, 0x0,\n        NULL, HFILL }\n    },\n    { &hf_dtls_record_sequence_number,\n      { \"Sequence Number\", \"dtls.record.sequence_number\",\n        FT_DOUBLE, BASE_NONE, NULL, 0x0,\n        NULL, HFILL }\n    },\n    { &hf_dtls_record_length,\n      { \"Length\", \"dtls.record.length\",\n        FT_UINT16, BASE_DEC, NULL, 0x0,\n        \"Length of DTLS record data\", HFILL }\n    },\n    { &hf_dtls_record_appdata,\n      { \"Encrypted Application Data\", \"dtls.app_data\",\n        FT_BYTES, BASE_NONE, NULL, 0x0,\n        \"Payload is encrypted application data\", HFILL }\n    },\n    { &hf_dtls_change_cipher_spec,\n      { \"Change Cipher Spec Message\", \"dtls.change_cipher_spec\",\n        FT_NONE, BASE_NONE, NULL, 0x0,\n        \"Signals a change in cipher specifications\", HFILL }\n    },\n    { & hf_dtls_alert_message,\n      { \"Alert Message\", \"dtls.alert_message\",\n        FT_NONE, BASE_NONE, NULL, 0x0,\n        NULL, HFILL }\n    },\n    { & hf_dtls_alert_message_level,\n      { \"Level\", \"dtls.alert_message.level\",\n        FT_UINT8, BASE_DEC, VALS(ssl_31_alert_level), 0x0,\n        \"Alert message level\", HFILL }\n    },\n    { &hf_dtls_alert_message_description,\n      { \"Description\", \"dtls.alert_message.desc\",\n        FT_UINT8, BASE_DEC, VALS(ssl_31_alert_description), 0x0,\n        \"Alert message description\", HFILL }\n    },\n    { &hf_dtls_handshake_protocol,\n      { \"Handshake Protocol\", \"dtls.handshake\",\n        FT_NONE, BASE_NONE, NULL, 0x0,\n        \"Handshake protocol message\", HFILL}\n    },\n    { &hf_dtls_handshake_type,\n      { \"Handshake Type\", \"dtls.handshake.type\",\n        FT_UINT8, BASE_DEC, VALS(ssl_31_handshake_type), 0x0,\n        \"Type of handshake message\", HFILL}\n    },\n    { &hf_dtls_handshake_length,\n      { \"Length\", \"dtls.handshake.length\",\n        FT_UINT24, BASE_DEC, NULL, 0x0,\n        \"Length of handshake message\", HFILL }\n    },\n    { &hf_dtls_handshake_message_seq,\n      { \"Message Sequence\", \"dtls.handshake.message_seq\",\n        FT_UINT16, BASE_DEC, NULL, 0x0,\n        \"Message sequence of handshake message\", HFILL }\n    },\n    { &hf_dtls_handshake_fragment_offset,\n      { \"Fragment Offset\", \"dtls.handshake.fragment_offset\",\n        FT_UINT24, BASE_DEC, NULL, 0x0,\n        \"Fragment offset of handshake message\", HFILL }\n    },\n    { &hf_dtls_handshake_fragment_length,\n      { \"Fragment Length\", \"dtls.handshake.fragment_length\",\n        FT_UINT24, BASE_DEC, NULL, 0x0,\n        \"Fragment length of handshake message\", HFILL }\n    },\n    { &hf_dtls_handshake_client_version,\n      { \"Version\", \"dtls.handshake.client_version\",\n        FT_UINT16, BASE_HEX, VALS(ssl_versions), 0x0,\n        \"Maximum version supported by client\", HFILL }\n    },\n    { &hf_dtls_handshake_server_version,\n      { \"Version\", \"dtls.handshake.server_version\",\n        FT_UINT16, BASE_HEX, VALS(ssl_versions), 0x0,\n        \"Version selected by server\", HFILL }\n    },\n    { &hf_dtls_handshake_random_time,\n      { \"Random.gmt_unix_time\", \"dtls.handshake.random_time\",\n        FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0,\n        \"Unix time field of random structure\", HFILL }\n    },\n    { &hf_dtls_handshake_random_bytes,\n      { \"Random.bytes\", \"dtls.handshake.random\",\n        FT_NONE, BASE_NONE, NULL, 0x0,\n        \"Random challenge used to authenticate server\", HFILL }\n    },\n    { &hf_dtls_handshake_cipher_suites_len,\n      { \"Cipher Suites Length\", \"dtls.handshake.cipher_suites_length\",\n        FT_UINT16, BASE_DEC, NULL, 0x0,\n        \"Length of cipher suites field\", HFILL }\n    },\n    { &hf_dtls_handshake_cipher_suites,\n      { \"Cipher Suites\", \"dtls.handshake.ciphersuites\",\n        FT_NONE, BASE_NONE, NULL, 0x0,\n        \"List of cipher suites supported by client\", HFILL }\n    },\n    { &hf_dtls_handshake_cipher_suite,\n      { \"Cipher Suite\", \"dtls.handshake.ciphersuite\",\n        FT_UINT16, BASE_HEX|BASE_EXT_STRING, &ssl_31_ciphersuite_ext, 0x0,\n        NULL, HFILL }\n    },\n    { &hf_dtls_handshake_cookie_len,\n      { \"Cookie Length\", \"dtls.handshake.cookie_length\",\n        FT_UINT8, BASE_DEC, NULL, 0x0,\n        \"Length of the cookie field\", HFILL }\n    },\n    { &hf_dtls_handshake_cookie,\n      { \"Cookie\", \"dtls.handshake.cookie\",\n        FT_BYTES, BASE_NONE, NULL, 0x0,\n        NULL, HFILL }\n    },\n    { &hf_dtls_handshake_session_id,\n      { \"Session ID\", \"dtls.handshake.session_id\",\n        FT_BYTES, BASE_NONE, NULL, 0x0,\n        \"Identifies the DTLS session, allowing later resumption\", HFILL }\n    },\n    { &hf_dtls_handshake_comp_methods_len,\n      { \"Compression Methods Length\", \"dtls.handshake.comp_methods_length\",\n        FT_UINT8, BASE_DEC, NULL, 0x0,\n        \"Length of compression methods field\", HFILL }\n    },\n    { &hf_dtls_handshake_comp_methods,\n      { \"Compression Methods\", \"dtls.handshake.comp_methods\",\n        FT_NONE, BASE_NONE, NULL, 0x0,\n        \"List of compression methods supported by client\", HFILL }\n    },\n    { &hf_dtls_handshake_comp_method,\n      { \"Compression Method\", \"dtls.handshake.comp_method\",\n        FT_UINT8, BASE_DEC, VALS(ssl_31_compression_method), 0x0,\n        NULL, HFILL }\n    },\n    { &hf_dtls_handshake_extensions_len,\n      { \"Extensions Length\", \"dtls.handshake.extensions_length\",\n        FT_UINT16, BASE_DEC, NULL, 0x0,\n        \"Length of hello extensions\", HFILL }\n    },\n    { &hf_dtls_handshake_extension_type,\n      { \"Type\", \"dtls.handshake.extension.type\",\n        FT_UINT16, BASE_HEX, VALS(tls_hello_extension_types), 0x0,\n        \"Hello extension type\", HFILL }\n    },\n    { &hf_dtls_handshake_extension_len,\n      { \"Length\", \"dtls.handshake.extension.len\",\n        FT_UINT16, BASE_DEC, NULL, 0x0,\n        \"Length of a hello extension\", HFILL }\n    },\n    { &hf_dtls_handshake_extension_data,\n      { \"Data\", \"dtls.handshake.extension.data\",\n        FT_BYTES, BASE_NONE, NULL, 0x0,\n        \"Hello Extension data\", HFILL }\n    },\n\t{ &hf_dtls_handshake_session_ticket_lifetime_hint,\n\t  { \"Session Ticket Lifetime Hint\", \"dtls.handshake.session_ticket_lifetime_hint\",\n\t\tFT_UINT32, BASE_DEC, NULL, 0x0,\n\t\t\"New DTLS Session Ticket Lifetime Hint\", HFILL }\n\t},\n\t{ &hf_dtls_handshake_session_ticket_len,\n\t  { \"Session Ticket Length\", \"dtls.handshake.session_ticket_length\",\n\t\tFT_UINT16, BASE_DEC, NULL, 0x0,\n\t\t\"New DTLS Session Ticket Length\", HFILL }\n\t},\n\t{ &hf_dtls_handshake_session_ticket,\n\t  { \"Session Ticket\", \"dtls.handshake.session_ticket\",\n\t\tFT_BYTES, BASE_NONE, NULL, 0x0,\n\t\t\"New DTLS Session Ticket\", HFILL }\n\t},\n    { &hf_dtls_handshake_certificates_len,\n      { \"Certificates Length\", \"dtls.handshake.certificates_length\",\n        FT_UINT24, BASE_DEC, NULL, 0x0,\n        \"Length of certificates field\", HFILL }\n    },\n    { &hf_dtls_handshake_certificates,\n      { \"Certificates\", \"dtls.handshake.certificates\",\n        FT_NONE, BASE_NONE, NULL, 0x0,\n        \"List of certificates\", HFILL }\n    },\n    { &hf_dtls_handshake_certificate,\n      { \"Certificate\", \"dtls.handshake.certificate\",\n        FT_BYTES, BASE_NONE, NULL, 0x0,\n        NULL, HFILL }\n    },\n    { &hf_dtls_handshake_certificate_len,\n      { \"Certificate Length\", \"dtls.handshake.certificate_length\",\n        FT_UINT24, BASE_DEC, NULL, 0x0,\n        \"Length of certificate\", HFILL }\n    },\n    { &hf_dtls_handshake_cert_types_count,\n      { \"Certificate types count\", \"dtls.handshake.cert_types_count\",\n        FT_UINT8, BASE_DEC, NULL, 0x0,\n        \"Count of certificate types\", HFILL }\n    },\n    { &hf_dtls_handshake_cert_types,\n      { \"Certificate types\", \"dtls.handshake.cert_types\",\n        FT_NONE, BASE_NONE, NULL, 0x0,\n        \"List of certificate types\", HFILL }\n    },\n    { &hf_dtls_handshake_cert_type,\n      { \"Certificate type\", \"dtls.handshake.cert_type\",\n        FT_UINT8, BASE_DEC, VALS(ssl_31_client_certificate_type), 0x0,\n        NULL, HFILL }\n    },\n    { &hf_dtls_handshake_finished,\n      { \"Verify Data\", \"dtls.handshake.verify_data\",\n        FT_NONE, BASE_NONE, NULL, 0x0,\n        \"Opaque verification data\", HFILL }\n    },\n    { &hf_dtls_handshake_md5_hash,\n      { \"MD5 Hash\", \"dtls.handshake.md5_hash\",\n        FT_NONE, BASE_NONE, NULL, 0x0,\n        \"Hash of messages, master_secret, etc.\", HFILL }\n    },\n    { &hf_dtls_handshake_sha_hash,\n      { \"SHA-1 Hash\", \"dtls.handshake.sha_hash\",\n        FT_NONE, BASE_NONE, NULL, 0x0,\n        \"Hash of messages, master_secret, etc.\", HFILL }\n    },\n    { &hf_dtls_handshake_session_id_len,\n      { \"Session ID Length\", \"dtls.handshake.session_id_length\",\n        FT_UINT8, BASE_DEC, NULL, 0x0,\n        \"Length of session ID field\", HFILL }\n    },\n    { &hf_dtls_handshake_dnames_len,\n      { \"Distinguished Names Length\", \"dtls.handshake.dnames_len\",\n        FT_UINT16, BASE_DEC, NULL, 0x0,\n        \"Length of list of CAs that server trusts\", HFILL }\n    },\n    { &hf_dtls_handshake_dnames,\n      { \"Distinguished Names\", \"dtls.handshake.dnames\",\n        FT_NONE, BASE_NONE, NULL, 0x0,\n        \"List of CAs that server trusts\", HFILL }\n    },\n    { &hf_dtls_handshake_dname_len,\n      { \"Distinguished Name Length\", \"dtls.handshake.dname_len\",\n        FT_UINT16, BASE_DEC, NULL, 0x0,\n        \"Length of distinguished name\", HFILL }\n    },\n    { &hf_dtls_handshake_dname,\n      { \"Distinguished Name\", \"dtls.handshake.dname\",\n        FT_BYTES, BASE_NONE, NULL, 0x0,\n        \"Distinguished name of a CA that server trusts\", HFILL }\n    },\n    { &hf_dtls_heartbeat_extension_mode,\n      { \"Mode\", \"dtls.handshake.extension.heartbeat.mode\",\n        FT_UINT8, BASE_DEC, VALS(tls_heartbeat_mode), 0x0,\n        \"Heartbeat extension mode\", HFILL }\n    },\n    { &hf_dtls_heartbeat_message,\n      { \"Heartbeat Message\", \"dtls.heartbeat_message\",\n        FT_NONE, BASE_NONE, NULL, 0x0,\n        NULL, HFILL }\n    },\n    { &hf_dtls_heartbeat_message_type,\n      { \"Type\", \"dtls.heartbeat_message.type\",\n        FT_UINT8, BASE_DEC, VALS(tls_heartbeat_type), 0x0,\n        \"Heartbeat message type\", HFILL }\n    },\n    { &hf_dtls_heartbeat_message_payload_length,\n      { \"Payload Length\", \"dtls.heartbeat_message.payload_length\",\n        FT_UINT16, BASE_DEC, NULL, 0x00, NULL, HFILL }\n    },\n    { &hf_dtls_heartbeat_message_payload,\n      { \"Payload Length\", \"dtls.heartbeat_message.payload\",\n        FT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }\n    },\n    { &hf_dtls_heartbeat_message_padding,\n      { \"Payload Length\", \"dtls.heartbeat_message.padding\",\n        FT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL }\n    },\n    { &hf_dtls_fragments,\n      { \"Message fragments\", \"dtls.fragments\",\n        FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL }\n    },\n    { &hf_dtls_fragment,\n      { \"Message fragment\", \"dtls.fragment\",\n        FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }\n    },\n    { &hf_dtls_fragment_overlap,\n      { \"Message fragment overlap\", \"dtls.fragment.overlap\",\n        FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_dtls_fragment_overlap_conflicts,\n      { \"Message fragment overlapping with conflicting data\",\n        \"dtls.fragment.overlap.conflicts\",\n       FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_dtls_fragment_multiple_tails,\n      { \"Message has multiple tail fragments\",\n        \"dtls.fragment.multiple_tails\",\n        FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_dtls_fragment_too_long_fragment,\n      { \"Message fragment too long\", \"dtls.fragment.too_long_fragment\",\n        FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL }\n    },\n    { &hf_dtls_fragment_error,\n      { \"Message defragmentation error\", \"dtls.fragment.error\",\n        FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }\n    },\n    { &hf_dtls_fragment_count,\n      { \"Message fragment count\", \"dtls.fragment.count\",\n        FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }\n    },\n    { &hf_dtls_reassembled_in,\n      { \"Reassembled in\", \"dtls.reassembled.in\",\n        FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL }\n    },\n    { &hf_dtls_reassembled_length,\n      { \"Reassembled DTLS length\", \"dtls.reassembled.length\",\n        FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL }\n    },\n  };\n\n  /* Setup protocol subtree array */\n  static gint *ett[] = {\n    &ett_dtls,\n    &ett_dtls_record,\n    &ett_dtls_alert,\n    &ett_dtls_handshake,\n    &ett_dtls_heartbeat,\n    &ett_dtls_cipher_suites,\n    &ett_dtls_comp_methods,\n    &ett_dtls_extension,\n\t&ett_dtls_new_ses_ticket,\n    &ett_dtls_certs,\n    &ett_dtls_cert_types,\n    &ett_dtls_dnames,\n    &ett_dtls_fragment,\n    &ett_dtls_fragments,\n  };\n\n  /* Register the protocol name and description */\n  proto_dtls = proto_register_protocol(\"Datagram Transport Layer Security\",\n                                       \"DTLS\", \"dtls\");\n\n  /* Required function calls to register the header fields and\n   * subtrees used */\n  proto_register_field_array(proto_dtls, hf, array_length(hf));\n  proto_register_subtree_array(ett, array_length(ett));\n\n#ifdef HAVE_LIBGNUTLS\n  {\n    module_t *dtls_module = prefs_register_protocol(proto_dtls, proto_reg_handoff_dtls);\n\n    static uat_field_t dtlskeylist_uats_flds[] = {\n      UAT_FLD_CSTRING_OTHER(sslkeylist_uats, ipaddr, \"IP address\", ssldecrypt_uat_fld_ip_chk_cb, \"IPv4 or IPv6 address\"),\n      UAT_FLD_CSTRING_OTHER(sslkeylist_uats, port, \"Port\", ssldecrypt_uat_fld_port_chk_cb, \"Port Number\"),\n      UAT_FLD_CSTRING_OTHER(sslkeylist_uats, protocol, \"Protocol\", ssldecrypt_uat_fld_protocol_chk_cb, \"Protocol\"),\n      UAT_FLD_FILENAME_OTHER(sslkeylist_uats, keyfile, \"Key File\", ssldecrypt_uat_fld_fileopen_chk_cb, \"Path to the keyfile.\"),\n      UAT_FLD_CSTRING_OTHER(sslkeylist_uats, password,\" Password (p12 file)\", ssldecrypt_uat_fld_password_chk_cb, \"Password\"),\n      UAT_END_FIELDS\n    };\n\n    dtlsdecrypt_uat = uat_new(\"DTLS RSA Keylist\",\n                              sizeof(ssldecrypt_assoc_t),\n                              \"dtlsdecrypttablefile\",         /* filename */\n                              TRUE,                           /* from_profile */\n                              (void*) &dtlskeylist_uats,      /* data_ptr */\n                              &ndtlsdecrypt,                  /* numitems_ptr */\n                              UAT_CAT_FFMT,                   /* category */\n                              \"ChK12ProtocolsSection\",        /* TODO, need revision - help */\n                              dtlsdecrypt_copy_cb,\n                              NULL, /* dtlsdecrypt_update_cb? */\n                              dtlsdecrypt_free_cb,\n                              dtls_parse_uat,\n                              dtlskeylist_uats_flds);\n\n    prefs_register_uat_preference(dtls_module, \"cfg\",\n                                  \"RSA keys list\",\n                                  \"A table of RSA keys for DTLS decryption\",\n                                  dtlsdecrypt_uat);\n\n    prefs_register_filename_preference(dtls_module, \"debug_file\", \"DTLS debug file\",\n                                       \"redirect dtls debug to file name; leave empty to disable debug, \"\n                                       \"use \\\"\" SSL_DEBUG_USE_STDERR \"\\\" to redirect output to stderr\\n\",\n                                       &dtls_debug_file_name);\n\n    prefs_register_string_preference(dtls_module, \"keys_list\", \"RSA keys list (deprecated)\",\n                                     \"Semicolon-separated list of private RSA keys used for DTLS decryption. \"\n                                     \"Used by versions of Wireshark prior to 1.6\",\n                                     &dtls_keys_list);\n\n  }\n#endif\n\n  register_dissector(\"dtls\", dissect_dtls, proto_dtls);\n  dtls_handle = find_dissector(\"dtls\");\n\n  dtls_associations = g_tree_new(ssl_association_cmp);\n\n  register_init_routine(dtls_init);\n  ssl_lib_init();\n  dtls_tap = register_tap(\"dtls\");\n  ssl_debug_printf(\"proto_register_dtls: registered tap %s:%d\\n\",\n                   \"dtls\", dtls_tap);\n\n  register_heur_dissector_list(\"dtls\", &heur_subdissector_list);\n}\n\n\n/* If this dissector uses sub-dissector registration add a registration\n * routine.  This format is required because a script is used to find\n * these routines and create the code that calls these routines.\n */\nvoid\nproto_reg_handoff_dtls(void)\n{\n  static gboolean initialized = FALSE;\n\n  /* add now dissector to default ports.*/\n  dtls_parse_uat();\n  dtls_parse_old_keys();\n\n  if (initialized == FALSE)\n    heur_dissector_add(\"udp\", dissect_dtls_heur, proto_dtls);\n\n  initialized = TRUE;\n}\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"out_of_bounds_read\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code reads memory outside the allocated bounds of an array or buffer. This can cause crashes or expose sensitive memory contents to attackers.\",\n  \"risk\": \"Memory disclosure, application crashes, information leakage, potential code execution\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before array access\\n// Instead of: value = array[index];\\n// Use: if (index >= 0 && index < array_size) {\\n//         value = array[index];\\n//       } else {\\n//         handle_error();\\n//       }\\n\\n// Or use safe library functions that check bounds\\n\",\n  \"source\": \"SARD-148907\",\n  \"cwe\": \"CWE-125\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* reassemble.c\n * Routines for {fragment,segment} reassembly\n *\n * $Id: reassemble.c 41216 2012-02-28 03:19:49Z morriss $\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <string.h>\n\n#include <epan/packet.h>\n\n#include <epan/reassemble.h>\n\n#include <epan/emem.h>\n\n#include <epan/dissectors/packet-dcerpc.h>\n\ntypedef struct _fragment_key {\n\taddress src;\n\taddress dst;\n\tguint32 id;\n} fragment_key;\n\ntypedef struct _dcerpc_fragment_key {\n\taddress src;\n\taddress dst;\n\tguint32 id;\n\te_uuid_t act_id;\n} dcerpc_fragment_key;\n\nstatic void LINK_FRAG(fragment_data *fd_head,fragment_data *fd)\n{\n\tfragment_data *fd_i;\n\n\t/* add fragment to list, keep list sorted */\n\tfor(fd_i= fd_head; fd_i->next;fd_i=fd_i->next) {\n\t\tif (fd->offset < fd_i->next->offset )\n\t\t\tbreak;\n\t}\n\tfd->next=fd_i->next;\n\tfd_i->next=fd;\n}\n\n/* copy a fragment key to heap store to insert in the hash */\nstatic void *fragment_key_copy(const void *k)\n{\n\tconst fragment_key* key = (const fragment_key*) k;\n\tfragment_key *new_key = g_slice_new(fragment_key);\n\n\tCOPY_ADDRESS(&new_key->src, &key->src);\n\tCOPY_ADDRESS(&new_key->dst, &key->dst);\n\tnew_key->id = key->id;\n\treturn new_key;\n}\n\n/* copy a dcerpc fragment key to heap store to insert in the hash */\nstatic void *dcerpc_fragment_key_copy(const void *k)\n{\n\tconst dcerpc_fragment_key* key = (const dcerpc_fragment_key*) k;\n\n\tdcerpc_fragment_key *new_key = g_slice_new(dcerpc_fragment_key);\n\n\tCOPY_ADDRESS(&new_key->src, &key->src);\n\tCOPY_ADDRESS(&new_key->dst, &key->dst);\n\tnew_key->id = key->id;\n\tnew_key->act_id = key->act_id;\n\n\treturn new_key;\n}\n\n\nstatic gint\nfragment_equal(gconstpointer k1, gconstpointer k2)\n{\n\tconst fragment_key* key1 = (const fragment_key*) k1;\n\tconst fragment_key* key2 = (const fragment_key*) k2;\n\n\t/*key.id is the first item to compare since item is most\n\t  likely to differ between sessions, thus shortcircuiting\n\t  the comparasion of addresses.\n\t*/\n\treturn ( ( (key1->id\t== key2->id) &&\n\t\t   (ADDRESSES_EQUAL(&key1->src, &key2->src)) &&\n\t\t   (ADDRESSES_EQUAL(&key1->dst, &key2->dst))\n\t\t ) ?\n\t\t TRUE : FALSE);\n}\n\nstatic guint\nfragment_hash(gconstpointer k)\n{\n\tconst fragment_key* key = (const fragment_key*) k;\n\tguint hash_val;\n/*\n\tint i;\n*/\n\n\thash_val = 0;\n\n/*\tMore than likely: in most captures src and dst addresses are the\n\tsame, and would hash the same.\n\tWe only use id as the hash as an optimization.\n\n\tfor (i = 0; i < key->src.len; i++)\n\t\thash_val += key->src.data[i];\n\tfor (i = 0; i < key->dst.len; i++)\n\t\thash_val += key->dst.data[i];\n*/\n\n\thash_val += key->id;\n\n\treturn hash_val;\n}\n\nstatic gint\ndcerpc_fragment_equal(gconstpointer k1, gconstpointer k2)\n{\n\tconst dcerpc_fragment_key* key1 = (const dcerpc_fragment_key*) k1;\n\tconst dcerpc_fragment_key* key2 = (const dcerpc_fragment_key*) k2;\n\n\t/*key.id is the first item to compare since item is most\n\t  likely to differ between sessions, thus shortcircuiting\n\t  the comparison of addresses.\n\t*/\n\treturn (((key1->id == key2->id)\n\t\t  && (ADDRESSES_EQUAL(&key1->src, &key2->src))\n\t\t  && (ADDRESSES_EQUAL(&key1->dst, &key2->dst))\n\t\t  && (memcmp (&key1->act_id, &key2->act_id, sizeof (e_uuid_t)) == 0))\n\t\t ? TRUE : FALSE);\n}\n\nstatic guint\ndcerpc_fragment_hash(gconstpointer k)\n{\n\tconst dcerpc_fragment_key* key = (const dcerpc_fragment_key*) k;\n\tguint hash_val;\n\n\thash_val = 0;\n\n\thash_val += key->id;\n\thash_val += key->act_id.Data1;\n\thash_val += key->act_id.Data2 << 16;\n\thash_val += key->act_id.Data3;\n\n\treturn hash_val;\n}\n\ntypedef struct _reassembled_key {\n\tguint32 id;\n\tguint32 frame;\n} reassembled_key;\n\nstatic gint\nreassembled_equal(gconstpointer k1, gconstpointer k2)\n{\n\tconst reassembled_key* key1 = (const reassembled_key*) k1;\n\tconst reassembled_key* key2 = (const reassembled_key*) k2;\n\n\t/*\n\t * We assume that the frame numbers are unlikely to be equal,\n\t * so we check them first.\n\t */\n\treturn key1->frame == key2->frame && key1->id == key2->id;\n}\n\nstatic guint\nreassembled_hash(gconstpointer k)\n{\n\tconst reassembled_key* key = (const reassembled_key*) k;\n\n\treturn key->frame;\n}\n\n/*\n * For a fragment hash table entry, free the associated fragments.\n * The entry value (fd_chain) is freed herein and the entry is freed\n * when fragment_free_key() [or dcerpc_fragment_free_key()] is called\n * (as a consequence of returning TRUE from this function).\n */\nstatic gboolean\nfree_all_fragments(gpointer key_arg _U_, gpointer value, gpointer user_data _U_)\n{\n\tfragment_data *fd_head, *tmp_fd;\n\n\t/* g_hash_table_new_full() was used to supply a function\n\t * to free the key and the addresses.\n\t */\n\tfor (fd_head = value; fd_head != NULL; fd_head = tmp_fd) {\n\t\ttmp_fd=fd_head->next;\n\n\t\tif(fd_head->data && !(fd_head->flags&FD_NOT_MALLOCED))\n\t\t\tg_free(fd_head->data);\n\t\tg_slice_free(fragment_data, fd_head);\n\t}\n\n\treturn TRUE;\n}\n\n/* ------------------------- */\nstatic fragment_data *new_head(const guint32 flags)\n{\n\tfragment_data *fd_head;\n\t/* If head/first structure in list only holds no other data than\n\t* 'datalen' then we don't have to change the head of the list\n\t* even if we want to keep it sorted\n\t*/\n\tfd_head=g_slice_new0(fragment_data);\n\n\tfd_head->flags=flags;\n\treturn fd_head;\n}\n\n/*\n * For a reassembled-packet hash table entry, free the fragment data\n * to which the value refers.\n */\nstatic gboolean\nfree_all_reassembled_fragments(gpointer key_arg _U_, gpointer value,\n\t\t\t\t   gpointer user_data _U_)\n{\n\tfragment_data *fd_head;\n\n\tfor (fd_head = value; fd_head != NULL; fd_head = fd_head->next) {\n\t\tif(fd_head->data && !(fd_head->flags&FD_NOT_MALLOCED)) {\n\t\t\tg_free(fd_head->data);\n\n\t\t\t/*\n\t\t\t * A reassembled packet is inserted into the\n\t\t\t * hash table once for every frame that made\n\t\t\t * up the reassembled packet; clear the data\n\t\t\t * pointer so that we only free the data the\n\t\t\t * first time we see it.\n\t\t\t */\n\t\t\tfd_head->data = NULL;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic void\nfragment_free_key(void *ptr)\n{\n\tfragment_key *key = (fragment_key *)ptr;\n\n\tif(key){\n\t\t/*\n\t\t * Free up the copies of the addresses from the old key.\n\t\t */\n\t\tg_free((gpointer)key->src.data);\n\t\tg_free((gpointer)key->dst.data);\n\n\t\tg_slice_free(fragment_key, key);\n\t}\n}\n\nstatic void\ndcerpc_fragment_free_key(void *ptr)\n{\n\tdcerpc_fragment_key *key = (dcerpc_fragment_key *)ptr;\n\n\tif(key){\n\t\t/*\n\t\t * Free up the copies of the addresses from the old key.\n\t\t */\n\t\tg_free((gpointer)key->src.data);\n\t\tg_free((gpointer)key->dst.data);\n\n\t\tg_slice_free(dcerpc_fragment_key, key);\n\t}\n}\n\n/*\n * Initialize a fragment table.\n */\nvoid\nfragment_table_init(GHashTable **fragment_table)\n{\n\tif (*fragment_table != NULL) {\n\t\t/*\n\t\t * The fragment hash table exists.\n\t\t *\n\t\t * Remove all entries and free fragment data for each entry.\n\t\t *\n\t\t * If slices are used (GLIB >= 2.10)\n\t\t * the keys are freed by calling fragment_free_key()\n\t\t * and the values are freed in free_all_fragments().\n\t\t *\n\t\t * free_all_fragments()\n\t\t * will free the address data associated with the key\n\t\t */\n\t\tg_hash_table_foreach_remove(*fragment_table,\n\t\t\t\tfree_all_fragments, NULL);\n\t} else {\n\t\t/* The fragment table does not exist. Create it */\n\t\t*fragment_table = g_hash_table_new_full(fragment_hash,\n\t\t\t\t\t\t\tfragment_equal, fragment_free_key, NULL);\n\t}\n}\n\nvoid\ndcerpc_fragment_table_init(GHashTable **fragment_table)\n{\n\tif (*fragment_table != NULL) {\n\t\t/*\n\t\t * The fragment hash table exists.\n\t\t *\n\t\t * Remove all entries and free fragment data for each entry.\n\t\t *\n\t\t * If slices are used (GLIB >= 2.10)\n\t\t * the keys are freed by calling dcerpc_fragment_free_key()\n\t\t * and the values are freed in free_all_fragments().\n\t\t *\n\t\t * free_all_fragments()\n\t\t * will free the adrress data associated with the key\n\t\t */\n\t\t   g_hash_table_foreach_remove(*fragment_table,\n\t\t\t\t\t\t   free_all_fragments, NULL);\n\t} else {\n\t\t   /* The fragment table does not exist. Create it */\n\t\t*fragment_table = g_hash_table_new_full(dcerpc_fragment_hash,\n\t\t\t\t\t\t\tdcerpc_fragment_equal, dcerpc_fragment_free_key, NULL);\n\t}\n}\n\n/*\n * Initialize a reassembled-packet table.\n */\nvoid\nreassembled_table_init(GHashTable **reassembled_table)\n{\n\tif (*reassembled_table != NULL) {\n\t\t/*\n\t\t * The reassembled-packet hash table exists.\n\t\t *\n\t\t * Remove all entries and free reassembled packet\n\t\t * data for each entry.\n\t\t */\n\t\tg_hash_table_foreach_remove(*reassembled_table,\n\t\t\t\tfree_all_reassembled_fragments, NULL);\n\t} else {\n\t\t/* The fragment table does not exist. Create it */\n\t\t*reassembled_table = g_hash_table_new(reassembled_hash,\n\t\t\t\treassembled_equal);\n\t}\n}\n\n/* This function cleans up the stored state and removes the reassembly data and\n * (with one exception) all allocated memory for matching reassembly.\n *\n * The exception is :\n * If the PDU was already completely reassembled, then the buffer containing the\n * reassembled data WILL NOT be free()d, and the pointer to that buffer will be\n * returned.\n * Othervise the function will return NULL.\n *\n * So, if you call fragment_delete and it returns non-NULL, YOU are responsible to\n * g_free() that buffer.\n */\nunsigned char *\nfragment_delete(const packet_info *pinfo, const guint32 id, GHashTable *fragment_table)\n{\n\tfragment_data *fd_head, *fd;\n\tfragment_key key;\n\tunsigned char *data=NULL;\n\n\t/* create key to search hash with */\n\tkey.src = pinfo->src;\n\tkey.dst = pinfo->dst;\n\tkey.id\t= id;\n\n\tfd_head = g_hash_table_lookup(fragment_table, &key);\n\n\tif(fd_head==NULL){\n\t\t/* We do not recognize this as a PDU we have seen before. return */\n\t\treturn NULL;\n\t}\n\n\tdata=fd_head->data;\n\t/* loop over all partial fragments and free any buffers */\n\tfor(fd=fd_head->next;fd;){\n\t\tfragment_data *tmp_fd;\n\t\ttmp_fd=fd->next;\n\n\t\tif( !(fd->flags&FD_NOT_MALLOCED) )\n\t\t\tg_free(fd->data);\n\t\tg_slice_free(fragment_data, fd);\n\t\tfd=tmp_fd;\n\t}\n\tg_slice_free(fragment_data, fd_head);\n\tg_hash_table_remove(fragment_table, &key);\n\n\treturn data;\n}\n\n/* This function is used to check if there is partial or completed reassembly state\n * matching this packet. I.e. Is there reassembly going on or not for this packet?\n */\nfragment_data *\nfragment_get(const packet_info *pinfo, const guint32 id, GHashTable *fragment_table)\n{\n\tfragment_data *fd_head;\n\tfragment_key key;\n\n\t/* create key to search hash with */\n\tkey.src = pinfo->src;\n\tkey.dst = pinfo->dst;\n\tkey.id\t= id;\n\n\tfd_head = g_hash_table_lookup(fragment_table, &key);\n\n\treturn fd_head;\n}\n\n/* id *must* be the frame number for this to work! */\nfragment_data *\nfragment_get_reassembled(const guint32 id, GHashTable *reassembled_table)\n{\n\tfragment_data *fd_head;\n\treassembled_key key;\n\n\t/* create key to search hash with */\n\tkey.frame = id;\n\tkey.id = id;\n\tfd_head = g_hash_table_lookup(reassembled_table, &key);\n\n\treturn fd_head;\n}\n\nfragment_data *\nfragment_get_reassembled_id(const packet_info *pinfo, const guint32 id, GHashTable *reassembled_table)\n{\n\tfragment_data *fd_head;\n\treassembled_key key;\n\n\t/* create key to search hash with */\n\tkey.frame = pinfo->fd->num;\n\tkey.id = id;\n\tfd_head = g_hash_table_lookup(reassembled_table, &key);\n\n\treturn fd_head;\n}\n\n/* This function can be used to explicitly set the total length (if known)\n * for reassembly of a PDU.\n * This is useful for reassembly of PDUs where one may have the total length specified\n * in the first fragment instead of as for, say, IPv4 where a flag indicates which\n * is the last fragment.\n *\n * Such protocols might fragment_add with a more_frags==TRUE for every fragment\n * and just tell the reassembly engine the expected total length of the reassembled data\n * using fragment_set_tot_len immediately after doing fragment_add for the first packet.\n *\n * Note that for FD_BLOCKSEQUENCE tot_len is the index for the tail fragment.\n * i.e. since the block numbers start at 0, if we specify tot_len==2, that\n * actually means we want to defragment 3 blocks, block 0, 1 and 2.\n */\nvoid\nfragment_set_tot_len(const packet_info *pinfo, const guint32 id, GHashTable *fragment_table,\n\t\t\t const guint32 tot_len)\n{\n\tfragment_data *fd_head;\n\tfragment_key key;\n\n\t/* create key to search hash with */\n\tkey.src = pinfo->src;\n\tkey.dst = pinfo->dst;\n\tkey.id\t= id;\n\n\tfd_head = g_hash_table_lookup(fragment_table, &key);\n\n\tif(fd_head){\n\t\tfd_head->datalen = tot_len;\n\t\tfd_head->flags |= FD_DATALEN_SET;\n\t}\n\n\treturn;\n}\n\nguint32\nfragment_get_tot_len(const packet_info *pinfo, const guint32 id, GHashTable *fragment_table)\n{\n\tfragment_data *fd_head;\n\tfragment_key key;\n\n\t/* create key to search hash with */\n\tkey.src = pinfo->src;\n\tkey.dst = pinfo->dst;\n\tkey.id\t= id;\n\n\tfd_head = g_hash_table_lookup(fragment_table, &key);\n\n\tif(fd_head){\n\t\treturn fd_head->datalen;\n\t}\n\n\treturn 0;\n}\n\n\n/* This function will set the partial reassembly flag for a fh.\n   When this function is called, the fh MUST already exist, i.e.\n   the fh MUST be created by the initial call to fragment_add() before\n   this function is called.\n   Also note that this function MUST be called to indicate a fh will be\n   extended (increase the already stored data)\n*/\n\nvoid\nfragment_set_partial_reassembly(const packet_info *pinfo, const guint32 id, GHashTable *fragment_table)\n{\n\tfragment_data *fd_head;\n\tfragment_key key;\n\n\t/* create key to search hash with */\n\tkey.src = pinfo->src;\n\tkey.dst = pinfo->dst;\n\tkey.id\t= id;\n\n\tfd_head = g_hash_table_lookup(fragment_table, &key);\n\n\t/*\n\t * XXX - why not do all the stuff done early in \"fragment_add_work()\",\n\t * turning off FD_DEFRAGMENTED and pointing the fragments' data\n\t * pointers to the appropriate part of the already-reassembled\n\t * data, and clearing the data length and \"reassembled in\" frame\n\t * number, here?  We currently have a hack in the TCP dissector\n\t * not to set the \"reassembled in\" value if the \"partial reassembly\"\n\t * flag is set, so that in the first pass through the packets\n\t * we don't falsely set a packet as reassembled in that packet\n\t * if the dissector decided that even more reassembly was needed.\n\t */\n\tif(fd_head){\n\t\tfd_head->flags |= FD_PARTIAL_REASSEMBLY;\n\t}\n}\n\n/*\n * This function gets rid of an entry from a fragment table, given\n * a pointer to the key for that entry; it also frees up the key\n * and the addresses in it.\n * Note: If we use slices keys are freed by fragment_free_key()\n         [or dcerpc_fragment_free_key()] being called\n *       during g_hash_table_remove().\n */\nstatic void\nfragment_unhash(GHashTable *fragment_table, fragment_key *key)\n{\n\t/*\n\t * Remove the entry from the fragment table.\n\t */\n\tg_hash_table_remove(fragment_table, key);\n\n\t/*\n\t * Free the key itself.\n\t */\n}\n\n/*\n * This function adds fragment_data structure to a reassembled-packet\n * hash table, using the frame numbers of each of the frames from\n * which it was reassembled as keys, and sets the \"reassembled_in\"\n * frame number.\n */\nstatic void\nfragment_reassembled(fragment_data *fd_head, const packet_info *pinfo,\n\t\t GHashTable *reassembled_table, const guint32 id)\n{\n\treassembled_key *new_key;\n\tfragment_data *fd;\n\n\tif (fd_head->next == NULL) {\n\t\t/*\n\t\t * This was not fragmented, so there's no fragment\n\t\t * table; just hash it using the current frame number.\n\t\t */\n\t\tnew_key = se_alloc(sizeof(reassembled_key));\n\t\tnew_key->frame = pinfo->fd->num;\n\t\tnew_key->id = id;\n\t\tg_hash_table_insert(reassembled_table, new_key, fd_head);\n\t} else {\n\t\t/*\n\t\t * Hash it with the frame numbers for all the frames.\n\t\t */\n\t\tfor (fd = fd_head->next; fd != NULL; fd = fd->next){\n\t\t\tnew_key = se_alloc(sizeof(reassembled_key));\n\t\t\tnew_key->frame = fd->frame;\n\t\t\tnew_key->id = id;\n\t\t\tg_hash_table_insert(reassembled_table, new_key,\n\t\t\t\tfd_head);\n\t\t}\n\t}\n\tfd_head->flags |= FD_DEFRAGMENTED;\n\tfd_head->reassembled_in = pinfo->fd->num;\n}\n\n/*\n * This function adds a new fragment to the fragment hash table.\n * If this is the first fragment seen for this datagram, a new entry\n * is created in the hash table, otherwise this fragment is just added\n * to the linked list of fragments for this packet.\n * The list of fragments for a specific datagram is kept sorted for\n * easier handling.\n *\n * Returns a pointer to the head of the fragment data list if we have all the\n * fragments, NULL otherwise.\n *\n * This function assumes frag_offset being a byte offset into the defragment\n * packet.\n *\n * 01-2002\n * Once the fh is defragmented (= FD_DEFRAGMENTED set), it can be\n * extended using the FD_PARTIAL_REASSEMBLY flag. This flag should be set\n * using fragment_set_partial_reassembly() before calling fragment_add\n * with the new fragment. FD_TOOLONGFRAGMENT and FD_MULTIPLETAILS flags\n * are lowered when a new extension process is started.\n */\nstatic gboolean\nfragment_add_work(fragment_data *fd_head, tvbuff_t *tvb, const int offset,\n\t\t const packet_info *pinfo, const guint32 frag_offset,\n\t\t const guint32 frag_data_len, const gboolean more_frags)\n{\n\tfragment_data *fd;\n\tfragment_data *fd_i;\n\tguint32 max, dfpos;\n\tunsigned char *old_data;\n\n\t/* create new fd describing this fragment */\n\tfd = g_slice_new(fragment_data);\n\tfd->next = NULL;\n\tfd->flags = 0;\n\tfd->frame = pinfo->fd->num;\n\tif (fd->frame > fd_head->frame)\n\t\tfd_head->frame = fd->frame;\n\tfd->offset = frag_offset;\n\tfd->len  = frag_data_len;\n\tfd->data = NULL;\n\n\t/*\n\t * If it was already defragmented and this new fragment goes beyond\n\t * data limits, set flag in already empty fds & point old fds to malloc'ed data.\n\t */\n\tif(fd_head->flags & FD_DEFRAGMENTED && (frag_offset+frag_data_len) >= fd_head->datalen &&\n\t\tfd_head->flags & FD_PARTIAL_REASSEMBLY){\n\t\tfor(fd_i=fd_head->next; fd_i; fd_i=fd_i->next){\n\t\t\tif( !fd_i->data ) {\n\t\t\t\tfd_i->data = fd_head->data + fd_i->offset;\n\t\t\t\tfd_i->flags |= FD_NOT_MALLOCED;\n\t\t\t}\n\t\t\tfd_i->flags &= (~FD_TOOLONGFRAGMENT) & (~FD_MULTIPLETAILS);\n\t\t}\n\t\tfd_head->flags &= ~(FD_DEFRAGMENTED|FD_PARTIAL_REASSEMBLY|FD_DATALEN_SET);\n\t\tfd_head->flags &= (~FD_TOOLONGFRAGMENT) & (~FD_MULTIPLETAILS);\n\t\tfd_head->datalen=0;\n\t\tfd_head->reassembled_in=0;\n\t}\n\n\tif (!more_frags) {\n\t\t/*\n\t\t * This is the tail fragment in the sequence.\n\t\t */\n\t\tif (fd_head->flags & FD_DATALEN_SET) {\n\t\t\t/* ok we have already seen other tails for this packet\n\t\t\t * it might be a duplicate.\n\t\t\t */\n\t\t\tif (fd_head->datalen != (fd->offset + fd->len) ){\n\t\t\t\t/* Oops, this tail indicates a different packet\n\t\t\t\t * len than the previous ones. Something's wrong.\n\t\t\t\t */\n\t\t\t\tfd->flags\t   |= FD_MULTIPLETAILS;\n\t\t\t\tfd_head->flags |= FD_MULTIPLETAILS;\n\t\t\t}\n\t\t} else {\n\t\t\t/* this was the first tail fragment, now we know the\n\t\t\t * length of the packet\n\t\t\t */\n\t\t\tfd_head->datalen = fd->offset + fd->len;\n\t\t\tfd_head->flags |= FD_DATALEN_SET;\n\t\t}\n\t}\n\n\n\n\n\t/* If the packet is already defragmented, this MUST be an overlap.\n\t * The entire defragmented packet is in fd_head->data.\n\t * Even if we have previously defragmented this packet, we still\n\t * check it. Someone might play overlap and TTL games.\n\t */\n\tif (fd_head->flags & FD_DEFRAGMENTED) {\n\t\tguint32 end_offset = fd->offset + fd->len;\n\t\tfd->flags\t   |= FD_OVERLAP;\n\t\tfd_head->flags |= FD_OVERLAP;\n\t\t/* make sure it's not too long */\n\t\tif (end_offset > fd_head->datalen || end_offset < fd->offset || end_offset < fd->len) {\n\t\t\tfd->flags\t   |= FD_TOOLONGFRAGMENT;\n\t\t\tfd_head->flags |= FD_TOOLONGFRAGMENT;\n\t\t}\n\t\t/* make sure it doesn't conflict with previous data */\n\t\telse if ( memcmp(fd_head->data+fd->offset,\n\t\t\ttvb_get_ptr(tvb,offset,fd->len),fd->len) ){\n\t\t\tfd->flags\t   |= FD_OVERLAPCONFLICT;\n\t\t\tfd_head->flags |= FD_OVERLAPCONFLICT;\n\t\t}\n\t\t/* it was just an overlap, link it and return */\n\t\tLINK_FRAG(fd_head,fd);\n\t\treturn TRUE;\n\t}\n\n\n\n\t/* If we have reached this point, the packet is not defragmented yet.\n\t * Save all payload in a buffer until we can defragment.\n\t * XXX - what if we didn't capture the entire fragment due\n\t * to a too-short snapshot length?\n\t */\n\tfd->data = g_malloc(fd->len);\n\ttvb_memcpy(tvb, fd->data, offset, fd->len);\n\tLINK_FRAG(fd_head,fd);\n\n\n\tif( !(fd_head->flags & FD_DATALEN_SET) ){\n\t\t/* if we dont know the datalen, there are still missing\n\t\t * packets. Cheaper than the check below.\n\t\t */\n\t\treturn FALSE;\n\t}\n\n\n\t/*\n\t * Check if we have received the entire fragment.\n\t * This is easy since the list is sorted and the head is faked.\n\t *\n\t * First, we compute the amount of contiguous data that's\n\t * available.  (The check for fd_i->offset <= max rules out\n\t * fragments that don't start before or at the end of the\n\t * previous fragment, i.e. fragments that have a gap between\n\t * them and the previous fragment.)\n\t */\n\tmax = 0;\n\tfor (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) {\n\t\tif ( ((fd_i->offset)<=max) &&\n\t\t\t((fd_i->offset+fd_i->len)>max) ){\n\t\t\tmax = fd_i->offset+fd_i->len;\n\t\t}\n\t}\n\n\tif (max < (fd_head->datalen)) {\n\t\t/*\n\t\t * The amount of contiguous data we have is less than the\n\t\t * amount of data we're trying to reassemble, so we haven't\n\t\t * received all packets yet.\n\t\t */\n\t\treturn FALSE;\n\t}\n\n\n\tif (max > (fd_head->datalen)) {\n\t\t/*XXX not sure if current fd was the TOOLONG*/\n\t\t/*XXX is it fair to flag current fd*/\n\t\t/* oops, too long fragment detected */\n\t\tfd->flags\t   |= FD_TOOLONGFRAGMENT;\n\t\tfd_head->flags |= FD_TOOLONGFRAGMENT;\n\t}\n\n\t/* we have received an entire packet, defragment it and\n\t * free all fragments\n\t */\n\t/* store old data just in case */\n\told_data=fd_head->data;\n\tfd_head->data = g_malloc(max);\n\n\t/* add all data fragments */\n\tfor (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next) {\n\t\tif (fd_i->len) {\n\t\t\t/* dfpos is always >= than fd_i->offset */\n\t\t\t/* No gaps can exist here, max_loop(above) does this */\n\t\t\t/* XXX - true? Can we get fd_i->offset+fd-i->len */\n\t\t\t/* overflowing, for example? */\n\t\t\t/*\tActually: there is at least one pathological case wherein there can be fragments\n\t\t\t *\ton the list which are for offsets greater than max (i.e.: following a gap after max).\n\t\t\t *\t(Apparently a \"DESEGMENT_UNTIL_FIN\" was involved wherein the FIN packet had an offset\n\t\t\t *\tless than the highest fragment offset seen. [Seen from a fuzz-test: bug #2470]).\n\t\t\t *\tNote that the \"overlap\" compare must only be done for fragments with (offset+len) <= max\n\t\t\t *\tand thus within the newly g_malloc'd buffer.\n\t\t\t */\n\n\t\t\tif ( fd_i->offset+fd_i->len > dfpos ) {\n\t\t\t\tif (fd_i->offset+fd_i->len > max)\n\t\t\t\t\tg_warning(\"Reassemble error in frame %u: offset %u + len %u > max %u\",\n\t\t\t\t\t\tpinfo->fd->num, fd_i->offset,\n\t\t\t\t\t\tfd_i->len, max);\n\t\t\t\telse if (dfpos < fd_i->offset)\n\t\t\t\t\tg_warning(\"Reassemble error in frame %u: dfpos %u < offset %u\",\n\t\t\t\t\t\tpinfo->fd->num, dfpos, fd_i->offset);\n\t\t\t\telse if (dfpos-fd_i->offset > fd_i->len)\n\t\t\t\t\tg_warning(\"Reassemble error in frame %u: dfpos %u - offset %u > len %u\",\n\t\t\t\t\t\tpinfo->fd->num, dfpos, fd_i->offset,\n\t\t\t\t\t\tfd_i->len);\n\t\t\t\telse if (!fd_head->data)\n\t\t\t\t\tg_warning(\"Reassemble error in frame %u: no data\",\n\t\t\t\t\t\tpinfo->fd->num);\n\t\t\t\telse {\n\t\t\t\t\tif (fd_i->offset < dfpos) {\n\t\t\t\t\t\tfd_i->flags    |= FD_OVERLAP;\n\t\t\t\t\t\tfd_head->flags |= FD_OVERLAP;\n\t\t\t\t\t\tif ( memcmp(fd_head->data+fd_i->offset,\n\t\t\t\t\t\t\t\tfd_i->data,\n\t\t\t\t\t\t\t\tMIN(fd_i->len,(dfpos-fd_i->offset))\n\t\t\t\t\t\t\t\t ) ) {\n\t\t\t\t\t\t\tfd_i->flags    |= FD_OVERLAPCONFLICT;\n\t\t\t\t\t\t\tfd_head->flags |= FD_OVERLAPCONFLICT;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmemcpy(fd_head->data+dfpos,\n\t\t\t\t\t\tfd_i->data+(dfpos-fd_i->offset),\n\t\t\t\t\t\tfd_i->len-(dfpos-fd_i->offset));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (fd_i->offset + fd_i->len < fd_i->offset) /* Integer overflow? */\n\t\t\t\t\tg_warning(\"Reassemble error in frame %u: offset %u + len %u < offset\",\n\t\t\t\t\t\tpinfo->fd->num, fd_i->offset,\n\t\t\t\t\t\tfd_i->len);\n\t\t\t}\n\t\t\tif( fd_i->flags & FD_NOT_MALLOCED )\n\t\t\t\tfd_i->flags &= ~FD_NOT_MALLOCED;\n\t\t\telse\n\t\t\t\tg_free(fd_i->data);\n\t\t\tfd_i->data=NULL;\n\n\t\t\tdfpos=MAX(dfpos,(fd_i->offset+fd_i->len));\n\t\t}\n\t}\n\n\tg_free(old_data);\n\t/* mark this packet as defragmented.\n\t\t   allows us to skip any trailing fragments */\n\tfd_head->flags |= FD_DEFRAGMENTED;\n\tfd_head->reassembled_in=pinfo->fd->num;\n\n\treturn TRUE;\n}\n\nstatic fragment_data *\nfragment_add_common(tvbuff_t *tvb, const int offset, const packet_info *pinfo, const guint32 id,\n\t\t GHashTable *fragment_table, const guint32 frag_offset,\n\t\t const guint32 frag_data_len, const gboolean more_frags,\n\t\t const gboolean check_already_added)\n{\n\tfragment_key key, *new_key;\n\tfragment_data *fd_head;\n\tfragment_data *fd_item;\n\tgboolean already_added=pinfo->fd->flags.visited;\n\n\n\t/* dissector shouldn't give us garbage tvb info */\n\tDISSECTOR_ASSERT(tvb_bytes_exist(tvb, offset, frag_data_len));\n\n\t/* create key to search hash with */\n\tkey.src = pinfo->src;\n\tkey.dst = pinfo->dst;\n\tkey.id\t= id;\n\n\tfd_head = g_hash_table_lookup(fragment_table, &key);\n\n#if 0\n\t/* debug output of associated fragments. */\n\t/* leave it here for future debugging sessions */\n\tif(strcmp(pinfo->current_proto, \"DCERPC\") == 0) {\n\t\tprintf(\"proto:%s num:%u id:%u offset:%u len:%u more:%u visited:%u\\n\",\n\t\t\tpinfo->current_proto, pinfo->fd->num, id, frag_offset, frag_data_len, more_frags, pinfo->fd->flags.visited);\n\t\tif(fd_head != NULL) {\n\t\t\tfor(fd_item=fd_head->next;fd_item;fd_item=fd_item->next){\n\t\t\t\tprintf(\"fd_frame:%u fd_offset:%u len:%u datalen:%u\\n\",\n\t\t\t\t\tfd_item->frame, fd_item->offset, fd_item->len, fd_item->datalen);\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * \"already_added\" is true if \"pinfo->fd->flags.visited\" is true;\n\t * if \"pinfo->fd->flags.visited\", this isn't the first pass, so\n\t * we've already done all the reassembly and added all the\n\t * fragments.\n\t *\n\t * If it's not true, but \"check_already_added\" is true, just check\n\t * if we have seen this fragment before, i.e., if we have already\n\t * added it to reassembly.\n\t * That can be true even if \"pinfo->fd->flags.visited\" is false\n\t * since we sometimes might call a subdissector multiple times.\n\t * As an additional check, just make sure we have not already added\n\t * this frame to the reassembly list, if there is a reassembly list;\n\t * note that the first item in the reassembly list is not a\n\t * fragment, it's a data structure for the reassembled packet.\n\t * We don't check it because its \"frame\" member isn't initialized\n\t * to anything, and because it doesn't count in any case.\n\t *\n\t * And as another additional check, make sure the fragment offsets are\n\t * the same, as otherwise we get into trouble if multiple fragments\n\t * are in one PDU.\n\t */\n\tif (!already_added && check_already_added && fd_head != NULL) {\n\t\tif (pinfo->fd->num <= fd_head->frame) {\n\t\t\tfor(fd_item=fd_head->next;fd_item;fd_item=fd_item->next){\n\t\t\t\tif(pinfo->fd->num==fd_item->frame && frag_offset==fd_item->offset){\n\t\t\t\t\talready_added=TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/* have we already added this frame ?*/\n\tif (already_added) {\n\t\tif (fd_head != NULL && fd_head->flags & FD_DEFRAGMENTED) {\n\t\t\treturn fd_head;\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (fd_head==NULL){\n\t\t/* not found, this must be the first snooped fragment for this\n\t\t\t\t * packet. Create list-head.\n\t\t */\n\t\tfd_head = new_head(0);\n\n\t\t/*\n\t\t * We're going to use the key to insert the fragment,\n\t\t * so allocate a structure for it, and copy the\n\t\t * addresses, allocating new buffers for the address\n\t\t * data.\n\t\t */\n\t\tnew_key = g_slice_new(fragment_key);\n\t\tCOPY_ADDRESS(&new_key->src, &key.src);\n\t\tCOPY_ADDRESS(&new_key->dst, &key.dst);\n\t\tnew_key->id = key.id;\n\t\tg_hash_table_insert(fragment_table, new_key, fd_head);\n\t}\n\n\tif (fragment_add_work(fd_head, tvb, offset, pinfo, frag_offset,\n\t\tfrag_data_len, more_frags)) {\n\t\t/*\n\t\t * Reassembly is complete.\n\t\t */\n\t\treturn fd_head;\n\t} else {\n\t\t/*\n\t\t * Reassembly isn't complete.\n\t\t */\n\t\treturn NULL;\n\t}\n}\n\nfragment_data *\nfragment_add(tvbuff_t *tvb, const int offset, const packet_info *pinfo, const guint32 id,\n\t\t GHashTable *fragment_table, const guint32 frag_offset,\n\t\t const guint32 frag_data_len, const gboolean more_frags)\n{\n\treturn fragment_add_common(tvb, offset, pinfo, id, fragment_table,\n\t\tfrag_offset, frag_data_len, more_frags, TRUE);\n}\n\n/*\n * For use when you can have multiple fragments in the same frame added\n * to the same reassembled PDU, e.g. with ONC RPC-over-TCP.\n */\nfragment_data *\nfragment_add_multiple_ok(tvbuff_t *tvb, const int offset, const packet_info *pinfo,\n\t\t\t const guint32 id, GHashTable *fragment_table,\n\t\t\t const guint32 frag_offset, const guint32 frag_data_len,\n\t\t\t const gboolean more_frags)\n{\n\treturn fragment_add_common(tvb, offset, pinfo, id, fragment_table,\n\t\tfrag_offset, frag_data_len, more_frags, FALSE);\n}\n\nfragment_data *\nfragment_add_check(tvbuff_t *tvb, const int offset, const packet_info *pinfo,\n\t\t const guint32 id, GHashTable *fragment_table,\n\t\t GHashTable *reassembled_table, const guint32 frag_offset,\n\t\t const guint32 frag_data_len, const gboolean more_frags)\n{\n\treassembled_key reass_key;\n\tfragment_key key, *new_key, *old_key;\n\tgpointer orig_key, value;\n\tfragment_data *fd_head;\n\n\t/*\n\t * If this isn't the first pass, look for this frame in the table\n\t * of reassembled packets.\n\t */\n\tif (pinfo->fd->flags.visited) {\n\t\treass_key.frame = pinfo->fd->num;\n\t\treass_key.id = id;\n\t\treturn g_hash_table_lookup(reassembled_table, &reass_key);\n\t}\n\n\t/* create key to search hash with */\n\tkey.src = pinfo->src;\n\tkey.dst = pinfo->dst;\n\tkey.id\t= id;\n\n\t/* Looks up a key in the GHashTable, returning the original key and the associated value\n\t * and a gboolean which is TRUE if the key was found. This is useful if you need to free\n\t * the memory allocated for the original key, for example before calling g_hash_table_remove()\n\t */\n\tif (!g_hash_table_lookup_extended(fragment_table, &key,\n\t\t\t\t\t  &orig_key, &value)) {\n\t\t/* not found, this must be the first snooped fragment for this\n\t\t\t\t * packet. Create list-head.\n\t\t */\n\t\tfd_head = new_head(0);\n\n\t\t/*\n\t\t * We're going to use the key to insert the fragment,\n\t\t * so allocate a structure for it, and copy the\n\t\t * addresses, allocating new buffers for the address\n\t\t * data.\n\t\t */\n\t\tnew_key = g_slice_new(fragment_key);\n\t\tCOPY_ADDRESS(&new_key->src, &key.src);\n\t\tCOPY_ADDRESS(&new_key->dst, &key.dst);\n\t\tnew_key->id = key.id;\n\t\tg_hash_table_insert(fragment_table, new_key, fd_head);\n\n\t\torig_key = new_key; /* for unhashing it later */\n\t} else {\n\t\t/*\n\t\t * We found it.\n\t\t */\n\t\tfd_head = value;\n\t}\n\n\t/*\n\t * If this is a short frame, then we can't, and don't, do\n\t * reassembly on it.  We just give up.\n\t */\n\tif (tvb_reported_length(tvb) > tvb_length(tvb))\n\t\treturn NULL;\n\n\tif (fragment_add_work(fd_head, tvb, offset, pinfo, frag_offset,\n\t\tfrag_data_len, more_frags)) {\n\t\t/*\n\t\t * Reassembly is complete.\n\t\t * Remove this from the table of in-progress\n\t\t * reassemblies, add it to the table of\n\t\t * reassembled packets, and return it.\n\t\t */\n\n\t\t/*\n\t\t * Remove this from the table of in-progress reassemblies,\n\t\t * and free up any memory used for it in that table.\n\t\t */\n\t\told_key = orig_key;\n\t\tfragment_unhash(fragment_table, old_key);\n\n\t\t/*\n\t\t * Add this item to the table of reassembled packets.\n\t\t */\n\t\tfragment_reassembled(fd_head, pinfo, reassembled_table, id);\n\t\treturn fd_head;\n\t} else {\n\t\t/*\n\t\t * Reassembly isn't complete.\n\t\t */\n\t\treturn NULL;\n\t}\n}\n\nstatic void\nfragment_defragment_and_free (fragment_data *fd_head, const packet_info *pinfo)\n{\n\tfragment_data *fd_i = NULL;\n\tfragment_data *last_fd = NULL;\n\tguint32  dfpos = 0, size = 0;\n\tvoid *old_data = NULL;\n\n\tfor(fd_i=fd_head->next;fd_i;fd_i=fd_i->next) {\n\t\tif(!last_fd || last_fd->offset!=fd_i->offset){\n\t\t\tsize+=fd_i->len;\n\t\t}\n\t\tlast_fd=fd_i;\n\t}\n\n\t/* store old data in case the fd_i->data pointers refer to it */\n\told_data=fd_head->data;\n\tfd_head->data = g_malloc(size);\n\tfd_head->len = size;\t\t/* record size for caller\t*/\n\n\t/* add all data fragments */\n\tlast_fd=NULL;\n\tfor (fd_i=fd_head->next; fd_i; fd_i=fd_i->next) {\n\t\tif (fd_i->len) {\n\t\t\tif(!last_fd || last_fd->offset != fd_i->offset) {\n\t\t\t\t/* First fragment or in-sequence fragment */\n\t\t\t\tmemcpy(fd_head->data+dfpos, fd_i->data, fd_i->len);\n\t\t\t\tdfpos += fd_i->len;\n\t\t\t} else {\n\t\t\t\t/* duplicate/retransmission/overlap */\n\t\t\t\tfd_i->flags    |= FD_OVERLAP;\n\t\t\t\tfd_head->flags |= FD_OVERLAP;\n\t\t\t\tif(last_fd->len != fd_i->len\n\t\t\t\t   || memcmp(last_fd->data, fd_i->data, last_fd->len) ) {\n\t\t\t\t\tfd_i->flags    |= FD_OVERLAPCONFLICT;\n\t\t\t\t\tfd_head->flags |= FD_OVERLAPCONFLICT;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlast_fd=fd_i;\n\t}\n\n\t/* we have defragmented the pdu, now free all fragments*/\n\tfor (fd_i=fd_head->next;fd_i;fd_i=fd_i->next) {\n\t\tif( fd_i->flags & FD_NOT_MALLOCED )\n\t\t\tfd_i->flags &= ~FD_NOT_MALLOCED;\n\t\telse\n\t\t\tg_free(fd_i->data);\n\t\tfd_i->data=NULL;\n\t}\n\tg_free(old_data);\n\n\t/* mark this packet as defragmented.\n\t * allows us to skip any trailing fragments.\n\t */\n\tfd_head->flags |= FD_DEFRAGMENTED;\n\tfd_head->reassembled_in=pinfo->fd->num;\n}\n\n/*\n * This function adds a new fragment to the entry for a reassembly\n * operation.\n *\n * The list of fragments for a specific datagram is kept sorted for\n * easier handling.\n *\n * Returns TRUE if we have all the fragments, FALSE otherwise.\n *\n * This function assumes frag_number being a block sequence number.\n * The bsn for the first block is 0.\n */\nstatic gboolean\nfragment_add_seq_work(fragment_data *fd_head, tvbuff_t *tvb, const int offset,\n\t\t const packet_info *pinfo, const guint32 frag_number,\n\t\t const guint32 frag_data_len, const gboolean more_frags,\n\t\t const guint32 flags _U_)\n{\n\tfragment_data *fd;\n\tfragment_data *fd_i;\n\tfragment_data *last_fd;\n\tguint32 max, dfpos;\n\n\t/* if the partial reassembly flag has been set, and we are extending\n\t * the pdu, un-reassemble the pdu. This means pointing old fds to malloc'ed data.\n\t */\n\tif(fd_head->flags & FD_DEFRAGMENTED && frag_number >= fd_head->datalen &&\n\t\tfd_head->flags & FD_PARTIAL_REASSEMBLY){\n\t\tguint32 lastdfpos = 0;\n\t\tdfpos = 0;\n\t\tfor(fd_i=fd_head->next; fd_i; fd_i=fd_i->next){\n\t\t\tif( !fd_i->data ) {\n\t\t\t\tif( fd_i->flags & FD_OVERLAP ) {\n\t\t\t\t\t/* this is a duplicate of the previous\n\t\t\t\t\t * fragment. */\n\t\t\t\t\tfd_i->data = fd_head->data + lastdfpos;\n\t\t\t\t} else {\n\t\t\t\t\tfd_i->data = fd_head->data + dfpos;\n\t\t\t\t\tlastdfpos = dfpos;\n\t\t\t\t\tdfpos += fd_i->len;\n\t\t\t\t}\n\t\t\t\tfd_i->flags |= FD_NOT_MALLOCED;\n\t\t\t}\n\t\t\tfd_i->flags &= (~FD_TOOLONGFRAGMENT) & (~FD_MULTIPLETAILS);\n\t\t}\n\t\tfd_head->flags &= ~(FD_DEFRAGMENTED|FD_PARTIAL_REASSEMBLY|FD_DATALEN_SET);\n\t\tfd_head->flags &= (~FD_TOOLONGFRAGMENT) & (~FD_MULTIPLETAILS);\n\t\tfd_head->datalen=0;\n\t\tfd_head->reassembled_in=0;\n\t}\n\n\n\t/* create new fd describing this fragment */\n\tfd = g_slice_new(fragment_data);\n\tfd->next = NULL;\n\tfd->flags = 0;\n\tfd->frame = pinfo->fd->num;\n\tfd->offset = frag_number;\n\tfd->len  = frag_data_len;\n\tfd->data = NULL;\n\n\tif (!more_frags) {\n\t\t/*\n\t\t * This is the tail fragment in the sequence.\n\t\t */\n\t\tif (fd_head->flags&FD_DATALEN_SET) {\n\t\t\t/* ok we have already seen other tails for this packet\n\t\t\t * it might be a duplicate.\n\t\t\t */\n\t\t\tif (fd_head->datalen != fd->offset ){\n\t\t\t\t/* Oops, this tail indicates a different packet\n\t\t\t\t * len than the previous ones. Something's wrong.\n\t\t\t\t */\n\t\t\t\tfd->flags\t|= FD_MULTIPLETAILS;\n\t\t\t\tfd_head->flags\t|= FD_MULTIPLETAILS;\n\t\t\t}\n\t\t} else {\n\t\t\t/* this was the first tail fragment, now we know the\n\t\t\t * sequence number of that fragment (which is NOT\n\t\t\t * the length of the packet!)\n\t\t\t */\n\t\t\tfd_head->datalen = fd->offset;\n\t\t\tfd_head->flags |= FD_DATALEN_SET;\n\t\t}\n\t}\n\n\t/* If the packet is already defragmented, this MUST be an overlap.\n\t * The entire defragmented packet is in fd_head->data\n\t * Even if we have previously defragmented this packet, we still check\n\t * check it. Someone might play overlap and TTL games.\n\t */\n\tif (fd_head->flags & FD_DEFRAGMENTED) {\n\t\tfd->flags\t|= FD_OVERLAP;\n\t\tfd_head->flags\t|= FD_OVERLAP;\n\n\t\t/* make sure it's not past the end */\n\t\tif (fd->offset > fd_head->datalen) {\n\t\t\t/* new fragment comes after the end */\n\t\t\tfd->flags\t|= FD_TOOLONGFRAGMENT;\n\t\t\tfd_head->flags\t|= FD_TOOLONGFRAGMENT;\n\t\t\tLINK_FRAG(fd_head,fd);\n\t\t\treturn TRUE;\n\t\t}\n\t\t/* make sure it doesn't conflict with previous data */\n\t\tdfpos=0;\n\t\tlast_fd=NULL;\n\t\tfor (fd_i=fd_head->next;fd_i && (fd_i->offset!=fd->offset);fd_i=fd_i->next) {\n\t\t  if (!last_fd || last_fd->offset!=fd_i->offset){\n\t\t\tdfpos += fd_i->len;\n\t\t  }\n\t\t  last_fd=fd_i;\n\t\t}\n\t\tif(fd_i){\n\t\t\t/* new fragment overlaps existing fragment */\n\t\t\tif(fd_i->len!=fd->len){\n\t\t\t\t/*\n\t\t\t\t * They have different lengths; this\n\t\t\t\t * is definitely a conflict.\n\t\t\t\t */\n\t\t\t\tfd->flags\t|= FD_OVERLAPCONFLICT;\n\t\t\t\tfd_head->flags\t|= FD_OVERLAPCONFLICT;\n\t\t\t\tLINK_FRAG(fd_head,fd);\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\tDISSECTOR_ASSERT(fd_head->len >= dfpos + fd->len);\n\t\t\tif ( memcmp(fd_head->data+dfpos,\n\t\t\t\ttvb_get_ptr(tvb,offset,fd->len),fd->len) ){\n\t\t\t\t/*\n\t\t\t\t * They have the same length, but the\n\t\t\t\t * data isn't the same.\n\t\t\t\t */\n\t\t\t\tfd->flags\t|= FD_OVERLAPCONFLICT;\n\t\t\t\tfd_head->flags\t|= FD_OVERLAPCONFLICT;\n\t\t\t\tLINK_FRAG(fd_head,fd);\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t\t/* it was just an overlap, link it and return */\n\t\t\tLINK_FRAG(fd_head,fd);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\t/*\n\t\t\t * New fragment doesn't overlap an existing\n\t\t\t * fragment - there was presumably a gap in\n\t\t\t * the sequence number space.\n\t\t\t *\n\t\t\t * XXX - what should we do here?  Is it always\n\t\t\t * the case that there are no gaps, or are there\n\t\t\t * protcols using sequence numbers where there\n\t\t\t * can be gaps?\n\t\t\t *\n\t\t\t * If the former, the check below for having\n\t\t\t * received all the fragments should check for\n\t\t\t * holes in the sequence number space and for the\n\t\t\t * first sequence number being 0.  If we do that,\n\t\t\t * the only way we can get here is if this fragment\n\t\t\t * is past the end of the sequence number space -\n\t\t\t * but the check for \"fd->offset > fd_head->datalen\"\n\t\t\t * would have caught that above, so it can't happen.\n\t\t\t *\n\t\t\t * If the latter, we don't have a good way of\n\t\t\t * knowing whether reassembly is complete if we\n\t\t\t * get packet out of order such that the \"last\"\n\t\t\t * fragment doesn't show up last - but, unless\n\t\t\t * in-order reliable delivery of fragments is\n\t\t\t * guaranteed, an implementation of the protocol\n\t\t\t * has no way of knowing whether reassembly is\n\t\t\t * complete, either.\n\t\t\t *\n\t\t\t * For now, we just link the fragment in and\n\t\t\t * return.\n\t\t\t */\n\t\t\tLINK_FRAG(fd_head,fd);\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\t/* If we have reached this point, the packet is not defragmented yet.\n\t * Save all payload in a buffer until we can defragment.\n\t * XXX - what if we didn't capture the entire fragment due\n\t * to a too-short snapshot length?\n\t */\n\t/* check len, there may be a fragment with 0 len, that is actually the tail */\n\tif (fd->len) {\n\t\tfd->data = g_malloc(fd->len);\n\t\ttvb_memcpy(tvb, fd->data, offset, fd->len);\n\t}\n\tLINK_FRAG(fd_head,fd);\n\n\n\tif( !(fd_head->flags & FD_DATALEN_SET) ){\n\t\t/* if we dont know the sequence number of the last fragment,\n\t\t * there are definitely still missing packets. Cheaper than\n\t\t * the check below.\n\t\t */\n\t\treturn FALSE;\n\t}\n\n\n\t/* check if we have received the entire fragment\n\t * this is easy since the list is sorted and the head is faked.\n\t * common case the whole list is scanned.\n\t */\n\tmax = 0;\n\tfor(fd_i=fd_head->next;fd_i;fd_i=fd_i->next) {\n\t  if ( fd_i->offset==max ){\n\t\tmax++;\n\t  }\n\t}\n\t/* max will now be datalen+1 if all fragments have been seen */\n\n\tif (max <= fd_head->datalen) {\n\t\t/* we have not received all packets yet */\n\t\treturn FALSE;\n\t}\n\n\n\tif (max > (fd_head->datalen+1)) {\n\t\t/* oops, too long fragment detected */\n\t\tfd->flags\t|= FD_TOOLONGFRAGMENT;\n\t\tfd_head->flags\t|= FD_TOOLONGFRAGMENT;\n\t}\n\n\n\t/* we have received an entire packet, defragment it and\n\t * free all fragments\n\t */\n\tfragment_defragment_and_free(fd_head, pinfo);\n\n\treturn TRUE;\n}\n\n/*\n * This function adds a new fragment to the fragment hash table.\n * If this is the first fragment seen for this datagram, a new entry\n * is created in the hash table, otherwise this fragment is just added\n * to the linked list of fragments for this packet.\n *\n * Returns a pointer to the head of the fragment data list if we have all the\n * fragments, NULL otherwise.\n *\n * This function assumes frag_number being a block sequence number.\n * The bsn for the first block is 0.\n */\nfragment_data *\nfragment_add_seq(tvbuff_t *tvb, const int offset, const packet_info *pinfo, const guint32 id,\n\t\t GHashTable *fragment_table, const guint32 frag_number,\n\t\t const guint32 frag_data_len, const gboolean more_frags)\n{\n\tfragment_key key;\n\n\t/* create key to search hash with */\n\tkey.src = pinfo->src;\n\tkey.dst = pinfo->dst;\n\tkey.id\t= id;\n\n\treturn fragment_add_seq_key(tvb, offset, pinfo,\n\t\t\t\t\t&key, fragment_key_copy,\n\t\t\t\t\tfragment_table, frag_number,\n\t\t\t\t\tfrag_data_len, more_frags, 0);\n}\n\n\nfragment_data *\nfragment_add_dcerpc_dg(tvbuff_t *tvb, const int offset, const packet_info *pinfo, const guint32 id,\n\t\t\t\t\tvoid *v_act_id,\n\t\t\t\t\tGHashTable *fragment_table, const guint32 frag_number,\n\t\t\t\t\tconst guint32 frag_data_len, const gboolean more_frags)\n{\n\te_uuid_t *act_id = (e_uuid_t *)v_act_id;\n\tdcerpc_fragment_key key;\n\n\t/* create key to search hash with */\n\tkey.src = pinfo->src;\n\tkey.dst = pinfo->dst;\n\tkey.id\t= id;\n\tkey.act_id\t= *act_id;\n\n\treturn fragment_add_seq_key(tvb, offset, pinfo,\n\t\t\t\t\t&key, dcerpc_fragment_key_copy,\n\t\t\t\t\tfragment_table, frag_number,\n\t\t\t\t\tfrag_data_len, more_frags, 0);\n}\n\nfragment_data *\nfragment_add_seq_key(tvbuff_t *tvb, const int offset, const packet_info *pinfo,\n\t\t\t\t\t void *key, fragment_key_copier key_copier,\n\t\t\t\t\tGHashTable *fragment_table, guint32 frag_number,\n\t\t\t\t\tconst guint32 frag_data_len, const gboolean more_frags,\n\t\t\t\t\tconst guint32 flags)\n{\n\tfragment_data *fd_head;\n\tfd_head = g_hash_table_lookup(fragment_table, key);\n\n\t/* have we already seen this frame ?*/\n\tif (pinfo->fd->flags.visited) {\n\t\tif (fd_head != NULL && fd_head->flags & FD_DEFRAGMENTED) {\n\t\t\treturn fd_head;\n\t\t} else {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tif (fd_head==NULL){\n\t\t/* not found, this must be the first snooped fragment for this\n\t\t\t\t * packet. Create list-head.\n\t\t */\n\t\tfd_head= new_head(FD_BLOCKSEQUENCE);\n\n\t\tif((flags & (REASSEMBLE_FLAGS_NO_FRAG_NUMBER|REASSEMBLE_FLAGS_802_11_HACK))\n\t\t   && !more_frags) {\n\t\t\t/*\n\t\t\t * This is the last fragment for this packet, and\n\t\t\t * is the only one we've seen.\n\t\t\t *\n\t\t\t * Either we don't have sequence numbers, in which\n\t\t\t * case we assume this is the first fragment for\n\t\t\t * this packet, or we're doing special 802.11\n\t\t\t * processing, in which case we assume it's one\n\t\t\t * of those reassembled packets with a non-zero\n\t\t\t * fragment number (see packet-80211.c); just\n\t\t\t * return a pointer to the head of the list;\n\t\t\t * fragment_add_seq_check will then add it to the table\n\t\t\t * of reassembled packets.\n\t\t\t */\n\t\t\tfd_head->reassembled_in=pinfo->fd->num;\n\t\t\treturn fd_head;\n\t\t}\n\n\t\t/*\n\t\t * We're going to use the key to insert the fragment,\n\t\t * so copy it to a long-term store.\n\t\t */\n\t\tif(key_copier != NULL)\n\t\t\tkey = key_copier(key);\n\t\tg_hash_table_insert(fragment_table, key, fd_head);\n\n\t\t/*\n\t\t * If we weren't given an initial fragment number,\n\t\t * make it 0.\n\t\t */\n\t\tif (flags & REASSEMBLE_FLAGS_NO_FRAG_NUMBER)\n\t\t\tfrag_number = 0;\n\t} else {\n\t\tif (flags & REASSEMBLE_FLAGS_NO_FRAG_NUMBER) {\n\t\t\tfragment_data *fd;\n\t\t\t/*\n\t\t\t * If we weren't given an initial fragment number,\n\t\t\t * use the next expected fragment number as the fragment\n\t\t\t * number for this fragment.\n\t\t\t */\n\t\t\tfor (fd = fd_head; fd != NULL; fd = fd->next) {\n\t\t\t\tif (fd->next == NULL)\n\t\t\t\t\tfrag_number = fd->offset + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * XXX I've copied this over from the old separate\n\t * fragment_add_seq_check_work, but I'm not convinced it's doing the\n\t * right thing -- rav\n\t *\n\t * If we don't have all the data that is in this fragment,\n\t * then we can't, and don't, do reassembly on it.\n\t *\n\t * If it's the first frame, handle it as an unfragmented packet.\n\t * Otherwise, just handle it as a fragment.\n\t *\n\t * If \"more_frags\" isn't set, we get rid of the entry in the\n\t * hash table for this reassembly, as we don't need it any more.\n\t */\n\tif ((flags & REASSEMBLE_FLAGS_CHECK_DATA_PRESENT) &&\n\t\t!tvb_bytes_exist(tvb, offset, frag_data_len)) {\n\t\tif (!more_frags) {\n\t\t\tgpointer orig_key;\n\t\t\t/*\n\t\t\t * Remove this from the table of in-progress\n\t\t\t * reassemblies, and free up any memory used for\n\t\t\t * it in that table.\n\t\t\t */\n\t\t\tif (g_hash_table_lookup_extended(fragment_table, key,\n\t\t\t\t\t\t\t &orig_key, NULL)) {\n\t\t\t\tfragment_unhash(fragment_table, (fragment_key *)orig_key);\n\t\t\t}\n\t\t}\n\t\tfd_head -> flags |= FD_DATA_NOT_PRESENT;\n\t\treturn frag_number == 0 ? fd_head : NULL;\n\t}\n\n\tif (fragment_add_seq_work(fd_head, tvb, offset, pinfo,\n\t\t\t\t  frag_number, frag_data_len, more_frags, flags)) {\n\t\t/*\n\t\t * Reassembly is complete.\n\t\t */\n\t\treturn fd_head;\n\t} else {\n\t\t/*\n\t\t * Reassembly isn't complete.\n\t\t */\n\t\treturn NULL;\n\t}\n}\n\n/*\n * This does the work for \"fragment_add_seq_check()\" and\n * \"fragment_add_seq_next()\".\n *\n * This function assumes frag_number being a block sequence number.\n * The bsn for the first block is 0.\n *\n * If \"no_frag_number\" is TRUE, it uses the next expected fragment number\n * as the fragment number if there is a reassembly in progress, otherwise\n * it uses 0.\n *\n * If \"no_frag_number\" is FALSE, it uses the \"frag_number\" argument as\n * the fragment number.\n *\n * If this is the first fragment seen for this datagram, a new\n * \"fragment_data\" structure is allocated to refer to the reassembled\n * packet.\n *\n * This fragment is added to the linked list of fragments for this packet.\n *\n * If \"more_frags\" is false and REASSEMBLE_FLAGS_802_11_HACK (as the name\n * implies, a special hack for 802.11) or REASSEMBLE_FLAGS_NO_FRAG_NUMBER\n * (implying messages must be in order since there's no sequence number) are\n * set in \"flags\", then this (one element) list is returned.\n *\n * If, after processing this fragment, we have all the fragments,\n * \"fragment_add_seq_check_work()\" removes that from the fragment hash\n * table if necessary and adds it to the table of reassembled fragments,\n * and returns a pointer to the head of the fragment list.\n *\n * Otherwise, it returns NULL.\n *\n * XXX - Should we simply return NULL for zero-length fragments?\n */\nstatic fragment_data *\nfragment_add_seq_check_work(tvbuff_t *tvb, const int offset,\n\t\t\t    const packet_info *pinfo, const guint32 id,\n\t\t\t    GHashTable *fragment_table,\n\t\t\t    GHashTable *reassembled_table,\n\t\t\t    const guint32 frag_number,\n\t\t\t    const guint32 frag_data_len,\n\t\t\t    const gboolean more_frags, const guint32 flags)\n{\n\treassembled_key reass_key;\n\tfragment_key key;\n\tfragment_data *fd_head;\n\n\t/*\n\t * Have we already seen this frame?\n\t * If so, look for it in the table of reassembled packets.\n\t */\n\tif (pinfo->fd->flags.visited) {\n\t\treass_key.frame = pinfo->fd->num;\n\t\treass_key.id = id;\n\t\treturn g_hash_table_lookup(reassembled_table, &reass_key);\n\t}\n\n\t/* create key to search hash with */\n\tkey.src = pinfo->src;\n\tkey.dst = pinfo->dst;\n\tkey.id\t= id;\n\n\tfd_head = fragment_add_seq_key(tvb, offset, pinfo,\n\t\t\t\t\t   &key, fragment_key_copy,\n\t\t\t\t\t   fragment_table, frag_number,\n\t\t\t\t\t   frag_data_len, more_frags, flags|REASSEMBLE_FLAGS_CHECK_DATA_PRESENT);\n\tif (fd_head) {\n\t\tgpointer orig_key;\n\n\t\tif(fd_head->flags & FD_DATA_NOT_PRESENT) {\n\t\t\t/* this is the first fragment of a datagram with\n\t\t\t * truncated fragments. Don't move it to the\n\t\t\t * reassembled table. */\n\t\t\treturn fd_head;\n\t\t}\n\n\t\t/*\n\t\t * Reassembly is complete.\n\t\t * Remove this from the table of in-progress\n\t\t * reassemblies, add it to the table of\n\t\t * reassembled packets, and return it.\n\t\t */\n\t\tif (g_hash_table_lookup_extended(fragment_table, &key,\n\t\t\t\t\t\t &orig_key, NULL)) {\n\t\t\t/*\n\t\t\t * Remove this from the table of in-progress reassemblies,\n\t\t\t * and free up any memory used for it in that table.\n\t\t\t */\n\t\t\tfragment_unhash(fragment_table, (fragment_key *)orig_key);\n\t\t}\n\n\t\t/*\n\t\t * Add this item to the table of reassembled packets.\n\t\t */\n\t\tfragment_reassembled(fd_head, pinfo, reassembled_table, id);\n\t\treturn fd_head;\n\t} else {\n\t\t/*\n\t\t * Reassembly isn't complete.\n\t\t */\n\t\treturn NULL;\n\t}\n}\n\nfragment_data *\nfragment_add_seq_check(tvbuff_t *tvb, const int offset,\n\t\t       const packet_info *pinfo, const guint32 id,\n\t\t       GHashTable *fragment_table,\n\t\t       GHashTable *reassembled_table, const guint32 frag_number,\n\t\t       const guint32 frag_data_len, const gboolean more_frags)\n{\n\treturn fragment_add_seq_check_work(tvb, offset, pinfo, id,\n\t\t\t\t\t   fragment_table, reassembled_table,\n\t\t\t\t\t   frag_number, frag_data_len,\n\t\t\t\t\t   more_frags, 0);\n}\n\nfragment_data *\nfragment_add_seq_802_11(tvbuff_t *tvb, const int offset,\n\t\t\tconst packet_info *pinfo, const guint32 id,\n\t\t\tGHashTable *fragment_table,\n\t\t\tGHashTable *reassembled_table,\n\t\t\tconst guint32 frag_number, const guint32 frag_data_len,\n\t\t\tconst gboolean more_frags)\n{\n\treturn fragment_add_seq_check_work(tvb, offset, pinfo, id,\n\t\t\t\t\t   fragment_table, reassembled_table,\n\t\t\t\t\t   frag_number, frag_data_len,\n\t\t\t\t\t   more_frags,\n\t\t\t\t\t   REASSEMBLE_FLAGS_802_11_HACK);\n}\n\nfragment_data *\nfragment_add_seq_next(tvbuff_t *tvb, const int offset, const packet_info *pinfo,\n\t\t      const guint32 id, GHashTable *fragment_table,\n\t\t      GHashTable *reassembled_table, const guint32 frag_data_len,\n\t\t      const gboolean more_frags)\n{\n\treturn fragment_add_seq_check_work(tvb, offset, pinfo, id,\n\t\t\t\t\t   fragment_table, reassembled_table, 0,\n\t\t\t\t\t   frag_data_len, more_frags,\n\t\t\t\t\t   REASSEMBLE_FLAGS_NO_FRAG_NUMBER);\n}\n\nvoid\nfragment_start_seq_check(const packet_info *pinfo, const guint32 id, GHashTable *fragment_table,\n\t\t\t const guint32 tot_len)\n{\n\tfragment_key key, *new_key;\n\tfragment_data *fd_head;\n\n\t/* Have we already seen this frame ?*/\n\tif (pinfo->fd->flags.visited) {\n\t\treturn;\n\t}\n\n\t/* Create key to search hash with */\n\tkey.src = pinfo->src;\n\tkey.dst = pinfo->dst;\n\tkey.id\t= id;\n\n\t/* Check if fragment data exist for this key */\n\tfd_head = g_hash_table_lookup(fragment_table, &key);\n\n\tif (fd_head == NULL) {\n\t\t/* Create list-head. */\n\t\tfd_head = g_slice_new(fragment_data);\n\t\tfd_head->next = NULL;\n\t\tfd_head->datalen = tot_len;\n\t\tfd_head->offset = 0;\n\t\tfd_head->len = 0;\n\t\tfd_head->flags = FD_BLOCKSEQUENCE|FD_DATALEN_SET;\n\t\tfd_head->data = NULL;\n\t\tfd_head->reassembled_in = 0;\n\t\t/*\n\t\t * We're going to use the key to insert the fragment,\n\t\t * so copy it to a long-term store.\n\t\t */\n\t\tnew_key = fragment_key_copy(&key);\n\t\tg_hash_table_insert(fragment_table, new_key, fd_head);\n\t}\n}\n\nfragment_data *\nfragment_end_seq_next(const packet_info *pinfo, const guint32 id, GHashTable *fragment_table,\n\t\t\t  GHashTable *reassembled_table)\n{\n\treassembled_key reass_key;\n\treassembled_key *new_key;\n\tfragment_key key;\n\tfragment_data *fd_head;\n\n\t/*\n\t * Have we already seen this frame?\n\t * If so, look for it in the table of reassembled packets.\n\t */\n\tif (pinfo->fd->flags.visited) {\n\t\treass_key.frame = pinfo->fd->num;\n\t\treass_key.id = id;\n\t\treturn g_hash_table_lookup(reassembled_table, &reass_key);\n\t}\n\n\t/* create key to search hash with */\n\tkey.src = pinfo->src;\n\tkey.dst = pinfo->dst;\n\tkey.id\t= id;\n\n\tfd_head = g_hash_table_lookup (fragment_table, &key);\n\n\tif (fd_head) {\n\t\tgpointer orig_key;\n\n\t\tif (fd_head->flags & FD_DATA_NOT_PRESENT) {\n\t\t\t/* No data added */\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfd_head->datalen = fd_head->offset;\n\t\tfd_head->flags |= FD_DATALEN_SET;\n\n\t\tfragment_defragment_and_free (fd_head, pinfo);\n\n\t\t/*\n\t\t * Remove this from the table of in-progress\n\t\t * reassemblies, add it to the table of\n\t\t * reassembled packets, and return it.\n\t\t */\n\t\tif (g_hash_table_lookup_extended(fragment_table, &key,\n\t\t\t\t\t\t &orig_key, NULL)) {\n\t\t\t/*\n\t\t\t * Remove this from the table of in-progress reassemblies,\n\t\t\t * and free up any memory used for it in that table.\n\t\t\t */\n\t\t\tfragment_unhash(fragment_table, (fragment_key *)orig_key);\n\t\t}\n\n\t\t/*\n\t\t * Add this item to the table of reassembled packets.\n\t\t */\n\t\tfragment_reassembled(fd_head, pinfo, reassembled_table, id);\n\t\tif (fd_head->next != NULL) {\n\t\t\tnew_key = se_alloc(sizeof(reassembled_key));\n\t\t\tnew_key->frame = pinfo->fd->num;\n\t\t\tnew_key->id = id;\n\t\t\tg_hash_table_insert(reassembled_table, new_key, fd_head);\n\t\t}\n\n\t\treturn fd_head;\n\t} else {\n\t\t/*\n\t\t * Fragment data not found.\n\t\t */\n\t\treturn NULL;\n\t}\n}\n\n/*\n * Process reassembled data; if we're on the frame in which the data\n * was reassembled, put the fragment information into the protocol\n * tree, and construct a tvbuff with the reassembled data, otherwise\n * just put a \"reassembled in\" item into the protocol tree.\n */\ntvbuff_t *\nprocess_reassembled_data(tvbuff_t *tvb, const int offset, packet_info *pinfo,\n\tconst char *name, fragment_data *fd_head, const fragment_items *fit,\n\tgboolean *update_col_infop, proto_tree *tree)\n{\n\ttvbuff_t *next_tvb;\n\tgboolean update_col_info;\n\tproto_item *frag_tree_item;\n\n\tif (fd_head != NULL && pinfo->fd->num == fd_head->reassembled_in) {\n\t\t/*\n\t\t * OK, we've reassembled this.\n\t\t * Is this something that's been reassembled from more\n\t\t * than one fragment?\n\t\t */\n\t\tif (fd_head->next != NULL) {\n\t\t\t/*\n\t\t\t * Yes.\n\t\t\t * Allocate a new tvbuff, referring to the\n\t\t\t * reassembled payload.\n\t\t\t */\n\t\t\tif (fd_head->flags & FD_BLOCKSEQUENCE) {\n\t\t\t\tnext_tvb = tvb_new_real_data(fd_head->data,\n\t\t\t\t\t  fd_head->len, fd_head->len);\n\t\t\t} else {\n\t\t\t\tnext_tvb = tvb_new_real_data(fd_head->data,\n\t\t\t\t\t  fd_head->datalen, fd_head->datalen);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Add the tvbuff to the list of tvbuffs to which\n\t\t\t * the tvbuff we were handed refers, so it'll get\n\t\t\t * cleaned up when that tvbuff is cleaned up.\n\t\t\t */\n\t\t\ttvb_set_child_real_data_tvbuff(tvb, next_tvb);\n\n\t\t\t/* Add the defragmented data to the data source list. */\n\t\t\tadd_new_data_source(pinfo, next_tvb, name);\n\n\t\t\t/* show all fragments */\n\t\t\tif (fd_head->flags & FD_BLOCKSEQUENCE) {\n\t\t\t\tupdate_col_info = !show_fragment_seq_tree(\n\t\t\t\t\tfd_head, fit,  tree, pinfo, next_tvb, &frag_tree_item);\n\t\t\t} else {\n\t\t\t\tupdate_col_info = !show_fragment_tree(fd_head,\n\t\t\t\t\tfit, tree, pinfo, next_tvb, &frag_tree_item);\n\t\t\t}\n\t\t} else {\n\t\t\t/*\n\t\t\t * No.\n\t\t\t * Return a tvbuff with the payload.\n\t\t\t */\n\t\t\tnext_tvb = tvb_new_subset_remaining(tvb, offset);\n\t\t\tpinfo->fragmented = FALSE;\t/* one-fragment packet */\n\t\t\tupdate_col_info = TRUE;\n\t\t}\n\t\tif (update_col_infop != NULL)\n\t\t\t*update_col_infop = update_col_info;\n\t} else {\n\t\t/*\n\t\t * We don't have the complete reassembled payload, or this\n\t\t * isn't the final frame of that payload.\n\t\t */\n\t\tnext_tvb = NULL;\n\n\t\t/*\n\t\t * If we know what frame this was reassembled in,\n\t\t * and if there's a field to use for the number of\n\t\t * the frame in which the packet was reassembled,\n\t\t * add it to the protocol tree.\n\t\t */\n\t\tif (fd_head != NULL && fit->hf_reassembled_in != NULL) {\n\t\t\tproto_tree_add_uint(tree,\n\t\t\t\t*(fit->hf_reassembled_in), tvb,\n\t\t\t\t0, 0, fd_head->reassembled_in);\n\t\t}\n\t}\n\treturn next_tvb;\n}\n\n/*\n * Show a single fragment in a fragment subtree, and put information about\n * it in the top-level item for that subtree.\n */\nstatic void\nshow_fragment(fragment_data *fd, const int offset, const fragment_items *fit,\n\tproto_tree *ft, proto_item *fi, const gboolean first_frag,\n\tconst guint32 count, tvbuff_t *tvb, packet_info *pinfo)\n{\n\tproto_item *fei=NULL;\n\tint hf;\n\n\tif (first_frag) {\n\t\tgchar *name;\n\t\tif (count == 1) {\n\t\t\tname = g_strdup(proto_registrar_get_name(*(fit->hf_fragment)));\n\t\t} else {\n\t\t\tname = g_strdup(proto_registrar_get_name(*(fit->hf_fragments)));\n\t\t}\n\t\tproto_item_set_text(fi, \"%u %s (%u byte%s): \", count, name, tvb_length(tvb),\n\t\t\t\t    plurality(tvb_length(tvb), \"\", \"s\"));\n\t\tg_free(name);\n\t} else {\n\t\tproto_item_append_text(fi, \", \");\n\t}\n\tproto_item_append_text(fi, \"#%u(%u)\", fd->frame, fd->len);\n\n\tif (fd->flags & (FD_OVERLAPCONFLICT\n\t\t|FD_MULTIPLETAILS|FD_TOOLONGFRAGMENT) ) {\n\t\thf = *(fit->hf_fragment_error);\n\t} else {\n\t\thf = *(fit->hf_fragment);\n\t}\n\tif (fd->len == 0) {\n\t\tfei = proto_tree_add_uint_format(ft, hf,\n\t\t\ttvb, offset, fd->len,\n\t\t\tfd->frame,\n\t\t\t\"Frame: %u (no data)\",\n\t\t\tfd->frame);\n\t} else {\n\t\tfei = proto_tree_add_uint_format(ft, hf,\n\t\t\ttvb, offset, fd->len,\n\t\t\tfd->frame,\n\t\t\t\"Frame: %u, payload: %u-%u (%u byte%s)\",\n\t\t\tfd->frame,\n\t\t\toffset,\n\t\t\toffset+fd->len-1,\n\t\t\tfd->len,\n\t\t\tplurality(fd->len, \"\", \"s\"));\n\t}\n\tPROTO_ITEM_SET_GENERATED(fei);\n\tmark_frame_as_depended_upon(pinfo, fd->frame);\n\tif (fd->flags & (FD_OVERLAP|FD_OVERLAPCONFLICT\n\t\t|FD_MULTIPLETAILS|FD_TOOLONGFRAGMENT) ) {\n\t\t/* this fragment has some flags set, create a subtree\n\t\t * for it and display the flags.\n\t\t */\n\t\tproto_tree *fet=NULL;\n\n\t\tfet = proto_item_add_subtree(fei, *(fit->ett_fragment));\n\t\tif (fd->flags&FD_OVERLAP) {\n\t\t\tfei=proto_tree_add_boolean(fet,\n\t\t\t\t*(fit->hf_fragment_overlap),\n\t\t\t\ttvb, 0, 0,\n\t\t\t\tTRUE);\n\t\t\tPROTO_ITEM_SET_GENERATED(fei);\n\t\t}\n\t\tif (fd->flags&FD_OVERLAPCONFLICT) {\n\t\t\tfei=proto_tree_add_boolean(fet,\n\t\t\t\t*(fit->hf_fragment_overlap_conflict),\n\t\t\t\ttvb, 0, 0,\n\t\t\t\tTRUE);\n\t\t\tPROTO_ITEM_SET_GENERATED(fei);\n\t\t}\n\t\tif (fd->flags&FD_MULTIPLETAILS) {\n\t\t\tfei=proto_tree_add_boolean(fet,\n\t\t\t\t*(fit->hf_fragment_multiple_tails),\n\t\t\t\ttvb, 0, 0,\n\t\t\t\tTRUE);\n\t\t\tPROTO_ITEM_SET_GENERATED(fei);\n\t\t}\n\t\tif (fd->flags&FD_TOOLONGFRAGMENT) {\n\t\t\tfei=proto_tree_add_boolean(fet,\n\t\t\t\t*(fit->hf_fragment_too_long_fragment),\n\t\t\t\ttvb, 0, 0,\n\t\t\t\tTRUE);\n\t\t\tPROTO_ITEM_SET_GENERATED(fei);\n\t\t}\n\t}\n}\n\nstatic gboolean\nshow_fragment_errs_in_col(fragment_data *fd_head, const fragment_items *fit,\n\tpacket_info *pinfo)\n{\n\tif (fd_head->flags & (FD_OVERLAPCONFLICT\n\t\t|FD_MULTIPLETAILS|FD_TOOLONGFRAGMENT) ) {\n\t\tif (check_col(pinfo->cinfo, COL_INFO)) {\n\t\t\tcol_add_fstr(pinfo->cinfo, COL_INFO,\n\t\t\t\t\"[Illegal %s]\", fit->tag);\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\n\treturn FALSE;\n}\n\n/* This function will build the fragment subtree; it's for fragments\n   reassembled with \"fragment_add()\".\n\n   It will return TRUE if there were fragmentation errors\n   or FALSE if fragmentation was ok.\n*/\ngboolean\nshow_fragment_tree(fragment_data *fd_head, const fragment_items *fit,\n\tproto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, proto_item **fi)\n{\n\tfragment_data *fd;\n\tproto_tree *ft;\n\tgboolean first_frag;\n\tguint32 count = 0;\n\t/* It's not fragmented. */\n\tpinfo->fragmented = FALSE;\n\n\t*fi = proto_tree_add_item(tree, *(fit->hf_fragments), tvb, 0, -1, ENC_NA);\n\tPROTO_ITEM_SET_GENERATED(*fi);\n\n\tft = proto_item_add_subtree(*fi, *(fit->ett_fragments));\n\tfirst_frag = TRUE;\n\tfor (fd = fd_head->next; fd != NULL; fd = fd->next) {\n\t\tcount++;\n\t}\n\tfor (fd = fd_head->next; fd != NULL; fd = fd->next) {\n\t\tshow_fragment(fd, fd->offset, fit, ft, *fi, first_frag, count, tvb, pinfo);\n\t\tfirst_frag = FALSE;\n\t}\n\n\tif (fit->hf_fragment_count) {\n\t\tproto_item *fli = proto_tree_add_uint(ft, *(fit->hf_fragment_count),\n\t\t\t\t\t\t      tvb, 0, 0, count);\n\t\tPROTO_ITEM_SET_GENERATED(fli);\n\t}\n\n\tif (fit->hf_reassembled_length) {\n\t\tproto_item *fli = proto_tree_add_uint(ft, *(fit->hf_reassembled_length),\n\t\t\t\t\t\t      tvb, 0, 0, tvb_length (tvb));\n\t\tPROTO_ITEM_SET_GENERATED(fli);\n\t}\n\n\treturn show_fragment_errs_in_col(fd_head, fit, pinfo);\n}\n\n/* This function will build the fragment subtree; it's for fragments\n   reassembled with \"fragment_add_seq()\" or \"fragment_add_seq_check()\".\n\n   It will return TRUE if there were fragmentation errors\n   or FALSE if fragmentation was ok.\n*/\ngboolean\nshow_fragment_seq_tree(fragment_data *fd_head, const fragment_items *fit,\n\tproto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, proto_item **fi)\n{\n\tguint32 offset, next_offset, count = 0;\n\tfragment_data *fd, *last_fd;\n\tproto_tree *ft;\n\tgboolean first_frag;\n\n\t/* It's not fragmented. */\n\tpinfo->fragmented = FALSE;\n\n\t*fi = proto_tree_add_item(tree, *(fit->hf_fragments), tvb, 0, -1, ENC_NA);\n\tPROTO_ITEM_SET_GENERATED(*fi);\n\n\tft = proto_item_add_subtree(*fi, *(fit->ett_fragments));\n\toffset = 0;\n\tnext_offset = 0;\n\tlast_fd = NULL;\n\tfirst_frag = TRUE;\n\tfor (fd = fd_head->next; fd != NULL; fd = fd->next){\n\t\tcount++;\n\t}\n\tfor (fd = fd_head->next; fd != NULL; fd = fd->next){\n\t\tif (last_fd == NULL || last_fd->offset != fd->offset) {\n\t\t\toffset = next_offset;\n\t\t\tnext_offset += fd->len;\n\t\t}\n\t\tlast_fd = fd;\n\t\tshow_fragment(fd, offset, fit, ft, *fi, first_frag, count, tvb, pinfo);\n\t\tfirst_frag = FALSE;\n\t}\n\n\tif (fit->hf_fragment_count) {\n\t\tproto_item *fli = proto_tree_add_uint(ft, *(fit->hf_fragment_count),\n\t\t\t\t\t\t      tvb, 0, 0, count);\n\t\tPROTO_ITEM_SET_GENERATED(fli);\n\t}\n\n\tif (fit->hf_reassembled_length) {\n\t\tproto_item *fli = proto_tree_add_uint(ft, *(fit->hf_reassembled_length),\n\t\t\t\t\t\t      tvb, 0, 0, tvb_length (tvb));\n\t\tPROTO_ITEM_SET_GENERATED(fli);\n\t}\n\n\treturn show_fragment_errs_in_col(fd_head, fit, pinfo);\n}\n\n/*\n * Local Variables:\n * c-basic-offset: 8\n * indent-tabs-mode: t\n * tab-width: 8\n * End:\n */\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"out_of_bounds_read\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code reads memory outside the allocated bounds of an array or buffer. This can cause crashes or expose sensitive memory contents to attackers.\",\n  \"risk\": \"Memory disclosure, application crashes, information leakage, potential code execution\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before array access\\n// Instead of: value = array[index];\\n// Use: if (index >= 0 && index < array_size) {\\n//         value = array[index];\\n//       } else {\\n//         handle_error();\\n//       }\\n\\n// Or use safe library functions that check bounds\\n\",\n  \"source\": \"SARD-148907\",\n  \"cwe\": \"CWE-125\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* packet-afs.c\n * Routines for AFS packet dissection\n * Copyright 1999, Nathan Neulinger <nneul@umr.edu>\n * Based on routines from tcpdump patches by\n *   Ken Hornstein <kenh@cmf.nrl.navy.mil>\n * Portions based on information retrieved from the RX definitions\n *   in Arla, the free AFS client at http://www.stacken.kth.se/project/arla/\n * Portions based on information/specs retrieved from the OpenAFS sources at\n *   www.openafs.org, Copyright IBM.\n *\n * $Id: packet-afs.c 28117 2009-04-22 03:07:37Z guy $\n *\n * Wireshark - Network traffic analyzer\n * By Gerald Combs <gerald@wireshark.org>\n * Copyright 1998 Gerald Combs\n *\n * Copied from packet-tftp.c\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include <stdio.h>\n\n#include <string.h>\n#include <glib.h>\n#include <epan/packet.h>\n#include <epan/conversation.h>\n#include <epan/addr_resolv.h>\n#include <epan/emem.h>\n#include <epan/strutil.h>\n\n#include \"packet-rx.h\"\n#include \"packet-afs.h\"\n\nstatic int proto_afs = -1;\nstatic int hf_afs_fs = -1;\nstatic int hf_afs_cb = -1;\nstatic int hf_afs_prot = -1;\nstatic int hf_afs_vldb = -1;\nstatic int hf_afs_kauth = -1;\nstatic int hf_afs_vol = -1;\nstatic int hf_afs_error = -1;\nstatic int hf_afs_bos = -1;\nstatic int hf_afs_update = -1;\nstatic int hf_afs_rmtsys = -1;\nstatic int hf_afs_ubik = -1;\nstatic int hf_afs_backup = -1;\n\nstatic int hf_afs_fs_opcode = -1;\nstatic int hf_afs_cb_opcode = -1;\nstatic int hf_afs_prot_opcode = -1;\nstatic int hf_afs_vldb_opcode = -1;\nstatic int hf_afs_kauth_opcode = -1;\nstatic int hf_afs_vol_opcode = -1;\nstatic int hf_afs_error_opcode = -1;\nstatic int hf_afs_bos_opcode = -1;\nstatic int hf_afs_update_opcode = -1;\nstatic int hf_afs_rmtsys_opcode = -1;\nstatic int hf_afs_ubik_opcode = -1;\nstatic int hf_afs_backup_opcode = -1;\n\nstatic int hf_afs_fs_fid_volume = -1;\nstatic int hf_afs_fs_fid_vnode = -1;\nstatic int hf_afs_fs_fid_uniqifier = -1;\nstatic int hf_afs_fs_offset = -1;\nstatic int hf_afs_fs_length = -1;\nstatic int hf_afs_fs_flength = -1;\nstatic int hf_afs_fs_offset64 = -1;\nstatic int hf_afs_fs_length64 = -1;\nstatic int hf_afs_fs_flength64 = -1;\nstatic int hf_afs_fs_errcode = -1;\nstatic int hf_afs_fs_data = -1;\nstatic int hf_afs_fs_name = -1;\nstatic int hf_afs_fs_oldname = -1;\nstatic int hf_afs_fs_newname = -1;\nstatic int hf_afs_fs_symlink_name = -1;\nstatic int hf_afs_fs_symlink_content = -1;\nstatic int hf_afs_fs_volid = -1;\nstatic int hf_afs_fs_volname = -1;\nstatic int hf_afs_fs_timestamp = -1;\nstatic int hf_afs_fs_offlinemsg = -1;\nstatic int hf_afs_fs_motd = -1;\nstatic int hf_afs_fs_xstats_version = -1;\nstatic int hf_afs_fs_xstats_timestamp = -1;\nstatic int hf_afs_fs_xstats_clientversion = -1;\nstatic int hf_afs_fs_xstats_collnumber = -1;\nstatic int hf_afs_fs_cps_spare1 = -1;\nstatic int hf_afs_fs_cps_spare2 = -1;\nstatic int hf_afs_fs_cps_spare3 = -1;\nstatic int hf_afs_fs_vicelocktype = -1;\nstatic int hf_afs_fs_viceid = -1;\nstatic int hf_afs_fs_ipaddr = -1;\nstatic int hf_afs_fs_token = -1;\n\nstatic int hf_afs_fs_status_anonymousaccess = -1;\nstatic int hf_afs_fs_status_author = -1;\nstatic int hf_afs_fs_status_calleraccess = -1;\nstatic int hf_afs_fs_status_clientmodtime = -1;\nstatic int hf_afs_fs_status_dataversion = -1;\nstatic int hf_afs_fs_status_dataversionhigh = -1;\nstatic int hf_afs_fs_status_filetype = -1;\nstatic int hf_afs_fs_status_group = -1;\nstatic int hf_afs_fs_status_interfaceversion = -1;\nstatic int hf_afs_fs_status_length = -1;\nstatic int hf_afs_fs_status_linkcount = -1;\nstatic int hf_afs_fs_status_mask = -1;\nstatic int hf_afs_fs_status_mask_fsync = -1;\nstatic int hf_afs_fs_status_mask_setgroup = -1;\nstatic int hf_afs_fs_status_mask_setmode = -1;\nstatic int hf_afs_fs_status_mask_setmodtime = -1;\nstatic int hf_afs_fs_status_mask_setowner = -1;\nstatic int hf_afs_fs_status_mask_setsegsize = -1;\nstatic int hf_afs_fs_status_mode = -1;\nstatic int hf_afs_fs_status_owner = -1;\nstatic int hf_afs_fs_status_parentunique = -1;\nstatic int hf_afs_fs_status_parentvnode = -1;\nstatic int hf_afs_fs_status_segsize = -1;\nstatic int hf_afs_fs_status_servermodtime = -1;\nstatic int hf_afs_fs_status_spare2 = -1;\nstatic int hf_afs_fs_status_spare3 = -1;\nstatic int hf_afs_fs_status_spare4 = -1;\nstatic int hf_afs_fs_status_synccounter = -1;\n\nstatic int hf_afs_fs_volsync_spare1 = -1;\nstatic int hf_afs_fs_volsync_spare2 = -1;\nstatic int hf_afs_fs_volsync_spare3 = -1;\nstatic int hf_afs_fs_volsync_spare4 = -1;\nstatic int hf_afs_fs_volsync_spare5 = -1;\nstatic int hf_afs_fs_volsync_spare6 = -1;\n\nstatic int hf_afs_fs_acl_datasize = -1;\nstatic int hf_afs_fs_acl_count_negative = -1;\nstatic int hf_afs_fs_acl_count_positive = -1;\nstatic int hf_afs_fs_acl_entity = -1;\nstatic int hf_afs_fs_acl_r = -1;\nstatic int hf_afs_fs_acl_l = -1;\nstatic int hf_afs_fs_acl_i = -1;\nstatic int hf_afs_fs_acl_d = -1;\nstatic int hf_afs_fs_acl_w = -1;\nstatic int hf_afs_fs_acl_k = -1;\nstatic int hf_afs_fs_acl_a = -1;\n\nstatic int hf_afs_fs_callback_version = -1;\nstatic int hf_afs_fs_callback_expires = -1;\nstatic int hf_afs_fs_callback_type = -1;\n\nstatic int hf_afs_bos_errcode = -1;\nstatic int hf_afs_bos_type = -1;\nstatic int hf_afs_bos_instance = -1;\nstatic int hf_afs_bos_status = -1;\nstatic int hf_afs_bos_statusdesc = -1;\nstatic int hf_afs_bos_num = -1;\nstatic int hf_afs_bos_size = -1;\nstatic int hf_afs_bos_flags = -1;\nstatic int hf_afs_bos_date = -1;\nstatic int hf_afs_bos_content = -1;\nstatic int hf_afs_bos_user = -1;\nstatic int hf_afs_bos_key = -1;\nstatic int hf_afs_bos_path = -1;\nstatic int hf_afs_bos_file = -1;\nstatic int hf_afs_bos_cmd = -1;\nstatic int hf_afs_bos_error = -1;\nstatic int hf_afs_bos_spare1 = -1;\nstatic int hf_afs_bos_spare2 = -1;\nstatic int hf_afs_bos_spare3 = -1;\nstatic int hf_afs_bos_parm = -1;\nstatic int hf_afs_bos_kvno = -1;\nstatic int hf_afs_bos_cell = -1;\nstatic int hf_afs_bos_host = -1;\nstatic int hf_afs_bos_newtime = -1;\nstatic int hf_afs_bos_baktime = -1;\nstatic int hf_afs_bos_oldtime = -1;\nstatic int hf_afs_bos_data = -1;\nstatic int hf_afs_bos_keymodtime = -1;\nstatic int hf_afs_bos_keychecksum = -1;\nstatic int hf_afs_bos_keyspare2 = -1;\n\nstatic int hf_afs_vldb_errcode = -1;\nstatic int hf_afs_vldb_name = -1;\nstatic int hf_afs_vldb_id = -1;\nstatic int hf_afs_vldb_type = -1;\nstatic int hf_afs_vldb_bump = -1;\nstatic int hf_afs_vldb_index = -1;\nstatic int hf_afs_vldb_nextindex = -1;\nstatic int hf_afs_vldb_count = -1;\nstatic int hf_afs_vldb_numservers = -1;\nstatic int hf_afs_vldb_server = -1;\nstatic int hf_afs_vldb_serveruuid = -1;\nstatic int hf_afs_vldb_serveruniq = -1;\nstatic int hf_afs_vldb_serverflags = -1;\nstatic int hf_afs_vldb_serverip = -1;\nstatic int hf_afs_vldb_partition = -1;\nstatic int hf_afs_vldb_rovol = -1;\nstatic int hf_afs_vldb_rwvol = -1;\nstatic int hf_afs_vldb_bkvol = -1;\nstatic int hf_afs_vldb_clonevol = -1;\nstatic int hf_afs_vldb_flags = -1;\nstatic int hf_afs_vldb_flags_rwexists = -1;\nstatic int hf_afs_vldb_flags_roexists = -1;\nstatic int hf_afs_vldb_flags_bkexists = -1;\nstatic int hf_afs_vldb_flags_dfsfileset = -1;\n\nstatic int hf_afs_vldb_spare1 = -1;\nstatic int hf_afs_vldb_spare2 = -1;\nstatic int hf_afs_vldb_spare3 = -1;\nstatic int hf_afs_vldb_spare4 = -1;\nstatic int hf_afs_vldb_spare5 = -1;\nstatic int hf_afs_vldb_spare6 = -1;\nstatic int hf_afs_vldb_spare7 = -1;\nstatic int hf_afs_vldb_spare8 = -1;\nstatic int hf_afs_vldb_spare9 = -1;\n\nstatic int hf_afs_kauth_errcode = -1;\nstatic int hf_afs_kauth_princ = -1;\nstatic int hf_afs_kauth_realm = -1;\nstatic int hf_afs_kauth_domain = -1;\nstatic int hf_afs_kauth_kvno = -1;\nstatic int hf_afs_kauth_name = -1;\nstatic int hf_afs_kauth_data = -1;\n\nstatic int hf_afs_vol_errcode = -1;\nstatic int hf_afs_vol_count = -1;\nstatic int hf_afs_vol_id = -1;\nstatic int hf_afs_vol_name = -1;\n\nstatic int hf_afs_cb_errcode = -1;\nstatic int hf_afs_cb_callback_version = -1;\nstatic int hf_afs_cb_callback_type = -1;\nstatic int hf_afs_cb_callback_expires = -1;\nstatic int hf_afs_cb_fid_volume = -1;\nstatic int hf_afs_cb_fid_vnode = -1;\nstatic int hf_afs_cb_fid_uniqifier = -1;\n\nstatic int hf_afs_prot_errcode = -1;\nstatic int hf_afs_prot_name = -1;\nstatic int hf_afs_prot_id = -1;\nstatic int hf_afs_prot_count = -1;\nstatic int hf_afs_prot_oldid = -1;\nstatic int hf_afs_prot_newid = -1;\nstatic int hf_afs_prot_pos = -1;\nstatic int hf_afs_prot_flag = -1;\nstatic int hf_afs_prot_uid = -1;\nstatic int hf_afs_prot_gid = -1;\nstatic int hf_afs_prot_maxuid = -1;\nstatic int hf_afs_prot_maxgid = -1;\n\nstatic int hf_afs_backup_errcode = -1;\n\nstatic int hf_afs_ubik_errcode = -1;\nstatic int hf_afs_ubik_version_epoch = -1;\nstatic int hf_afs_ubik_version_counter = -1;\nstatic int hf_afs_ubik_votestart = -1;\nstatic int hf_afs_ubik_state = -1;\nstatic int hf_afs_ubik_site = -1;\nstatic int hf_afs_ubik_interface = -1;\nstatic int hf_afs_ubik_file = -1;\nstatic int hf_afs_ubik_pos = -1;\nstatic int hf_afs_ubik_length = -1;\nstatic int hf_afs_ubik_locktype = -1;\nstatic int hf_afs_ubik_voteend = -1;\nstatic int hf_afs_ubik_votetype = -1;\n\nstatic int hf_afs_ubik_now = -1;\nstatic int hf_afs_ubik_lastyestime = -1;\nstatic int hf_afs_ubik_lastyeshost = -1;\nstatic int hf_afs_ubik_lastyesstate = -1;\nstatic int hf_afs_ubik_lastyesclaim = -1;\nstatic int hf_afs_ubik_lowesthost = -1;\nstatic int hf_afs_ubik_lowesttime = -1;\nstatic int hf_afs_ubik_synchost = -1;\nstatic int hf_afs_ubik_synctime = -1;\nstatic int hf_afs_ubik_amsyncsite = -1;\nstatic int hf_afs_ubik_syncsiteuntil = -1;\nstatic int hf_afs_ubik_nservers = -1;\nstatic int hf_afs_ubik_lockedpages = -1;\nstatic int hf_afs_ubik_writelockedpages = -1;\nstatic int hf_afs_ubik_activewrite = -1;\nstatic int hf_afs_ubik_tidcounter = -1;\nstatic int hf_afs_ubik_anyreadlocks = -1;\nstatic int hf_afs_ubik_anywritelocks = -1;\nstatic int hf_afs_ubik_recoverystate = -1;\nstatic int hf_afs_ubik_currenttrans = -1;\nstatic int hf_afs_ubik_writetrans = -1;\nstatic int hf_afs_ubik_epochtime = -1;\nstatic int hf_afs_ubik_isclone = -1;\nstatic int hf_afs_ubik_addr = -1;\nstatic int hf_afs_ubik_lastvotetime = -1;\nstatic int hf_afs_ubik_lastbeaconsent = -1;\nstatic int hf_afs_ubik_lastvote = -1;\nstatic int hf_afs_ubik_currentdb = -1;\nstatic int hf_afs_ubik_beaconsincedown = -1;\nstatic int hf_afs_ubik_up = -1;\nstatic int hf_afs_repframe = -1;\nstatic int hf_afs_reqframe = -1;\nstatic int hf_afs_time = -1;\n\nstatic gint ett_afs = -1;\nstatic gint ett_afs_op = -1;\nstatic gint ett_afs_acl = -1;\nstatic gint ett_afs_fid = -1;\nstatic gint ett_afs_callback = -1;\nstatic gint ett_afs_ubikver = -1;\nstatic gint ett_afs_status = -1;\nstatic gint ett_afs_status_mask = -1;\nstatic gint ett_afs_volsync = -1;\nstatic gint ett_afs_volumeinfo = -1;\nstatic gint ett_afs_vicestat = -1;\nstatic gint ett_afs_vldb_flags = -1;\n\n/*\n * Macros for helper dissection routines\n *\n * The macros are here to save on coding. They assume that\n * the current offset is in 'offset', and that the offset\n * should be incremented after performing the macro's operation.\n */\n\n\n/* Output a unsigned integer, stored into field 'field'\n   Assumes it is in network byte order, converts to host before using */\n#define OUT_UINT(field) \\\n\tproto_tree_add_uint(tree, field, tvb, offset, 4, tvb_get_ntohl(tvb, offset)); \\\n\toffset += 4;\n\n/* Output a unsigned integer, stored into field 'field'\n   Assumes it is in network byte order, converts to host before using */\n#define OUT_INT(field) \\\n\tproto_tree_add_int(tree, field, tvb, offset, 4, tvb_get_ntohl(tvb, offset)); \\\n\toffset += 4;\n\n/* Output a unsigned integer, stored into field 'field'\n   Assumes it is in network byte order, converts to host before using */\n#define OUT_UINT64(field) \\\n\tproto_tree_add_item(tree, field, tvb, offset, 8, FALSE); \\\n\toffset += 8;\n\n/* Output a unsigned integer, stored into field 'field'\n   Assumes it is in network byte order, converts to host before using */\n#define OUT_INT64(field) \\\n\tproto_tree_add_item(tree, field, tvb, offset, 8, FALSE); \\\n\toffset += 8;\n\n/* Output a unsigned integer, stored into field 'field'\n   Assumes it is in network byte order, converts to host before using,\n   Note - does not increment offset, so can be used repeatedly for bitfields */\n#define DISP_UINT(field) \\\n\tproto_tree_add_uint(tree,field,tvb,offset,4,tvb_get_ntohl(tvb, offset));\n\n/* Output an IPv4 address, stored into field 'field' */\n#define OUT_IP(field) \\\n\tproto_tree_add_ipv4(tree,field,tvb,offset,4,\\\n\t\ttvb_get_letohl(tvb, offset));\\\n\toffset += 4;\n\n/* Output a simple rx array */\n#define OUT_RXArray8(func) \\\n\t{ \\\n\t\tunsigned int j,i; \\\n\t\tj = tvb_get_guint8(tvb, offset); \\\n\t\toffset += 1; \\\n\t\tfor (i=0; i<j; i++) { \\\n\t\t\tfunc; \\\n\t\t} \\\n\t}\n\n/* Output a simple rx array */\n#define OUT_RXArray32(func) \\\n\t{ \\\n\t\tunsigned int j,i; \\\n\t\tj = tvb_get_ntohl(tvb, offset); \\\n\t\toffset += 4; \\\n\t\tfor (i=0; i<j; i++) { \\\n\t\t\tfunc; \\\n\t\t} \\\n\t}\n\n/* Output a UNIX seconds/microseconds timestamp, after converting to an\n   nstime_t */\n#define OUT_TIMESTAMP(field) \\\n\t{ nstime_t ts; \\\n\tts.secs = tvb_get_ntohl(tvb, offset); \\\n\tts.nsecs = tvb_get_ntohl(tvb, offset+4)*1000; \\\n\tproto_tree_add_time(tree,field, tvb,offset,2*4,&ts); \\\n\toffset += 8; \\\n\t}\n\n/* Output a seconds-only time value, after converting to an nstime_t;\n   this can be an absolute time as a UNIX time-since-epoch, or a\n   relative time in seconds */\n#define OUT_TIMESECS(field) \\\n\t{ nstime_t ts; \\\n\tts.secs = tvb_get_ntohl(tvb, offset); \\\n\tts.nsecs = 0; \\\n\tproto_tree_add_time(tree,field, tvb,offset,4,&ts); \\\n\toffset += 4; \\\n\t}\n\n/* Output a rx style string, up to a maximum length first\n   4 bytes - length, then char data */\n#define OUT_RXString(field) \\\n\t{\tguint32 i_orxs,len_orxs; \\\n\t\tchar *tmp_orxs; \\\n\t\tconst guint8 *p_orxs; \\\n\t\ti_orxs = tvb_get_ntohl(tvb, offset); \\\n\t\toffset += 4; \\\n\t\tp_orxs = tvb_get_ptr(tvb,offset,i_orxs); \\\n\t\tlen_orxs = ((i_orxs+4-1)/4)*4; \\\n\t\ttmp_orxs = ep_alloc(i_orxs+1); \\\n\t\tmemcpy(tmp_orxs, p_orxs, i_orxs); \\\n\t\ttmp_orxs[i_orxs] = '\\0'; \\\n\t\tproto_tree_add_string(tree, field, tvb, offset-4, len_orxs+4, \\\n\t\t(void *)tmp_orxs); \\\n\t\toffset += len_orxs; \\\n\t}\n\n/* Output a fixed length vectorized string (each char is a 32 bit int) */\n#define OUT_RXStringV(field, length) \\\n\t{ \tchar tmp_orxsv[length+1]; \\\n\t\tint i_orxsv,soff_orxsv; \\\n\t\tsoff_orxsv = offset;\\\n\t\tfor (i_orxsv=0; i_orxsv<length; i_orxsv++)\\\n\t\t{\\\n\t\t\ttmp_orxsv[i_orxsv] = (char) tvb_get_ntohl(tvb, offset);\\\n\t\t\toffset += 4;\\\n\t\t}\\\n\t\ttmp_orxsv[length] = '\\0';\\\n\t\tproto_tree_add_string(tree, field, tvb, soff_orxsv, length*4, tmp_orxsv);\\\n\t}\n\n\n/* Output a callback */\n#define OUT_FS_AFSCallBack() \\\n\t{ \tproto_tree *save, *ti; \\\n\t\tti = proto_tree_add_text(tree, tvb, offset, 3*4, \"Callback\"); \\\n\t\tsave = tree; \\\n\t\ttree = proto_item_add_subtree(ti, ett_afs_callback); \\\n\t\tOUT_UINT(hf_afs_fs_callback_version); \\\n\t\tOUT_TIMESECS(hf_afs_fs_callback_expires); \\\n\t\tOUT_UINT(hf_afs_fs_callback_type); \\\n\t\ttree = save; \\\n\t}\n\n/* Output a callback */\n#define OUT_CB_AFSCallBack() \\\n\t{ \tproto_tree *save, *ti; \\\n\t\tti = proto_tree_add_text(tree, tvb, offset, 3*4, \"Callback\"); \\\n\t\tsave = tree; \\\n\t\ttree = proto_item_add_subtree(ti, ett_afs_callback); \\\n\t\tOUT_UINT(hf_afs_cb_callback_version); \\\n\t\tOUT_TIMESECS(hf_afs_cb_callback_expires); \\\n\t\tOUT_UINT(hf_afs_cb_callback_type); \\\n\t\ttree = save; \\\n\t}\n\n/* Output a File ID */\n#define OUT_FS_AFSFid(label) \\\n\t{ \tproto_tree *save, *ti; \\\n\t\tti = proto_tree_add_text(tree, tvb, offset, 3*4, \\\n\t\t\t\"FileID (%s)\", label); \\\n\t\tsave = tree; \\\n\t\ttree = proto_item_add_subtree(ti, ett_afs_fid); \\\n\t\tOUT_UINT(hf_afs_fs_fid_volume); \\\n\t\tOUT_UINT(hf_afs_fs_fid_vnode); \\\n\t\tOUT_UINT(hf_afs_fs_fid_uniqifier); \\\n\t\ttree = save; \\\n\t}\n\n/* Output a Status mask */\n#define OUT_FS_STATUSMASK() \\\n\t{ \tproto_tree *save_ofsm, *ti_ofsm; \\\n\t\tguint32 mask_ofsm; \\\n\t\tmask_ofsm = tvb_get_ntohl(tvb, offset); \\\n\t\tti_ofsm = proto_tree_add_uint(tree, hf_afs_fs_status_mask, tvb, offset, \\\n\t\t\t4, mask_ofsm); \\\n\t\tsave_ofsm = tree; \\\n\t\ttree = proto_item_add_subtree(ti_ofsm, ett_afs_status_mask); \\\n\t\tproto_tree_add_boolean(tree, hf_afs_fs_status_mask_setmodtime, \\\n\t\t\ttvb,offset,4, mask_ofsm); \\\n\t\tproto_tree_add_boolean(tree, hf_afs_fs_status_mask_setowner, \\\n\t\t\ttvb,offset,4, mask_ofsm); \\\n\t\tproto_tree_add_boolean(tree, hf_afs_fs_status_mask_setgroup, \\\n\t\t\ttvb,offset,4, mask_ofsm); \\\n\t\tproto_tree_add_boolean(tree, hf_afs_fs_status_mask_setmode, \\\n\t\t\ttvb,offset,4, mask_ofsm); \\\n\t\tproto_tree_add_boolean(tree, hf_afs_fs_status_mask_setsegsize, \\\n\t\t\ttvb,offset,4, mask_ofsm); \\\n\t\tproto_tree_add_boolean(tree, hf_afs_fs_status_mask_fsync, \\\n\t\t\ttvb,offset,4, mask_ofsm); \\\n\t\toffset += 4; \\\n\t\ttree = save_ofsm; \\\n\t}\n\n/* Output vldb flags */\n#define OUT_VLDB_Flags() \\\n\t{ \tproto_tree *save, *ti; \\\n\t\tguint32 flags; \\\n\t\tflags = tvb_get_ntohl(tvb, offset); \\\n\t\tti = proto_tree_add_uint(tree, hf_afs_vldb_flags, tvb, offset, \\\n\t\t\t4, flags); \\\n\t\tsave = tree; \\\n\t\ttree = proto_item_add_subtree(ti, ett_afs_vldb_flags); \\\n\t\tproto_tree_add_boolean(tree, hf_afs_vldb_flags_rwexists, \\\n\t\t\ttvb,offset,4, flags); \\\n\t\tproto_tree_add_boolean(tree, hf_afs_vldb_flags_roexists, \\\n\t\t\ttvb,offset,4, flags); \\\n\t\tproto_tree_add_boolean(tree, hf_afs_vldb_flags_bkexists, \\\n\t\t\ttvb,offset,4, flags); \\\n\t\tproto_tree_add_boolean(tree, hf_afs_vldb_flags_dfsfileset, \\\n\t\t\ttvb,offset,4, flags); \\\n\t\toffset += 4; \\\n\t\ttree = save; \\\n\t}\n\n\n\n/* Output a File ID */\n#define OUT_CB_AFSFid(label) \\\n\t{ \tproto_tree *save, *ti; \\\n\t\tti = proto_tree_add_text(tree, tvb, offset, 3*4, \\\n\t\t\t\"FileID (%s)\", label); \\\n\t\tsave = tree; \\\n\t\ttree = proto_item_add_subtree(ti, ett_afs_fid); \\\n\t\tOUT_UINT(hf_afs_cb_fid_volume); \\\n\t\tOUT_UINT(hf_afs_cb_fid_vnode); \\\n\t\tOUT_UINT(hf_afs_cb_fid_uniqifier); \\\n\t\ttree = save; \\\n\t}\n\n/* Output a StoreStatus */\n#define OUT_FS_AFSStoreStatus(label) \\\n\t{ \tproto_tree *save, *ti; \\\n\t\tti = proto_tree_add_text(tree, tvb, offset, 6*4, \\\n\t\t\tlabel); \\\n\t\tsave = tree; \\\n\t\ttree = proto_item_add_subtree(ti, ett_afs_status); \\\n\t\tOUT_FS_STATUSMASK(); \\\n\t\tOUT_TIMESECS(hf_afs_fs_status_clientmodtime); \\\n\t\tOUT_UINT(hf_afs_fs_status_owner); \\\n\t\tOUT_UINT(hf_afs_fs_status_group); \\\n\t\tOUT_UINT(hf_afs_fs_status_mode); \\\n\t\tOUT_UINT(hf_afs_fs_status_segsize); \\\n\t\ttree = save; \\\n\t}\n\n/* Output a FetchStatus */\n#define OUT_FS_AFSFetchStatus(label) \\\n\t{ \tproto_tree *save, *ti; \\\n\t\tti = proto_tree_add_text(tree, tvb, offset, 21*4, \\\n\t\t\tlabel); \\\n\t\tsave = tree; \\\n\t\ttree = proto_item_add_subtree(ti, ett_afs_status); \\\n\t\tOUT_UINT(hf_afs_fs_status_interfaceversion); \\\n\t\tOUT_UINT(hf_afs_fs_status_filetype); \\\n\t\tOUT_UINT(hf_afs_fs_status_linkcount); \\\n\t\tOUT_UINT(hf_afs_fs_status_length); \\\n\t\tOUT_UINT(hf_afs_fs_status_dataversion); \\\n\t\tOUT_UINT(hf_afs_fs_status_author); \\\n\t\tOUT_UINT(hf_afs_fs_status_owner); \\\n\t\tOUT_UINT(hf_afs_fs_status_calleraccess); \\\n\t\tOUT_UINT(hf_afs_fs_status_anonymousaccess); \\\n\t\tOUT_UINT(hf_afs_fs_status_mode); \\\n\t\tOUT_UINT(hf_afs_fs_status_parentvnode); \\\n\t\tOUT_UINT(hf_afs_fs_status_parentunique); \\\n\t\tOUT_UINT(hf_afs_fs_status_segsize); \\\n\t\tOUT_TIMESECS(hf_afs_fs_status_clientmodtime); \\\n\t\tOUT_TIMESECS(hf_afs_fs_status_servermodtime); \\\n\t\tOUT_UINT(hf_afs_fs_status_group); \\\n\t\tOUT_UINT(hf_afs_fs_status_synccounter); \\\n\t\tOUT_UINT(hf_afs_fs_status_dataversionhigh); \\\n\t\tOUT_UINT(hf_afs_fs_status_spare2); \\\n\t\tOUT_UINT(hf_afs_fs_status_spare3); \\\n\t\tOUT_UINT(hf_afs_fs_status_spare4); \\\n\t\ttree = save; \\\n\t}\n\n/* Output a VolSync */\n#define OUT_FS_AFSVolSync() \\\n\t{ \tproto_tree *save, *ti; \\\n\t\tti = proto_tree_add_text(tree, tvb, offset, 6*4, \\\n\t\t\t\"VolSync\"); \\\n\t\tsave = tree; \\\n\t\ttree = proto_item_add_subtree(ti, ett_afs_volsync); \\\n\t\tOUT_TIMESECS(hf_afs_fs_volsync_spare1); \\\n\t\tOUT_UINT(hf_afs_fs_volsync_spare2); \\\n\t\tOUT_UINT(hf_afs_fs_volsync_spare3); \\\n\t\tOUT_UINT(hf_afs_fs_volsync_spare4); \\\n\t\tOUT_UINT(hf_afs_fs_volsync_spare5); \\\n\t\tOUT_UINT(hf_afs_fs_volsync_spare6); \\\n\t\ttree = save; \\\n\t}\n\n/* Output a AFSCBFids */\n#define OUT_FS_AFSCBFids() \\\n\tOUT_RXArray32(OUT_FS_AFSFid(\"Target\"));\n\n/* Output a ViceIds */\n#define OUT_FS_ViceIds() \\\n\tOUT_RXArray8(OUT_UINT(hf_afs_fs_viceid));\n\n/* Output a IPAddrs */\n#define OUT_FS_IPAddrs() \\\n\tOUT_RXArray8(OUT_IP(hf_afs_fs_ipaddr));\n\n/* Output a AFSCBs */\n#define OUT_FS_AFSCBs()\t\\\n\tOUT_RXArray32(OUT_FS_AFSCallBack());\n\n/* Output a AFSBulkStats */\n#define OUT_FS_AFSBulkStats() \\\n\tOUT_RXArray32(OUT_FS_AFSFetchStatus(\"Status\"));\n\n/* Output a AFSFetchVolumeStatus */\n#define OUT_FS_AFSFetchVolumeStatus()\n\n/* Output a AFSStoreVolumeStatus */\n#define OUT_FS_AFSStoreVolumeStatus()\n\n/* Output a ViceStatistics structure */\n#define OUT_FS_ViceStatistics()\n\n/* Output a AFS_CollData structure */\n#define OUT_FS_AFS_CollData()\n\n/* Output a VolumeInfo structure */\n#define OUT_FS_VolumeInfo()\n\n/* Output an AFS Token - might just be bytes though */\n#define OUT_FS_AFSTOKEN() OUT_RXStringV(hf_afs_fs_token, 1024)\n\n/* Output a AFS acl */\n#define ACLOUT(who, positive, acl, bytes) \\\n\t{ \tproto_tree *save, *ti; \\\n\t\tint tmpoffset; \\\n\t\tint acllen; \\\n\t\tchar tmp[10]; \\\n\t\ttmp[0] = 0; \\\n\t\tif ( acl & PRSFS_READ ) g_strlcat(tmp, \"r\", 10);\t\\\n\t\tif ( acl & PRSFS_LOOKUP ) g_strlcat(tmp, \"l\", 10);\t\\\n\t\tif ( acl & PRSFS_INSERT ) g_strlcat(tmp, \"i\", 10);\t\\\n\t\tif ( acl & PRSFS_DELETE ) g_strlcat(tmp, \"d\", 10);\t\\\n\t\tif ( acl & PRSFS_WRITE ) g_strlcat(tmp, \"w\", 10);\t\\\n\t\tif ( acl & PRSFS_LOCK ) g_strlcat(tmp, \"k\", 10);\t\\\n\t\tif ( acl & PRSFS_ADMINISTER ) g_strlcat(tmp, \"a\", 10);  \\\n\t\tti = proto_tree_add_text(tree, tvb, offset, bytes, \\\n\t\t\t\"ACL:  %s %s%s\", \\\n\t\t\twho, tmp, positive ? \"\" : \" (negative)\"); \\\n\t\tsave = tree; \\\n\t\ttree = proto_item_add_subtree(ti, ett_afs_acl); \\\n\t\tproto_tree_add_string(tree,hf_afs_fs_acl_entity, tvb,offset,(int)strlen(who), who);\\\n\t\ttmpoffset = offset + (int)strlen(who) + 1; \\\n\t\tacllen = bytes - (int)strlen(who) - 1; \\\n\t\tproto_tree_add_boolean(tree,hf_afs_fs_acl_r, tvb,tmpoffset,acllen,acl);\\\n\t\tproto_tree_add_boolean(tree,hf_afs_fs_acl_l, tvb,tmpoffset,acllen,acl);\\\n\t\tproto_tree_add_boolean(tree,hf_afs_fs_acl_i, tvb,tmpoffset,acllen,acl);\\\n\t\tproto_tree_add_boolean(tree,hf_afs_fs_acl_d, tvb,tmpoffset,acllen,acl);\\\n\t\tproto_tree_add_boolean(tree,hf_afs_fs_acl_w, tvb,tmpoffset,acllen,acl);\\\n\t\tproto_tree_add_boolean(tree,hf_afs_fs_acl_k, tvb,tmpoffset,acllen,acl);\\\n\t\tproto_tree_add_boolean(tree,hf_afs_fs_acl_a, tvb,tmpoffset,acllen,acl);\\\n\t\ttree = save; \\\n\t}\n\n/* Output a UUID */\n#define OUT_UUID(x) \\\n\tOUT_BYTES(x, 11*4);\n#define SKIP_UUID() \\\n\tSKIP(11*4);\n\n\n/* Output a bulkaddr */\n#define OUT_VLDB_BulkAddr() \\\n\tOUT_RXArray32(OUT_IP(hf_afs_vldb_serverip));\n\n/* output a bozo_key */\n#define OUT_BOS_KEY() \\\n\tOUT_BYTES(hf_afs_bos_key, 8);\n\n/* output a bozo_key */\n#define OUT_BOS_KEYINFO() \\\n\tOUT_TIMESTAMP(hf_afs_bos_keymodtime); \\\n\tOUT_UINT(hf_afs_bos_keychecksum); \\\n\tOUT_UINT(hf_afs_bos_keyspare2);\n\n/* output a bozo_netKTime */\n#define OUT_BOS_TIME() \\\n\tSKIP(4); SKIP(2); SKIP(2); SKIP(2); SKIP(2);\n\n/* output a bozo_status */\n#define OUT_BOS_STATUS() \\\n\tSKIP(10 * 4);\n\n/* output a ubik interface addr array */\n#define OUT_UBIK_InterfaceAddrs() \\\n    { \\\n        unsigned int i,j,seen_null=0; \\\n        for (i=0; i<255; i++) { \\\n\t\tj = tvb_get_ntohl(tvb, offset); \\\n\t\tif ( j != 0 ) { \\\n\t\t\tOUT_IP(hf_afs_ubik_interface); \\\n\t\t\tseen_null = 0; \\\n\t\t} else { \\\n\t\t\tif ( ! seen_null ) { \\\n\t\t\tproto_tree_add_text(tree, tvb, offset, \\\n\t\t\t\ttvb_length_remaining(tvb, offset), \\\n\t\t\t\t\"Null Interface Addresses\"); \\\n\t\t\t\tseen_null = 1; \\\n\t\t\t} \\\n\t\t\toffset += 4; \\\n\t\t}\\\n        } \\\n    }\n\n#define OUT_UBIK_DebugOld() \\\n\t{ \\\n\t\tOUT_TIMESECS(hf_afs_ubik_now); \\\n\t\tOUT_TIMESECS(hf_afs_ubik_lastyestime); \\\n\t\tOUT_IP(hf_afs_ubik_lastyeshost); \\\n\t\tOUT_UINT(hf_afs_ubik_lastyesstate); \\\n\t\tOUT_TIMESECS(hf_afs_ubik_lastyesclaim); \\\n\t\tOUT_IP(hf_afs_ubik_lowesthost); \\\n\t\tOUT_TIMESECS(hf_afs_ubik_lowesttime); \\\n\t\tOUT_IP(hf_afs_ubik_synchost); \\\n\t\tOUT_TIMESECS(hf_afs_ubik_synctime); \\\n\t\tOUT_UBIKVERSION(\"Sync Version\"); \\\n\t\tOUT_UBIKVERSION(\"Sync TID\"); \\\n\t\tOUT_UINT(hf_afs_ubik_amsyncsite); \\\n\t\tOUT_TIMESECS(hf_afs_ubik_syncsiteuntil); \\\n\t\tOUT_UINT(hf_afs_ubik_nservers); \\\n\t\tOUT_UINT(hf_afs_ubik_lockedpages); \\\n\t\tOUT_UINT(hf_afs_ubik_writelockedpages); \\\n\t\tOUT_UBIKVERSION(\"Local Version\"); \\\n\t\tOUT_UINT(hf_afs_ubik_activewrite); \\\n\t\tOUT_UINT(hf_afs_ubik_tidcounter); \\\n\t\tOUT_UINT(hf_afs_ubik_anyreadlocks); \\\n\t\tOUT_UINT(hf_afs_ubik_anywritelocks); \\\n\t\tOUT_UINT(hf_afs_ubik_recoverystate); \\\n\t\tOUT_UINT(hf_afs_ubik_currenttrans); \\\n\t\tOUT_UINT(hf_afs_ubik_writetrans); \\\n\t\tOUT_TIMESECS(hf_afs_ubik_epochtime); \\\n\t}\n\n#define OUT_UBIK_SDebugOld() \\\n\t{ \\\n\t\tOUT_IP(hf_afs_ubik_addr); \\\n\t\tOUT_TIMESECS(hf_afs_ubik_lastvotetime); \\\n\t\tOUT_TIMESECS(hf_afs_ubik_lastbeaconsent); \\\n\t\tOUT_UINT(hf_afs_ubik_lastvote); \\\n\t\tOUT_UBIKVERSION(\"Remote Version\"); \\\n\t\tOUT_UINT(hf_afs_ubik_currentdb); \\\n\t\tOUT_UINT(hf_afs_ubik_beaconsincedown); \\\n\t\tOUT_UINT(hf_afs_ubik_up); \\\n\t}\n\n/* Skip a certain number of bytes */\n#define SKIP(bytes) \\\n\toffset += bytes;\n\n/* Raw data - to end of frame */\n#define OUT_BYTES_ALL(field) OUT_BYTES(field, tvb_length_remaining(tvb,offset))\n\n/* Raw data */\n#define OUT_BYTES(field, bytes) \\\n\tproto_tree_add_item(tree, field, tvb, offset, bytes, FALSE);\\\n\toffset += bytes;\n\n\n\n/* Skip the opcode */\n#define SKIP_OPCODE() \\\n\t{ \\\n\t\tSKIP(4); \\\n\t}\n\n/* Output a UBIK version code */\n#define OUT_UBIKVERSION(label) \\\n\t{ \tproto_tree *save, *ti; \\\n\t\tunsigned int epoch,counter; \\\n\t\tnstime_t ts; \\\n\t\tepoch = tvb_get_ntohl(tvb, offset); \\\n\t\toffset += 4; \\\n\t\tcounter = tvb_get_ntohl(tvb, offset); \\\n\t\toffset += 4; \\\n\t\tts.secs = epoch; \\\n\t\tts.nsecs = 0; \\\n\t\tti = proto_tree_add_text(tree, tvb, offset-8, 8, \\\n\t\t\t\"UBIK Version (%s): %u.%u\", label, epoch, counter ); \\\n\t\tsave = tree; \\\n\t\ttree = proto_item_add_subtree(ti, ett_afs_ubikver); \\\n\t\tif ( epoch != 0 ) \\\n\t\tproto_tree_add_time(tree,hf_afs_ubik_version_epoch, tvb,offset-8, \\\n\t\t\t4,&ts); \\\n\t\telse \\\n\t\t\tproto_tree_add_text(tree, tvb, offset-8, \\\n\t\t\t4,\"Epoch: 0\"); \\\n\t\tproto_tree_add_uint(tree,hf_afs_ubik_version_counter, tvb,offset-4, \\\n\t\t\t4,counter); \\\n\t\ttree = save; \\\n\t}\n\n/* Output a kauth getticket request */\n#define OUT_KAUTH_GetTicket() \\\n\t{ \\\n\t\tint len = 0; \\\n\t\tOUT_UINT(hf_afs_kauth_kvno); \\\n\t\tOUT_RXString(hf_afs_kauth_domain); \\\n\t\tlen = tvb_get_ntohl(tvb, offset); \\\n\t\toffset += 4; \\\n\t\tOUT_BYTES(hf_afs_kauth_data, len); \\\n\t\tOUT_RXString(hf_afs_kauth_princ); \\\n\t\tOUT_RXString(hf_afs_kauth_realm); \\\n\t}\n\n#define GETSTR ((const char *)tvb_get_ptr(tvb,offset,tvb_ensure_length_remaining(tvb,offset)))\n\n#define VALID_OPCODE(opcode) ((opcode >= OPCODE_LOW && opcode <= OPCODE_HIGH) || \\\n\t\t(opcode >= VOTE_LOW && opcode <= VOTE_HIGH) || \\\n\t\t(opcode >= DISK_LOW && opcode <= DISK_HIGH))\n\nstatic const value_string fs_req[] = {\n\t{ 130,\t\t\"fetch-data\" },\n\t{ 131,\t\t\"fetch-acl\" },\n\t{ 132,\t\t\"fetch-status\" },\n\t{ 133,\t\t\"store-data\" },\n\t{ 134,\t\t\"store-acl\" },\n\t{ 135,\t\t\"store-status\" },\n\t{ 136,\t\t\"remove-file\" },\n\t{ 137,\t\t\"create-file\" },\n\t{ 138,\t\t\"rename\" },\n\t{ 139,\t\t\"symlink\" },\n\t{ 140,\t\t\"link\" },\n\t{ 141,\t\t\"makedir\" },\n\t{ 142,\t\t\"rmdir\" },\n\t{ 143,\t\t\"old-set-lock\" },\n\t{ 144,\t\t\"old-extend-lock\" },\n\t{ 145,\t\t\"old-release-lock\" },\n\t{ 146,\t\t\"get-stats\" },\n\t{ 147,\t\t\"give-up-callbacks\" },\n\t{ 148,\t\t\"get-volume-info\" },\n\t{ 149,\t\t\"get-volume-status\" },\n\t{ 150,\t\t\"set-volume-status\" },\n\t{ 151,\t\t\"get-root-volume\" },\n\t{ 152,\t\t\"check-token\" },\n\t{ 153,\t\t\"get-time\" },\n\t{ 154,\t\t\"nget-volume-info\" },\n\t{ 155,\t\t\"bulk-status\" },\n\t{ 156,\t\t\"set-lock\" },\n\t{ 157,\t\t\"extend-lock\" },\n\t{ 158,\t\t\"release-lock\" },\n\t{ 159,\t\t\"xstats-version\" },\n\t{ 160,\t\t\"get-xstats\" },\n\t{ 161,\t\t\"dfs-lookup\" },\n\t{ 162,\t\t\"dfs-flushcps\" },\n\t{ 163,\t\t\"dfs-symlink\" },\n\t{ 220,\t\t\"residency\" },\n\t{ 65536, \t\"inline-bulk-status\" },\n\t{ 65537, \t\"fetch-data-64\" },\n\t{ 65538, \t\"store-data-64\" },\n\t{ 65539, \t\"give-up-all-callbacks\" },\n\t{ 65540, \t\"get-capabilities\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const value_string cb_req[] = {\n\t{ 204,\t\t\"callback\" },\n\t{ 205,\t\t\"init-callback-state\" },\n\t{ 206,\t\t\"probe\" },\n\t{ 207,\t\t\"get-lock\" },\n\t{ 208,\t\t\"get-ce\" },\n\t{ 209,\t\t\"xstats-version\" },\n\t{ 210,\t\t\"get-xstats\" },\n\t{ 211,\t\t\"init-callback-state2\" },\n\t{ 212,\t\t\"who-are-you\" },\n\t{ 213,\t\t\"init-callback-state3\" },\n\t{ 214,\t\t\"probeuuid\" },\n\t{ 215,\t\t\"get-server-prefs\" },\n\t{ 216,\t\t\"get-cellservdb\" },\n\t{ 217,\t\t\"get-local-cell\" },\n\t{ 218,\t\t\"get-cache-config\" },\n\t{ 65536,\t\"get-ce-64\" },\n\t{ 65537,\t\"get-cell-by-num\" },\n\t{ 65538,\t\"get-capabilities\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const value_string prot_req[] = {\n\t{ 500,\t\t\"new-user\" },\n\t{ 501,\t\t\"where-is-it\" },\n\t{ 502,\t\t\"dump-entry\" },\n\t{ 503,\t\t\"add-to-group\" },\n\t{ 504,\t\t\"name-to-id\" },\n\t{ 505,\t\t\"id-to-name\" },\n\t{ 506,\t\t\"delete\" },\n\t{ 507,\t\t\"remove-from-group\" },\n\t{ 508,\t\t\"get-cps\" },\n\t{ 509,\t\t\"new-entry\" },\n\t{ 510,\t\t\"list-max\" },\n\t{ 511,\t\t\"set-max\" },\n\t{ 512,\t\t\"list-entry\" },\n\t{ 513,\t\t\"change-entry\" },\n\t{ 514,\t\t\"list-elements\" },\n\t{ 515,\t\t\"is-member-of\" },\n\t{ 516,\t\t\"set-fld-sentry\" },\n\t{ 517,\t\t\"list-owned\" },\n\t{ 518,\t\t\"get-cps2\" },\n\t{ 519,\t\t\"get-host-cps\" },\n\t{ 520,\t\t\"update-entry\" },\n\t{ 521,\t\t\"list-entries\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const value_string vldb_req[] = {\n\t{ 501,\t\t\"create-entry\" },\n\t{ 502,\t\t\"delete-entry\" },\n\t{ 503,\t\t\"get-entry-by-id\" },\n\t{ 504,\t\t\"get-entry-by-name\" },\n\t{ 505,\t\t\"get-new-volume-id\" },\n\t{ 506,\t\t\"replace-entry\" },\n\t{ 507,\t\t\"update-entry\" },\n\t{ 508,\t\t\"set-lock\" },\n\t{ 509,\t\t\"release-lock\" },\n\t{ 510,\t\t\"list-entry\" },\n\t{ 511,\t\t\"list-attributes\" },\n\t{ 512,\t\t\"linked-list\" },\n\t{ 513,\t\t\"get-stats\" },\n\t{ 514,\t\t\"probe\" },\n\t{ 515,\t\t\"get-addrs\" },\n\t{ 516,\t\t\"change-addr\" },\n\t{ 517,\t\t\"create-entry-n\" },\n\t{ 518,\t\t\"get-entry-by-id-n\" },\n\t{ 519,\t\t\"get-entry-by-name-n\" },\n\t{ 520,\t\t\"replace-entry-n\" },\n\t{ 521,\t\t\"list-entry-n\" },\n\t{ 522,\t\t\"list-attrib-n\" },\n\t{ 523,\t\t\"linked-list-n\" },\n\t{ 524,\t\t\"update-entry-by-name\" },\n\t{ 525,\t\t\"create-entry-u\" },\n\t{ 526,\t\t\"get-entry-by-id-u\" },\n\t{ 527,\t\t\"get-entry-by-name-u\" },\n\t{ 528,\t\t\"replace-entry-u\" },\n\t{ 529,\t\t\"list-entry-u\" },\n\t{ 530,\t\t\"list-attrib-u\" },\n\t{ 531,\t\t\"linked-list-u\" },\n\t{ 532,\t\t\"regaddr\" },\n\t{ 533,\t\t\"get-addrs-u\" },\n\t{ 534,\t\t\"list-attrib-n2\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const value_string kauth_req[] = {\n\t{ 1,\t\t\"auth-old\" },\n\t{ 21,\t\t\"authenticate\" },\n\t{ 22,\t\t\"authenticate-v2\" },\n\t{ 2,\t\t\"change-pw\" },\n\t{ 3,\t\t\"get-ticket-old\" },\n\t{ 23,\t\t\"get-ticket\" },\n\t{ 4,\t\t\"set-pw\" },\n\t{ 5,\t\t\"set-fields\" },\n\t{ 6,\t\t\"create-user\" },\n\t{ 7,\t\t\"delete-user\" },\n\t{ 8,\t\t\"get-entry\" },\n\t{ 9,\t\t\"list-entry\" },\n\t{ 10,\t\t\"get-stats\" },\n\t{ 11,\t\t\"debug\" },\n\t{ 12,\t\t\"get-pw\" },\n\t{ 13,\t\t\"get-random-key\" },\n\t{ 14,\t\t\"unlock\" },\n\t{ 15,\t\t\"lock-status\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const value_string vol_req[] = {\n\t{ 100,\t\t\"create-volume\" },\n\t{ 101,\t\t\"delete-volume\" },\n\t{ 102,\t\t\"restore\" },\n\t{ 103,\t\t\"forward\" },\n\t{ 104,\t\t\"end-trans\" },\n\t{ 105,\t\t\"clone\" },\n\t{ 106,\t\t\"set-flags\" },\n\t{ 107,\t\t\"get-flags\" },\n\t{ 108,\t\t\"trans-create\" },\n\t{ 109,\t\t\"dump\" },\n\t{ 110,\t\t\"get-nth-volume\" },\n\t{ 111,\t\t\"set-forwarding\" },\n\t{ 112,\t\t\"get-name\" },\n\t{ 113,\t\t\"get-status\" },\n\t{ 114,\t\t\"sig-restore\" },\n\t{ 115,\t\t\"list-partitions\" },\n\t{ 116,\t\t\"list-volumes\" },\n\t{ 117,\t\t\"set-id-types\" },\n\t{ 118,\t\t\"monitor\" },\n\t{ 119,\t\t\"partition-info\" },\n\t{ 120,\t\t\"reclone\" },\n\t{ 121,\t\t\"list-one-volume\" },\n\t{ 122,\t\t\"nuke\" },\n\t{ 123,\t\t\"set-date\" },\n\t{ 124,\t\t\"x-list-volumes\" },\n\t{ 125,\t\t\"x-list-one-volume\" },\n\t{ 126,\t\t\"set-info\" },\n\t{ 127,\t\t\"x-list-partitions\" },\n\t{ 128,\t\t\"forward-multiple\" },\n\t{ 65536,\t\"convert-ro\" },\n\t{ 65537,\t\"getsize\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const value_string bos_req[] = {\n\t{ 80,\t\t\"create-bnode\" },\n\t{ 81,\t\t\"delete-bnode\" },\n\t{ 82,\t\t\"set-status\" },\n\t{ 83,\t\t\"get-status\" },\n\t{ 84,\t\t\"enumerate-instance\" },\n\t{ 85,\t\t\"get-instance-info\" },\n\t{ 86,\t\t\"get-instance-parm\" },\n\t{ 87,\t\t\"add-superuser\" },\n\t{ 88,\t\t\"delete-superuser\" },\n\t{ 89,\t\t\"list-superusers\" },\n\t{ 90,\t\t\"list-keys\" },\n\t{ 91,\t\t\"add-key\" },\n\t{ 92,\t\t\"delete-key\" },\n\t{ 93,\t\t\"set-cell-name\" },\n\t{ 94,\t\t\"get-cell-name\" },\n\t{ 95,\t\t\"get-cell-host\" },\n\t{ 96,\t\t\"add-cell-host\" },\n\t{ 97,\t\t\"delete-cell-host\" },\n\t{ 98,\t\t\"set-t-status\" },\n\t{ 99,\t\t\"shutdown-all\" },\n\t{ 100,\t\t\"restart-all\" },\n\t{ 101,\t\t\"startup-all\" },\n\t{ 102,\t\t\"set-noauth-flag\" },\n\t{ 103,\t\t\"re-bozo\" },\n\t{ 104,\t\t\"restart\" },\n\t{ 105,\t\t\"install\" },\n\t{ 106,\t\t\"uninstall\" },\n\t{ 107,\t\t\"get-dates\" },\n\t{ 108,\t\t\"exec\" },\n\t{ 109,\t\t\"prune\" },\n\t{ 110,\t\t\"set-restart-time\" },\n\t{ 111,\t\t\"get-restart-time\" },\n\t{ 112,\t\t\"get-log\" },\n\t{ 113,\t\t\"wait-all\" },\n\t{ 114,\t\t\"get-instance-strings\" },\n\t{ 115, \t\t\"get-restricted\" },\n\t{ 116, \t\t\"set restricted\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const value_string update_req[] = {\n\t{ 1,\t\t\"fetch-file\" },\n\t{ 2,\t\t\"fetch-info\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const value_string rmtsys_req[] = {\n\t{ 1,\t\t\"setpag\" },\n\t{ 2,\t\t\"pioctl\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const value_string backup_req[] = {\n\t{ 100,\t\t\"perform-dump\" },\n\t{ 101,\t\t\"perform-restore\" },\n\t{ 102,\t\t\"check-dump\" },\n\t{ 103,\t\t\"abort-dump\" },\n\t{ 104,\t\t\"wait-for-dump\" },\n\t{ 105,\t\t\"end-dump\" },\n\t{ 106,\t\t\"get-tm-info\" },\n\t{ 107,\t\t\"label-tape\" },\n\t{ 108,\t\t\"scan-nodes\" },\n\t{ 109,\t\t\"read-label\" },\n\t{ 110,\t\t\"scan-dumps\" },\n\t{ 111,\t\t\"get-tc-info\" },\n\t{ 112,\t\t\"save-database\" },\n\t{ 113,\t\t\"restore-database\" },\n\t{ 114,\t\t\"get-status\" },\n\t{ 115,\t\t\"request-abort\" },\n\t{ 116,\t\t\"end-status\" },\n\t{ 117,\t\t\"scan-status\" },\n\t{ 118,\t\t\"delete-dump\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const value_string ubik_req[] = {\n\t{ 10000,\t\"vote-beacon\" },\n\t{ 10001,\t\"vote-debug-old\" },\n\t{ 10002,\t\"vote-sdebug-old\" },\n\t{ 10003,\t\"vote-getsyncsite\" },\n\t{ 10004,\t\"vote-debug\" },\n\t{ 10005,\t\"vote-sdebug\" },\n\t{ 10006,\t\"vote-xdebug\" },\n\t{ 10007,\t\"vote-xsdebug\" },\n\t{ 20000,\t\"disk-begin\" },\n\t{ 20001,\t\"disk-commit\" },\n\t{ 20002,\t\"disk-lock\" },\n\t{ 20003,\t\"disk-write\" },\n\t{ 20004,\t\"disk-getversion\" },\n\t{ 20005,\t\"disk-getfile\" },\n\t{ 20006,\t\"disk-sendfile\" },\n\t{ 20007,\t\"disk-abort\" },\n\t{ 20008,\t\"disk-releaselocks\" },\n\t{ 20009,\t\"disk-truncate\" },\n\t{ 20010,\t\"disk-probe\" },\n\t{ 20011,\t\"disk-writev\" },\n\t{ 20012,\t\"disk-interfaceaddr\" },\n\t{ 20013,\t\"disk-setversion\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const value_string cb_types[] = {\n\t{ CB_TYPE_EXCLUSIVE, \"exclusive\" },\n\t{ CB_TYPE_SHARED, \"shared\" },\n\t{ CB_TYPE_DROPPED, \"dropped\" },\n\t{ 0, NULL },\n};\n\nstatic const value_string afs_errors[] = {\n\t/* VOL Errors */\n\t{ 363520, \"ID Exists\"},\n\t{ 363521, \"IO Error\"},\n\t{ 363522, \"Name Exists\"},\n\t{ 363523, \"Create Failed\"},\n\t{ 363524, \"Entry Not Found\"},\n\t{ 363525, \"Empty\"},\n\t{ 363526, \"Entry Deleted\"},\n\t{ 363527, \"Bad Name\"},\n\t{ 363528, \"Bad Index\"},\n\t{ 363529, \"Bad Volume Type\"},\n\t{ 363530, \"Bad Partition\"},\n\t{ 363531, \"Bad Server\"},\n\t{ 363532, \"Bad Replicate Server\"},\n\t{ 363533, \"No Replicate Server\"},\n\t{ 363534, \"Duplicate Replicate Server\"},\n\t{ 363535, \"ReadWrite Volume Not Found\"},\n\t{ 363536, \"Bad Reference Count\"},\n\t{ 363537, \"Size Exceeded\"},\n\t{ 363538, \"Bad Entry\"},\n\t{ 363539, \"Bad Volume ID Bump\"},\n\t{ 363540, \"Already has edit\"},\n\t{ 363541, \"Entry Locked\"},\n\t{ 363542, \"Bad Volume Operation\"},\n\t{ 363543, \"Bad Rel Lock Type\"},\n\t{ 363544, \"Rerelease\"},\n\t{ 363545, \"Bad Server\"},\n\t{ 363546, \"Permission Denied\"},\n\t{ 363547, \"Out of Memory\"},\n\n\t/* KAUTH Errors */\n\t{ 180480, \"Database Inconsistent\"},\n\t{ 180481, \"Exists\"},\n\t{ 180482, \"IO\"},\n\t{ 180483, \"Create Failed\"},\n\t{ 180484, \"noent\"},\n\t{ 180485, \"Empty\"},\n\t{ 180486, \"Bad Name\"},\n\t{ 180487, \"Bad Index\"},\n\t{ 180488, \"No auth\"},\n\t{ 180489, \"Answer too long\"},\n\t{ 180490, \"Bad Request\"},\n\t{ 180491, \"Old Interface\"},\n\t{ 180492, \"Bad Argument\"},\n\t{ 180493, \"Bad Command\"},\n\t{ 180494, \"No keys\"},\n\t{ 180495, \"Read PW\"},\n\t{ 180496, \"Bad key\"},\n\t{ 180497, \"Ubik Init\"},\n\t{ 180498, \"Ubik Call\"},\n\t{ 180499, \"Bad Protocol\"},\n\t{ 180500, \"No cells\"},\n\t{ 180501, \"No cell\"},\n\t{ 180502, \"Too many ubiks\"},\n\t{ 180503, \"Too many keys\"},\n\t{ 180504, \"Bad ticket\"},\n\t{ 180505, \"Unknown Key\"},\n\t{ 180506, \"Key Cache Invalid\"},\n\t{ 180507, \"Bad Server\"},\n\t{ 180508, \"Bad User\"},\n\t{ 180509, \"Bad CPW\"},\n\t{ 180510, \"Bad Create\"},\n\t{ 180511, \"No ticket\"},\n\t{ 180512, \"Assoc user\"},\n\t{ 180513, \"Not special\"},\n\t{ 180514, \"Clock skew too great\"},\n\t{ 180515, \"No recursion\"},\n\t{ 180516, \"RX failed\"},\n\t{ 180517, \"Null password\"},\n\t{ 180518, \"Internal error\"},\n\t{ 180519, \"Password expired\"},\n\t{ 180520, \"Reused\"},\n\t{ 180521, \"Too soon\"},\n\t{ 180522, \"Locked\"},\n\n\t/* PT Errors */\n\t{ 267264, \"Exists\"},\n\t{ 267265, \"ID Exists\"},\n\t{ 267266, \"No IDs\"},\n\t{ 267267, \"DB Failed\"},\n\t{ 267268, \"No such entry\"},\n\t{ 267269, \"Permission denied\"},\n\t{ 267270, \"Not group\"},\n\t{ 267271, \"Not user\"},\n\t{ 267272, \"Bad name\"},\n\t{ 267273, \"Bad argument\"},\n\t{ 267274, \"No more\"},\n\t{ 267275, \"Bad DB\"},\n\t{ 267276, \"Group empty\"},\n\t{ 267277, \"Inconsistent\"},\n\t{ 267278, \"DB Address\"},\n\t{ 267279, \"Too many\"},\n\t{ 267280, \"No memory\"},\n\n\t/* Volume server errors */\n\t{ 1492325120, \"Release error\"},\n\t{ 1492325121, \"No op\"},\n\t{ 1492325122, \"Read dump error\"},\n\t{ 1492325123, \"Dump error\"},\n\t{ 1492325124, \"Attach error\"},\n\t{ 1492325125, \"Illegal partition\"},\n\t{ 1492325126, \"Detach error\"},\n\t{ 1492325127, \"Bad access\"},\n\t{ 1492325128, \"VLDB error\"},\n\t{ 1492325129, \"Bad Name\"},\n\t{ 1492325130, \"Volume moved\"},\n\t{ 1492325131, \"Bad operation\"},\n\t{ 1492325132, \"Bad release\"},\n\t{ 1492325133, \"Volume busy\"},\n\t{ 1492325134, \"No memory\"},\n\t{ 1492325135, \"No volume\"},\n\t{ 1492325136, \"Multiple RW volumes\"},\n\t{ 1492325137, \"Failed operation\"},\n\n\t/* add more of these errors to decode the errcode responses */\n\t{ 0, NULL },\n};\n\nstatic const value_string port_types[] = {\n\t{ AFS_PORT_FS, \"File Server\" },\n\t{ AFS_PORT_CB, \"Callback Server\" },\n\t{ AFS_PORT_BOS, \"BOS Server\" },\n\t{ AFS_PORT_PROT, \"Protection Server\" },\n\t{ AFS_PORT_VLDB, \"Volume Location Database Server\" },\n\t{ AFS_PORT_KAUTH, \"Kerberos Authentication Server\" },\n\t{ AFS_PORT_ERROR, \"Error Server\" },\n\t{ AFS_PORT_VOL, \"Volume Server\" },\n\t{ AFS_PORT_RMTSYS, \"Rmtsys? Server\" },\n\t{ AFS_PORT_UPDATE, \"Update? Server\" },\n\t{ AFS_PORT_BACKUP, \"Backup Server\" },\n\t{ 0, NULL }\n};\n\nstatic const value_string port_types_short[] = {\n\t{ AFS_PORT_FS, \"FS\" },\n\t{ AFS_PORT_CB, \"CB\" },\n\t{ AFS_PORT_BOS, \"BOS\" },\n\t{ AFS_PORT_PROT, \"PROT\" },\n\t{ AFS_PORT_VLDB, \"VLDB\" },\n\t{ AFS_PORT_KAUTH, \"KAUTH\" },\n\t{ AFS_PORT_ERROR, \"ERR\" },\n\t{ AFS_PORT_VOL, \"VOL\" },\n\t{ AFS_PORT_RMTSYS, \"RMT\" },\n\t{ AFS_PORT_UPDATE, \"UPD\" },\n\t{ AFS_PORT_BACKUP, \"BKUP\" },\n\t{ 0, NULL }\n};\n\nstatic const value_string ubik_lock_types[] = {\n\t{ 1,\t\t\"read\" },\n\t{ 2,\t\t\"write\" },\n\t{ 3,\t\t\"wait\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const value_string xstat_collections[] = {\n\t{ 0,\t\t\"call counting & info\" },\n\t{ 1,\t\t\"performance info\" },\n\t{ 2,\t\t\"full performance info\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const value_string vice_lock_types[] = {\n\t{ 0,\t\t\"read\" },\n\t{ 1,\t\t\"write\" },\n\t{ 2,\t\t\"extend\" },\n\t{ 3,\t\t\"release\" },\n\t{ 0,\t\tNULL },\n};\n\nstatic const value_string volume_types[] = {\n\t{ 0,\t\t\"read-write\" },\n\t{ 1,\t\t\"read-only\" },\n\t{ 2,\t\t\"backup\" },\n\t{ 0xffffffff, \"any\" },\n\t{ 0,\t\tNULL },\n};\n\nstruct afs_request_key {\n  guint32 conversation, epoch, cid, callnumber;\n  guint16 service;\n};\n\nstruct afs_request_val {\n  guint32 opcode;\n  guint req_num;\n  guint rep_num;\n  nstime_t req_time;\n};\n\nstatic GHashTable *afs_request_hash = NULL;\n\n\n/*\n * Dissector prototypes\n */\nstatic int dissect_acl(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset);\nstatic void dissect_fs_reply(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_fs_request(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_bos_reply(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_bos_request(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_vol_reply(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_vol_request(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_kauth_reply(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_kauth_request(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_cb_reply(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_cb_request(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_prot_reply(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_prot_request(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_vldb_reply(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_vldb_request(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_ubik_reply(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_ubik_request(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_backup_reply(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\nstatic void dissect_backup_request(tvbuff_t *tvb, struct rxinfo *rxinfo,\n\tproto_tree *tree, int offset, int opcode);\n\n/*\n * Hash Functions\n */\nstatic gint\nafs_equal(gconstpointer v, gconstpointer w)\n{\n  const struct afs_request_key *v1 = (const struct afs_request_key *)v;\n  const struct afs_request_key *v2 = (const struct afs_request_key *)w;\n\n  if (v1 -> conversation == v2 -> conversation &&\n      v1 -> epoch == v2 -> epoch &&\n      v1 -> cid == v2 -> cid &&\n      v1 -> callnumber == v2 -> callnumber ) {\n\n    return 1;\n  }\n\n  return 0;\n}\n\nstatic guint\nafs_hash (gconstpointer v)\n{\n\tconst struct afs_request_key *key = (const struct afs_request_key *)v;\n\tguint val;\n\n\tval = key -> conversation + key -> epoch + key -> cid + key -> callnumber;\n\n\treturn val;\n}\n\n/*\n * Protocol initialization\n */\nstatic void\nafs_init_protocol(void)\n{\n\tif (afs_request_hash)\n\t\tg_hash_table_destroy(afs_request_hash);\n\n\tafs_request_hash = g_hash_table_new(afs_hash, afs_equal);\n}\n\n\n\n/*\n * Dissection routines\n */\n\nstatic void\ndissect_afs(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n\tstruct rxinfo *rxinfo = pinfo->private_data;\n\tint reply = 0;\n\tconversation_t *conversation;\n\tstruct afs_request_key request_key, *new_request_key;\n\tstruct afs_request_val *request_val=NULL;\n\tproto_tree      *afs_tree, *afs_op_tree, *ti;\n\tproto_item\t\t*hidden_item;\n\tint port, node, typenode, opcode;\n\tvalue_string const *vals;\n\tint offset = 0;\n\tnstime_t delta_ts;\n\n\tvoid (*dissector)(tvbuff_t *tvb, struct rxinfo *rxinfo, proto_tree *tree, int offset, int opcode);\n\n\n\tif (check_col(pinfo->cinfo, COL_PROTOCOL)) {\n\t\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"AFS (RX)\");\n\t}\n\tif (check_col(pinfo->cinfo, COL_INFO)) {\n\t\tcol_clear(pinfo->cinfo, COL_INFO);\n\t}\n\n\treply = (rxinfo->flags & RX_CLIENT_INITIATED) == 0;\n\tport = ((reply == 0) ? pinfo->destport : pinfo->srcport );\n\n\t/*\n\t * Find out what conversation this packet is part of.\n\t * XXX - this should really be done by the transport-layer protocol,\n\t * although for connectionless transports, we may not want to do that\n\t * unless we know some higher-level protocol will want it - or we\n\t * may want to do it, so you can say e.g. \"show only the packets in\n\t * this UDP 'connection'\".\n\t *\n\t * Note that we don't have to worry about the direction this packet\n\t * was going - the conversation code handles that for us, treating\n\t * packets from A:X to B:Y as being part of the same conversation as\n\t * packets from B:Y to A:X.\n\t */\n\tconversation = find_conversation(pinfo->fd->num, &pinfo->src, &pinfo->dst, pinfo->ptype,\n\t    pinfo->srcport, pinfo->destport, 0);\n\tif (conversation == NULL) {\n\t\t/* It's not part of any conversation - create a new one. */\n\t\tconversation = conversation_new(pinfo->fd->num, &pinfo->src, &pinfo->dst,\n\t\t\tpinfo->ptype, pinfo->srcport, pinfo->destport, 0);\n\t}\n\n\trequest_key.conversation = conversation->index;\n\trequest_key.service = rxinfo->serviceid;\n\trequest_key.epoch = rxinfo->epoch;\n\trequest_key.cid = rxinfo->cid;\n\trequest_key.callnumber = rxinfo->callnumber;\n\n\trequest_val = (struct afs_request_val *) g_hash_table_lookup(\n\t\tafs_request_hash, &request_key);\n\n\t/* only allocate a new hash element when it's a request */\n\topcode = 0;\n\tif(!pinfo->fd->flags.visited){\n\t\tif ( !request_val && !reply) {\n\t\t\tnew_request_key = se_alloc(sizeof(struct afs_request_key));\n\t\t\t*new_request_key = request_key;\n\n\t\t\trequest_val = se_alloc(sizeof(struct afs_request_val));\n\t\t\trequest_val -> opcode = tvb_get_ntohl(tvb, offset);\n\t\t\trequest_val -> req_num = pinfo->fd->num;\n\t\t\trequest_val -> rep_num = 0;\n\t\t\trequest_val -> req_time = pinfo->fd->abs_ts;\n\n\t\t\tg_hash_table_insert(afs_request_hash, new_request_key,\n\t\t\t\trequest_val);\n\t\t}\n\t\tif( request_val && reply ) {\n\t\t\trequest_val -> rep_num = pinfo->fd->num;\n\t\t}\n\t}\n\n\tif ( request_val ) {\n\t\topcode = request_val->opcode;\n\t}\n\n\n\tnode = 0;\n\ttypenode = 0;\n\tvals = NULL;\n\tdissector = NULL;\n\tswitch (port) {\n\t\tcase AFS_PORT_FS:\n\t\t\ttypenode = hf_afs_fs;\n\t\t\tnode = hf_afs_fs_opcode;\n\t\t\tvals = fs_req;\n\t\t\tdissector = reply ? dissect_fs_reply : dissect_fs_request;\n\t\t\tbreak;\n\t\tcase AFS_PORT_CB:\n\t\t\ttypenode = hf_afs_cb;\n\t\t\tnode = hf_afs_cb_opcode;\n\t\t\tvals = cb_req;\n\t\t\tdissector = reply ? dissect_cb_reply : dissect_cb_request;\n\t\t\tbreak;\n\t\tcase AFS_PORT_PROT:\n\t\t\ttypenode = hf_afs_prot;\n\t\t\tnode = hf_afs_prot_opcode;\n\t\t\tvals = prot_req;\n\t\t\tdissector = reply ? dissect_prot_reply : dissect_prot_request;\n\t\t\tbreak;\n\t\tcase AFS_PORT_VLDB:\n\t\t\ttypenode = hf_afs_vldb;\n\t\t\tnode = hf_afs_vldb_opcode;\n\t\t\tvals = vldb_req;\n\t\t\tdissector = reply ? dissect_vldb_reply : dissect_vldb_request;\n\t\t\tbreak;\n\t\tcase AFS_PORT_KAUTH:\n\t\t\ttypenode = hf_afs_kauth;\n\t\t\tnode = hf_afs_kauth_opcode;\n\t\t\tvals = kauth_req;\n\t\t\tdissector = reply ? dissect_kauth_reply : dissect_kauth_request;\n\t\t\tbreak;\n\t\tcase AFS_PORT_VOL:\n\t\t\ttypenode = hf_afs_vol;\n\t\t\tnode = hf_afs_vol_opcode;\n\t\t\tvals = vol_req;\n\t\t\tdissector = reply ? dissect_vol_reply : dissect_vol_request;\n\t\t\tbreak;\n\t\tcase AFS_PORT_ERROR:\n\t\t\ttypenode = hf_afs_error;\n\t\t\tnode = hf_afs_error_opcode;\n\t\t\t/* dissector = reply ? dissect_error_reply : dissect_error_request; */\n\t\t\tbreak;\n\t\tcase AFS_PORT_BOS:\n\t\t\ttypenode = hf_afs_bos;\n\t\t\tnode = hf_afs_bos_opcode;\n\t\t\tvals = bos_req;\n\t\t\tdissector = reply ? dissect_bos_reply : dissect_bos_request;\n\t\t\tbreak;\n\t\tcase AFS_PORT_UPDATE:\n\t\t\ttypenode = hf_afs_update;\n\t\t\tnode = hf_afs_update_opcode;\n\t\t\tvals = update_req;\n\t\t\t/* dissector = reply ? dissect_update_reply : dissect_update_request; */\n\t\t\tbreak;\n\t\tcase AFS_PORT_RMTSYS:\n\t\t\ttypenode = hf_afs_rmtsys;\n\t\t\tnode = hf_afs_rmtsys_opcode;\n\t\t\tvals = rmtsys_req;\n\t\t\t/* dissector = reply ? dissect_rmtsys_reply : dissect_rmtsys_request; */\n\t\t\tbreak;\n\t\tcase AFS_PORT_BACKUP:\n\t\t\ttypenode = hf_afs_backup;\n\t\t\tnode = hf_afs_backup_opcode;\n\t\t\tvals = backup_req;\n\t\t\tdissector = reply ? dissect_backup_reply : dissect_backup_request;\n\t\t\tbreak;\n\t}\n\n\tif ( (opcode >= VOTE_LOW && opcode <= VOTE_HIGH) ||\n\t\t(opcode >= DISK_LOW && opcode <= DISK_HIGH) ) {\n\t\ttypenode = hf_afs_ubik;\n\t\tnode = hf_afs_ubik_opcode;\n\t\tvals = ubik_req;\n\t\tdissector = reply ? dissect_ubik_reply : dissect_ubik_request;\n\t}\n\n\n\tif ( VALID_OPCODE(opcode) ) {\n\t\tif ( vals ) {\n\t\t\tif (check_col(pinfo->cinfo, COL_INFO))\n\t\t\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"%s%s %s: %s (%d)\",\n\t\t\t\ttypenode == hf_afs_ubik ? \"UBIK-\" : \"\",\n\t\t\t\tval_to_str(port, port_types_short, \"Unknown(%d)\"),\n\t\t\t\treply ? \"Reply\" : \"Request\",\n\t\t\t\tval_to_str(opcode, vals, \"Unknown(%d)\"), opcode);\n\t\t} else {\n\t\t\tif (check_col(pinfo->cinfo, COL_INFO))\n\t\t\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"%s%s %s: Unknown(%d)\",\n\t\t\t\ttypenode == hf_afs_ubik ? \"UBIK-\" : \"\",\n\t\t\t\tval_to_str(port, port_types_short, \"Unknown(%d)\"),\n\t\t\t\treply ? \"Reply\" : \"Request\",\n\t\t\t\topcode);\n\t\t}\n\t} else {\n\t\tif (check_col(pinfo->cinfo, COL_INFO))\n\t\t\tcol_add_fstr(pinfo->cinfo, COL_INFO, \"Encrypted %s %s\",\n\t\t\tval_to_str(port, port_types_short, \"Unknown(%d)\"),\n\t\t\treply ? \"Reply\" : \"Request\"\n\t\t\t);\n\t}\n\n\tif (tree) {\n\t\tti = proto_tree_add_item(tree, proto_afs, tvb, offset, -1,\n\t\t\t\tFALSE);\n\t\tafs_tree = proto_item_add_subtree(ti, ett_afs);\n\n\t\tproto_tree_add_text(afs_tree, tvb, 0, 0,\n\t\t\t\"Service: %s%s%s %s\",\n\t\t\tVALID_OPCODE(opcode) ? \"\" : \"Encrypted \",\n\t\t\ttypenode == hf_afs_ubik ? \"UBIK - \" : \"\",\n\t\t\tval_to_str(port, port_types, \"Unknown(%d)\"),\n\t\t\treply ? \"Reply\" : \"Request\");\n\n\t\tif( request_val && !reply && request_val->rep_num) {\n\t\t\tproto_tree_add_uint_format(afs_tree, hf_afs_repframe,\n\t\t\t    tvb, 0, 0, request_val->rep_num,\n\t\t\t    \"The reply to this request is in frame %u\",\n\t\t\t    request_val->rep_num);\n\t\t}\n\t\tif( request_val && reply && request_val->rep_num) {\n\t\t\tproto_tree_add_uint_format(afs_tree, hf_afs_reqframe,\n\t\t\t    tvb, 0, 0, request_val->req_num,\n\t\t\t    \"This is a reply to a request in frame %u\",\n\t\t\t    request_val->req_num);\n\t\t\tnstime_delta(&delta_ts, &pinfo->fd->abs_ts, &request_val->req_time);\n\t\t\tproto_tree_add_time(afs_tree, hf_afs_time, tvb, offset, 0,\n\t\t\t\t&delta_ts);\n\t\t}\n\n\n\t\tif ( VALID_OPCODE(opcode) ) {\n\t\t\t/* until we do cache, can't handle replies */\n\t\t\tti = NULL;\n\t\t\tif ( !reply && node != 0 ) {\n\t\t\t\tif ( rxinfo->seq == 1 )\n\t\t\t\t{\n\t\t\t\t\tti = proto_tree_add_uint(afs_tree,\n\t\t\t\t\t\tnode, tvb, offset, 4, opcode);\n\t\t\t\t} else {\n\t\t\t\t\tti = proto_tree_add_uint(afs_tree,\n\t\t\t\t\t\tnode, tvb, 0, 0, opcode);\n\t\t\t\t}\n\t\t\t} else if ( reply && node != 0 ) {\n\t\t\t\t/* the opcode isn't in this packet */\n\t\t\t\tti = proto_tree_add_uint(afs_tree,\n\t\t\t\t\tnode, tvb, 0, 0, opcode);\n\t\t\t} else {\n\t\t\t\tti = proto_tree_add_text(afs_tree, tvb,\n\t\t\t\t\t0, 0, \"Operation: Unknown\");\n\t\t\t}\n\n\t\t\t/* Add the subtree for this particular service */\n\t\t\tafs_op_tree = proto_item_add_subtree(ti, ett_afs_op);\n\n\n\t\t\tif ( typenode != 0 ) {\n\t\t\t\t/* indicate the type of request */\n\t\t\t\thidden_item = proto_tree_add_boolean(afs_tree, typenode, tvb, offset, 0, 1);\n\t\t\t\tPROTO_ITEM_SET_HIDDEN(hidden_item);\n\t\t\t}\n\n\t\t\t/* Process the packet according to what service it is */\n\t\t\tif ( dissector ) {\n\t\t\t\t(*dissector)(tvb, rxinfo, afs_op_tree, offset, opcode);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* if it's the last packet, and it's a reply, remove opcode\n\t\tfrom hash */\n\t/* ignoring for now, I'm not sure how the chunk deallocation works */\n\tif ( rxinfo->flags & RX_LAST_PACKET && reply ){\n\n\t}\n}\n\n\n/*\n * Here is a helper routine for adding an AFS acl to the proto tree\n * This is to be used with FS packets only\n *\n * An AFS ACL is a string that has the following format:\n *\n * <positive> <negative>\n * <uid1> <aclbits1>\n * ....\n *\n * \"positive\" and \"negative\" are integers which contain the number of\n * positive and negative ACL's in the string.  The uid/aclbits pair are\n * ASCII strings containing the UID/PTS record and and a ascii number\n * representing a logical OR of all the ACL permission bits\n */\n/*\n * XXX - FIXME:\n *\n *\tsscanf is probably quite dangerous if we run outside the packet.\n *\n *\t\"GETSTR\" doesn't guarantee that the resulting string is\n *\tnull-terminated.\n *\n * Should this just scan the string itself, rather than using \"sscanf()\"?\n */\nstatic int\ndissect_acl(tvbuff_t *tvb, struct rxinfo *rxinfo _U_, proto_tree *tree, int offset)\n{\n\tint old_offset;\n\tgint32 bytes;\n\tint i, n, pos, neg, acl;\n\tchar user[128]; /* Be sure to adjust sscanf()s below if length is changed... */\n\n\told_offset = offset;\n\tbytes = tvb_get_ntohl(tvb, offset);\n\tOUT_UINT(hf_afs_fs_acl_datasize);\n\n\n\tif (sscanf(GETSTR, \"%d %n\", &pos, &n) != 1) {\n\t\t/* does not matter what we return, if this fails,\n\t\t * we cant dissect anything else in the packet either.\n\t\t */\n\t\treturn offset;\n\t}\n\tproto_tree_add_uint(tree, hf_afs_fs_acl_count_positive, tvb,\n\t\toffset, n, pos);\n\toffset += n;\n\n\n\tif (sscanf(GETSTR, \"%d %n\", &neg, &n) != 1) {\n\t\treturn offset;\n\t}\n\tproto_tree_add_uint(tree, hf_afs_fs_acl_count_negative, tvb,\n\t\toffset, n, neg);\n\toffset += n;\n\n\t/*\n\t * This wacky order preserves the order used by the \"fs\" command\n\t */\n\tfor (i = 0; i < pos; i++) {\n\t\tif (sscanf(GETSTR, \"%127s %d %n\", user, &acl, &n) != 2) {\n\t\t\treturn offset;\n\t\t}\n\t\tACLOUT(user,1,acl,n);\n\t\toffset += n;\n\t}\n\tfor (i = 0; i < neg; i++) {\n\t\tif (sscanf(GETSTR, \"%127s %d %n\", user, &acl, &n) != 2) {\n\t\t\treturn offset;\n\t\t}\n\t\tACLOUT(user,0,acl,n);\n\t\toffset += n;\n\t\tif (offset >= old_offset+bytes ) {\n\t\t\treturn offset;\n\t\t}\n\t}\n\n\treturn offset;\n}\n\n/*\n * Here are the helper dissection routines\n */\n\nstatic void\ndissect_fs_reply(tvbuff_t *tvb, struct rxinfo *rxinfo, proto_tree *tree, int offset, int opcode)\n{\n\tif ( rxinfo->type == RX_PACKET_TYPE_DATA )\n\t{\n\t\tswitch ( opcode )\n\t\t{\n\t\t\tcase 130: /* fetch data */\n\t\t\t\t/* only on first packet */\n\t\t\t\tif ( rxinfo->seq == 1 )\n\t\t\t\t{\n\t\t\t\t\tOUT_FS_AFSFetchStatus(\"Status\");\n\t\t\t\t\tOUT_FS_AFSCallBack();\n\t\t\t\t\tOUT_FS_AFSVolSync();\n\t\t\t\t}\n\t\t\t\tOUT_BYTES_ALL(hf_afs_fs_data);\n\t\t\t\tbreak;\n\t\t\tcase 131: /* fetch acl */\n\t\t\t\toffset = dissect_acl(tvb, rxinfo, tree, offset);\n\t\t\t\tOUT_FS_AFSFetchStatus(\"Status\");\n\t\t\t\tOUT_FS_AFSVolSync();\n\t\t\t\tbreak;\n\t\t\tcase 132: /* Fetch status */\n\t\t\t\tOUT_FS_AFSFetchStatus(\"Status\");\n\t\t\t\tOUT_FS_AFSCallBack();\n\t\t\t\tOUT_FS_AFSVolSync();\n\t\t\t\tbreak;\n\t\t\tcase 133: /* Store data */\n\t\t\tcase 134: /* Store ACL */\n\t \t\tcase 135: /* Store status */\n\t\t\tcase 136: /* Remove file */\n\t\t\t\tOUT_FS_AFSFetchStatus(\"Status\");\n\t\t\t\tOUT_FS_AFSVolSync();\n\t\t\t\tbreak;\n\t\t\tcase 137: /* create file */\n\t\t\tcase 141: /* make dir */\n\t\t\tcase 161: /* lookup */\n\t\t\tcase 163: /* dfs symlink */\n\t\t\t\tOUT_FS_AFSFid((opcode == 137)? \"New File\" : ((opcode == 141)? \"New Directory\" : \"File\"));\n\t\t\t\tOUT_FS_AFSFetchStatus(\"File Status\");\n\t\t\t\tOUT_FS_AFSFetchStatus(\"Directory Status\");\n\t\t\t\tOUT_FS_AFSCallBack();\n\t\t\t\tOUT_FS_AFSVolSync();\n\t\t\t\tbreak;\n\t\t\tcase 138: /* rename */\n\t\t\t\tOUT_FS_AFSFetchStatus(\"Old Directory Status\");\n\t\t\t\tOUT_FS_AFSFetchStatus(\"New Directory Status\");\n\t\t\t\tOUT_FS_AFSVolSync();\n\t\t\t\tbreak;\n\t\t\tcase 139: /* symlink */\n\t\t\t\tOUT_FS_AFSFid(\"Symlink\");\n\t\t\tcase 140: /* link */\n\t\t\t\tOUT_FS_AFSFetchStatus(\"Symlink Status\");\n\t\t\tcase 142: /* rmdir */\n\t\t\t\tOUT_FS_AFSFetchStatus(\"Directory Status\");\n\t\t\t\tOUT_FS_AFSVolSync();\n\t\t\t\tbreak;\n\t\t\tcase 143: /* old set lock */\n\t\t\tcase 144: /* old extend lock */\n\t\t\tcase 145: /* old release lock */\n\t\t\tcase 147: /* give up callbacks */\n\t\t\tcase 150: /* set volume status */\n\t\t\tcase 152: /* check token */\n\t\t\t\t/* nothing returned */\n\t\t\t\tbreak;\n\t\t\tcase 146: /* get statistics */\n\t\t\t\tOUT_FS_ViceStatistics();\n\t\t\t\tbreak;\n\t\t\tcase 148: /* get volume info */\n\t\t\tcase 154: /* n-get-volume-info */\n\t\t\t\tOUT_FS_VolumeInfo();\n\t\t\t\tbreak;\n\t\t\tcase 149: /* get volume status */\n\t\t\t\tOUT_FS_AFSFetchVolumeStatus();\n\t\t\t\tOUT_RXString(hf_afs_fs_volname);\n\t\t\t\tOUT_RXString(hf_afs_fs_offlinemsg);\n\t\t\t\tOUT_RXString(hf_afs_fs_motd);\n\t\t\t\tbreak;\n\t\t\tcase 151: /* root volume */\n\t\t\t\tOUT_RXString(hf_afs_fs_volname);\n\t\t\t\tbreak;\n\t\t\tcase 153: /* get time */\n\t\t\t\tOUT_TIMESTAMP(hf_afs_fs_timestamp);\n\t\t\t\tbreak;\n\t\t\tcase 155: /* bulk status */\n\t\t\t\tOUT_FS_AFSBulkStats();\n\t\t\t\tSKIP(4);\n\t\t\t\tOUT_FS_AFSCBs();\n\t\t\t\tOUT_FS_AFSVolSync();\n\t\t\t\tbreak;\n\t\t\tcase 156: /* set lock */\n\t\t\tcase 157: /* extend lock */\n\t\t\tcase 158: /* release lock */\n\t\t\t\tOUT_FS_AFSVolSync();\n\t\t\t\tbreak;\n\t\t\tcase 159: /* x-stats-version */\n\t\t\t\tOUT_UINT(hf_afs_fs_xstats_version);\n\t\t\t\tbreak;\n\t\t\tcase 160: /* get xstats */\n\t\t\t\tOUT_UINT(hf_afs_fs_xstats_version);\n\t\t\t\tOUT_TIMESECS(hf_afs_fs_xstats_timestamp);\n\t\t\t\tOUT_FS_AFS_CollData();\n\t\t\t\tbreak;\n\t\t\tcase 162: /* flush cps */\n\t\t\t\tOUT_UINT(hf_afs_fs_cps_spare2);\n\t\t\t\tOUT_UINT(hf_afs_fs_cps_spare3);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if ( rxinfo->type == RX_PACKET_TYPE_ABORT )\n\t{\n\t\tOUT_UINT(hf_afs_fs_errcode);\n\t}\n}\n\nstatic void\ndissect_fs_request(tvbuff_t *tvb, struct rxinfo *rxinfo, proto_tree *tree, int offset, int opcode)\n{\n\t/* skip the opcode if this is the first packet in the stream */\n\tif ( rxinfo->seq == 1 )\n\t{\n\t\toffset += 4;  /* skip the opcode */\n\t}\n\n\tswitch ( opcode )\n\t{\n\t\tcase 130: /* Fetch data */\n\t\t\tOUT_FS_AFSFid(\"Source\");\n\t\t\tOUT_UINT(hf_afs_fs_offset);\n\t\t\tOUT_UINT(hf_afs_fs_length);\n\t\t\tbreak;\n\t\tcase 131: /* Fetch ACL */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\tbreak;\n\t\tcase 132: /* Fetch Status */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\tbreak;\n\t\tcase 133: /* Store Data */\n\t\t\tif ( rxinfo->seq == 1 )\n\t\t\t{\n\t\t\t\tOUT_FS_AFSFid(\"Destination\");\n\t\t\t\tOUT_FS_AFSStoreStatus(\"Status\");\n\t\t\t\tOUT_UINT(hf_afs_fs_offset);\n\t\t\t\tOUT_UINT(hf_afs_fs_length);\n\t\t\t\tOUT_UINT(hf_afs_fs_flength);\n\t\t\t}\n\t\t\tOUT_BYTES_ALL(hf_afs_fs_data);\n\t\t\tbreak;\n\t\tcase 134: /* Store ACL */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\toffset = dissect_acl(tvb, rxinfo, tree, offset);\n\t\t\tbreak;\n\t\tcase 135: /* Store Status */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\tOUT_FS_AFSStoreStatus(\"Status\");\n\t\t\tbreak;\n\t\tcase 136: /* Remove File */\n\t\t\tOUT_FS_AFSFid(\"Remove File\");\n\t\t\tOUT_RXString(hf_afs_fs_name);\n\t\t\tbreak;\n\t\tcase 137: /* Create File */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\tOUT_RXString(hf_afs_fs_name);\n\t\t\tOUT_FS_AFSStoreStatus(\"Status\");\n\t\t\tbreak;\n\t\tcase 138: /* Rename file */\n\t\t\tOUT_FS_AFSFid(\"Old\");\n\t\t\tOUT_RXString(hf_afs_fs_oldname);\n\t\t\tOUT_FS_AFSFid(\"New\");\n\t\t\tOUT_RXString(hf_afs_fs_newname);\n\t\t\tbreak;\n\t\tcase 139: /* Symlink */\n\t\t\tOUT_FS_AFSFid(\"File\");\n\t\t\tOUT_RXString(hf_afs_fs_symlink_name);\n\t\t\tOUT_RXString(hf_afs_fs_symlink_content);\n\t\t\tOUT_FS_AFSStoreStatus(\"Status\");\n\t\t\tbreak;\n\t\tcase 140: /* Link */\n\t\t\tOUT_FS_AFSFid(\"Link To (New File)\");\n\t\t\tOUT_RXString(hf_afs_fs_name);\n\t\t\tOUT_FS_AFSFid(\"Link From (Old File)\");\n\t\t\tbreak;\n\t\tcase 141: /* Make dir */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\tOUT_RXString(hf_afs_fs_name);\n\t\t\tOUT_FS_AFSStoreStatus(\"Status\");\n\t\t\tbreak;\n\t\tcase 142: /* Remove dir */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\tOUT_RXString(hf_afs_fs_name);\n\t\t\tbreak;\n\t\tcase 143: /* Old Set Lock */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\tOUT_UINT(hf_afs_fs_vicelocktype);\n\t\t\tOUT_FS_AFSVolSync();\n\t\t\tbreak;\n\t\tcase 144: /* Old Extend Lock */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\tOUT_FS_AFSVolSync();\n\t\t\tbreak;\n\t\tcase 145: /* Old Release Lock */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\tOUT_FS_AFSVolSync();\n\t\t\tbreak;\n\t\tcase 146: /* Get statistics */\n\t\t\t/* no params */\n\t\t\tbreak;\n\t\tcase 147: /* Give up callbacks */\n\t\t\tOUT_FS_AFSCBFids();\n\t\t\tOUT_FS_AFSCBs();\n\t\t\tbreak;\n\t\tcase 148: /* Get vol info */\n\t\t\tOUT_RXString(hf_afs_fs_volname);\n\t\t\tbreak;\n\t\tcase 149: /* Get vol stats */\n\t\t\tOUT_UINT(hf_afs_fs_volid);\n\t\t\tbreak;\n\t\tcase 150: /* Set vol stats */\n\t\t\tOUT_UINT(hf_afs_fs_volid);\n\t\t\tOUT_FS_AFSStoreVolumeStatus();\n\t\t\tOUT_RXString(hf_afs_fs_volname);\n\t\t\tOUT_RXString(hf_afs_fs_offlinemsg);\n\t\t\tOUT_RXString(hf_afs_fs_motd);\n\t\t\tbreak;\n\t\tcase 151: /* get root volume */\n\t\t\t/* no params */\n\t\t\tbreak;\n\t\tcase 152: /* check token */\n\t\t\tOUT_UINT(hf_afs_fs_viceid);\n\t\t\tOUT_FS_AFSTOKEN();\n\t\t\tbreak;\n\t\tcase 153: /* get time */\n\t\t\t/* no params */\n\t\t\tbreak;\n\t\tcase 154: /* new get vol info */\n\t\t\tOUT_RXString(hf_afs_fs_volname);\n\t\t\tbreak;\n\t\tcase 155: /* bulk stat */\n\t\t\tOUT_FS_AFSCBFids();\n\t\t\tbreak;\n\t\tcase 156: /* Set Lock */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\tOUT_UINT(hf_afs_fs_vicelocktype);\n\t\t\tbreak;\n\t\tcase 157: /* Extend Lock */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\tbreak;\n\t\tcase 158: /* Release Lock */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\tbreak;\n\t\tcase 159: /* xstats version */\n\t\t\t/* no params */\n\t\t\tbreak;\n\t\tcase 160: /* get xstats */\n\t\t\tOUT_UINT(hf_afs_fs_xstats_clientversion);\n\t\t\tOUT_UINT(hf_afs_fs_xstats_collnumber);\n\t\t\tbreak;\n\t\tcase 161: /* lookup */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\tOUT_RXString(hf_afs_fs_name);\n\t\t\tbreak;\n\t\tcase 162: /* flush cps */\n\t\t\tOUT_FS_ViceIds();\n\t\t\tOUT_FS_IPAddrs();\n\t\t\tOUT_UINT(hf_afs_fs_cps_spare1);\n\t\t\tbreak;\n\t\tcase 163: /* dfs symlink */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\tOUT_RXString(hf_afs_fs_symlink_name);\n\t\t\tOUT_RXString(hf_afs_fs_symlink_content);\n\t\t\tOUT_FS_AFSStoreStatus(\"Symlink Status\");\n\t\t\tbreak;\n\t\tcase 220: /* residencycmd */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\t/* need residency inputs here */\n\t\t\tbreak;\n\t\tcase 65536: /* inline bulk status */\n\t\t\tOUT_FS_AFSCBFids();\n\t\t\tbreak;\n\t\tcase 65537: /* fetch-data-64 */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\tOUT_INT64(hf_afs_fs_offset64);\n\t\t\tOUT_INT64(hf_afs_fs_length64);\n\t\t\t/* need more here */\n\t\t\tbreak;\n\t\tcase 65538: /* store-data-64 */\n\t\t\tOUT_FS_AFSFid(\"Target\");\n\t\t\tOUT_FS_AFSStoreStatus(\"Status\");\n\t\t\tOUT_INT64(hf_afs_fs_offset64);\n\t\t\tOUT_INT64(hf_afs_fs_length64);\n\t\t\tOUT_INT64(hf_afs_fs_flength64);\n\t\t\t/* need residency inputs here */\n\t\t\tbreak;\n\t\tcase 65539: /* give up all cbs */\n\t\t\tbreak;\n\t\tcase 65540: /* get capabilities */\n\t\t\tbreak;\n\t}\n}\n\n/*\n * BOS Helpers\n */\nstatic void\ndissect_bos_reply(tvbuff_t *tvb, struct rxinfo *rxinfo, proto_tree *tree, int offset, int opcode)\n{\n\tif ( rxinfo->type == RX_PACKET_TYPE_DATA )\n\t{\n\t\tswitch ( opcode )\n\t\t{\n\t\t\tcase 80: /* create bnode */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 81: /* delete bnode */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 82: /* set status */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 83: /* get status */\n\t\t\t\tOUT_INT(hf_afs_bos_status);\n\t\t\t\tOUT_RXString(hf_afs_bos_statusdesc);\n\t\t\t\tbreak;\n\t\t\tcase 84: /* enumerate instance */\n\t\t\t\tOUT_RXString(hf_afs_bos_instance);\n\t\t\t\tbreak;\n\t\t\tcase 85: /* get instance info */\n\t\t\t\tOUT_RXString(hf_afs_bos_type);\n\t\t\t\tOUT_BOS_STATUS();\n\t\t\t\tbreak;\n\t\t\tcase 86: /* get instance parm */\n\t\t\t\tOUT_RXString(hf_afs_bos_parm);\n\t\t\t\tbreak;\n\t\t\tcase 87: /* add siperuser */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 88: /* delete superuser */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 89: /* list superusers */\n\t\t\t\tOUT_RXString(hf_afs_bos_user);\n\t\t\t\tbreak;\n\t\t\tcase 90: /* list keys */\n\t\t\t\tOUT_UINT(hf_afs_bos_kvno);\n\t\t\t\tOUT_BOS_KEY();\n\t\t\t\tOUT_BOS_KEYINFO();\n\t\t\t\tbreak;\n\t\t\tcase 91: /* add key */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 92: /* delete key */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 93: /* set cell name */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 94: /* get cell name */\n\t\t\t\tOUT_RXString(hf_afs_bos_cell);\n\t\t\t\tbreak;\n\t\t\tcase 95: /* get cell host */\n\t\t\t\tOUT_RXString(hf_afs_bos_host);\n\t\t\t\tbreak;\n\t\t\tcase 96: /* add cell host */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 97: /* delete cell host */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 98: /* set tstatus */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 99: /* shutdown all */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 100: /* restart all */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 101: /* startup all */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 102: /* set noauth flag */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 103: /* rebozo */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 104: /* restart */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 105: /* install */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 106: /* uninstall */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 107: /* get dates */\n\t\t\t\tOUT_TIMESECS(hf_afs_bos_newtime);\n\t\t\t\tOUT_TIMESECS(hf_afs_bos_baktime);\n\t\t\t\tOUT_TIMESECS(hf_afs_bos_oldtime);\n\t\t\t\tbreak;\n\t\t\tcase 108: /* exec */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 109: /* prune */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 110: /* set restart time */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 111: /* get restart time */\n\t\t\t\tOUT_BOS_TIME();\n\t\t\t\tbreak;\n\t\t\tcase 112: /* get log */\n\t\t\t\t/* need to make this dump a big string somehow */\n\t\t\t\tOUT_BYTES_ALL(hf_afs_bos_data);\n\t\t\t\tbreak;\n\t\t\tcase 113: /* wait all */\n\t\t\t\t/* no output */\n\t\t\t\tbreak;\n\t\t\tcase 114: /* get instance strings */\n\t\t\t\tOUT_RXString(hf_afs_bos_error);\n\t\t\t\tOUT_RXString(hf_afs_bos_spare1);\n\t\t\t\tOUT_RXString(hf_afs_bos_spare2);\n\t\t\t\tOUT_RXString(hf_afs_bos_spare3);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if ( rxinfo->type == RX_PACKET_TYPE_ABORT )\n\t{\n\t\tOUT_UINT(hf_afs_bos_errcode);\n\t}\n}\n\nstatic void\ndissect_bos_request(tvbuff_t *tvb, struct rxinfo *rxinfo _U_, proto_tree *tree, int offset, int opcode)\n{\n\toffset += 4;  /* skip the opcode */\n\n\tswitch ( opcode )\n\t{\n\t\tcase 80: /* create b node */\n\t\t\tOUT_RXString(hf_afs_bos_type);\n\t\t\tOUT_RXString(hf_afs_bos_instance);\n\t\t\tOUT_RXString(hf_afs_bos_parm);\n\t\t\tOUT_RXString(hf_afs_bos_parm);\n\t\t\tOUT_RXString(hf_afs_bos_parm);\n\t\t\tOUT_RXString(hf_afs_bos_parm);\n\t\t\tOUT_RXString(hf_afs_bos_parm);\n\t\t\tOUT_RXString(hf_afs_bos_parm);\n\t\t\tbreak;\n\t\tcase 81: /* delete b node */\n\t\t\tOUT_RXString(hf_afs_bos_instance);\n\t\t\tbreak;\n\t\tcase 82: /* set status */\n\t\t\tOUT_RXString(hf_afs_bos_instance);\n\t\t\tOUT_INT(hf_afs_bos_status);\n\t\t\tbreak;\n\t\tcase 83: /* get status */\n\t\t\tOUT_RXString(hf_afs_bos_instance);\n\t\t\tbreak;\n\t\tcase 84: /* enumerate instance */\n\t\t\tOUT_UINT(hf_afs_bos_num);\n\t\t\tbreak;\n\t\tcase 85: /* get instance info */\n\t\t\tOUT_RXString(hf_afs_bos_instance);\n\t\t\tbreak;\n\t\tcase 86: /* get instance parm */\n\t\t\tOUT_RXString(hf_afs_bos_instance);\n\t\t\tOUT_UINT(hf_afs_bos_num);\n\t\t\tbreak;\n\t\tcase 87: /* add super user */\n\t\t\tOUT_RXString(hf_afs_bos_user);\n\t\t\tbreak;\n\t\tcase 88: /* delete super user */\n\t\t\tOUT_RXString(hf_afs_bos_user);\n\t\t\tbreak;\n\t\tcase 89: /* list super users */\n\t\t\tOUT_UINT(hf_afs_bos_num);\n\t\t\tbreak;\n\t\tcase 90: /* list keys */\n\t\t\tOUT_UINT(hf_afs_bos_num);\n\t\t\tbreak;\n\t\tcase 91: /* add key */\n\t\t\tOUT_UINT(hf_afs_bos_num);\n\t\t\tOUT_BOS_KEY();\n\t\t\tbreak;\n\t\tcase 92: /* delete key */\n\t\t\tOUT_UINT(hf_afs_bos_num);\n\t\t\tbreak;\n\t\tcase 93: /* set cell name */\n\t\t\tOUT_RXString(hf_afs_bos_content);\n\t\t\tbreak;\n\t\tcase 95: /* set cell host */\n\t\t\tOUT_UINT(hf_afs_bos_num);\n\t\t\tbreak;\n\t\tcase 96: /* add cell host */\n\t\t\tOUT_RXString(hf_afs_bos_content);\n\t\t\tbreak;\n\t\tcase 97: /* delete cell host */\n\t\t\tOUT_RXString(hf_afs_bos_content);\n\t\t\tbreak;\n\t\tcase 98: /* set t status */\n\t\t\tOUT_RXString(hf_afs_bos_content);\n\t\t\tOUT_INT(hf_afs_bos_status);\n\t\t\tbreak;\n\t\tcase 99: /* shutdown all */\n\t\t\t/* no params */\n\t\t\tbreak;\n\t\tcase 100: /* restart all */\n\t\t\t/* no params */\n\t\t\tbreak;\n\t\tcase 101: /* startup all */\n\t\t\t/* no params */\n\t\t\tbreak;\n\t\tcase 102: /* set no-auth flag */\n\t\t\tOUT_UINT(hf_afs_bos_flags);\n\t\t\tbreak;\n\t\tcase 103: /* re-bozo? */\n\t\t\t/* no params */\n\t\t\tbreak;\n\t\tcase 104: /* restart */\n\t\t\tOUT_RXString(hf_afs_bos_instance);\n\t\t\tbreak;\n\t\tcase 105: /* install */\n\t\t\tOUT_RXString(hf_afs_bos_path);\n\t\t\tOUT_UINT(hf_afs_bos_size);\n\t\t\tOUT_UINT(hf_afs_bos_flags);\n\t\t\tOUT_UINT(hf_afs_bos_date);\n\t\t\tbreak;\n\t\tcase 106: /* uninstall */\n\t\t\tOUT_RXString(hf_afs_bos_path);\n\t\t\tbreak;\n\t\tcase 107: /* get dates */\n\t\t\tOUT_RXString(hf_afs_bos_path);\n\t\t\tbreak;\n\t\tcase 108: /* exec */\n\t\t\tOUT_RXString(hf_afs_bos_cmd);\n\t\t\tbreak;\n\t\tcase 109: /* prune */\n\t\t\tOUT_UINT(hf_afs_bos_flags);\n\t\t\tbreak;\n\t\tcase 110: /* set restart time */\n\t\t\tOUT_UINT(hf_afs_bos_num);\n\t\t\tOUT_BOS_TIME();\n\t\t\tbreak;\n\t\tcase 111: /* get restart time */\n\t\t\tOUT_UINT(hf_afs_bos_num);\n\t\t\tbreak;\n\t\tcase 112: /* get log */\n\t\t\tOUT_RXString(hf_afs_bos_file);\n\t\t\tbreak;\n\t\tcase 113: /* wait all */\n\t\t\t/* no params */\n\t\t\tbreak;\n\t\tcase 114: /* get instance strings */\n\t\t\tOUT_RXString(hf_afs_bos_content);\n\t\t\tbreak;\n\t}\n}\n\n/*\n * VOL Helpers\n */\nstatic void\ndissect_vol_reply(tvbuff_t *tvb, struct rxinfo *rxinfo, proto_tree *tree, int offset, int opcode)\n{\n\tif ( rxinfo->type == RX_PACKET_TYPE_DATA )\n\t{\n\t\tswitch ( opcode )\n\t\t{\n\t\t\tcase 121:\n\t\t\t\t/* should loop here maybe */\n\t\t\t\tOUT_UINT(hf_afs_vol_count);\n\t\t\t\tOUT_RXStringV(hf_afs_vol_name, 32); /* not sure on  */\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if ( rxinfo->type == RX_PACKET_TYPE_ABORT )\n\t{\n\t\tOUT_UINT(hf_afs_vol_errcode);\n\t}\n}\n\nstatic void\ndissect_vol_request(tvbuff_t *tvb, struct rxinfo *rxinfo _U_, proto_tree *tree, int offset, int opcode)\n{\n\toffset += 4;  /* skip the opcode */\n\n\tswitch ( opcode )\n\t{\n\t\tcase 121: /* list one vol */\n\t\t\tOUT_UINT(hf_afs_vol_count);\n\t\t\tOUT_UINT(hf_afs_vol_id);\n\t\t\tbreak;\n\t}\n}\n\n/*\n * KAUTH Helpers\n */\nstatic void\ndissect_kauth_reply(tvbuff_t *tvb, struct rxinfo *rxinfo, proto_tree *tree, int offset, int opcode)\n{\n\tif ( rxinfo->type == RX_PACKET_TYPE_DATA )\n\t{\n\t\tswitch ( opcode )\n\t\t{\n\t\t}\n\t}\n\telse if ( rxinfo->type == RX_PACKET_TYPE_ABORT )\n\t{\n\t\tOUT_UINT(hf_afs_kauth_errcode);\n\t}\n}\n\nstatic void\ndissect_kauth_request(tvbuff_t *tvb, struct rxinfo *rxinfo _U_, proto_tree *tree, int offset, int opcode)\n{\n\toffset += 4;  /* skip the opcode */\n\n\tswitch ( opcode )\n\t{\n\t\tcase 1: /* authenticate old */\n\t\tcase 21: /* authenticate */\n\t\tcase 22: /* authenticate v2 */\n\t\tcase 2: /* change pw */\n\t\tcase 5: /* set fields */\n\t\tcase 6: /* create user */\n\t\tcase 7: /* delete user */\n\t\tcase 8: /* get entry */\n\t\tcase 14: /* unlock */\n\t\tcase 15: /* lock status */\n\t\t\tOUT_RXString(hf_afs_kauth_princ);\n\t\t\tOUT_RXString(hf_afs_kauth_realm);\n\t\t\tOUT_BYTES_ALL(hf_afs_kauth_data);\n\t\t\tbreak;\n\t\tcase 3: /* getticket-old */\n\t\tcase 23: /* getticket */\n\t\t\tOUT_KAUTH_GetTicket();\n\t\t\tbreak;\n\t\tcase 4: /* set pass */\n\t\t\tOUT_RXString(hf_afs_kauth_princ);\n\t\t\tOUT_RXString(hf_afs_kauth_realm);\n\t\t\tOUT_UINT(hf_afs_kauth_kvno);\n\t\t\tbreak;\n\t\tcase 12: /* get pass */\n\t\t\tOUT_RXString(hf_afs_kauth_name);\n\t\t\tbreak;\n\t}\n}\n\n/*\n * CB Helpers\n */\nstatic void\ndissect_cb_reply(tvbuff_t *tvb, struct rxinfo *rxinfo, proto_tree *tree, int offset, int opcode)\n{\n\tif ( rxinfo->type == RX_PACKET_TYPE_DATA )\n\t{\n\t\tswitch ( opcode )\n\t\t{\n\t\t}\n\t}\n\telse if ( rxinfo->type == RX_PACKET_TYPE_ABORT )\n\t{\n\t\tOUT_UINT(hf_afs_cb_errcode);\n\t}\n}\n\nstatic void\ndissect_cb_request(tvbuff_t *tvb, struct rxinfo *rxinfo _U_, proto_tree *tree, int offset, int opcode)\n{\n\toffset += 4;  /* skip the opcode */\n\n\tswitch ( opcode )\n\t{\n\t\tcase 204: /* callback */\n\t\t{\n\t\t\tunsigned int i,j;\n\n\t\t\tj = tvb_get_ntohl(tvb, offset);\n\t\t\toffset += 4;\n\n\t\t\tfor (i=0; i<j; i++)\n\t\t\t{\n\t\t\t\tOUT_CB_AFSFid(\"Target\");\n\t\t\t}\n\n\t\t\tj = tvb_get_ntohl(tvb, offset);\n\t\t\toffset += 4;\n\t\t\tfor (i=0; i<j; i++)\n\t\t\t{\n\t\t\t\tOUT_CB_AFSCallBack();\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * PROT Helpers\n */\nstatic void\ndissect_prot_reply(tvbuff_t *tvb, struct rxinfo *rxinfo, proto_tree *tree, int offset, int opcode)\n{\n\tif ( rxinfo->type == RX_PACKET_TYPE_DATA )\n\t{\n\t\tswitch ( opcode )\n\t\t{\n\t\t\tcase 504: /* name to id */\n\t\t\t\t{\n\t\t\t\t\tunsigned int i, j;\n\n\t\t\t\t\tj = tvb_get_ntohl(tvb, offset);\n\t\t\t\t\tOUT_UINT(hf_afs_prot_count);\n\n\t\t\t\t\tfor (i=0; i<j; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tOUT_UINT(hf_afs_prot_id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 505: /* id to name */\n\t\t\t\t{\n\t\t\t\t\tunsigned int i, j;\n\n\t\t\t\t\tj = tvb_get_ntohl(tvb, offset);\n\t\t\t\t\tOUT_UINT(hf_afs_prot_count);\n\n\t\t\t\t\tfor (i=0; i<j; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tOUT_RXStringV(hf_afs_prot_name, PRNAMEMAX);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 508: /* get cps */\n\t\t\tcase 514: /* list elements */\n\t\t\tcase 517: /* list owned */\n\t\t\tcase 518: /* get cps2 */\n\t\t\tcase 519: /* get host cps */\n\t\t\t\t{\n\t\t\t\t\tunsigned int i, j;\n\n\t\t\t\t\tj = tvb_get_ntohl(tvb, offset);\n\t\t\t\t\tOUT_UINT(hf_afs_prot_count);\n\n\t\t\t\t\tfor (i=0; i<j; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tOUT_UINT(hf_afs_prot_id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 510: /* list max */\n\t\t\t\tOUT_UINT(hf_afs_prot_maxuid);\n\t\t\t\tOUT_UINT(hf_afs_prot_maxgid);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if ( rxinfo->type == RX_PACKET_TYPE_ABORT )\n\t{\n\t\tOUT_UINT(hf_afs_prot_errcode);\n\t}\n}\n\nstatic void\ndissect_prot_request(tvbuff_t *tvb, struct rxinfo *rxinfo _U_, proto_tree *tree, int offset, int opcode)\n{\n\toffset += 4;  /* skip the opcode */\n\n\tswitch ( opcode )\n\t{\n\t\tcase 500: /* new user */\n\t\t\tOUT_RXString(hf_afs_prot_name);\n\t\t\tOUT_UINT(hf_afs_prot_id);\n\t\t\tOUT_UINT(hf_afs_prot_oldid);\n\t\t\tbreak;\n\t\tcase 501: /* where is it */\n\t\tcase 506: /* delete */\n\t\tcase 508: /* get cps */\n\t\tcase 512: /* list entry */\n\t\tcase 514: /* list elements */\n\t\tcase 517: /* list owned */\n\t\tcase 519: /* get host cps */\n\t\t\tOUT_UINT(hf_afs_prot_id);\n\t\t\tbreak;\n\t\tcase 502: /* dump entry */\n\t\t\tOUT_UINT(hf_afs_prot_pos);\n\t\t\tbreak;\n\t\tcase 503: /* add to group */\n\t\tcase 507: /* remove from group */\n\t\tcase 515: /* is a member of? */\n\t\t\tOUT_UINT(hf_afs_prot_uid);\n\t\t\tOUT_UINT(hf_afs_prot_gid);\n\t\t\tbreak;\n\t\tcase 504: /* name to id */\n\t\t\t{\n\t\t\t\tunsigned int i, j;\n\n\t\t\t\tj = tvb_get_ntohl(tvb, offset);\n\t\t\t\tOUT_UINT(hf_afs_prot_count);\n\n\t\t\t\tfor (i=0; i<j; i++)\n\t\t\t\t{\n\t\t\t\t\tOUT_RXStringV(hf_afs_prot_name,PRNAMEMAX);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 505: /* id to name */\n\t\t\t{\n\t\t\t\tunsigned int i, j;\n\n\t\t\t\tj = tvb_get_ntohl(tvb, offset);\n\t\t\t\tOUT_UINT(hf_afs_prot_count);\n\n\t\t\t\tfor (i=0; i<j; i++)\n\t\t\t\t{\n\t\t\t\t\tOUT_UINT(hf_afs_prot_id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 509: /* new entry */\n\t\t\tOUT_RXString(hf_afs_prot_name);\n\t\t\tOUT_UINT(hf_afs_prot_flag);\n\t\t\tOUT_UINT(hf_afs_prot_oldid);\n\t\t\tbreak;\n\t\tcase 511: /* set max */\n\t\t\tOUT_UINT(hf_afs_prot_id);\n\t\t\tOUT_UINT(hf_afs_prot_flag);\n\t\t\tbreak;\n\t\tcase 513: /* change entry */\n\t\t\tOUT_UINT(hf_afs_prot_id);\n\t\t\tOUT_RXString(hf_afs_prot_name);\n\t\t\tOUT_UINT(hf_afs_prot_oldid);\n\t\t\tOUT_UINT(hf_afs_prot_newid);\n\t\t\tbreak;\n\t\tcase 520: /* update entry */\n\t\t\tOUT_UINT(hf_afs_prot_id);\n\t\t\tOUT_RXString(hf_afs_prot_name);\n\t\t\tbreak;\n\t}\n}\n\n/*\n * VLDB Helpers\n */\nstatic void\ndissect_vldb_reply(tvbuff_t *tvb, struct rxinfo *rxinfo, proto_tree *tree, int offset, int opcode)\n{\n\tif ( rxinfo->type == RX_PACKET_TYPE_DATA )\n\t{\n\t\tswitch ( opcode )\n\t\t{\n\t\t\tcase 510: /* list entry */\n\t\t\t\tOUT_UINT(hf_afs_vldb_count);\n\t\t\t\tOUT_UINT(hf_afs_vldb_nextindex);\n\t\t\t\tbreak;\n\t\t\tcase 503: /* get entry by id */\n\t\t\tcase 504: /* get entry by name */\n\t\t\t\t{\n\t\t\t\t\tint nservers,i,j;\n\t\t\t\t\tOUT_RXStringV(hf_afs_vldb_name, VLNAMEMAX);\n\t\t\t\t\tSKIP(4);\n\t\t\t\t\tnservers = tvb_get_ntohl(tvb, offset);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_numservers);\n\t\t\t\t\tfor (i=0; i<8; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( i<nservers )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOUT_IP(hf_afs_vldb_server);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSKIP(4);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (i=0; i<8; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar *part;\n\t\t\t\t\t\tpart=ep_alloc(8);\n\t\t\t\t\t\tj = tvb_get_ntohl(tvb, offset);\n\t\t\t\t\t\tg_snprintf(part, 8, \"/vicepa\");\n\t\t\t\t\t\tif ( i<nservers && j<=25 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpart[6] = 'a' + (char) j;\n\t\t\t\t\t\t\tproto_tree_add_string(tree, hf_afs_vldb_partition, tvb,\n\t\t\t\t\t\t\t\toffset, 4, part);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSKIP(4);\n\t\t\t\t\t}\n\t\t\t\t\tSKIP(8 * 4);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_rwvol);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_rovol);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_bkvol);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_clonevol);\n\t\t\t\t\tOUT_VLDB_Flags();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 505: /* get new volume id */\n\t\t\t\tOUT_UINT(hf_afs_vldb_id);\n\t\t\t\tbreak;\n\t\t\tcase 521: /* list entry */\n\t\t\tcase 529: /* list entry U */\n\t\t\t\tOUT_UINT(hf_afs_vldb_count);\n\t\t\t\tOUT_UINT(hf_afs_vldb_nextindex);\n\t\t\t\tbreak;\n\t\t\tcase 518: /* get entry by id n */\n\t\t\tcase 519: /* get entry by name N */\n\t\t\t\t{\n\t\t\t\t\tint nservers,i,j;\n\t\t\t\t\tOUT_RXStringV(hf_afs_vldb_name, VLNAMEMAX);\n\t\t\t\t\tnservers = tvb_get_ntohl(tvb, offset);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_numservers);\n\t\t\t\t\tfor (i=0; i<13; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( i<nservers )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOUT_IP(hf_afs_vldb_server);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSKIP(4);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (i=0; i<13; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar *part;\n\t\t\t\t\t\tpart=ep_alloc(8);\n\t\t\t\t\t\tj = tvb_get_ntohl(tvb, offset);\n\t\t\t\t\t\tg_snprintf(part, 8, \"/vicepa\");\n\t\t\t\t\t\tif ( i<nservers && j<=25 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpart[6] = 'a' + (char) j;\n\t\t\t\t\t\t\tproto_tree_add_string(tree, hf_afs_vldb_partition, tvb,\n\t\t\t\t\t\t\t\toffset, 4, part);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSKIP(4);\n\t\t\t\t\t}\n\t\t\t\t\tSKIP(13 * 4);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_rwvol);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_rovol);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_bkvol);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 526: /* get entry by id u */\n\t\t\tcase 527: /* get entry by name u */\n\t\t\t\t{\n\t\t\t\t\tint nservers,i,j;\n\t\t\t\t\tOUT_RXStringV(hf_afs_vldb_name, VLNAMEMAX);\n\t\t\t\t\tnservers = tvb_get_ntohl(tvb, offset);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_numservers);\n\t\t\t\t\tfor (i=0; i<13; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( i<nservers )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOUT_UUID(hf_afs_vldb_serveruuid);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSKIP_UUID();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (i=0; i<13; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( i<nservers )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOUT_UINT(hf_afs_vldb_serveruniq);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSKIP(4);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (i=0; i<13; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tchar *part;\n\t\t\t\t\t\tpart=ep_alloc(8);\n\t\t\t\t\t\tj = tvb_get_ntohl(tvb, offset);\n\t\t\t\t\t\tg_snprintf(part, 8, \"/vicepa\");\n\t\t\t\t\t\tif ( i<nservers && j<=25 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpart[6] = 'a' + (char) j;\n\t\t\t\t\t\t\tproto_tree_add_string(tree, hf_afs_vldb_partition, tvb,\n\t\t\t\t\t\t\t\toffset, 4, part);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSKIP(4);\n\t\t\t\t\t}\n\t\t\t\t\tfor (i=0; i<13; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( i<nservers )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tOUT_UINT(hf_afs_vldb_serverflags);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSKIP(4);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_rwvol);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_rovol);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_bkvol);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_clonevol);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_flags);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_spare1);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_spare2);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_spare3);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_spare4);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_spare5);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_spare6);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_spare7);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_spare8);\n\t\t\t\t\tOUT_UINT(hf_afs_vldb_spare9);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if ( rxinfo->type == RX_PACKET_TYPE_ABORT )\n\t{\n\t\tOUT_UINT(hf_afs_vldb_errcode);\n\t}\n}\n\nstatic void\ndissect_vldb_request(tvbuff_t *tvb, struct rxinfo *rxinfo _U_, proto_tree *tree, int offset, int opcode)\n{\n\toffset += 4;  /* skip the opcode */\n\n\tswitch ( opcode )\n\t{\n\t\tcase 501: /* create new volume */\n\t\tcase 517: /* create entry N */\n\t\t\tOUT_RXStringV(hf_afs_vldb_name, VLNAMEMAX);\n\t\t\tbreak;\n\t\tcase 502: /* delete entry */\n\t\tcase 503: /* get entry by id */\n\t\tcase 507: /* update entry */\n\t\tcase 508: /* set lock */\n\t\tcase 509: /* release lock */\n\t\tcase 518: /* get entry by id */\n\t\t\tOUT_UINT(hf_afs_vldb_id);\n\t\t\tOUT_UINT(hf_afs_vldb_type);\n\t\t\tbreak;\n\t\tcase 504: /* get entry by name */\n\t\tcase 519: /* get entry by name N */\n\t\tcase 524: /* update entry by name */\n\t\tcase 527: /* get entry by name U */\n\t\t\tOUT_RXString(hf_afs_vldb_name);\n\t\t\tbreak;\n\t\tcase 505: /* get new vol id */\n\t\t\tOUT_UINT(hf_afs_vldb_bump);\n\t\t\tbreak;\n\t\tcase 506: /* replace entry */\n\t\tcase 520: /* replace entry N */\n\t\t\tOUT_UINT(hf_afs_vldb_id);\n\t\t\tOUT_UINT(hf_afs_vldb_type);\n\t\t\tOUT_RXStringV(hf_afs_vldb_name, VLNAMEMAX);\n\t\t\tbreak;\n\t\tcase 510: /* list entry */\n\t\tcase 521: /* list entry N */\n\t\t\tOUT_UINT(hf_afs_vldb_index);\n\t\t\tbreak;\n\t\tcase 532: /* regaddr */\n\t\t\tOUT_UUID(hf_afs_vldb_serveruuid);\n\t\t\tOUT_UINT(hf_afs_vldb_spare1);\n\t\t\tOUT_VLDB_BulkAddr();\n\t\t\tbreak;\n\t}\n}\n\n/*\n * UBIK Helpers\n */\nstatic void\ndissect_ubik_reply(tvbuff_t *tvb, struct rxinfo *rxinfo _U_, proto_tree *tree, int offset, int opcode)\n{\n\tswitch ( opcode )\n\t{\n\t\tcase 10000: /* vote-beacon */\n\t\t\tbreak;\n\t\tcase 10001: /* vote-debug-old */\n\t\t\tOUT_UBIK_DebugOld();\n\t\t\tbreak;\n\t\tcase 10002: /* vote-sdebug-old */\n\t\t\tOUT_UBIK_SDebugOld();\n\t\t\tbreak;\n\t\tcase 10003: /* vote-get syncsite */\n\t\t\tbreak;\n\t\tcase 10004: /* vote-debug */\n\t\t\tOUT_UBIK_DebugOld();\n\t\t\tOUT_UBIK_InterfaceAddrs();\n\t\t\tbreak;\n\t\tcase 10005: /* vote-sdebug */\n\t\t\tOUT_UBIK_SDebugOld();\n\t\t\tOUT_UBIK_InterfaceAddrs();\n\t\t\tbreak;\n\t\tcase 10006: /* vote-xdebug */\n\t\t\tOUT_UBIK_DebugOld();\n\t\t\tOUT_UBIK_InterfaceAddrs();\n\t\t\tOUT_UINT(hf_afs_ubik_isclone);\n\t\t\tbreak;\n\t\tcase 10007: /* vote-xsdebug */\n\t\t\tOUT_UBIK_SDebugOld();\n\t\t\tOUT_UBIK_InterfaceAddrs();\n\t\t\tOUT_UINT(hf_afs_ubik_isclone);\n\t\t\tbreak;\n\t\tcase 20000: /* disk-begin */\n\t\t\tbreak;\n\t\tcase 20004: /* get version */\n\t\t\tOUT_UBIKVERSION(\"DB Version\");\n\t\t\tbreak;\n\t\tcase 20010: /* disk-probe */\n\t\t\tbreak;\n\t\tcase 20012: /* disk-interfaceaddr */\n\t\t\tOUT_UBIK_InterfaceAddrs();\n\t\t\tbreak;\n\t}\n}\n\nstatic void\ndissect_ubik_request(tvbuff_t *tvb, struct rxinfo *rxinfo _U_, proto_tree *tree, int offset, int opcode)\n{\n\toffset += 4;  /* skip the opcode */\n\n\tswitch ( opcode )\n\t{\n\t\tcase 10000: /* vote-beacon */\n\t\t\tOUT_UINT(hf_afs_ubik_state);\n\t\t\tOUT_TIMESECS(hf_afs_ubik_votestart);\n\t\t\tOUT_UBIKVERSION(\"DB Version\");\n\t\t\tOUT_UBIKVERSION(\"TID\");\n\t\t\tbreak;\n\t\tcase 10001: /* vote-debug-old */\n\t\t\tbreak;\n\t\tcase 10002: /* vote-sdebug-old */\n\t\t\tOUT_UINT(hf_afs_ubik_site);\n\t\t\tbreak;\n\t\tcase 10003: /* vote-get sync site */\n\t\t\tOUT_IP(hf_afs_ubik_site);\n\t\t\tbreak;\n\t\tcase 10004: /* vote-debug */\n\t\tcase 10005: /* vote-sdebug */\n\t\t\tOUT_IP(hf_afs_ubik_site);\n\t\t\tbreak;\n\t\tcase 20000: /* disk-begin */\n\t\t\tOUT_UBIKVERSION(\"TID\");\n\t\t\tbreak;\n\t\tcase 20001: /* disk-commit */\n\t\t\tOUT_UBIKVERSION(\"TID\");\n\t\t\tbreak;\n\t\tcase 20002: /* disk-lock */\n\t\t\tOUT_UBIKVERSION(\"TID\");\n\t\t\tOUT_UINT(hf_afs_ubik_file);\n\t\t\tOUT_UINT(hf_afs_ubik_pos);\n\t\t\tOUT_UINT(hf_afs_ubik_length);\n\t\t\tOUT_UINT(hf_afs_ubik_locktype);\n\t\t\tbreak;\n\t\tcase 20003: /* disk-write */\n\t\t\tOUT_UBIKVERSION(\"TID\");\n\t\t\tOUT_UINT(hf_afs_ubik_file);\n\t\t\tOUT_UINT(hf_afs_ubik_pos);\n\t\t\tbreak;\n\t\tcase 20004: /* disk-get version */\n\t\t\tbreak;\n\t\tcase 20005: /* disk-get file */\n\t\t\tOUT_UINT(hf_afs_ubik_file);\n\t\t\tbreak;\n\t\tcase 20006: /* disk-send file */\n\t\t\tOUT_UINT(hf_afs_ubik_file);\n\t\t\tOUT_UINT(hf_afs_ubik_length);\n\t\t\tOUT_UBIKVERSION(\"DB Version\");\n\t\t\tbreak;\n\t\tcase 20007: /* disk-abort */\n\t\tcase 20008: /* disk-release locks */\n\t\tcase 20010: /* disk-probe */\n\t\t\tbreak;\n\t\tcase 20009: /* disk-truncate */\n\t\t\tOUT_UBIKVERSION(\"TID\");\n\t\t\tOUT_UINT(hf_afs_ubik_file);\n\t\t\tOUT_UINT(hf_afs_ubik_length);\n\t\t\tbreak;\n\t\tcase 20011: /* disk-writev */\n\t\t\tOUT_UBIKVERSION(\"TID\");\n\t\t\tbreak;\n\t\tcase 20012: /* disk-interfaceaddr */\n\t\t\tOUT_UBIK_InterfaceAddrs();\n\t\t\tbreak;\n\t\tcase 20013: /* disk-set version */\n\t\t\tOUT_UBIKVERSION(\"TID\");\n\t\t\tOUT_UBIKVERSION(\"Old DB Version\");\n\t\t\tOUT_UBIKVERSION(\"New DB Version\");\n\t\t\tbreak;\n\t}\n}\n\n/*\n * BACKUP Helpers\n */\nstatic void\ndissect_backup_reply(tvbuff_t *tvb, struct rxinfo *rxinfo, proto_tree *tree, int offset, int opcode)\n{\n\tif ( rxinfo->type == RX_PACKET_TYPE_DATA )\n\t{\n\t\tswitch ( opcode )\n\t\t{\n\t\t}\n\t}\n\telse if ( rxinfo->type == RX_PACKET_TYPE_ABORT )\n\t{\n\t\tOUT_UINT(hf_afs_backup_errcode);\n\t}\n}\n\nstatic void\ndissect_backup_request(tvbuff_t *tvb _U_, struct rxinfo *rxinfo _U_, proto_tree *tree _U_, int offset, int opcode)\n{\n\toffset += 4;  /* skip the opcode */\n\n\tswitch ( opcode )\n\t{\n\t}\n}\n\n/*\n * Registration code for registering the protocol and fields\n */\n\nvoid\nproto_register_afs(void)\n{\n\tstatic hf_register_info hf[] = {\n\t{ &hf_afs_fs, {\t\"File Server\", \"afs.fs\",\n\t\tFT_BOOLEAN, BASE_NONE, 0, 0, \"File Server\", HFILL }},\n\t{ &hf_afs_cb, {\t\"Callback\", \"afs.cb\",\n\t\tFT_BOOLEAN, BASE_NONE, 0, 0, \"Callback\", HFILL }},\n\t{ &hf_afs_prot, { \"Protection\", \"afs.prot\",\n\t\tFT_BOOLEAN, BASE_NONE, 0, 0, \"Protection Server\", HFILL }},\n\t{ &hf_afs_vldb, { \"VLDB\", \"afs.vldb\",\n\t\tFT_BOOLEAN, BASE_NONE, 0, 0, \"Volume Location Database Server\", HFILL }},\n\t{ &hf_afs_kauth, { \"KAuth\", \"afs.kauth\",\n\t\tFT_BOOLEAN, BASE_NONE, 0, 0, \"Kerberos Auth Server\", HFILL }},\n\t{ &hf_afs_vol, { \"Volume Server\", \"afs.vol\",\n\t\tFT_BOOLEAN, BASE_NONE, 0, 0, \"Volume Server\", HFILL }},\n\t{ &hf_afs_error, { \"Error\", \"afs.error\",\n\t\tFT_BOOLEAN, BASE_NONE, 0, 0, \"Error\", HFILL }},\n\t{ &hf_afs_bos, { \"BOS\", \"afs.bos\",\n\t\tFT_BOOLEAN, BASE_NONE, 0, 0, \"Basic Oversee Server\", HFILL }},\n\t{ &hf_afs_update, { \"Update\", \"afs.update\",\n\t\tFT_BOOLEAN, BASE_NONE, 0, 0, \"Update Server\", HFILL }},\n\t{ &hf_afs_rmtsys, { \"Rmtsys\", \"afs.rmtsys\",\n\t\tFT_BOOLEAN, BASE_NONE, 0, 0, \"Rmtsys\", HFILL }},\n\t{ &hf_afs_ubik, { \"Ubik\", \"afs.ubik\",\n\t\tFT_BOOLEAN, BASE_NONE, 0, 0, \"Ubik\", HFILL }},\n\t{ &hf_afs_backup, { \"Backup\", \"afs.backup\",\n\t\tFT_BOOLEAN, BASE_NONE, 0, 0, \"Backup Server\", HFILL }},\n\n\t{ &hf_afs_fs_opcode, { \"Operation\", \"afs.fs.opcode\",\n\t\tFT_UINT32, BASE_DEC,\n\tVALS(fs_req), 0, \"Operation\", HFILL }},\n\t{ &hf_afs_cb_opcode, { \"Operation\", \"afs.cb.opcode\",\n\t\tFT_UINT32, BASE_DEC,\n\tVALS(cb_req), 0, \"Operation\", HFILL }},\n\t{ &hf_afs_prot_opcode, { \"Operation\", \"afs.prot.opcode\",\n\t\tFT_UINT32, BASE_DEC,\n\tVALS(prot_req), 0, \"Operation\", HFILL }},\n\t{ &hf_afs_vldb_opcode, { \"Operation\", \"afs.vldb.opcode\",\n\t\tFT_UINT32, BASE_DEC,\n\tVALS(vldb_req), 0, \"Operation\", HFILL }},\n\t{ &hf_afs_kauth_opcode, { \"Operation\", \"afs.kauth.opcode\",\n\t\tFT_UINT32, BASE_DEC,\n\tVALS(kauth_req), 0, \"Operation\", HFILL }},\n\t{ &hf_afs_vol_opcode, { \"Operation\", \"afs.vol.opcode\",\n\t\tFT_UINT32, BASE_DEC,\n\tVALS(vol_req), 0, \"Operation\", HFILL }},\n\t{ &hf_afs_bos_opcode, { \"Operation\", \"afs.bos.opcode\",\n\t\tFT_UINT32, BASE_DEC,\n\tVALS(bos_req), 0, \"Operation\", HFILL }},\n\t{ &hf_afs_update_opcode, { \"Operation\", \"afs.update.opcode\",\n\t\tFT_UINT32, BASE_DEC,\n\tVALS(update_req), 0, \"Operation\", HFILL }},\n\t{ &hf_afs_rmtsys_opcode, { \"Operation\", \"afs.rmtsys.opcode\",\n\t\tFT_UINT32, BASE_DEC,\n\tVALS(rmtsys_req), 0, \"Operation\", HFILL }},\n\t{ &hf_afs_error_opcode, { \"Operation\", \"afs.error.opcode\",\n\t\tFT_UINT32, BASE_DEC,\n\t0, 0, \"Operation\", HFILL }},\n\t{ &hf_afs_backup_opcode, {\n\t\"Operation\", \"afs.backup.opcode\",\n\t\tFT_UINT32, BASE_DEC,\n\tVALS(backup_req), 0, \"Operation\", HFILL }},\n\t{ &hf_afs_ubik_opcode, {\n\t\"Operation\", \"afs.ubik.opcode\",\n\t\tFT_UINT32, BASE_DEC,\n\tVALS(ubik_req), 0, \"Operation\", HFILL }},\n\n\n/* File Server Fields */\n\t{ &hf_afs_fs_fid_volume, { \"FileID (Volume)\", \"afs.fs.fid.volume\",\n\t\tFT_UINT32, BASE_DEC,\n\t0, 0, \"File ID (Volume)\", HFILL }},\n\t{ &hf_afs_fs_fid_vnode, { \"FileID (VNode)\", \"afs.fs.fid.vnode\",\n\t\tFT_UINT32, BASE_DEC,\n\t0, 0, \"File ID (VNode)\", HFILL }},\n\t{ &hf_afs_fs_fid_uniqifier, { \"FileID (Uniqifier)\", \"afs.fs.fid.uniq\",\n\t\tFT_UINT32, BASE_DEC,\n\t0, 0, \"File ID (Uniqifier)\", HFILL }},\n\t{ &hf_afs_fs_offset, { \"Offset\", \"afs.fs.offset\",\n\t\tFT_UINT32, BASE_DEC,\n\t0, 0, \"Offset\", HFILL }},\n\t{ &hf_afs_fs_length, { \"Length\", \"afs.fs.length\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Length\", HFILL }},\n\t{ &hf_afs_fs_flength, { \"FLength\", \"afs.fs.flength\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"FLength\", HFILL }},\n\t{ &hf_afs_fs_offset64, { \"Offset64\", \"afs.fs.offset64\",\n\t\tFT_UINT64, BASE_DEC,\n\t0, 0, \"Offset64\", HFILL }},\n\t{ &hf_afs_fs_length64, { \"Length64\", \"afs.fs.length64\",\n\t\tFT_UINT64, BASE_DEC, 0, 0, \"Length64\", HFILL }},\n\t{ &hf_afs_fs_flength64, { \"FLength64\", \"afs.fs.flength64\",\n\t\tFT_UINT64, BASE_DEC, 0, 0, \"FLength64\", HFILL }},\n\t{ &hf_afs_fs_errcode, { \"Error Code\", \"afs.fs.errcode\",\n\t\tFT_UINT32, BASE_DEC, VALS(afs_errors), 0, \"Error Code\", HFILL }},\n\t{ &hf_afs_fs_data, { \"Data\", \"afs.fs.data\",\n\t\tFT_BYTES, BASE_HEX, 0, 0, \"Data\", HFILL }},\n\t{ &hf_afs_fs_token, { \"Token\", \"afs.fs.token\",\n\t\tFT_BYTES, BASE_HEX, 0, 0, \"Token\", HFILL }},\n\t{ &hf_afs_fs_oldname, { \"Old Name\", \"afs.fs.oldname\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Old Name\", HFILL }},\n\t{ &hf_afs_fs_newname, { \"New Name\", \"afs.fs.newname\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"New Name\", HFILL }},\n\t{ &hf_afs_fs_name, { \"Name\", \"afs.fs.name\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Name\", HFILL }},\n\t{ &hf_afs_fs_symlink_name, { \"Symlink Name\", \"afs.fs.symlink.name\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Symlink Name\", HFILL }},\n\t{ &hf_afs_fs_symlink_content, { \"Symlink Content\", \"afs.fs.symlink.content\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Symlink Content\", HFILL }},\n\t{ &hf_afs_fs_volid, { \"Volume ID\", \"afs.fs.volid\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Volume ID\", HFILL }},\n\t{ &hf_afs_fs_volname, { \"Volume Name\", \"afs.fs.volname\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Volume Name\", HFILL }},\n\t{ &hf_afs_fs_timestamp, { \"Timestamp\", \"afs.fs.timestamp\",\n\t\tFT_ABSOLUTE_TIME, BASE_NONE, 0, 0, \"Timestamp\", HFILL }},\n\t{ &hf_afs_fs_offlinemsg, { \"Offline Message\", \"afs.fs.offlinemsg\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Volume Name\", HFILL }},\n\t{ &hf_afs_fs_motd, { \"Message of the Day\", \"afs.fs.motd\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Message of the Day\", HFILL }},\n\t{ &hf_afs_fs_xstats_version, { \"XStats Version\", \"afs.fs.xstats.version\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"XStats Version\", HFILL }},\n\t{ &hf_afs_fs_xstats_clientversion, { \"Client Version\", \"afs.fs.xstats.clientversion\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Client Version\", HFILL }},\n\t{ &hf_afs_fs_xstats_collnumber, { \"Collection Number\", \"afs.fs.xstats.collnumber\",\n\t\tFT_UINT32, BASE_DEC, VALS(xstat_collections), 0, \"Collection Number\", HFILL }},\n\t{ &hf_afs_fs_xstats_timestamp, { \"XStats Timestamp\", \"afs.fs.xstats.timestamp\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"XStats Timestamp\", HFILL }},\n\t{ &hf_afs_fs_cps_spare1, { \"CPS Spare1\", \"afs.fs.cps.spare1\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"CPS Spare1\", HFILL }},\n\t{ &hf_afs_fs_cps_spare2, { \"CPS Spare2\", \"afs.fs.cps.spare2\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"CPS Spare2\", HFILL }},\n\t{ &hf_afs_fs_cps_spare3, { \"CPS Spare3\", \"afs.fs.cps.spare3\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"CPS Spare3\", HFILL }},\n\t{ &hf_afs_fs_vicelocktype, { \"Vice Lock Type\", \"afs.fs.vicelocktype\",\n\t\tFT_UINT32, BASE_DEC, VALS(vice_lock_types), 0, \"Vice Lock Type\", HFILL }},\n/* XXX - is this an IP address? */\n\t{ &hf_afs_fs_viceid, { \"Vice ID\", \"afs.fs.viceid\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Vice ID\", HFILL }},\n\t{ &hf_afs_fs_ipaddr, { \"IP Addr\", \"afs.fs.ipaddr\",\n\t\tFT_IPv4, BASE_HEX, 0, 0, \"IP Addr\", HFILL }},\n\n\t{ &hf_afs_fs_status_mask, { \"Mask\", \"afs.fs.status.mask\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Mask\", HFILL }},\n\t{ &hf_afs_fs_status_mask_setmodtime, { \"Set Modification Time\", \"afs.fs.status.mask.setmodtime\",\n\t\tFT_BOOLEAN, 32, 0, 0x00000001, \"Set Modification Time\", HFILL }},\n\t{ &hf_afs_fs_status_mask_setowner, { \"Set Owner\", \"afs.fs.status.mask.setowner\",\n\t\tFT_BOOLEAN, 32, 0, 0x00000002, \"Set Owner\", HFILL }},\n\t{ &hf_afs_fs_status_mask_setgroup, { \"Set Group\", \"afs.fs.status.mask.setgroup\",\n\t\tFT_BOOLEAN, 32, 0, 0x00000004, \"Set Group\", HFILL }},\n\t{ &hf_afs_fs_status_mask_setmode, { \"Set Mode\", \"afs.fs.status.mask.setmode\",\n\t\tFT_BOOLEAN, 32, 0, 0x00000008, \"Set Mode\", HFILL }},\n\t{ &hf_afs_fs_status_mask_setsegsize, { \"Set Segment Size\", \"afs.fs.status.mask.setsegsize\",\n\t\tFT_BOOLEAN, 32, 0, 0x00000010, \"Set Segment Size\", HFILL }},\n\t{ &hf_afs_fs_status_mask_fsync, { \"FSync\", \"afs.fs.status.mask.fsync\",\n\t\tFT_BOOLEAN, 32, 0, 0x00000400, \"FSync\", HFILL }},\n\n\t{ &hf_afs_fs_status_clientmodtime, { \"Client Modification Time\", \"afs.fs.status.clientmodtime\",\n\t\tFT_ABSOLUTE_TIME, BASE_NONE, 0, 0, \"Client Modification Time\", HFILL }},\n\t{ &hf_afs_fs_status_servermodtime, { \"Server Modification Time\", \"afs.fs.status.servermodtime\",\n\t\tFT_ABSOLUTE_TIME, BASE_NONE, 0, 0, \"Server Modification Time\", HFILL }},\n\t{ &hf_afs_fs_status_owner, { \"Owner\", \"afs.fs.status.owner\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Owner\", HFILL }},\n\t{ &hf_afs_fs_status_group, { \"Group\", \"afs.fs.status.group\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Group\", HFILL }},\n\t{ &hf_afs_fs_status_mode, { \"Unix Mode\", \"afs.fs.status.mode\",\n\t\tFT_UINT32, BASE_OCT, 0, 0, \"Unix Mode\", HFILL }},\n\t{ &hf_afs_fs_status_segsize, { \"Segment Size\", \"afs.fs.status.segsize\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Segment Size\", HFILL }},\n\t{ &hf_afs_fs_status_interfaceversion, { \"Interface Version\", \"afs.fs.status.interfaceversion\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Interface Version\", HFILL }},\n\t{ &hf_afs_fs_status_filetype, { \"File Type\", \"afs.fs.status.filetype\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"File Type\", HFILL }},\n\t{ &hf_afs_fs_status_author, { \"Author\", \"afs.fs.status.author\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Author\", HFILL }},\n\t{ &hf_afs_fs_status_calleraccess, { \"Caller Access\", \"afs.fs.status.calleraccess\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Caller Access\", HFILL }},\n\t{ &hf_afs_fs_status_anonymousaccess, { \"Anonymous Access\", \"afs.fs.status.anonymousaccess\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Anonymous Access\", HFILL }},\n\t{ &hf_afs_fs_status_parentvnode, { \"Parent VNode\", \"afs.fs.status.parentvnode\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Parent VNode\", HFILL }},\n\t{ &hf_afs_fs_status_parentunique, { \"Parent Unique\", \"afs.fs.status.parentunique\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Parent Unique\", HFILL }},\n\t{ &hf_afs_fs_status_dataversion, { \"Data Version\", \"afs.fs.status.dataversion\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Data Version\", HFILL }},\n\t{ &hf_afs_fs_status_dataversionhigh, { \"Data Version (High)\", \"afs.fs.status.dataversionhigh\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Data Version (High)\", HFILL }},\n\t{ &hf_afs_fs_status_linkcount, { \"Link Count\", \"afs.fs.status.linkcount\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Link Count\", HFILL }},\n\t{ &hf_afs_fs_status_spare2, { \"Spare 2\", \"afs.fs.status.spare2\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 2\", HFILL }},\n\t{ &hf_afs_fs_status_spare3, { \"Spare 3\", \"afs.fs.status.spare3\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 3\", HFILL }},\n\t{ &hf_afs_fs_status_spare4, { \"Spare 4\", \"afs.fs.status.spare4\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 4\", HFILL }},\n\t{ &hf_afs_fs_status_synccounter, { \"Sync Counter\", \"afs.fs.status.synccounter\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Sync Counter\", HFILL }},\n\t{ &hf_afs_fs_status_length, { \"Length\", \"afs.fs.status.length\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Length\", HFILL }},\n\n\n\t{ &hf_afs_fs_volsync_spare1, { \"Volume Creation Timestamp\", \"afs.fs.volsync.spare1\",\n\t\tFT_ABSOLUTE_TIME, BASE_NONE, 0, 0, \"Volume Creation Timestamp\", HFILL }},\n\t{ &hf_afs_fs_volsync_spare2, { \"Spare 2\", \"afs.fs.volsync.spare2\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 2\", HFILL }},\n\t{ &hf_afs_fs_volsync_spare3, { \"Spare 3\", \"afs.fs.volsync.spare3\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 3\", HFILL }},\n\t{ &hf_afs_fs_volsync_spare4, { \"Spare 4\", \"afs.fs.volsync.spare4\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 4\", HFILL }},\n\t{ &hf_afs_fs_volsync_spare5, { \"Spare 5\", \"afs.fs.volsync.spare5\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 5\", HFILL }},\n\t{ &hf_afs_fs_volsync_spare6, { \"Spare 6\", \"afs.fs.volsync.spare6\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 6\", HFILL }},\n\n\n\t{ &hf_afs_fs_acl_count_positive, {\n\t\"ACL Count (Positive)\", \"afs.fs.acl.count.positive\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Number of Positive ACLs\", HFILL }},\n\t{ &hf_afs_fs_acl_count_negative, {\n\t\"ACL Count (Negative)\", \"afs.fs.acl.count.negative\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Number of Negative ACLs\", HFILL }},\n\t{ &hf_afs_fs_acl_datasize, {\n\t\"ACL Size\", \"afs.fs.acl.datasize\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"ACL Data Size\", HFILL }},\n\t{ &hf_afs_fs_acl_entity, {\n\t\"Entity (User/Group)\", \"afs.fs.acl.entity\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"ACL Entity (User/Group)\", HFILL }},\n\t{ &hf_afs_fs_acl_r, {\n\t\"_R_ead\", \"afs.fs.acl.r\",\n\t\tFT_BOOLEAN, 8, 0, PRSFS_READ, \"Read\", HFILL }},\n\t{ &hf_afs_fs_acl_l, {\n\t\"_L_ookup\", \"afs.fs.acl.l\",\n\t\tFT_BOOLEAN, 8, 0, PRSFS_LOOKUP, \"Lookup\", HFILL }},\n\t{ &hf_afs_fs_acl_i, {\n\t\"_I_nsert\", \"afs.fs.acl.i\",\n\t\tFT_BOOLEAN, 8, 0, PRSFS_INSERT, \"Insert\", HFILL }},\n\t{ &hf_afs_fs_acl_d, { \"_D_elete\", \"afs.fs.acl.d\",\n\t\tFT_BOOLEAN, 8, 0, PRSFS_DELETE, \"Delete\", HFILL }},\n\t{ &hf_afs_fs_acl_w, { \"_W_rite\", \"afs.fs.acl.w\",\n\t\tFT_BOOLEAN, 8, 0, PRSFS_WRITE, \"Write\", HFILL }},\n\t{ &hf_afs_fs_acl_k, { \"_L_ock\", \"afs.fs.acl.k\",\n\t\tFT_BOOLEAN, 8, 0, PRSFS_LOCK, \"Lock\", HFILL }},\n\t{ &hf_afs_fs_acl_a, { \"_A_dminister\", \"afs.fs.acl.a\",\n\t\tFT_BOOLEAN, 8, 0, PRSFS_ADMINISTER, \"Administer\", HFILL }},\n\n\t{ &hf_afs_fs_callback_version, { \"Version\", \"afs.fs.callback.version\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Version\", HFILL }},\n\t{ &hf_afs_fs_callback_expires, { \"Expires\", \"afs.fs.callback.expires\",\n\t\tFT_RELATIVE_TIME, BASE_NONE, 0, 0, \"Expires\", HFILL }},\n\t{ &hf_afs_fs_callback_type, { \"Type\", \"afs.fs.callback.type\",\n\t\tFT_UINT32, BASE_DEC, VALS(cb_types), 0, \"Type\", HFILL }},\n\n/* BOS Server Fields */\n\t{ &hf_afs_bos_errcode, { \"Error Code\", \"afs.bos.errcode\",\n\t\tFT_UINT32, BASE_DEC, VALS(afs_errors), 0, \"Error Code\", HFILL }},\n\t{ &hf_afs_bos_type, { \"Type\", \"afs.bos.type\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Type\", HFILL }},\n\t{ &hf_afs_bos_content, { \"Content\", \"afs.bos.content\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Content\", HFILL }},\n\t{ &hf_afs_bos_data, { \"Data\", \"afs.bos.data\",\n\t\tFT_BYTES, BASE_HEX, 0, 0, \"Data\", HFILL }},\n\t{ &hf_afs_bos_path, { \"Path\", \"afs.bos.path\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Path\", HFILL }},\n\t{ &hf_afs_bos_parm, { \"Parm\", \"afs.bos.parm\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Parm\", HFILL }},\n\t{ &hf_afs_bos_error, { \"Error\", \"afs.bos.error\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Error\", HFILL }},\n\t{ &hf_afs_bos_spare1, { \"Spare1\", \"afs.bos.spare1\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Spare1\", HFILL }},\n\t{ &hf_afs_bos_spare2, { \"Spare2\", \"afs.bos.spare2\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Spare2\", HFILL }},\n\t{ &hf_afs_bos_spare3, { \"Spare3\", \"afs.bos.spare3\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Spare3\", HFILL }},\n\t{ &hf_afs_bos_file, { \"File\", \"afs.bos.file\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"File\", HFILL }},\n\t{ &hf_afs_bos_cmd, { \"Command\", \"afs.bos.cmd\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Command\", HFILL }},\n\t{ &hf_afs_bos_key, { \"Key\", \"afs.bos.key\",\n\t\tFT_BYTES, BASE_HEX, 0, 0, \"key\", HFILL }},\n\t{ &hf_afs_bos_user, { \"User\", \"afs.bos.user\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"User\", HFILL }},\n\t{ &hf_afs_bos_instance, { \"Instance\", \"afs.bos.instance\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Instance\", HFILL }},\n\t{ &hf_afs_bos_status, { \"Status\", \"afs.bos.status\",\n\t\tFT_INT32, BASE_DEC, 0, 0, \"Status\", HFILL }},\n\t{ &hf_afs_bos_statusdesc, { \"Status Description\", \"afs.bos.statusdesc\",\n\t\tFT_STRING, BASE_DEC, 0, 0, \"Status Description\", HFILL }},\n\t{ &hf_afs_bos_num, { \"Number\", \"afs.bos.number\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Number\", HFILL }},\n\t{ &hf_afs_bos_size, { \"Size\", \"afs.bos.size\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Size\", HFILL }},\n\t{ &hf_afs_bos_flags, { \"Flags\", \"afs.bos.flags\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Flags\", HFILL }},\n\t{ &hf_afs_bos_date, { \"Date\", \"afs.bos.date\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Date\", HFILL }},\n\t{ &hf_afs_bos_kvno, { \"Key Version Number\", \"afs.bos.kvno\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Key Version Number\", HFILL }},\n\t{ &hf_afs_bos_cell, { \"Cell\", \"afs.bos.cell\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Cell\", HFILL }},\n\t{ &hf_afs_bos_host, { \"Host\", \"afs.bos.host\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Host\", HFILL }},\n\t{ &hf_afs_bos_newtime, { \"New Time\", \"afs.bos.newtime\",\n\t\tFT_ABSOLUTE_TIME, BASE_NONE, 0, 0, \"New Time\", HFILL }},\n\t{ &hf_afs_bos_baktime, { \"Backup Time\", \"afs.bos.baktime\",\n\t\tFT_ABSOLUTE_TIME, BASE_NONE, 0, 0, \"Backup Time\", HFILL }},\n\t{ &hf_afs_bos_oldtime, { \"Old Time\", \"afs.bos.oldtime\",\n\t\tFT_ABSOLUTE_TIME, BASE_NONE, 0, 0, \"Old Time\", HFILL }},\n\t{ &hf_afs_bos_keymodtime, { \"Key Modification Time\", \"afs.bos.keymodtime\",\n\t\tFT_ABSOLUTE_TIME, BASE_NONE, 0, 0, \"Key Modification Time\", HFILL }},\n\t{ &hf_afs_bos_keychecksum, { \"Key Checksum\", \"afs.bos.keychecksum\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Key Checksum\", HFILL }},\n\t{ &hf_afs_bos_keyspare2, { \"Key Spare 2\", \"afs.bos.keyspare2\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Key Spare 2\", HFILL }},\n\n\n/* KAUTH Server Fields */\n\t{ &hf_afs_kauth_errcode, { \"Error Code\", \"afs.kauth.errcode\",\n\t\tFT_UINT32, BASE_DEC, VALS(afs_errors), 0, \"Error Code\", HFILL }},\n\t{ &hf_afs_kauth_princ, { \"Principal\", \"afs.kauth.princ\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Principal\", HFILL }},\n\t{ &hf_afs_kauth_realm, { \"Realm\", \"afs.kauth.realm\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Realm\", HFILL }},\n\t{ &hf_afs_kauth_domain, { \"Domain\", \"afs.kauth.domain\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Domain\", HFILL }},\n\t{ &hf_afs_kauth_name, { \"Name\", \"afs.kauth.name\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Name\", HFILL }},\n\t{ &hf_afs_kauth_data, { \"Data\", \"afs.kauth.data\",\n\t\tFT_BYTES, BASE_HEX, 0, 0, \"Data\", HFILL }},\n\t{ &hf_afs_kauth_kvno, { \"Key Version Number\", \"afs.kauth.kvno\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Key Version Number\", HFILL }},\n\n/* VOL Server Fields */\n\t{ &hf_afs_vol_errcode, { \"Error Code\", \"afs.vol.errcode\",\n\t\tFT_UINT32, BASE_DEC, VALS(afs_errors), 0, \"Error Code\", HFILL }},\n\t{ &hf_afs_vol_id, { \"Volume ID\", \"afs.vol.id\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Volume ID\", HFILL }},\n\t{ &hf_afs_vol_count, { \"Volume Count\", \"afs.vol.count\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Volume Count\", HFILL }},\n\t{ &hf_afs_vol_name, { \"Volume Name\", \"afs.vol.name\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Volume Name\", HFILL }},\n\n/* VLDB Server Fields */\n\t{ &hf_afs_vldb_errcode, { \"Error Code\", \"afs.vldb.errcode\",\n\t\tFT_UINT32, BASE_DEC, VALS(afs_errors), 0, \"Error Code\", HFILL }},\n\t{ &hf_afs_vldb_type, { \"Volume Type\", \"afs.vldb.type\",\n\t\tFT_UINT32, BASE_HEX, VALS(volume_types), 0, \"Volume Type\", HFILL }},\n\t{ &hf_afs_vldb_id, { \"Volume ID\", \"afs.vldb.id\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Volume ID\", HFILL }},\n\t{ &hf_afs_vldb_bump, { \"Bumped Volume ID\", \"afs.vldb.bump\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Bumped Volume ID\", HFILL }},\n\t{ &hf_afs_vldb_index, { \"Volume Index\", \"afs.vldb.index\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Volume Index\", HFILL }},\n\t{ &hf_afs_vldb_count, { \"Volume Count\", \"afs.vldb.count\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Volume Count\", HFILL }},\n\t{ &hf_afs_vldb_numservers, { \"Number of Servers\", \"afs.vldb.numservers\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Number of Servers\", HFILL }},\n\t{ &hf_afs_vldb_nextindex, { \"Next Volume Index\", \"afs.vldb.nextindex\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Next Volume Index\", HFILL }},\n\t{ &hf_afs_vldb_rovol, { \"Read-Only Volume ID\", \"afs.vldb.rovol\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Read-Only Volume ID\", HFILL }},\n\t{ &hf_afs_vldb_rwvol, { \"Read-Write Volume ID\", \"afs.vldb.rwvol\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Read-Only Volume ID\", HFILL }},\n\t{ &hf_afs_vldb_bkvol, { \"Backup Volume ID\", \"afs.vldb.bkvol\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Read-Only Volume ID\", HFILL }},\n\t{ &hf_afs_vldb_clonevol, { \"Clone Volume ID\", \"afs.vldb.clonevol\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Clone Volume ID\", HFILL }},\n\t{ &hf_afs_vldb_name, { \"Volume Name\", \"afs.vldb.name\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Volume Name\", HFILL }},\n\t{ &hf_afs_vldb_partition, { \"Partition\", \"afs.vldb.partition\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Partition\", HFILL }},\n\t{ &hf_afs_vldb_server, { \"Server\", \"afs.vldb.server\",\n\t\tFT_IPv4, BASE_HEX, 0, 0, \"Server\", HFILL }},\n\t{ &hf_afs_vldb_serveruuid, { \"Server UUID\", \"afs.vldb.serveruuid\",\n\t\tFT_BYTES, BASE_HEX, 0, 0, \"Server UUID\", HFILL }},\n\t{ &hf_afs_vldb_serveruniq, { \"Server Unique Address\", \"afs.vldb.serveruniq\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Server Unique Address\", HFILL }},\n\t{ &hf_afs_vldb_serverflags, { \"Server Flags\", \"afs.vldb.serverflags\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Server Flags\", HFILL }},\n\t{ &hf_afs_vldb_serverip, { \"Server IP\", \"afs.vldb.serverip\",\n\t\tFT_IPv4, BASE_HEX, 0, 0, \"Server IP\", HFILL }},\n\t{ &hf_afs_vldb_flags, { \"Flags\", \"afs.vldb.flags\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Flags\", HFILL }},\n\n\t{ &hf_afs_vldb_flags_rwexists, { \"Read/Write Exists\", \"afs.vldb.flags.rwexists\",\n\t\tFT_BOOLEAN, 32, 0, 0x1000, \"Read/Write Exists\", HFILL }},\n\t{ &hf_afs_vldb_flags_roexists, { \"Read-Only Exists\", \"afs.vldb.flags.roexists\",\n\t\tFT_BOOLEAN, 32, 0, 0x2000, \"Read-Only Exists\", HFILL }},\n\t{ &hf_afs_vldb_flags_bkexists, { \"Backup Exists\", \"afs.vldb.flags.bkexists\",\n\t\tFT_BOOLEAN, 32, 0, 0x4000, \"Backup Exists\", HFILL }},\n\t{ &hf_afs_vldb_flags_dfsfileset, { \"DFS Fileset\", \"afs.vldb.flags.dfsfileset\",\n\t\tFT_BOOLEAN, 32, 0, 0x8000, \"DFS Fileset\", HFILL }},\n\n\t{ &hf_afs_vldb_spare1, { \"Spare 1\", \"afs.vldb.spare1\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 1\", HFILL }},\n\t{ &hf_afs_vldb_spare2, { \"Spare 2\", \"afs.vldb.spare2\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 2\", HFILL }},\n\t{ &hf_afs_vldb_spare3, { \"Spare 3\", \"afs.vldb.spare3\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 3\", HFILL }},\n\t{ &hf_afs_vldb_spare4, { \"Spare 4\", \"afs.vldb.spare4\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 4\", HFILL }},\n\t{ &hf_afs_vldb_spare5, { \"Spare 5\", \"afs.vldb.spare5\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 5\", HFILL }},\n\t{ &hf_afs_vldb_spare6, { \"Spare 6\", \"afs.vldb.spare6\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 6\", HFILL }},\n\t{ &hf_afs_vldb_spare7, { \"Spare 7\", \"afs.vldb.spare7\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 7\", HFILL }},\n\t{ &hf_afs_vldb_spare8, { \"Spare 8\", \"afs.vldb.spare8\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 8\", HFILL }},\n\t{ &hf_afs_vldb_spare9, { \"Spare 9\", \"afs.vldb.spare9\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Spare 9\", HFILL }},\n\n/* BACKUP Server Fields */\n\t{ &hf_afs_backup_errcode, { \"Error Code\", \"afs.backup.errcode\",\n\t\tFT_UINT32, BASE_DEC, VALS(afs_errors), 0, \"Error Code\", HFILL }},\n\n/* CB Server Fields */\n\t{ &hf_afs_cb_errcode, { \"Error Code\", \"afs.cb.errcode\",\n\t\tFT_UINT32, BASE_DEC, VALS(afs_errors), 0, \"Error Code\", HFILL }},\n\t{ &hf_afs_cb_callback_version, { \"Version\", \"afs.cb.callback.version\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Version\", HFILL }},\n\t{ &hf_afs_cb_callback_expires, { \"Expires\", \"afs.cb.callback.expires\",\n\t\tFT_ABSOLUTE_TIME, BASE_NONE, 0, 0, \"Expires\", HFILL }},\n\t{ &hf_afs_cb_callback_type, { \"Type\", \"afs.cb.callback.type\",\n\t\tFT_UINT32, BASE_DEC, VALS(cb_types), 0, \"Type\", HFILL }},\n\t{ &hf_afs_cb_fid_volume, { \"FileID (Volume)\", \"afs.cb.fid.volume\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"File ID (Volume)\", HFILL }},\n\t{ &hf_afs_cb_fid_vnode, { \"FileID (VNode)\", \"afs.cb.fid.vnode\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"File ID (VNode)\", HFILL }},\n\t{ &hf_afs_cb_fid_uniqifier, { \"FileID (Uniqifier)\", \"afs.cb.fid.uniq\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"File ID (Uniqifier)\", HFILL }},\n\n/* PROT Server Fields */\n\t{ &hf_afs_prot_errcode, { \"Error Code\", \"afs.prot.errcode\",\n\t\tFT_UINT32, BASE_DEC, VALS(afs_errors), 0, \"Error Code\", HFILL }},\n\t{ &hf_afs_prot_name, { \"Name\", \"afs.prot.name\",\n\t\tFT_STRING, BASE_HEX, 0, 0, \"Name\", HFILL }},\n\t{ &hf_afs_prot_id, { \"ID\", \"afs.prot.id\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"ID\", HFILL }},\n\t{ &hf_afs_prot_oldid, { \"Old ID\", \"afs.prot.oldid\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Old ID\", HFILL }},\n\t{ &hf_afs_prot_newid, { \"New ID\", \"afs.prot.newid\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"New ID\", HFILL }},\n\t{ &hf_afs_prot_gid, { \"Group ID\", \"afs.prot.gid\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Group ID\", HFILL }},\n\t{ &hf_afs_prot_uid, { \"User ID\", \"afs.prot.uid\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"User ID\", HFILL }},\n\t{ &hf_afs_prot_count, { \"Count\", \"afs.prot.count\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Count\", HFILL }},\n\t{ &hf_afs_prot_maxgid, { \"Maximum Group ID\", \"afs.prot.maxgid\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Maximum Group ID\", HFILL }},\n\t{ &hf_afs_prot_maxuid, { \"Maximum User ID\", \"afs.prot.maxuid\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Maximum User ID\", HFILL }},\n\t{ &hf_afs_prot_pos, { \"Position\", \"afs.prot.pos\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Position\", HFILL }},\n\t{ &hf_afs_prot_flag, { \"Flag\", \"afs.prot.flag\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Flag\", HFILL }},\n\n/* UBIK Fields */\n\t{ &hf_afs_ubik_errcode, { \"Error Code\", \"afs.ubik.errcode\",\n\t\tFT_UINT32, BASE_DEC, VALS(afs_errors), 0, \"Error Code\", HFILL }},\n\t{ &hf_afs_ubik_state, { \"State\", \"afs.ubik.state\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"State\", HFILL }},\n\t{ &hf_afs_ubik_version_epoch, { \"Epoch\", \"afs.ubik.version.epoch\",\n\t\tFT_ABSOLUTE_TIME, BASE_NONE, 0, 0, \"Epoch\", HFILL }},\n\t{ &hf_afs_ubik_version_counter, { \"Counter\", \"afs.ubik.version.counter\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Counter\", HFILL }},\n\t{ &hf_afs_ubik_votestart, { \"Vote Started\", \"afs.ubik.votestart\",\n\t\tFT_ABSOLUTE_TIME, BASE_NONE, 0, 0, \"Vote Started\", HFILL }},\n\t{ &hf_afs_ubik_voteend, { \"Vote Ends\", \"afs.ubik.voteend\",\n\t\tFT_ABSOLUTE_TIME, BASE_NONE, 0, 0, \"Vote Ends\", HFILL }},\n\t{ &hf_afs_ubik_file, { \"File\", \"afs.ubik.file\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"File\", HFILL }},\n\t{ &hf_afs_ubik_pos, { \"Position\", \"afs.ubik.position\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Position\", HFILL }},\n\t{ &hf_afs_ubik_length, { \"Length\", \"afs.ubik.length\",\n\t\tFT_UINT32, BASE_DEC, 0, 0, \"Length\", HFILL }},\n\t{ &hf_afs_ubik_locktype, { \"Lock Type\", \"afs.ubik.locktype\",\n\t\tFT_UINT32, BASE_DEC, VALS(ubik_lock_types), 0, \"Lock Type\", HFILL }},\n\t{ &hf_afs_ubik_votetype, { \"Vote Type\", \"afs.ubik.votetype\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Vote Type\", HFILL }},\n\t{ &hf_afs_ubik_site, { \"Site\", \"afs.ubik.site\",\n\t\tFT_IPv4, BASE_HEX, 0, 0, \"Site\", HFILL }},\n\t{ &hf_afs_ubik_interface, { \"Interface Address\", \"afs.ubik.interface\",\n\t\tFT_IPv4, BASE_HEX, 0, 0, \"Interface Address\", HFILL }},\n\n\t{ &hf_afs_ubik_now, { \"Now\", \"afs.ubik.now\",\n\t\tFT_ABSOLUTE_TIME, BASE_HEX, 0, 0, \"Now\", HFILL }},\n\t{ &hf_afs_ubik_lastyestime, { \"Last Yes Time\", \"afs.ubik.lastyesttime\",\n\t\tFT_ABSOLUTE_TIME, BASE_HEX, 0, 0, \"Last Yes Time\", HFILL }},\n\t{ &hf_afs_ubik_lastyeshost, { \"Last Yes Host\", \"afs.ubik.lastyeshost\",\n\t\tFT_IPv4, BASE_HEX, 0, 0, \"Last Yes Host\", HFILL }},\n\t{ &hf_afs_ubik_lastyesstate, { \"Last Yes State\", \"afs.ubik.lastyesstate\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Last Yes State\", HFILL }},\n\t{ &hf_afs_ubik_lastyesclaim, { \"Last Yes Claim\", \"afs.ubik.lastyesclaim\",\n\t\tFT_ABSOLUTE_TIME, BASE_HEX, 0, 0, \"Last Yes Claim\", HFILL }},\n\t{ &hf_afs_ubik_lowesthost, { \"Lowest Host\", \"afs.ubik.lowesthost\",\n\t\tFT_IPv4, BASE_HEX, 0, 0, \"Lowest Host\", HFILL }},\n\t{ &hf_afs_ubik_lowesttime, { \"Lowest Time\", \"afs.ubik.lowesttime\",\n\t\tFT_ABSOLUTE_TIME, BASE_HEX, 0, 0, \"Lowest Time\", HFILL }},\n\t{ &hf_afs_ubik_synchost, { \"Sync Host\", \"afs.ubik.synchost\",\n\t\tFT_IPv4, BASE_HEX, 0, 0, \"Sync Host\", HFILL }},\n\t{ &hf_afs_ubik_addr, { \"Address\", \"afs.ubik.addr\",\n\t\tFT_IPv4, BASE_HEX, 0, 0, \"Address\", HFILL }},\n\t{ &hf_afs_ubik_synctime, { \"Sync Time\", \"afs.ubik.synctime\",\n\t\tFT_ABSOLUTE_TIME, BASE_HEX, 0, 0, \"Sync Time\", HFILL }},\n\t{ &hf_afs_ubik_lastvotetime, { \"Last Vote Time\", \"afs.ubik.lastvotetime\",\n\t\tFT_ABSOLUTE_TIME, BASE_HEX, 0, 0, \"Last Vote Time\", HFILL }},\n\t{ &hf_afs_ubik_lastbeaconsent, { \"Last Beacon Sent\", \"afs.ubik.lastbeaconsent\",\n\t\tFT_ABSOLUTE_TIME, BASE_HEX, 0, 0, \"Last Beacon Sent\", HFILL }},\n\t{ &hf_afs_ubik_lastvote, { \"Last Vote\", \"afs.ubik.lastvote\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Last Vote\", HFILL }},\n\t{ &hf_afs_ubik_currentdb, { \"Current DB\", \"afs.ubik.currentdb\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Current DB\", HFILL }},\n\t{ &hf_afs_ubik_up, { \"Up\", \"afs.ubik.up\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Up\", HFILL }},\n\t{ &hf_afs_ubik_beaconsincedown, { \"Beacon Since Down\", \"afs.ubik.beaconsincedown\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Beacon Since Down\", HFILL }},\n\t{ &hf_afs_ubik_amsyncsite, { \"Am Sync Site\", \"afs.ubik.amsyncsite\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Am Sync Site\", HFILL }},\n\t{ &hf_afs_ubik_syncsiteuntil, { \"Sync Site Until\", \"afs.ubik.syncsiteuntil\",\n\t\tFT_ABSOLUTE_TIME, BASE_HEX, 0, 0, \"Sync Site Until\", HFILL }},\n\t{ &hf_afs_ubik_nservers, { \"Number of Servers\", \"afs.ubik.nservers\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Number of Servers\", HFILL }},\n\t{ &hf_afs_ubik_lockedpages, { \"Locked Pages\", \"afs.ubik.lockedpages\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Locked Pages\", HFILL }},\n\t{ &hf_afs_ubik_writelockedpages, { \"Write Locked Pages\", \"afs.ubik.writelockedpages\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Write Locked Pages\", HFILL }},\n\t{ &hf_afs_ubik_activewrite, { \"Active Write\", \"afs.ubik.activewrite\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Active Write\", HFILL }},\n\t{ &hf_afs_ubik_tidcounter, { \"TID Counter\", \"afs.ubik.tidcounter\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"TID Counter\", HFILL }},\n\t{ &hf_afs_ubik_anyreadlocks, { \"Any Read Locks\", \"afs.ubik.anyreadlocks\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Any Read Locks\", HFILL }},\n\t{ &hf_afs_ubik_anywritelocks, { \"Any Write Locks\", \"afs.ubik.anywritelocks\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Any Write Locks\", HFILL }},\n\t{ &hf_afs_ubik_recoverystate, { \"Recovery State\", \"afs.ubik.recoverystate\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Recovery State\", HFILL }},\n\t{ &hf_afs_ubik_currenttrans, { \"Current Transaction\", \"afs.ubik.currenttran\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Current Transaction\", HFILL }},\n\t{ &hf_afs_ubik_writetrans, { \"Write Transaction\", \"afs.ubik.writetran\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Write Transaction\", HFILL }},\n\t{ &hf_afs_ubik_epochtime, { \"Epoch Time\", \"afs.ubik.epochtime\",\n\t\tFT_ABSOLUTE_TIME, BASE_HEX, 0, 0, \"Epoch Time\", HFILL }},\n\t{ &hf_afs_ubik_isclone, { \"Is Clone\", \"afs.ubik.isclone\",\n\t\tFT_UINT32, BASE_HEX, 0, 0, \"Is Clone\", HFILL }},\n\t{ &hf_afs_reqframe, { \"Request Frame\", \"afs.reqframe\",\n\t\tFT_FRAMENUM, BASE_NONE, NULL, 0, \"Request Frame\", HFILL }},\n\t{ &hf_afs_repframe, { \"Reply Frame\", \"afs.repframe\",\n\t\tFT_FRAMENUM, BASE_NONE,\tNULL, 0, \"Reply Frame\", HFILL }},\n\t{ &hf_afs_time, { \"Time from request\", \"afs.time\",\n\t\tFT_RELATIVE_TIME, BASE_NONE, NULL, 0, \"Time between Request and Reply for AFS calls\", HFILL }},\n\t};\n\tstatic gint *ett[] = {\n\t\t&ett_afs,\n\t\t&ett_afs_op,\n\t\t&ett_afs_acl,\n\t\t&ett_afs_fid,\n\t\t&ett_afs_callback,\n\t\t&ett_afs_ubikver,\n\t\t&ett_afs_status,\n\t\t&ett_afs_status_mask,\n\t\t&ett_afs_volsync,\n\t\t&ett_afs_volumeinfo,\n\t\t&ett_afs_vicestat,\n\t\t&ett_afs_vldb_flags,\n\t};\n\n\tproto_afs = proto_register_protocol(\"Andrew File System (AFS)\",\n\t    \"AFS (RX)\", \"afs\");\n\tproto_register_field_array(proto_afs, hf, array_length(hf));\n\tproto_register_subtree_array(ett, array_length(ett));\n\tregister_init_routine(&afs_init_protocol);\n\n\tregister_dissector(\"afs\", dissect_afs, proto_afs);\n}\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"out_of_bounds_read\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code reads memory outside the allocated bounds of an array or buffer. This can cause crashes or expose sensitive memory contents to attackers.\",\n  \"risk\": \"Memory disclosure, application crashes, information leakage, potential code execution\",\n  \"compliant_patch\": \"\\n// FIXED: Add bounds checking before array access\\n// Instead of: value = array[index];\\n// Use: if (index >= 0 && index < array_size) {\\n//         value = array[index];\\n//       } else {\\n//         handle_error();\\n//       }\\n\\n// Or use safe library functions that check bounds\\n\",\n  \"source\": \"SARD-148876\",\n  \"cwe\": \"CWE-125\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_31.c\nLabel Definition File: CWE319_Cleartext_Tx_Sensitive_Info__w32.label.xml\nTemplate File: sources-sinks-31.tmpl.c\n*/\n/*\n * @description\n * CWE: 319 Cleartext Transmission of Sensitive Information\n * BadSource: listen_socket Read the password using a listen socket (server side)\n * GoodSource: Use a hardcoded password (one that was not sent over the network)\n * Sinks:\n *    GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext\n *    BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext\n * Flow Variant: 31 Data flow using a copy of data within the same function\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" /* INCIDENTAL: Hardcoded crypto */\n\n#ifndef OMITBAD\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_31_bad()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            /* POTENTIAL FLAW: Reading sensitive data from the network */\n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        wchar_t * passwordCopy = password;\n        wchar_t * password = passwordCopy;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n            /* POTENTIAL FLAW: Using sensitive information that was possibly sent in plaintext over the network */\n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B() uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    /* FIX: Use a hardcoded password (it was not sent over the network)\n    * INCIDENTAL FLAW: CWE-259 Hard Coded Password */\n    wcscpy(password, L\"Password1234!\");\n    {\n        wchar_t * passwordCopy = password;\n        wchar_t * password = passwordCopy;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n            /* POTENTIAL FLAW: Using sensitive information that was possibly sent in plaintext over the network */\n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n/* goodB2G() uses the BadSource with the GoodSink */\nstatic void goodB2G()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            /* POTENTIAL FLAW: Reading sensitive data from the network */\n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    {\n        wchar_t * passwordCopy = password;\n        wchar_t * password = passwordCopy;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; /* same size as password except for NUL terminator */\n                DWORD payloadBytes;\n                /* Hex-decode the input string into raw bytes */\n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                /* Wipe the hex string, to prevent it from being given to LogonUserW if\n                 * any of the crypto calls fail. */\n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                /* Aquire a Context */\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                /* Create hash handle */\n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                /* Hash the input string */\n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                /* Derive an AES key from the hash */\n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                /* FIX: Decrypt the password */\n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                /* Copy back into password and NUL-terminate */\n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_31_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_31_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_31_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"cleartext_transmission\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code transmits sensitive information without encryption. Attackers can intercept and read confidential data sent over the network.\",\n  \"risk\": \"Data interception, credential theft, privacy violations, compliance violations\",\n  \"compliant_patch\": \"\\n// FIXED: Use encryption for sensitive data transmission\\n// Instead of: send_data_in_cleartext(data);\\n// Use: encrypted_data = encrypt_data(data, encryption_key);\\n//       send_encrypted_data(encrypted_data);\\n\\n// Use TLS/SSL for network communication\\n// Ensure all connections use HTTPS/SSL/TLS\\n\",\n  \"source\": \"SARD-94262\",\n  \"cwe\": \"CWE-319\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"cleartext_transmission\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code transmits sensitive information without encryption. Attackers can intercept and read confidential data sent over the network.\",\n  \"risk\": \"Data interception, credential theft, privacy violations, compliance violations\",\n  \"compliant_patch\": \"\\n// FIXED: Use encryption for sensitive data transmission\\n// Instead of: send_data_in_cleartext(data);\\n// Use: encrypted_data = encrypt_data(data, encryption_key);\\n//       send_encrypted_data(encrypted_data);\\n\\n// Use TLS/SSL for network communication\\n// Ensure all connections use HTTPS/SSL/TLS\\n\",\n  \"source\": \"SARD-94262\",\n  \"cwe\": \"CWE-319\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_44.c\nLabel Definition File: CWE319_Cleartext_Tx_Sensitive_Info__w32.label.xml\nTemplate File: sources-sinks-44.tmpl.c\n*/\n/*\n * @description\n * CWE: 319 Cleartext Transmission of Sensitive Information\n * BadSource: listen_socket Read the password using a listen socket (server side)\n * GoodSource: Use a hardcoded password (one that was not sent over the network)\n * Sinks:\n *    GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext\n *    BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext\n * Flow Variant: 44 Data/control flow: data passed as an argument from one function to a function in the same source file called via a function pointer\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" /* INCIDENTAL: Hardcoded crypto */\n\n#ifndef OMITBAD\n\nstatic void badSink(wchar_t * password)\n{\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n        /* POTENTIAL FLAW: Using sensitive information that was possibly sent in plaintext over the network */\n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_44_bad()\n{\n    wchar_t * password;\n    /* define a function pointer */\n    void (*funcPtr) (wchar_t *) = badSink;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            /* POTENTIAL FLAW: Reading sensitive data from the network */\n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    /* use the function pointer */\n    funcPtr(password);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B() uses the GoodSource with the BadSink */\nstatic void goodG2BSink(wchar_t * password)\n{\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n        /* POTENTIAL FLAW: Using sensitive information that was possibly sent in plaintext over the network */\n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void goodG2B()\n{\n    wchar_t * password;\n    void (*funcPtr) (wchar_t *) = goodG2BSink;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    /* FIX: Use a hardcoded password (it was not sent over the network)\n    * INCIDENTAL FLAW: CWE-259 Hard Coded Password */\n    wcscpy(password, L\"Password1234!\");\n    funcPtr(password);\n}\n\n/* goodB2G() uses the BadSource with the GoodSink */\nstatic void goodB2GSink(wchar_t * password)\n{\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; /* same size as password except for NUL terminator */\n            DWORD payloadBytes;\n            /* Hex-decode the input string into raw bytes */\n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            /* Wipe the hex string, to prevent it from being given to LogonUserW if\n             * any of the crypto calls fail. */\n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            /* Aquire a Context */\n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            /* Create hash handle */\n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            /* Hash the input string */\n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            /* Derive an AES key from the hash */\n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            /* FIX: Decrypt the password */\n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            /* Copy back into password and NUL-terminate */\n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\nstatic void goodB2G()\n{\n    wchar_t * password;\n    void (*funcPtr) (wchar_t *) = goodB2GSink;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            /* POTENTIAL FLAW: Reading sensitive data from the network */\n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    funcPtr(password);\n}\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_44_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_44_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_44_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"cleartext_transmission\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code transmits sensitive information without encryption. Attackers can intercept and read confidential data sent over the network.\",\n  \"risk\": \"Data interception, credential theft, privacy violations, compliance violations\",\n  \"compliant_patch\": \"\\n// FIXED: Use encryption for sensitive data transmission\\n// Instead of: send_data_in_cleartext(data);\\n// Use: encrypted_data = encrypt_data(data, encryption_key);\\n//       send_encrypted_data(encrypted_data);\\n\\n// Use TLS/SSL for network communication\\n// Ensure all connections use HTTPS/SSL/TLS\\n\",\n  \"source\": \"SARD-94269\",\n  \"cwe\": \"CWE-319\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"cleartext_transmission\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code transmits sensitive information without encryption. Attackers can intercept and read confidential data sent over the network.\",\n  \"risk\": \"Data interception, credential theft, privacy violations, compliance violations\",\n  \"compliant_patch\": \"\\n// FIXED: Use encryption for sensitive data transmission\\n// Instead of: send_data_in_cleartext(data);\\n// Use: encrypted_data = encrypt_data(data, encryption_key);\\n//       send_encrypted_data(encrypted_data);\\n\\n// Use TLS/SSL for network communication\\n// Ensure all connections use HTTPS/SSL/TLS\\n\",\n  \"source\": \"SARD-94269\",\n  \"cwe\": \"CWE-319\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67a.c\nLabel Definition File: CWE319_Cleartext_Tx_Sensitive_Info__w32.label.xml\nTemplate File: sources-sinks-67a.tmpl.c\n*/\n/*\n * @description\n * CWE: 319 Cleartext Transmission of Sensitive Information\n * BadSource: listen_socket Read the password using a listen socket (server side)\n * GoodSource: Use a hardcoded password (one that was not sent over the network)\n * Sinks:\n *    GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext\n *    BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext\n * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" /* INCIDENTAL: Hardcoded crypto */\n\ntypedef struct _CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_structType\n{\n    wchar_t * structFirst;\n} CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_structType;\n\n#ifndef OMITBAD\n\n/* bad function declaration */\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67b_badSink(CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_structType myStruct);\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_bad()\n{\n    wchar_t * password;\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_structType myStruct;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            /* POTENTIAL FLAW: Reading sensitive data from the network */\n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myStruct.structFirst = password;\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67b_badSink(myStruct);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67b_goodG2BSink(CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_structType myStruct);\n\nstatic void goodG2B()\n{\n    wchar_t * password;\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_structType myStruct;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    /* FIX: Use a hardcoded password (it was not sent over the network)\n    * INCIDENTAL FLAW: CWE-259 Hard Coded Password */\n    wcscpy(password, L\"Password1234!\");\n    myStruct.structFirst = password;\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67b_goodG2BSink(myStruct);\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67b_goodB2GSink(CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_structType myStruct);\n\nstatic void goodB2G()\n{\n    wchar_t * password;\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_structType myStruct;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            /* POTENTIAL FLAW: Reading sensitive data from the network */\n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myStruct.structFirst = password;\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67b_goodB2GSink(myStruct);\n}\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"cleartext_transmission\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code transmits sensitive information without encryption. Attackers can intercept and read confidential data sent over the network.\",\n  \"risk\": \"Data interception, credential theft, privacy violations, compliance violations\",\n  \"compliant_patch\": \"\\n// FIXED: Use encryption for sensitive data transmission\\n// Instead of: send_data_in_cleartext(data);\\n// Use: encrypted_data = encrypt_data(data, encryption_key);\\n//       send_encrypted_data(encrypted_data);\\n\\n// Use TLS/SSL for network communication\\n// Ensure all connections use HTTPS/SSL/TLS\\n\",\n  \"source\": \"SARD-94281\",\n  \"cwe\": \"CWE-319\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67b.c\nLabel Definition File: CWE319_Cleartext_Tx_Sensitive_Info__w32.label.xml\nTemplate File: sources-sinks-67b.tmpl.c\n*/\n/*\n * @description\n * CWE: 319 Cleartext Transmission of Sensitive Information\n * BadSource: listen_socket Read the password using a listen socket (server side)\n * GoodSource: Use a hardcoded password (one that was not sent over the network)\n * Sinks:\n *    GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext\n *    BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext\n * Flow Variant: 67 Data flow: data passed in a struct from one function to another in different source files\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" /* INCIDENTAL: Hardcoded crypto */\n\ntypedef struct _CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_structType\n{\n    wchar_t * structFirst;\n} CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_structType;\n\n#ifndef OMITBAD\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67b_badSink(CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_structType myStruct)\n{\n    wchar_t * password = myStruct.structFirst;\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n        /* POTENTIAL FLAW: Using sensitive information that was possibly sent in plaintext over the network */\n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67b_goodG2BSink(CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_structType myStruct)\n{\n    wchar_t * password = myStruct.structFirst;\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n        /* POTENTIAL FLAW: Using sensitive information that was possibly sent in plaintext over the network */\n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67b_goodB2GSink(CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_structType myStruct)\n{\n    wchar_t * password = myStruct.structFirst;\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; /* same size as password except for NUL terminator */\n            DWORD payloadBytes;\n            /* Hex-decode the input string into raw bytes */\n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            /* Wipe the hex string, to prevent it from being given to LogonUserW if\n             * any of the crypto calls fail. */\n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            /* Aquire a Context */\n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            /* Create hash handle */\n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            /* Hash the input string */\n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            /* Derive an AES key from the hash */\n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            /* FIX: Decrypt the password */\n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            /* Copy back into password and NUL-terminate */\n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n#endif /* OMITGOOD */\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"cleartext_transmission\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code transmits sensitive information without encryption. Attackers can intercept and read confidential data sent over the network.\",\n  \"risk\": \"Data interception, credential theft, privacy violations, compliance violations\",\n  \"compliant_patch\": \"\\n// FIXED: Use encryption for sensitive data transmission\\n// Instead of: send_data_in_cleartext(data);\\n// Use: encrypted_data = encrypt_data(data, encryption_key);\\n//       send_encrypted_data(encrypted_data);\\n\\n// Use TLS/SSL for network communication\\n// Ensure all connections use HTTPS/SSL/TLS\\n\",\n  \"source\": \"SARD-94281\",\n  \"cwe\": \"CWE-319\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"cleartext_transmission\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code transmits sensitive information without encryption. Attackers can intercept and read confidential data sent over the network.\",\n  \"risk\": \"Data interception, credential theft, privacy violations, compliance violations\",\n  \"compliant_patch\": \"\\n// FIXED: Use encryption for sensitive data transmission\\n// Instead of: send_data_in_cleartext(data);\\n// Use: encrypted_data = encrypt_data(data, encryption_key);\\n//       send_encrypted_data(encrypted_data);\\n\\n// Use TLS/SSL for network communication\\n// Ensure all connections use HTTPS/SSL/TLS\\n\",\n  \"source\": \"SARD-94281\",\n  \"cwe\": \"CWE-319\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34.c\nLabel Definition File: CWE319_Cleartext_Tx_Sensitive_Info__w32.label.xml\nTemplate File: sources-sinks-34.tmpl.c\n*/\n/*\n * @description\n * CWE: 319 Cleartext Transmission of Sensitive Information\n * BadSource: listen_socket Read the password using a listen socket (server side)\n * GoodSource: Use a hardcoded password (one that was not sent over the network)\n * Sinks:\n *    GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext\n *    BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext\n * Flow Variant: 34 Data flow: use of a union containing two methods of accessing the same data (within the same function)\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" /* INCIDENTAL: Hardcoded crypto */\n\ntypedef union\n{\n    wchar_t * unionFirst;\n    wchar_t * unionSecond;\n} CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_unionType;\n\n#ifndef OMITBAD\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_bad()\n{\n    wchar_t * password;\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_unionType myUnion;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            /* POTENTIAL FLAW: Reading sensitive data from the network */\n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myUnion.unionFirst = password;\n    {\n        wchar_t * password = myUnion.unionSecond;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n            /* POTENTIAL FLAW: Using sensitive information that was possibly sent in plaintext over the network */\n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B() uses the GoodSource with the BadSink */\nstatic void goodG2B()\n{\n    wchar_t * password;\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_unionType myUnion;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    /* FIX: Use a hardcoded password (it was not sent over the network)\n    * INCIDENTAL FLAW: CWE-259 Hard Coded Password */\n    wcscpy(password, L\"Password1234!\");\n    myUnion.unionFirst = password;\n    {\n        wchar_t * password = myUnion.unionSecond;\n        {\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n            /* POTENTIAL FLAW: Using sensitive information that was possibly sent in plaintext over the network */\n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\n/* goodB2G() uses the BadSource with the GoodSink */\nstatic void goodB2G()\n{\n    wchar_t * password;\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_unionType myUnion;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            /* POTENTIAL FLAW: Reading sensitive data from the network */\n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    myUnion.unionFirst = password;\n    {\n        wchar_t * password = myUnion.unionSecond;\n        {\n            HCRYPTPROV hCryptProv = 0;\n            HCRYPTHASH hHash = 0;\n            HCRYPTKEY hKey = 0;\n            char hashData[100] = HASH_INPUT;\n            HANDLE pHandle;\n            wchar_t * username = L\"User\";\n            wchar_t * domain = L\"Domain\";\n            do\n            {\n                BYTE payload[(100 - 1) * sizeof(wchar_t)]; /* same size as password except for NUL terminator */\n                DWORD payloadBytes;\n                /* Hex-decode the input string into raw bytes */\n                payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n                /* Wipe the hex string, to prevent it from being given to LogonUserW if\n                 * any of the crypto calls fail. */\n                SecureZeroMemory(password, 100 * sizeof(wchar_t));\n                /* Aquire a Context */\n                if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n                {\n                    break;\n                }\n                /* Create hash handle */\n                if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n                {\n                    break;\n                }\n                /* Hash the input string */\n                if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n                {\n                    break;\n                }\n                /* Derive an AES key from the hash */\n                if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n                {\n                    break;\n                }\n                /* FIX: Decrypt the password */\n                if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n                {\n                    break;\n                }\n                /* Copy back into password and NUL-terminate */\n                memcpy(password, payload, payloadBytes);\n                password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n            }\n            while (0);\n            if (hKey)\n            {\n                CryptDestroyKey(hKey);\n            }\n            if (hHash)\n            {\n                CryptDestroyHash(hHash);\n            }\n            if (hCryptProv)\n            {\n                CryptReleaseContext(hCryptProv, 0);\n            }\n            /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n            if (LogonUserW(\n                        username,\n                        domain,\n                        password,\n                        LOGON32_LOGON_NETWORK,\n                        LOGON32_PROVIDER_DEFAULT,\n                        &pHandle) != 0)\n            {\n                printLine(\"User logged in successfully.\");\n                CloseHandle(pHandle);\n            }\n            else\n            {\n                printLine(\"Unable to login.\");\n            }\n        }\n    }\n}\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"cleartext_transmission\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code transmits sensitive information without encryption. Attackers can intercept and read confidential data sent over the network.\",\n  \"risk\": \"Data interception, credential theft, privacy violations, compliance violations\",\n  \"compliant_patch\": \"\\n// FIXED: Use encryption for sensitive data transmission\\n// Instead of: send_data_in_cleartext(data);\\n// Use: encrypted_data = encrypt_data(data, encryption_key);\\n//       send_encrypted_data(encrypted_data);\\n\\n// Use TLS/SSL for network communication\\n// Ensure all connections use HTTPS/SSL/TLS\\n\",\n  \"source\": \"SARD-94265\",\n  \"cwe\": \"CWE-319\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"cleartext_transmission\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code transmits sensitive information without encryption. Attackers can intercept and read confidential data sent over the network.\",\n  \"risk\": \"Data interception, credential theft, privacy violations, compliance violations\",\n  \"compliant_patch\": \"\\n// FIXED: Use encryption for sensitive data transmission\\n// Instead of: send_data_in_cleartext(data);\\n// Use: encrypted_data = encrypt_data(data, encryption_key);\\n//       send_encrypted_data(encrypted_data);\\n\\n// Use TLS/SSL for network communication\\n// Ensure all connections use HTTPS/SSL/TLS\\n\",\n  \"source\": \"SARD-94265\",\n  \"cwe\": \"CWE-319\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52a.c\nLabel Definition File: CWE319_Cleartext_Tx_Sensitive_Info__w32.label.xml\nTemplate File: sources-sinks-52a.tmpl.c\n*/\n/*\n * @description\n * CWE: 319 Cleartext Transmission of Sensitive Information\n * BadSource: listen_socket Read the password using a listen socket (server side)\n * GoodSource: Use a hardcoded password (one that was not sent over the network)\n * Sinks:\n *    GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext\n *    BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext\n * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" /* INCIDENTAL: Hardcoded crypto */\n\n#ifndef OMITBAD\n\n/* bad function declaration */\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52b_badSink(wchar_t * password);\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52_bad()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            /* POTENTIAL FLAW: Reading sensitive data from the network */\n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52b_badSink(password);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52b_goodG2BSink(wchar_t * password);\n\nstatic void goodG2B()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    /* FIX: Use a hardcoded password (it was not sent over the network)\n    * INCIDENTAL FLAW: CWE-259 Hard Coded Password */\n    wcscpy(password, L\"Password1234!\");\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52b_goodG2BSink(password);\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52b_goodB2GSink(wchar_t * password);\n\nstatic void goodB2G()\n{\n    wchar_t * password;\n    wchar_t passwordBuffer[100] = L\"\";\n    password = passwordBuffer;\n    {\n        WSADATA wsaData;\n        int wsaDataInit = 0;\n        int recvResult;\n        struct sockaddr_in service;\n        wchar_t *replace;\n        SOCKET listenSocket = INVALID_SOCKET;\n        SOCKET acceptSocket = INVALID_SOCKET;\n        size_t passwordLen = wcslen(password);\n        do\n        {\n            if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)\n            {\n                break;\n            }\n            wsaDataInit = 1;\n            listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (listenSocket == INVALID_SOCKET)\n            {\n                break;\n            }\n            memset(&service, 0, sizeof(service));\n            service.sin_family = AF_INET;\n            service.sin_addr.s_addr = INADDR_ANY;\n            service.sin_port = htons(TCP_PORT);\n            if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)\n            {\n                break;\n            }\n            if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)\n            {\n                break;\n            }\n            acceptSocket = accept(listenSocket, NULL, NULL);\n            if (acceptSocket == SOCKET_ERROR)\n            {\n                break;\n            }\n            /* Abort on error or the connection was closed */\n            /* POTENTIAL FLAW: Reading sensitive data from the network */\n            recvResult = recv(acceptSocket, (char*)(password + passwordLen), (100 - passwordLen - 1) * sizeof(wchar_t), 0);\n            if (recvResult == SOCKET_ERROR || recvResult == 0)\n            {\n                break;\n            }\n            /* Append null terminator */\n            password[passwordLen + recvResult / sizeof(wchar_t)] = L'\\0';\n            /* Eliminate CRLF */\n            replace = wcschr(password, L'\\r');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n            replace = wcschr(password, L'\\n');\n            if (replace)\n            {\n                *replace = L'\\0';\n            }\n        }\n        while (0);\n        if (listenSocket != INVALID_SOCKET)\n        {\n            closesocket(listenSocket);\n        }\n        if (acceptSocket != INVALID_SOCKET)\n        {\n            closesocket(acceptSocket);\n        }\n        if (wsaDataInit)\n        {\n            WSACleanup();\n        }\n    }\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52b_goodB2GSink(password);\n}\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52_good()\n{\n    goodG2B();\n    goodB2G();\n}\n\n#endif /* OMITGOOD */\n\n/* Below is the main(). It is only used when building this testcase on\n   its own for testing or for building a binary to use in testing binary\n   analysis tools. It is not used when compiling all the testcases as one\n   application, which is how source code analysis tools are tested. */\n\n#ifdef INCLUDEMAIN\n\nint main(int argc, char * argv[])\n{\n    /* seed randomness */\n    srand( (unsigned)time(NULL) );\n#ifndef OMITGOOD\n    printLine(\"Calling good()...\");\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52_good();\n    printLine(\"Finished good()\");\n#endif /* OMITGOOD */\n#ifndef OMITBAD\n    printLine(\"Calling bad()...\");\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52_bad();\n    printLine(\"Finished bad()\");\n#endif /* OMITBAD */\n    return 0;\n}\n\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"cleartext_transmission\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code transmits sensitive information without encryption. Attackers can intercept and read confidential data sent over the network.\",\n  \"risk\": \"Data interception, credential theft, privacy violations, compliance violations\",\n  \"compliant_patch\": \"\\n// FIXED: Use encryption for sensitive data transmission\\n// Instead of: send_data_in_cleartext(data);\\n// Use: encrypted_data = encrypt_data(data, encryption_key);\\n//       send_encrypted_data(encrypted_data);\\n\\n// Use TLS/SSL for network communication\\n// Ensure all connections use HTTPS/SSL/TLS\\n\",\n  \"source\": \"SARD-94272\",\n  \"cwe\": \"CWE-319\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52b.c\nLabel Definition File: CWE319_Cleartext_Tx_Sensitive_Info__w32.label.xml\nTemplate File: sources-sinks-52b.tmpl.c\n*/\n/*\n * @description\n * CWE: 319 Cleartext Transmission of Sensitive Information\n * BadSource: listen_socket Read the password using a listen socket (server side)\n * GoodSource: Use a hardcoded password (one that was not sent over the network)\n * Sinks:\n *    GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext\n *    BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext\n * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" /* INCIDENTAL: Hardcoded crypto */\n\n#ifndef OMITBAD\n\n/* bad function declaration */\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52c_badSink(wchar_t * password);\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52b_badSink(wchar_t * password)\n{\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52c_badSink(password);\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52c_goodG2BSink(wchar_t * password);\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52b_goodG2BSink(wchar_t * password)\n{\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52c_goodG2BSink(password);\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52c_goodB2GSink(wchar_t * password);\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52b_goodB2GSink(wchar_t * password)\n{\n    CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52c_goodB2GSink(password);\n}\n\n#endif /* OMITGOOD */\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"cleartext_transmission\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code transmits sensitive information without encryption. Attackers can intercept and read confidential data sent over the network.\",\n  \"risk\": \"Data interception, credential theft, privacy violations, compliance violations\",\n  \"compliant_patch\": \"\\n// FIXED: Use encryption for sensitive data transmission\\n// Instead of: send_data_in_cleartext(data);\\n// Use: encrypted_data = encrypt_data(data, encryption_key);\\n//       send_encrypted_data(encrypted_data);\\n\\n// Use TLS/SSL for network communication\\n// Ensure all connections use HTTPS/SSL/TLS\\n\",\n  \"source\": \"SARD-94272\",\n  \"cwe\": \"CWE-319\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/* TEMPLATE GENERATED TESTCASE FILE\nFilename: CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52c.c\nLabel Definition File: CWE319_Cleartext_Tx_Sensitive_Info__w32.label.xml\nTemplate File: sources-sinks-52c.tmpl.c\n*/\n/*\n * @description\n * CWE: 319 Cleartext Transmission of Sensitive Information\n * BadSource: listen_socket Read the password using a listen socket (server side)\n * GoodSource: Use a hardcoded password (one that was not sent over the network)\n * Sinks:\n *    GoodSink: Decrypt the password before using it in an authentication API call to show that it was transferred as ciphertext\n *    BadSink : Use the password directly from the source in an authentication API call to show that it was transferred as plaintext\n * Flow Variant: 52 Data flow: data passed as an argument from one function to another to another in three different source files\n *\n * */\n\n#include \"std_testcase.h\"\n\n#include <winsock2.h>\n#include <windows.h>\n#include <direct.h>\n#pragma comment(lib, \"ws2_32\") /* include ws2_32.lib when linking */\n\n#define TCP_PORT 27015\n#define LISTEN_BACKLOG 5\n\n#pragma comment(lib, \"advapi32.lib\")\n\n#define HASH_INPUT \"ABCDEFG123456\" /* INCIDENTAL: Hardcoded crypto */\n\n#ifndef OMITBAD\n\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52c_badSink(wchar_t * password)\n{\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n        /* POTENTIAL FLAW: Using sensitive information that was possibly sent in plaintext over the network */\n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n#endif /* OMITBAD */\n\n#ifndef OMITGOOD\n\n/* goodG2B uses the GoodSource with the BadSink */\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52c_goodG2BSink(wchar_t * password)\n{\n    {\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n        /* POTENTIAL FLAW: Using sensitive information that was possibly sent in plaintext over the network */\n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n/* goodB2G uses the BadSource with the GoodSink */\nvoid CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_52c_goodB2GSink(wchar_t * password)\n{\n    {\n        HCRYPTPROV hCryptProv = 0;\n        HCRYPTHASH hHash = 0;\n        HCRYPTKEY hKey = 0;\n        char hashData[100] = HASH_INPUT;\n        HANDLE pHandle;\n        wchar_t * username = L\"User\";\n        wchar_t * domain = L\"Domain\";\n        do\n        {\n            BYTE payload[(100 - 1) * sizeof(wchar_t)]; /* same size as password except for NUL terminator */\n            DWORD payloadBytes;\n            /* Hex-decode the input string into raw bytes */\n            payloadBytes = decodeHexWChars(payload, sizeof(payload), password);\n            /* Wipe the hex string, to prevent it from being given to LogonUserW if\n             * any of the crypto calls fail. */\n            SecureZeroMemory(password, 100 * sizeof(wchar_t));\n            /* Aquire a Context */\n            if(!CryptAcquireContext(&hCryptProv, NULL, MS_ENH_RSA_AES_PROV, PROV_RSA_AES, 0))\n            {\n                break;\n            }\n            /* Create hash handle */\n            if(!CryptCreateHash(hCryptProv, CALG_SHA_256, 0, 0, &hHash))\n            {\n                break;\n            }\n            /* Hash the input string */\n            if(!CryptHashData(hHash, (BYTE*)hashData, strlen(hashData), 0))\n            {\n                break;\n            }\n            /* Derive an AES key from the hash */\n            if(!CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey))\n            {\n                break;\n            }\n            /* FIX: Decrypt the password */\n            if(!CryptDecrypt(hKey, 0, 1, 0, payload, &payloadBytes))\n            {\n                break;\n            }\n            /* Copy back into password and NUL-terminate */\n            memcpy(password, payload, payloadBytes);\n            password[payloadBytes / sizeof(wchar_t)] = L'\\0';\n        }\n        while (0);\n        if (hKey)\n        {\n            CryptDestroyKey(hKey);\n        }\n        if (hHash)\n        {\n            CryptDestroyHash(hHash);\n        }\n        if (hCryptProv)\n        {\n            CryptReleaseContext(hCryptProv, 0);\n        }\n        /* Use the password in LogonUser() to establish that it is \"sensitive\" */\n        if (LogonUserW(\n                    username,\n                    domain,\n                    password,\n                    LOGON32_LOGON_NETWORK,\n                    LOGON32_PROVIDER_DEFAULT,\n                    &pHandle) != 0)\n        {\n            printLine(\"User logged in successfully.\");\n            CloseHandle(pHandle);\n        }\n        else\n        {\n            printLine(\"Unable to login.\");\n        }\n    }\n}\n\n#endif /* OMITGOOD */\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"cleartext_transmission\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code transmits sensitive information without encryption. Attackers can intercept and read confidential data sent over the network.\",\n  \"risk\": \"Data interception, credential theft, privacy violations, compliance violations\",\n  \"compliant_patch\": \"\\n// FIXED: Use encryption for sensitive data transmission\\n// Instead of: send_data_in_cleartext(data);\\n// Use: encrypted_data = encrypt_data(data, encryption_key);\\n//       send_encrypted_data(encrypted_data);\\n\\n// Use TLS/SSL for network communication\\n// Ensure all connections use HTTPS/SSL/TLS\\n\",\n  \"source\": \"SARD-94272\",\n  \"cwe\": \"CWE-319\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n#include <inttypes.h> // for PRId64\n#include <stdio.h>\n#include <stdlib.h>\n#include <wctype.h>\n#include \"std_testcase.h\"\n\n#ifndef _WIN32\n#include <wchar.h>\n#endif\n\nvoid printLine (const char * line)\n{\n    if(line != NULL) \n    {\n        printf(\"%s\\n\", line);\n    }\n}\n\nvoid printWLine (const wchar_t * line)\n{\n    if(line != NULL) \n    {\n        wprintf(L\"%ls\\n\", line);\n    }\n}\n\nvoid printIntLine (int intNumber)\n{\n    printf(\"%d\\n\", intNumber);\n}\n\nvoid printShortLine (short shortNumber)\n{\n    printf(\"%hd\\n\", shortNumber);\n}\n\nvoid printFloatLine (float floatNumber)\n{\n    printf(\"%f\\n\", floatNumber);\n}\n\nvoid printLongLine (long longNumber)\n{\n    printf(\"%ld\\n\", longNumber);\n}\n\nvoid printLongLongLine (int64_t longLongIntNumber)\n{\n    printf(\"%\" PRId64 \"\\n\", longLongIntNumber);\n}\n\nvoid printSizeTLine (size_t sizeTNumber)\n{\n    printf(\"%zu\\n\", sizeTNumber);\n}\n\nvoid printHexCharLine (char charHex)\n{\n    printf(\"%02x\\n\", charHex);\n}\n\nvoid printWcharLine(wchar_t wideChar) \n{\n    /* ISO standard dictates wchar_t can be ref'd only with %ls, so we must make a\n     * string to print a wchar */\n    wchar_t s[2];\n        s[0] = wideChar;\n        s[1] = L'\\0';\n    printf(\"%ls\\n\", s);\n}\n\nvoid printUnsignedLine(unsigned unsignedNumber) \n{\n    printf(\"%u\\n\", unsignedNumber);\n}\n\nvoid printHexUnsignedCharLine(unsigned char unsignedCharacter) \n{\n    printf(\"%02x\\n\", unsignedCharacter);\n}\n\nvoid printDoubleLine(double doubleNumber) \n{\n    printf(\"%g\\n\", doubleNumber);\n}\n\nvoid printStructLine (const twoIntsStruct * structTwoIntsStruct)\n{\n    printf(\"%d -- %d\\n\", structTwoIntsStruct->intOne, structTwoIntsStruct->intTwo);\n}\n\nvoid printBytesLine(const unsigned char * bytes, size_t numBytes)\n{\n    size_t i;\n    for (i = 0; i < numBytes; ++i)\n    {\n        printf(\"%02x\", bytes[i]);\n    }\n    puts(\"\");\t/* output newline */\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\nsize_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)\n{\n    size_t numWritten = 0;\n\n    /* We can't sscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling sscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && isxdigit(hex[2 * numWritten]) && isxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        sscanf(&hex[2 * numWritten], \"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* Decode a string of hex characters into the bytes they represent.  The second\n * parameter specifies the length of the output buffer.  The number of bytes\n * actually written to the output buffer is returned. */\n size_t decodeHexWChars(unsigned char * bytes, size_t numBytes, const wchar_t * hex)\n {\n    size_t numWritten = 0;\n\n    /* We can't swscanf directly into the byte array since %02x expects a pointer to int,\n     * not a pointer to unsigned char.  Also, since we expect an unbroken string of hex\n     * characters, we check for that before calling swscanf; otherwise we would get a\n     * framing error if there's whitespace in the input string. */\n    while (numWritten < numBytes && iswxdigit(hex[2 * numWritten]) && iswxdigit(hex[2 * numWritten + 1]))\n    {\n        int byte;\n        swscanf(&hex[2 * numWritten], L\"%02x\", &byte);\n        bytes[numWritten] = (unsigned char) byte;\n        ++numWritten;\n    }\n\n    return numWritten;\n}\n\n/* The two functions always return 1 or 0, so a tool should be able to \n   identify that uses of these functions will always return these values */\nint globalReturnsTrue() \n{\n    return 1;\n}\n\nint globalReturnsFalse() \n{\n    return 0;\n}\n\nint globalReturnsTrueOrFalse() \n{\n    return (rand() % 2);\n}\n\n/* The variables below are declared \"const\", so a tool should\n   be able to identify that reads of these will always return their \n   initialized values. */\nconst int GLOBAL_CONST_TRUE = 1; /* true */\nconst int GLOBAL_CONST_FALSE = 0; /* false */\nconst int GLOBAL_CONST_FIVE = 5; \n\n/* The variables below are not defined as \"const\", but are never\n   assigned any other value, so a tool should be able to identify that\n   reads of these will always return their initialized values. */\nint globalTrue = 1; /* true */\nint globalFalse = 0; /* false */\nint globalFive = 5; \n\n/* define a bunch of these as empty functions so that if a test case forgets\n   to make their's statically scoped, we'll get a linker error */\nvoid good1() { }\nvoid good2() { }\nvoid good3() { }\nvoid good4() { }\nvoid good5() { }\nvoid good6() { }\nvoid good7() { }\nvoid good8() { }\nvoid good9() { }\n\n/* shouldn't be used, but just in case */\nvoid bad1() { }\nvoid bad2() { }\nvoid bad3() { }\nvoid bad4() { }\nvoid bad5() { }\nvoid bad6() { }\nvoid bad7() { }\nvoid bad8() { }\nvoid bad9() { }\n\n/* define global argc and argv */\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nint globalArgc = 0;\nchar** globalArgv = NULL;\n\n#ifdef __cplusplus\n}\n#endif\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"cleartext_transmission\",\n  \"severity\": \"high\",\n  \"explanation\": \"This code transmits sensitive information without encryption. Attackers can intercept and read confidential data sent over the network.\",\n  \"risk\": \"Data interception, credential theft, privacy violations, compliance violations\",\n  \"compliant_patch\": \"\\n// FIXED: Use encryption for sensitive data transmission\\n// Instead of: send_data_in_cleartext(data);\\n// Use: encrypted_data = encrypt_data(data, encryption_key);\\n//       send_encrypted_data(encrypted_data);\\n\\n// Use TLS/SSL for network communication\\n// Ensure all connections use HTTPS/SSL/TLS\\n\",\n  \"source\": \"SARD-94272\",\n  \"cwe\": \"CWE-319\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/*\nDescription: Execl() is called with user-provided data.\nKeywords: Unix C Size0 Complex0 Taint Unsafe\n\nCopyright 2005 Fortify Software.\n\nPermission is hereby granted, without written agreement or royalty fee, to\nuse, copy, modify, and distribute this software and its documentation for\nany purpose, provided that the above copyright notice and the following\nthree paragraphs appear in all copies of this software.\n\nIN NO EVENT SHALL FORTIFY SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT,\nINDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF FORTIFY SOFTWARE HAS\nBEEN ADVISED OF THE POSSIBILITY OF SUCH DAMANGE.\n\nFORTIFY SOFTWARE SPECIFICALLY DISCLAIMS ANY WARRANTIES INCLUDING, BUT NOT\nLIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE, AND NON-INFRINGEMENT.\n\nTHE SOFTWARE IS PROVIDED ON AN \"AS-IS\" BASIS AND FORTIFY SOFTWARE HAS NO\nOBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR\nMODIFICATIONS.\n*/\n\n#include <stdio.h>\n#include <unistd.h>\n\n#define\tMAXSIZE\t\t40\nvoid\ntest(char *str)\n{\n\tchar buf[MAXSIZE];\n\n\t/* str can contain \"..\" components */\n\tsnprintf(buf, sizeof buf, \"/usr/games/%s\", str);\n\tbuf[MAXSIZE-1] = 0;\n\texecl(buf, str, 0);\t\t\t/* BAD */\n}\n\nint\nmain(int argc, char **argv)\n{\n\tchar *userstr;\n\n\tif(argc > 1) {\n\t\tuserstr = argv[1];\n\t\ttest(userstr);\n\t}\n\treturn 0;\n}\n\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"input_validation\",\n  \"severity\": \"medium\",\n  \"explanation\": \"This code does not properly validate user input before processing it. Attackers can provide malformed or unexpected input to cause errors or exploit vulnerabilities.\",\n  \"risk\": \"Application crashes, unexpected behavior, potential exploitation of other vulnerabilities\",\n  \"compliant_patch\": \"\\n// FIXED: Validate all user input before processing\\n// Instead of: process_user_input(raw_input);\\n// Use: if (is_valid_input(raw_input)) {\\n//         sanitized_input = sanitize_input(raw_input);\\n//         process_user_input(sanitized_input);\\n//       } else {\\n//         reject_invalid_input();\\n//       }\\n\",\n  \"source\": \"SARD-1647\",\n  \"cwe\": \"CWE-20\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/*\nDescription: System() is called with user-provided data.\nKeywords: Port C Size0 Complex0 Taint Unsafe\nInvalidArg: \"';kill -TERM $PPID'\"\n\nCopyright 2005 Fortify Software.\n\nPermission is hereby granted, without written agreement or royalty fee, to\nuse, copy, modify, and distribute this software and its documentation for\nany purpose, provided that the above copyright notice and the following\nthree paragraphs appear in all copies of this software.\n\nIN NO EVENT SHALL FORTIFY SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT,\nINDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF FORTIFY SOFTWARE HAS\nBEEN ADVISED OF THE POSSIBILITY OF SUCH DAMANGE.\n\nFORTIFY SOFTWARE SPECIFICALLY DISCLAIMS ANY WARRANTIES INCLUDING, BUT NOT\nLIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE, AND NON-INFRINGEMENT.\n\nTHE SOFTWARE IS PROVIDED ON AN \"AS-IS\" BASIS AND FORTIFY SOFTWARE HAS NO\nOBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR\nMODIFICATIONS.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define\tMAXSIZE\t\t40\nvoid\ntest(char *str)\n{\n\tchar buf[MAXSIZE];\n\n\tsnprintf(buf, sizeof buf, \"/bin/echo %s\", str);\n\tbuf[MAXSIZE-1] = 0;\n\tsystem(buf);\t\t\t\t/* BAD */\n}\n\nint\nmain(int argc, char **argv)\n{\n\tchar *userstr;\n\n\tif(argc > 1) {\n\t\tuserstr = argv[1];\n\t\ttest(userstr);\n\t}\n\treturn 0;\n}\n\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"input_validation\",\n  \"severity\": \"medium\",\n  \"explanation\": \"This code does not properly validate user input before processing it. Attackers can provide malformed or unexpected input to cause errors or exploit vulnerabilities.\",\n  \"risk\": \"Application crashes, unexpected behavior, potential exploitation of other vulnerabilities\",\n  \"compliant_patch\": \"\\n// FIXED: Validate all user input before processing\\n// Instead of: process_user_input(raw_input);\\n// Use: if (is_valid_input(raw_input)) {\\n//         sanitized_input = sanitize_input(raw_input);\\n//         process_user_input(sanitized_input);\\n//       } else {\\n//         reject_invalid_input();\\n//       }\\n\",\n  \"source\": \"SARD-1645\",\n  \"cwe\": \"CWE-20\"\n}"
      }
    ]
  },
  {
    "messages": [
      {
        "role": "user",
        "content": "analyze this code for security violations:\n\n/*\nDescription: Execl() is called with user-provided data but only if it matches an item in a safe list.\nKeywords: Unix C Size0 Complex0 Taint Unsafe\n\nCopyright 2005 Fortify Software.\n\nPermission is hereby granted, without written agreement or royalty fee, to\nuse, copy, modify, and distribute this software and its documentation for\nany purpose, provided that the above copyright notice and the following\nthree paragraphs appear in all copies of this software.\n\nIN NO EVENT SHALL FORTIFY SOFTWARE BE LIABLE TO ANY PARTY FOR DIRECT,\nINDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF FORTIFY SOFTWARE HAS\nBEEN ADVISED OF THE POSSIBILITY OF SUCH DAMANGE.\n\nFORTIFY SOFTWARE SPECIFICALLY DISCLAIMS ANY WARRANTIES INCLUDING, BUT NOT\nLIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE, AND NON-INFRINGEMENT.\n\nTHE SOFTWARE IS PROVIDED ON AN \"AS-IS\" BASIS AND FORTIFY SOFTWARE HAS NO\nOBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR\nMODIFICATIONS.\n*/\n\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\nchar *validGames[] = {\n\t\"moria\", \"fortune\", \"adventure\", \"zork\", \"rogue\", \"worm\", \"trek\",\n\t0\n};\n\n#define\tMAXSIZE\t\t40\nvoid\ntest(char *str)\n{\n\tchar buf[MAXSIZE];\n\tint x;\n\n\t/* str can contain \"..\" components */\n\tfor(x = 0; validGames[x]; x++) {\n\t\tif(strcmp(str, validGames[x]) == 0)\n\t\t\tbreak;\n\t}\n\tif(!validGames[x])\n\t\treturn;\n\tsnprintf(buf, sizeof buf, \"/usr/games/%s\", str);\n\tbuf[MAXSIZE-1] = 0;\n\texecl(buf, str, 0);\t\t\t/* OK */\n}\n\nint\nmain(int argc, char **argv)\n{\n\tchar *userstr;\n\n\tif(argc > 1) {\n\t\tuserstr = argv[1];\n\t\ttest(userstr);\n\t}\n\treturn 0;\n}\n\n"
      },
      {
        "role": "assistant",
        "content": "{\n  \"violation_type\": \"input_validation\",\n  \"severity\": \"medium\",\n  \"explanation\": \"This code does not properly validate user input before processing it. Attackers can provide malformed or unexpected input to cause errors or exploit vulnerabilities.\",\n  \"risk\": \"Application crashes, unexpected behavior, potential exploitation of other vulnerabilities\",\n  \"compliant_patch\": \"\\n// FIXED: Validate all user input before processing\\n// Instead of: process_user_input(raw_input);\\n// Use: if (is_valid_input(raw_input)) {\\n//         sanitized_input = sanitize_input(raw_input);\\n//         process_user_input(sanitized_input);\\n//       } else {\\n//         reject_invalid_input();\\n//       }\\n\",\n  \"source\": \"SARD-1648\",\n  \"cwe\": \"CWE-20\"\n}"
      }
    ]
  }
]